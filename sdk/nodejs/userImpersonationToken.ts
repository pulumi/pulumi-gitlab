// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

/**
 * The `gitlab.UserImpersonationToken` resource allows to manage impersonation tokens of users.
 * Requires administrator access. Token values are returned once. You are only able to create impersonation tokens to impersonate the user and perform both API calls and Git reads and writes. The user canâ€™t see these tokens in their profile settings page.
 *
 * **Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/api/users/#create-an-impersonation-token)
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gitlab from "@pulumi/gitlab";
 *
 * const _this = new gitlab.UserImpersonationToken("this", {
 *     userId: 12345,
 *     name: "token_name",
 *     scopes: ["api"],
 *     expiresAt: "2024-08-27",
 * });
 * ```
 *
 * ## Import
 *
 * Starting in Terraform v1.5.0, you can use an import block to import `gitlab_user_impersonation_token`. For example:
 *
 * terraform
 *
 * import {
 *
 *   to = gitlab_user_impersonation_token.example
 *
 *   id = "see CLI command below for ID"
 *
 * }
 *
 * Importing using the CLI is supported with the following syntax:
 *
 * A GitLab User Impersonation Token can be imported using a key composed of `<user-id>:<token-id>`, e.g.
 *
 * ```sh
 * $ pulumi import gitlab:index/userImpersonationToken:UserImpersonationToken example "12345:1"
 * ```
 *
 * NOTE: the `token` resource attribute is not available for imported resources as this information cannot be read from the GitLab API.
 */
export class UserImpersonationToken extends pulumi.CustomResource {
    /**
     * Get an existing UserImpersonationToken resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: UserImpersonationTokenState, opts?: pulumi.CustomResourceOptions): UserImpersonationToken {
        return new UserImpersonationToken(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'gitlab:index/userImpersonationToken:UserImpersonationToken';

    /**
     * Returns true if the given object is an instance of UserImpersonationToken.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is UserImpersonationToken {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === UserImpersonationToken.__pulumiType;
    }

    /**
     * True if the token is active.
     */
    declare public /*out*/ readonly active: pulumi.Output<boolean>;
    /**
     * Time the token has been created, RFC3339 format.
     */
    declare public /*out*/ readonly createdAt: pulumi.Output<string>;
    /**
     * Expiration date of the impersonation token in ISO format (YYYY-MM-DD).
     */
    declare public readonly expiresAt: pulumi.Output<string>;
    /**
     * True as the token is always an impersonation token.
     */
    declare public /*out*/ readonly impersonation: pulumi.Output<boolean>;
    /**
     * The name of the impersonation token.
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * True if the token is revoked.
     */
    declare public /*out*/ readonly revoked: pulumi.Output<boolean>;
    /**
     * Array of scopes of the impersonation token. valid values are: `api`, `readUser`, `readApi`, `readRepository`, `writeRepository`, `readRegistry`, `writeRegistry`, `readVirtualRegistry`, `writeVirtualRegistry`, `sudo`, `adminMode`, `createRunner`, `manageRunner`, `aiFeatures`, `k8sProxy`, `selfRotate`, `readServicePing`
     */
    declare public readonly scopes: pulumi.Output<string[]>;
    /**
     * The token of the user impersonation token. **Note**: the token is not available for imported resources.
     */
    declare public /*out*/ readonly token: pulumi.Output<string>;
    /**
     * ID of the impersonation token.
     */
    declare public /*out*/ readonly tokenId: pulumi.Output<number>;
    /**
     * The ID of the user.
     */
    declare public readonly userId: pulumi.Output<number>;

    /**
     * Create a UserImpersonationToken resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: UserImpersonationTokenArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: UserImpersonationTokenArgs | UserImpersonationTokenState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as UserImpersonationTokenState | undefined;
            resourceInputs["active"] = state?.active;
            resourceInputs["createdAt"] = state?.createdAt;
            resourceInputs["expiresAt"] = state?.expiresAt;
            resourceInputs["impersonation"] = state?.impersonation;
            resourceInputs["name"] = state?.name;
            resourceInputs["revoked"] = state?.revoked;
            resourceInputs["scopes"] = state?.scopes;
            resourceInputs["token"] = state?.token;
            resourceInputs["tokenId"] = state?.tokenId;
            resourceInputs["userId"] = state?.userId;
        } else {
            const args = argsOrState as UserImpersonationTokenArgs | undefined;
            if (args?.expiresAt === undefined && !opts.urn) {
                throw new Error("Missing required property 'expiresAt'");
            }
            if (args?.scopes === undefined && !opts.urn) {
                throw new Error("Missing required property 'scopes'");
            }
            if (args?.userId === undefined && !opts.urn) {
                throw new Error("Missing required property 'userId'");
            }
            resourceInputs["expiresAt"] = args?.expiresAt;
            resourceInputs["name"] = args?.name;
            resourceInputs["scopes"] = args?.scopes;
            resourceInputs["userId"] = args?.userId;
            resourceInputs["active"] = undefined /*out*/;
            resourceInputs["createdAt"] = undefined /*out*/;
            resourceInputs["impersonation"] = undefined /*out*/;
            resourceInputs["revoked"] = undefined /*out*/;
            resourceInputs["token"] = undefined /*out*/;
            resourceInputs["tokenId"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const secretOpts = { additionalSecretOutputs: ["token"] };
        opts = pulumi.mergeOptions(opts, secretOpts);
        super(UserImpersonationToken.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering UserImpersonationToken resources.
 */
export interface UserImpersonationTokenState {
    /**
     * True if the token is active.
     */
    active?: pulumi.Input<boolean>;
    /**
     * Time the token has been created, RFC3339 format.
     */
    createdAt?: pulumi.Input<string>;
    /**
     * Expiration date of the impersonation token in ISO format (YYYY-MM-DD).
     */
    expiresAt?: pulumi.Input<string>;
    /**
     * True as the token is always an impersonation token.
     */
    impersonation?: pulumi.Input<boolean>;
    /**
     * The name of the impersonation token.
     */
    name?: pulumi.Input<string>;
    /**
     * True if the token is revoked.
     */
    revoked?: pulumi.Input<boolean>;
    /**
     * Array of scopes of the impersonation token. valid values are: `api`, `readUser`, `readApi`, `readRepository`, `writeRepository`, `readRegistry`, `writeRegistry`, `readVirtualRegistry`, `writeVirtualRegistry`, `sudo`, `adminMode`, `createRunner`, `manageRunner`, `aiFeatures`, `k8sProxy`, `selfRotate`, `readServicePing`
     */
    scopes?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The token of the user impersonation token. **Note**: the token is not available for imported resources.
     */
    token?: pulumi.Input<string>;
    /**
     * ID of the impersonation token.
     */
    tokenId?: pulumi.Input<number>;
    /**
     * The ID of the user.
     */
    userId?: pulumi.Input<number>;
}

/**
 * The set of arguments for constructing a UserImpersonationToken resource.
 */
export interface UserImpersonationTokenArgs {
    /**
     * Expiration date of the impersonation token in ISO format (YYYY-MM-DD).
     */
    expiresAt: pulumi.Input<string>;
    /**
     * The name of the impersonation token.
     */
    name?: pulumi.Input<string>;
    /**
     * Array of scopes of the impersonation token. valid values are: `api`, `readUser`, `readApi`, `readRepository`, `writeRepository`, `readRegistry`, `writeRegistry`, `readVirtualRegistry`, `writeVirtualRegistry`, `sudo`, `adminMode`, `createRunner`, `manageRunner`, `aiFeatures`, `k8sProxy`, `selfRotate`, `readServicePing`
     */
    scopes: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The ID of the user.
     */
    userId: pulumi.Input<number>;
}
