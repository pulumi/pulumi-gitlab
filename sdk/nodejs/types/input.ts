// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ApplicationSettingsDefaultBranchProtectionDefaults {
    /**
     * Allow force push for all users with push access.
     */
    allowForcePush?: pulumi.Input<boolean>;
    /**
     * An array of access levels allowed to merge. Supports Developer (30) or Maintainer (40).
     */
    allowedToMerges?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * An array of access levels allowed to push. Supports Developer (30) or Maintainer (40).
     */
    allowedToPushes?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * Allow developers to initial push.
     */
    developerCanInitialPush?: pulumi.Input<boolean>;
}

export interface BranchCommit {
    /**
     * The email of the author.
     */
    authorEmail?: pulumi.Input<string>;
    /**
     * The name of the author.
     */
    authorName?: pulumi.Input<string>;
    /**
     * The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
     */
    authoredDate?: pulumi.Input<string>;
    /**
     * The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
     */
    committedDate?: pulumi.Input<string>;
    /**
     * The email of the user that committed.
     */
    committerEmail?: pulumi.Input<string>;
    /**
     * The name of the user that committed.
     */
    committerName?: pulumi.Input<string>;
    /**
     * The unique id assigned to the commit by Gitlab.
     */
    id?: pulumi.Input<string>;
    /**
     * The commit message
     */
    message?: pulumi.Input<string>;
    /**
     * The id of the parents of the commit
     */
    parentIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The short id assigned to the commit by Gitlab.
     */
    shortId?: pulumi.Input<string>;
    /**
     * The title of the commit
     */
    title?: pulumi.Input<string>;
}

export interface BranchProtectionAllowedToMerge {
    /**
     * Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
     */
    accessLevel?: pulumi.Input<string>;
    /**
     * Readable description of access level.
     */
    accessLevelDescription?: pulumi.Input<string>;
    /**
     * The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `userId`.
     */
    groupId?: pulumi.Input<number>;
    /**
     * The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `groupId`.
     */
    userId?: pulumi.Input<number>;
}

export interface BranchProtectionAllowedToPush {
    /**
     * Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
     */
    accessLevel?: pulumi.Input<string>;
    /**
     * Readable description of access level.
     */
    accessLevelDescription?: pulumi.Input<string>;
    /**
     * The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `groupId` and `userId`. This field is read-only until Gitlab 17.5.
     */
    deployKeyId?: pulumi.Input<number>;
    /**
     * The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deployKeyId` and `userId`.
     */
    groupId?: pulumi.Input<number>;
    /**
     * The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deployKeyId` and `groupId`.
     */
    userId?: pulumi.Input<number>;
}

export interface BranchProtectionAllowedToUnprotect {
    /**
     * Access levels allowed to unprotect push to protected branch. Valid values are: `developer`, `maintainer`, `admin`.
     */
    accessLevel?: pulumi.Input<string>;
    /**
     * Readable description of access level.
     */
    accessLevelDescription?: pulumi.Input<string>;
    /**
     * The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `userId`.
     */
    groupId?: pulumi.Input<number>;
    /**
     * The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `groupId`.
     */
    userId?: pulumi.Input<number>;
}

export interface GetGroupProvisionedUsersProvisionedUser {
    /**
     * The avatar URL of the provisioned user.
     */
    avatarUrl?: string;
    /**
     * The bio of the provisioned user.
     */
    bio?: string;
    /**
     * Whether the provisioned user is a bot.
     */
    bot?: boolean;
    /**
     * The confirmation date of the provisioned user.
     */
    confirmedAt?: string;
    /**
     * The creation date of the provisioned user.
     */
    createdAt?: string;
    /**
     * The email of the provisioned user.
     */
    email?: string;
    /**
     * Whether the provisioned user is external.
     */
    external?: boolean;
    /**
     * The ID of the provisioned user.
     */
    id?: string;
    /**
     * The job title of the provisioned user.
     */
    jobTitle?: string;
    /**
     * The last activity date of the provisioned user.
     */
    lastActivityOn?: string;
    /**
     * The last sign-in date of the provisioned user.
     */
    lastSignInAt?: string;
    /**
     * The LinkedIn ID of the provisioned user.
     */
    linkedin?: string;
    /**
     * The location of the provisioned user.
     */
    location?: string;
    /**
     * The name of the provisioned user.
     */
    name?: string;
    /**
     * The organization of the provisioned user.
     */
    organization?: string;
    /**
     * Whether the provisioned user has a private profile.
     */
    privateProfile?: boolean;
    /**
     * The pronouns of the provisioned user.
     */
    pronouns?: string;
    /**
     * The public email of the provisioned user.
     */
    publicEmail?: string;
    /**
     * The Skype ID of the provisioned user.
     */
    skype?: string;
    /**
     * The state of the provisioned user.
     */
    state?: string;
    /**
     * The Twitter ID of the provisioned user.
     */
    twitter?: string;
    /**
     * Whether two-factor authentication is enabled for the provisioned user.
     */
    twoFactorEnabled?: boolean;
    /**
     * The username of the provisioned user.
     */
    username?: string;
    /**
     * The web URL of the provisioned user.
     */
    webUrl?: string;
    /**
     * The website URL of the provisioned user.
     */
    websiteUrl?: string;
}

export interface GetGroupProvisionedUsersProvisionedUserArgs {
    /**
     * The avatar URL of the provisioned user.
     */
    avatarUrl?: pulumi.Input<string>;
    /**
     * The bio of the provisioned user.
     */
    bio?: pulumi.Input<string>;
    /**
     * Whether the provisioned user is a bot.
     */
    bot?: pulumi.Input<boolean>;
    /**
     * The confirmation date of the provisioned user.
     */
    confirmedAt?: pulumi.Input<string>;
    /**
     * The creation date of the provisioned user.
     */
    createdAt?: pulumi.Input<string>;
    /**
     * The email of the provisioned user.
     */
    email?: pulumi.Input<string>;
    /**
     * Whether the provisioned user is external.
     */
    external?: pulumi.Input<boolean>;
    /**
     * The ID of the provisioned user.
     */
    id?: pulumi.Input<string>;
    /**
     * The job title of the provisioned user.
     */
    jobTitle?: pulumi.Input<string>;
    /**
     * The last activity date of the provisioned user.
     */
    lastActivityOn?: pulumi.Input<string>;
    /**
     * The last sign-in date of the provisioned user.
     */
    lastSignInAt?: pulumi.Input<string>;
    /**
     * The LinkedIn ID of the provisioned user.
     */
    linkedin?: pulumi.Input<string>;
    /**
     * The location of the provisioned user.
     */
    location?: pulumi.Input<string>;
    /**
     * The name of the provisioned user.
     */
    name?: pulumi.Input<string>;
    /**
     * The organization of the provisioned user.
     */
    organization?: pulumi.Input<string>;
    /**
     * Whether the provisioned user has a private profile.
     */
    privateProfile?: pulumi.Input<boolean>;
    /**
     * The pronouns of the provisioned user.
     */
    pronouns?: pulumi.Input<string>;
    /**
     * The public email of the provisioned user.
     */
    publicEmail?: pulumi.Input<string>;
    /**
     * The Skype ID of the provisioned user.
     */
    skype?: pulumi.Input<string>;
    /**
     * The state of the provisioned user.
     */
    state?: pulumi.Input<string>;
    /**
     * The Twitter ID of the provisioned user.
     */
    twitter?: pulumi.Input<string>;
    /**
     * Whether two-factor authentication is enabled for the provisioned user.
     */
    twoFactorEnabled?: pulumi.Input<boolean>;
    /**
     * The username of the provisioned user.
     */
    username?: pulumi.Input<string>;
    /**
     * The web URL of the provisioned user.
     */
    webUrl?: pulumi.Input<string>;
    /**
     * The website URL of the provisioned user.
     */
    websiteUrl?: pulumi.Input<string>;
}

export interface GetProjectApprovalRulesApprovalRule {
    /**
     * If true, applies the rule to all protected branches, ignoring the protected branches attribute.
     */
    appliesToAllProtectedBranches?: boolean;
    /**
     * The number of approvals required for this rule.
     */
    approvalsRequired?: number;
    /**
     * List of all approver IDs that are eligible to approve this rule.
     */
    eligibleApproverIds?: number[];
    /**
     * List of group IDs that are eligible to approve this rule.
     */
    groupIds?: number[];
    /**
     * The ID of the approval rule.
     */
    id?: number;
    /**
     * The name of the approval rule.
     */
    name?: string;
    /**
     * List of protected branch IDs that this rule applies to.
     */
    protectedBranchIds?: number[];
    /**
     * The report type. Required when the rule type is `reportApprover`. The supported report types are `licenseScanning` and `codeCoverage`.
     */
    reportType?: string;
    /**
     * The type of the approval rule. Can be `anyApprover`, `regular` or `reportApprover`.
     */
    ruleType?: string;
    /**
     * List of user IDs that are eligible to approve this rule.
     */
    userIds?: number[];
}

export interface GetProjectApprovalRulesApprovalRuleArgs {
    /**
     * If true, applies the rule to all protected branches, ignoring the protected branches attribute.
     */
    appliesToAllProtectedBranches?: pulumi.Input<boolean>;
    /**
     * The number of approvals required for this rule.
     */
    approvalsRequired?: pulumi.Input<number>;
    /**
     * List of all approver IDs that are eligible to approve this rule.
     */
    eligibleApproverIds?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * List of group IDs that are eligible to approve this rule.
     */
    groupIds?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * The ID of the approval rule.
     */
    id?: pulumi.Input<number>;
    /**
     * The name of the approval rule.
     */
    name?: pulumi.Input<string>;
    /**
     * List of protected branch IDs that this rule applies to.
     */
    protectedBranchIds?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * The report type. Required when the rule type is `reportApprover`. The supported report types are `licenseScanning` and `codeCoverage`.
     */
    reportType?: pulumi.Input<string>;
    /**
     * The type of the approval rule. Can be `anyApprover`, `regular` or `reportApprover`.
     */
    ruleType?: pulumi.Input<string>;
    /**
     * List of user IDs that are eligible to approve this rule.
     */
    userIds?: pulumi.Input<pulumi.Input<number>[]>;
}

export interface GetProjectProtectedBranchMergeAccessLevel {
    /**
     * Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
     */
    accessLevel?: string;
    /**
     * Readable description of access level.
     */
    accessLevelDescription?: string;
    /**
     * The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `userId`.
     */
    groupId?: number;
    /**
     * The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `groupId`.
     */
    userId?: number;
}

export interface GetProjectProtectedBranchMergeAccessLevelArgs {
    /**
     * Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
     */
    accessLevel?: pulumi.Input<string>;
    /**
     * Readable description of access level.
     */
    accessLevelDescription?: pulumi.Input<string>;
    /**
     * The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `userId`.
     */
    groupId?: pulumi.Input<number>;
    /**
     * The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `groupId`.
     */
    userId?: pulumi.Input<number>;
}

export interface GetProjectProtectedBranchPushAccessLevel {
    /**
     * Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
     */
    accessLevel?: string;
    /**
     * Readable description of access level.
     */
    accessLevelDescription?: string;
    /**
     * The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `groupId` and `userId`. This field is read-only until Gitlab 17.5.
     */
    deployKeyId?: number;
    /**
     * The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deployKeyId` and `userId`.
     */
    groupId?: number;
    /**
     * The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deployKeyId` and `groupId`.
     */
    userId?: number;
}

export interface GetProjectProtectedBranchPushAccessLevelArgs {
    /**
     * Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
     */
    accessLevel?: pulumi.Input<string>;
    /**
     * Readable description of access level.
     */
    accessLevelDescription?: pulumi.Input<string>;
    /**
     * The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `groupId` and `userId`. This field is read-only until Gitlab 17.5.
     */
    deployKeyId?: pulumi.Input<number>;
    /**
     * The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deployKeyId` and `userId`.
     */
    groupId?: pulumi.Input<number>;
    /**
     * The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deployKeyId` and `groupId`.
     */
    userId?: pulumi.Input<number>;
}

export interface GetProjectProtectedBranchesProtectedBranch {
    /**
     * Whether force push is allowed.
     */
    allowForcePush?: boolean;
    /**
     * Reject code pushes that change files listed in the CODEOWNERS file.
     */
    codeOwnerApprovalRequired?: boolean;
    /**
     * The ID of this resource.
     */
    id?: number;
    /**
     * Array of access levels and user(s)/group(s) allowed to merge to protected branch.
     */
    mergeAccessLevels?: inputs.GetProjectProtectedBranchesProtectedBranchMergeAccessLevel[];
    /**
     * The name of the protected branch.
     */
    name?: string;
    /**
     * Array of access levels and user(s)/group(s) allowed to push to protected branch.
     */
    pushAccessLevels?: inputs.GetProjectProtectedBranchesProtectedBranchPushAccessLevel[];
}

export interface GetProjectProtectedBranchesProtectedBranchArgs {
    /**
     * Whether force push is allowed.
     */
    allowForcePush?: pulumi.Input<boolean>;
    /**
     * Reject code pushes that change files listed in the CODEOWNERS file.
     */
    codeOwnerApprovalRequired?: pulumi.Input<boolean>;
    /**
     * The ID of this resource.
     */
    id?: pulumi.Input<number>;
    /**
     * Array of access levels and user(s)/group(s) allowed to merge to protected branch.
     */
    mergeAccessLevels?: pulumi.Input<pulumi.Input<inputs.GetProjectProtectedBranchesProtectedBranchMergeAccessLevelArgs>[]>;
    /**
     * The name of the protected branch.
     */
    name?: pulumi.Input<string>;
    /**
     * Array of access levels and user(s)/group(s) allowed to push to protected branch.
     */
    pushAccessLevels?: pulumi.Input<pulumi.Input<inputs.GetProjectProtectedBranchesProtectedBranchPushAccessLevelArgs>[]>;
}

export interface GetProjectProtectedBranchesProtectedBranchMergeAccessLevel {
    /**
     * Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
     */
    accessLevel?: string;
    /**
     * Readable description of access level.
     */
    accessLevelDescription?: string;
    /**
     * The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `userId`.
     */
    groupId?: number;
    /**
     * The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `groupId`.
     */
    userId?: number;
}

export interface GetProjectProtectedBranchesProtectedBranchMergeAccessLevelArgs {
    /**
     * Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
     */
    accessLevel?: pulumi.Input<string>;
    /**
     * Readable description of access level.
     */
    accessLevelDescription?: pulumi.Input<string>;
    /**
     * The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `userId`.
     */
    groupId?: pulumi.Input<number>;
    /**
     * The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `groupId`.
     */
    userId?: pulumi.Input<number>;
}

export interface GetProjectProtectedBranchesProtectedBranchPushAccessLevel {
    /**
     * Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
     */
    accessLevel?: string;
    /**
     * Readable description of access level.
     */
    accessLevelDescription?: string;
    /**
     * The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `groupId` and `userId`. This field is read-only until Gitlab 17.5.
     */
    deployKeyId?: number;
    /**
     * The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deployKeyId` and `userId`.
     */
    groupId?: number;
    /**
     * The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deployKeyId` and `groupId`.
     */
    userId?: number;
}

export interface GetProjectProtectedBranchesProtectedBranchPushAccessLevelArgs {
    /**
     * Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
     */
    accessLevel?: pulumi.Input<string>;
    /**
     * Readable description of access level.
     */
    accessLevelDescription?: pulumi.Input<string>;
    /**
     * The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `groupId` and `userId`. This field is read-only until Gitlab 17.5.
     */
    deployKeyId?: pulumi.Input<number>;
    /**
     * The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deployKeyId` and `userId`.
     */
    groupId?: pulumi.Input<number>;
    /**
     * The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deployKeyId` and `groupId`.
     */
    userId?: pulumi.Input<number>;
}

export interface GetReleaseAssets {
    /**
     * The number of assets for a release
     */
    count?: number;
    /**
     * The links for a release
     */
    links?: inputs.GetReleaseAssetsLink[];
    /**
     * The sources for a release
     */
    sources?: inputs.GetReleaseAssetsSource[];
}

export interface GetReleaseAssetsArgs {
    /**
     * The number of assets for a release
     */
    count?: pulumi.Input<number>;
    /**
     * The links for a release
     */
    links?: pulumi.Input<pulumi.Input<inputs.GetReleaseAssetsLinkArgs>[]>;
    /**
     * The sources for a release
     */
    sources?: pulumi.Input<pulumi.Input<inputs.GetReleaseAssetsSourceArgs>[]>;
}

export interface GetReleaseAssetsLink {
    /**
     * The ID of the link
     */
    id?: number;
    /**
     * The type of the link
     */
    linkType?: string;
    /**
     * The name of the link
     */
    name?: string;
    /**
     * The URL of the link
     */
    url?: string;
}

export interface GetReleaseAssetsLinkArgs {
    /**
     * The ID of the link
     */
    id?: pulumi.Input<number>;
    /**
     * The type of the link
     */
    linkType?: pulumi.Input<string>;
    /**
     * The name of the link
     */
    name?: pulumi.Input<string>;
    /**
     * The URL of the link
     */
    url?: pulumi.Input<string>;
}

export interface GetReleaseAssetsSource {
    /**
     * The format of the source
     */
    format?: string;
    /**
     * The URL of the source
     */
    url?: string;
}

export interface GetReleaseAssetsSourceArgs {
    /**
     * The format of the source
     */
    format?: pulumi.Input<string>;
    /**
     * The URL of the source
     */
    url?: pulumi.Input<string>;
}

export interface GroupAccessTokenRotationConfiguration {
    /**
     * The duration (in days) the new token should be valid for.
     */
    expirationDays: pulumi.Input<number>;
    /**
     * The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
     */
    rotateBeforeDays: pulumi.Input<number>;
}

export interface GroupDefaultBranchProtectionDefaults {
    /**
     * Allow force push for all users with push access.
     */
    allowForcePush?: pulumi.Input<boolean>;
    /**
     * An array of access levels allowed to merge. Valid values are: `developer`, `maintainer`, `no one`.
     */
    allowedToMerges?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * An array of access levels allowed to push. Valid values are: `developer`, `maintainer`, `no one`.
     */
    allowedToPushes?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Allow developers to initial push.
     */
    developerCanInitialPush?: pulumi.Input<boolean>;
}

export interface GroupEpicBoardList {
    /**
     * The ID of the list.
     */
    id?: pulumi.Input<number>;
    /**
     * The ID of the label the list should be scoped to.
     */
    labelId?: pulumi.Input<number>;
    /**
     * The position of the list within the board. The position for the list is sed on the its position in the `lists` array.
     */
    position?: pulumi.Input<number>;
}

export interface GroupHookCustomHeader {
    /**
     * Key of the custom header.
     */
    key: pulumi.Input<string>;
    /**
     * Value of the custom header. This value cannot be imported.
     */
    value: pulumi.Input<string>;
}

export interface GroupIssueBoardList {
    /**
     * The ID of the list.
     */
    id?: pulumi.Input<number>;
    /**
     * The ID of the label the list should be scoped to.
     */
    labelId?: pulumi.Input<number>;
    /**
     * The explicit position of the list within the board, zero based.
     */
    position?: pulumi.Input<number>;
}

export interface GroupProtectedEnvironmentApprovalRule {
    /**
     * Levels of access allowed to approve a deployment to this protected environment. Mutually exclusive with `userId` and `groupId`. Valid values are `developer`, `maintainer`.
     */
    accessLevel?: pulumi.Input<string>;
    /**
     * Readable description of level of access.
     */
    accessLevelDescription?: pulumi.Input<string>;
    /**
     * The ID of the group allowed to approve a deployment to this protected environment. TThe group must be a sub-group under the given group. Mutually exclusive with `accessLevel` and `userId`.
     */
    groupId?: pulumi.Input<number>;
    /**
     * Group inheritance allows access rules to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
     */
    groupInheritanceType?: pulumi.Input<number>;
    /**
     * The unique ID of the Approval Rules object.
     */
    id?: pulumi.Input<number>;
    /**
     * The number of approval required to allow deployment to this protected environment. This is mutually exclusive with user_id.
     */
    requiredApprovals?: pulumi.Input<number>;
    /**
     * The ID of the user allowed to approve a deployment to this protected environment. The user must be a member of the group with Maintainer role or higher. Mutually exclusive with `accessLevel` and `groupId`.
     */
    userId?: pulumi.Input<number>;
}

export interface GroupProtectedEnvironmentDeployAccessLevel {
    /**
     * Levels of access required to deploy to this protected environment. Mutually exclusive with `userId` and `groupId`. Valid values are `developer`, `maintainer`.
     */
    accessLevel?: pulumi.Input<string>;
    /**
     * Readable description of level of access.
     */
    accessLevelDescription?: pulumi.Input<string>;
    /**
     * The ID of the group allowed to deploy to this protected environment. The group must be a sub-group under the given group. Mutually exclusive with `accessLevel` and `userId`.
     */
    groupId?: pulumi.Input<number>;
    /**
     * Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
     */
    groupInheritanceType?: pulumi.Input<number>;
    /**
     * The unique ID of the Deploy Access Level object.
     */
    id?: pulumi.Input<number>;
    /**
     * The ID of the user allowed to deploy to this protected environment. The user must be a member of the group with Maintainer role or higher. Mutually exclusive with `accessLevel` and `groupId`.
     */
    userId?: pulumi.Input<number>;
}

export interface GroupPushRules {
    /**
     * All commit author emails must match this regex, e.g. `@my-company.com$`.
     */
    authorEmailRegex?: pulumi.Input<string>;
    /**
     * All branch names must match this regex, e.g. `(feature|hotfix)\/*`.
     */
    branchNameRegex?: pulumi.Input<string>;
    /**
     * Only commits pushed using verified emails are allowed.
     */
    commitCommitterCheck?: pulumi.Input<boolean>;
    /**
     * Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
     */
    commitCommitterNameCheck?: pulumi.Input<boolean>;
    /**
     * No commit message is allowed to match this regex, for example `ssh\:\/\/`.
     */
    commitMessageNegativeRegex?: pulumi.Input<string>;
    /**
     * All commit messages must match this regex, e.g. `Fixed \d+\..*`.
     */
    commitMessageRegex?: pulumi.Input<string>;
    /**
     * Deny deleting a tag.
     */
    denyDeleteTag?: pulumi.Input<boolean>;
    /**
     * Filenames matching the regular expression provided in this attribute are not allowed, for example, `(jar|exe)$`.
     */
    fileNameRegex?: pulumi.Input<string>;
    /**
     * Maximum file size (MB) allowed.
     */
    maxFileSize?: pulumi.Input<number>;
    /**
     * Allows only GitLab users to author commits.
     */
    memberCheck?: pulumi.Input<boolean>;
    /**
     * GitLab will reject any files that are likely to contain secrets.
     */
    preventSecrets?: pulumi.Input<boolean>;
    /**
     * Reject commit when it’s not DCO certified.
     */
    rejectNonDcoCommits?: pulumi.Input<boolean>;
    /**
     * Only commits signed through GPG are allowed.
     */
    rejectUnsignedCommits?: pulumi.Input<boolean>;
}

export interface GroupServiceAccountAccessTokenRotationConfiguration {
    /**
     * The duration (in days) the new token should be valid for.
     */
    expirationDays?: pulumi.Input<number>;
    /**
     * The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
     */
    rotateBeforeDays: pulumi.Input<number>;
}

export interface GroupServiceAccountTimeouts {
    /**
     * How long to wait for the service account to be fully deleted. Defaults to 10 minutes.
     */
    delete?: pulumi.Input<string>;
}

export interface InstanceServiceAccountTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: pulumi.Input<string>;
}

export interface PersonalAccessTokenRotationConfiguration {
    /**
     * The duration (in days) the new token should be valid for.
     */
    expirationDays: pulumi.Input<number>;
    /**
     * The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
     */
    rotateBeforeDays: pulumi.Input<number>;
}

export interface ProjectAccessTokenRotationConfiguration {
    /**
     * The duration (in days) the new token should be valid for.
     */
    expirationDays: pulumi.Input<number>;
    /**
     * The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
     */
    rotateBeforeDays: pulumi.Input<number>;
}

export interface ProjectContainerExpirationPolicy {
    /**
     * The cadence of the policy. Valid values are: `1d`, `7d`, `14d`, `1month`, `3month`.
     */
    cadence?: pulumi.Input<string>;
    /**
     * If true, the policy is enabled.
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * The number of images to keep.
     */
    keepN?: pulumi.Input<number>;
    /**
     * The regular expression to match image names to delete.
     */
    nameRegexDelete?: pulumi.Input<string>;
    /**
     * The regular expression to match image names to keep.
     */
    nameRegexKeep?: pulumi.Input<string>;
    /**
     * The next time the policy will run.
     */
    nextRunAt?: pulumi.Input<string>;
    /**
     * The number of days to keep images.
     */
    olderThan?: pulumi.Input<string>;
}

export interface ProjectHookCustomHeader {
    /**
     * Key of the custom header.
     */
    key: pulumi.Input<string>;
    /**
     * Value of the custom header. This value cannot be imported.
     */
    value: pulumi.Input<string>;
}

export interface ProjectIssueBoardList {
    /**
     * The ID of the assignee the list should be scoped to. Requires a GitLab EE license.
     */
    assigneeId?: pulumi.Input<number>;
    /**
     * The ID of the list
     */
    id?: pulumi.Input<number>;
    /**
     * The ID of the iteration the list should be scoped to. Requires a GitLab EE license.
     */
    iterationId?: pulumi.Input<number>;
    /**
     * The ID of the label the list should be scoped to. Requires a GitLab EE license.
     */
    labelId?: pulumi.Input<number>;
    /**
     * The ID of the milestone the list should be scoped to. Requires a GitLab EE license.
     */
    milestoneId?: pulumi.Input<number>;
    /**
     * The position of the list within the board. The position for the list is based on the its position in the `lists` array.
     */
    position?: pulumi.Input<number>;
}

export interface ProjectIssueTaskCompletionStatus {
    /**
     * The number of tasks that are completed.
     */
    completedCount?: pulumi.Input<number>;
    /**
     * The number of tasks.
     */
    count?: pulumi.Input<number>;
}

export interface ProjectPagesSettingsDeployment {
    /**
     * Date the deployment was created.
     */
    createdAt?: pulumi.Input<string>;
    /**
     * The path prefix of the deployment when using parallel deployments.
     */
    pathPrefix?: pulumi.Input<string>;
    /**
     * The root directory of the deployment.
     */
    rootDirectory?: pulumi.Input<string>;
    /**
     * The URL of the deployment.
     */
    url?: pulumi.Input<string>;
}

export interface ProjectProtectedEnvironmentApprovalRule {
    /**
     * Levels of access allowed to approve a deployment to this protected environment. Mutually exclusive with `userId` and `groupId`. Valid values are `developer`, `maintainer`.
     */
    accessLevel?: pulumi.Input<string>;
    /**
     * Readable description of level of access.
     */
    accessLevelDescription?: pulumi.Input<string>;
    /**
     * The ID of the group allowed to approve a deployment to this protected environment. The project must be shared with the group. Mutually exclusive with `accessLevel` and `userId`.
     */
    groupId?: pulumi.Input<number>;
    /**
     * Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
     */
    groupInheritanceType?: pulumi.Input<number>;
    /**
     * The unique ID of the Approval Rules object.
     */
    id?: pulumi.Input<number>;
    /**
     * The number of approval required to allow deployment to this protected environment. This is mutually exclusive with user_id.
     */
    requiredApprovals?: pulumi.Input<number>;
    /**
     * The ID of the user allowed to approve a deployment to this protected environment. The user must be a member of the project. Mutually exclusive with `accessLevel` and `groupId`.
     */
    userId?: pulumi.Input<number>;
}

export interface ProjectProtectedEnvironmentDeployAccessLevel {
    /**
     * Levels of access required to deploy to this protected environment. Mutually exclusive with `userId` and `groupId`. Valid values are `developer`, `maintainer`.
     */
    accessLevel?: pulumi.Input<string>;
    /**
     * Readable description of level of access.
     */
    accessLevelDescription?: pulumi.Input<string>;
    /**
     * The ID of the group allowed to deploy to this protected environment. The project must be shared with the group. Mutually exclusive with `accessLevel` and `userId`.
     */
    groupId?: pulumi.Input<number>;
    /**
     * Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
     */
    groupInheritanceType?: pulumi.Input<number>;
    /**
     * The unique ID of the Deploy Access Level object.
     */
    id?: pulumi.Input<number>;
    /**
     * The ID of the user allowed to deploy to this protected environment. The user must be a member of the project. Mutually exclusive with `accessLevel` and `groupId`.
     */
    userId?: pulumi.Input<number>;
}

export interface ProjectProtectedEnvironmentDeployAccessLevelsAttribute {
    /**
     * Levels of access required to deploy to this protected environment. Mutually exclusive with `userId` and `groupId`. Valid values are `developer`, `maintainer`.
     */
    accessLevel?: pulumi.Input<string>;
    /**
     * Readable description of level of access.
     */
    accessLevelDescription?: pulumi.Input<string>;
    /**
     * The ID of the group allowed to deploy to this protected environment. The project must be shared with the group. Mutually exclusive with `accessLevel` and `userId`.
     */
    groupId?: pulumi.Input<number>;
    /**
     * Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
     */
    groupInheritanceType?: pulumi.Input<number>;
    /**
     * The unique ID of the Deploy Access Level object.
     */
    id?: pulumi.Input<number>;
    /**
     * The ID of the user allowed to deploy to this protected environment. The user must be a member of the project. Mutually exclusive with `accessLevel` and `groupId`.
     */
    userId?: pulumi.Input<number>;
}

export interface ProjectPushRules {
    /**
     * All commit author emails must match this regex, e.g. `@my-company.com$`.
     */
    authorEmailRegex?: pulumi.Input<string>;
    /**
     * All branch names must match this regex, e.g. `(feature|hotfix)\/*`.
     */
    branchNameRegex?: pulumi.Input<string>;
    /**
     * Users can only push commits to this repository that were committed with one of their own verified emails.
     */
    commitCommitterCheck?: pulumi.Input<boolean>;
    /**
     * Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
     */
    commitCommitterNameCheck?: pulumi.Input<boolean>;
    /**
     * No commit message is allowed to match this regex, e.g. `ssh\:\/\/`.
     */
    commitMessageNegativeRegex?: pulumi.Input<string>;
    /**
     * All commit messages must match this regex, e.g. `Fixed \d+\..*`.
     */
    commitMessageRegex?: pulumi.Input<string>;
    /**
     * Deny deleting a tag.
     */
    denyDeleteTag?: pulumi.Input<boolean>;
    /**
     * All committed filenames must not match this regex, e.g. `(jar|exe)$`.
     */
    fileNameRegex?: pulumi.Input<string>;
    /**
     * Maximum file size (MB).
     */
    maxFileSize?: pulumi.Input<number>;
    /**
     * Restrict commits by author (email) to existing GitLab users.
     */
    memberCheck?: pulumi.Input<boolean>;
    /**
     * GitLab will reject any files that are likely to contain secrets.
     */
    preventSecrets?: pulumi.Input<boolean>;
    /**
     * Reject commit when it’s not DCO certified.
     */
    rejectNonDcoCommits?: pulumi.Input<boolean>;
    /**
     * Reject commit when it’s not signed through GPG.
     */
    rejectUnsignedCommits?: pulumi.Input<boolean>;
}

export interface ProjectTagCommit {
    /**
     * The email of the author.
     */
    authorEmail?: pulumi.Input<string>;
    /**
     * The name of the author.
     */
    authorName?: pulumi.Input<string>;
    /**
     * The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
     */
    authoredDate?: pulumi.Input<string>;
    /**
     * The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
     */
    committedDate?: pulumi.Input<string>;
    /**
     * The email of the user that committed.
     */
    committerEmail?: pulumi.Input<string>;
    /**
     * The name of the user that committed.
     */
    committerName?: pulumi.Input<string>;
    /**
     * The unique id assigned to the commit by Gitlab.
     */
    id?: pulumi.Input<string>;
    /**
     * The commit message
     */
    message?: pulumi.Input<string>;
    /**
     * The id of the parents of the commit
     */
    parentIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The short id assigned to the commit by Gitlab.
     */
    shortId?: pulumi.Input<string>;
    /**
     * The title of the commit
     */
    title?: pulumi.Input<string>;
}

export interface ProjectTagRelease {
    /**
     * The description of release.
     */
    description?: pulumi.Input<string>;
    /**
     * The name of the tag.
     */
    tagName?: pulumi.Input<string>;
}

export interface ReleaseAssets {
    /**
     * The total count of assets in this release.
     */
    count?: pulumi.Input<number>;
}

export interface ReleaseAuthor {
    /**
     * The url of the author's' user avatar.
     */
    avatarUrl?: pulumi.Input<string>;
    /**
     * The ID of the author's user.
     */
    id?: pulumi.Input<number>;
    /**
     * The name of the author.
     */
    name?: pulumi.Input<string>;
    /**
     * The state of the author's user.
     */
    state?: pulumi.Input<string>;
    /**
     * The username of the author.
     */
    username?: pulumi.Input<string>;
    /**
     * The url to the author's user profile.
     */
    webUrl?: pulumi.Input<string>;
}

export interface ReleaseCommit {
    /**
     * The email address of the commit author.
     */
    authorEmail?: pulumi.Input<string>;
    /**
     * The name of the commit author.
     */
    authorName?: pulumi.Input<string>;
    /**
     * The date and time the commit was authored. In ISO 8601 format (2019-03-15T08:00:00Z).
     */
    authoredDate?: pulumi.Input<string>;
    /**
     * The date and time the commit was made. In ISO 8601 format (2019-03-15T08:00:00Z).
     */
    committedDate?: pulumi.Input<string>;
    /**
     * The email address of the committer.
     */
    committerEmail?: pulumi.Input<string>;
    /**
     * The name of the committer.
     */
    committerName?: pulumi.Input<string>;
    /**
     * The date and time the commit was created. In ISO 8601 format (2019-03-15T08:00:00Z).
     */
    createdAt?: pulumi.Input<string>;
    /**
     * The git commit full SHA
     */
    id?: pulumi.Input<string>;
    /**
     * The commit message.
     */
    message?: pulumi.Input<string>;
    /**
     * The full SHA of any parent commits.
     */
    parentIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The git commit short SHA.
     */
    shortId?: pulumi.Input<string>;
    /**
     * The title of the commit.
     */
    title?: pulumi.Input<string>;
}

export interface ReleaseLinks {
    /**
     * URL of the release's closed issues.
     */
    closedIssuesUrl?: pulumi.Input<string>;
    /**
     * URL of the release's closed merge requests.
     */
    closedMergeRequestsUrl?: pulumi.Input<string>;
    /**
     * URL of the release's edit page.
     */
    editUrl?: pulumi.Input<string>;
    /**
     * URL of the release's merged merge requests.
     */
    mergedMergeRequestsUrl?: pulumi.Input<string>;
    /**
     * URL of the release's open issues.
     */
    openedIssuesUrl?: pulumi.Input<string>;
    /**
     * URL of the release's open merge requests.
     */
    openedMergeRequestsUrl?: pulumi.Input<string>;
    /**
     * URL of the release.
     */
    self?: pulumi.Input<string>;
}

export interface TagProtectionAllowedToCreate {
    /**
     * Access levels allowed to create protected tags. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
     */
    accessLevel?: pulumi.Input<string>;
    /**
     * Readable description of access level.
     */
    accessLevelDescription?: pulumi.Input<string>;
    /**
     * The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `userId`.
     */
    groupId?: pulumi.Input<number>;
    /**
     * The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `groupId`.
     */
    userId?: pulumi.Input<number>;
}

export interface ValueStreamAnalyticsStage {
    /**
     * Boolean whether the stage is customized. If false, it assigns a built-in default stage by name.
     */
    custom?: pulumi.Input<boolean>;
    /**
     * End event identifier. Valid values are: `CODE_STAGE_START`, `ISSUE_CLOSED`, `ISSUE_CREATED`, `ISSUE_DEPLOYED_TO_PRODUCTION`, `ISSUE_FIRST_ADDED_TO_BOARD`, `ISSUE_FIRST_ADDED_TO_ITERATION`, `ISSUE_FIRST_ASSIGNED_AT`, `ISSUE_FIRST_ASSOCIATED_WITH_MILESTONE`, `ISSUE_FIRST_MENTIONED_IN_COMMIT`, `ISSUE_LABEL_ADDED`, `ISSUE_LABEL_REMOVED`, `ISSUE_LAST_EDITED`, `ISSUE_STAGE_END`, `MERGE_REQUEST_CLOSED`, `MERGE_REQUEST_CREATED`, `MERGE_REQUEST_FIRST_ASSIGNED_AT`, `MERGE_REQUEST_FIRST_COMMIT_AT`, `MERGE_REQUEST_FIRST_DEPLOYED_TO_PRODUCTION`, `MERGE_REQUEST_LABEL_ADDED`, `MERGE_REQUEST_LABEL_REMOVED`, `MERGE_REQUEST_LAST_BUILD_FINISHED`, `MERGE_REQUEST_LAST_BUILD_STARTED`, `MERGE_REQUEST_LAST_EDITED`, `MERGE_REQUEST_MERGED`, `MERGE_REQUEST_REVIEWER_FIRST_ASSIGNED`, `MERGE_REQUEST_PLAN_STAGE_START`
     */
    endEventIdentifier?: pulumi.Input<string>;
    /**
     * Label ID associated with the end event identifier. In the format of `gid://gitlab/GroupLabel/<id>` or `gid://gitlab/ProjectLabel/<id>`
     */
    endEventLabelId?: pulumi.Input<string>;
    /**
     * Boolean whether the stage is hidden, GitLab provided default stages are hidden by default.
     */
    hidden?: pulumi.Input<boolean>;
    /**
     * The ID of the value stream stage.
     */
    id?: pulumi.Input<string>;
    /**
     * The name of the value stream stage.
     */
    name: pulumi.Input<string>;
    /**
     * Start event identifier. Valid values are: `CODE_STAGE_START`, `ISSUE_CLOSED`, `ISSUE_CREATED`, `ISSUE_DEPLOYED_TO_PRODUCTION`, `ISSUE_FIRST_ADDED_TO_BOARD`, `ISSUE_FIRST_ADDED_TO_ITERATION`, `ISSUE_FIRST_ASSIGNED_AT`, `ISSUE_FIRST_ASSOCIATED_WITH_MILESTONE`, `ISSUE_FIRST_MENTIONED_IN_COMMIT`, `ISSUE_LABEL_ADDED`, `ISSUE_LABEL_REMOVED`, `ISSUE_LAST_EDITED`, `ISSUE_STAGE_END`, `MERGE_REQUEST_CLOSED`, `MERGE_REQUEST_CREATED`, `MERGE_REQUEST_FIRST_ASSIGNED_AT`, `MERGE_REQUEST_FIRST_COMMIT_AT`, `MERGE_REQUEST_FIRST_DEPLOYED_TO_PRODUCTION`, `MERGE_REQUEST_LABEL_ADDED`, `MERGE_REQUEST_LABEL_REMOVED`, `MERGE_REQUEST_LAST_BUILD_FINISHED`, `MERGE_REQUEST_LAST_BUILD_STARTED`, `MERGE_REQUEST_LAST_EDITED`, `MERGE_REQUEST_MERGED`, `MERGE_REQUEST_REVIEWER_FIRST_ASSIGNED`, `MERGE_REQUEST_PLAN_STAGE_START`
     */
    startEventIdentifier?: pulumi.Input<string>;
    /**
     * Label ID associated with the start event identifier. In the format of `gid://gitlab/GroupLabel/<id>` or `gid://gitlab/ProjectLabel/<id>`
     */
    startEventLabelId?: pulumi.Input<string>;
}
