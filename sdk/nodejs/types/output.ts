// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface BranchCommit {
    authorEmail: string;
    authorName: string;
    authoredDate: string;
    committedDate: string;
    committerEmail: string;
    committerName: string;
    id: string;
    message: string;
    parentIds: string[];
    shortId: string;
    title: string;
}

export interface BranchProtectionAllowedToMerge {
    /**
     * Level of access.
     */
    accessLevel: string;
    /**
     * Readable description of level of access.
     */
    accessLevelDescription: string;
    /**
     * The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `userId`.
     */
    groupId?: number;
    /**
     * The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `groupId`.
     */
    userId?: number;
}

export interface BranchProtectionAllowedToPush {
    /**
     * Level of access.
     */
    accessLevel: string;
    /**
     * Readable description of level of access.
     */
    accessLevelDescription: string;
    /**
     * The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `userId`.
     */
    groupId?: number;
    /**
     * The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `groupId`.
     */
    userId?: number;
}

export interface BranchProtectionAllowedToUnprotect {
    /**
     * Level of access.
     */
    accessLevel: string;
    /**
     * Readable description of level of access.
     */
    accessLevelDescription: string;
    /**
     * The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `userId`.
     */
    groupId?: number;
    /**
     * The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `groupId`.
     */
    userId?: number;
}

export interface GetBranchCommit {
    authorEmail: string;
    authorName: string;
    authoredDate: string;
    committedDate: string;
    committerEmail: string;
    committerName: string;
    id: string;
    message: string;
    parentIds: string[];
    shortId: string;
    title: string;
}

export interface GetClusterAgentsClusterAgent {
    agentId: number;
    createdAt: string;
    createdByUserId: number;
    name: string;
    project: string;
}

export interface GetGroupHooksHook {
    confidentialIssuesEvents: boolean;
    confidentialNoteEvents: boolean;
    deploymentEvents: boolean;
    enableSslVerification: boolean;
    group: string;
    groupId: number;
    hookId: number;
    issuesEvents: boolean;
    jobEvents: boolean;
    mergeRequestsEvents: boolean;
    noteEvents: boolean;
    pipelineEvents: boolean;
    pushEvents: boolean;
    pushEventsBranchFilter: string;
    releasesEvents: boolean;
    subgroupEvents: boolean;
    tagPushEvents: boolean;
    token: string;
    url: string;
    wikiPageEvents: boolean;
}

export interface GetGroupMembershipMember {
    accessLevel: string;
    avatarUrl: string;
    expiresAt: string;
    id: number;
    name: string;
    state: string;
    username: string;
    webUrl: string;
}

export interface GetGroupSubgroupsSubgroup {
    autoDevopsEnabled: boolean;
    avatarUrl: string;
    createdAt: string;
    defaultBranchProtection: number;
    description: string;
    emailsDisabled: boolean;
    fileTemplateProjectId: number;
    fullName: string;
    fullPath: string;
    groupId: number;
    ipRestrictionRanges: string;
    lfsEnabled: boolean;
    mentionsDisabled: boolean;
    name: string;
    parentId: number;
    path: string;
    projectCreationLevel: string;
    requestAccessEnabled: boolean;
    requireTwoFactorAuthentication: boolean;
    shareWithGroupLock: boolean;
    sharedRunnersSetting: string;
    statistics: {[key: string]: string};
    subgroupCreationLevel: string;
    twoFactorGracePeriod: number;
    visibility: string;
    webUrl: string;
    wikiAccessLevel: string;
}

export interface GetGroupVariablesVariable {
    environmentScope: string;
    group: string;
    key: string;
    masked: boolean;
    protected: boolean;
    raw: boolean;
    value: string;
    variableType: string;
}

export interface GetGroupsGroup {
    defaultBranchProtection: number;
    description: string;
    fullName: string;
    fullPath: string;
    groupId: number;
    lfsEnabled: boolean;
    name: string;
    parentId: number;
    path: string;
    preventForkingOutsideGroup: boolean;
    requestAccessEnabled: boolean;
    runnersToken: string;
    sharedRunnersSetting: string;
    visibilityLevel: string;
    webUrl: string;
    wikiAccessLevel: string;
}

export interface GetInstanceDeployKeysDeployKey {
    createdAt: string;
    fingerprint: string;
    id: number;
    key: string;
    projectsWithWriteAccesses: outputs.GetInstanceDeployKeysDeployKeyProjectsWithWriteAccess[];
    title: string;
}

export interface GetInstanceDeployKeysDeployKeyProjectsWithWriteAccess {
    createdAt: string;
    description: string;
    id: number;
    name: string;
    nameWithNamespace: string;
    path: string;
    pathWithNamespace: string;
}

export interface GetInstanceVariablesVariable {
    key: string;
    masked: boolean;
    protected: boolean;
    raw: boolean;
    value: string;
    variableType: string;
}

export interface GetMetadataKas {
    /**
     * Indicates whether KAS is enabled.
     */
    enabled: boolean;
    /**
     * URL used by the agents to communicate with KAS. It’s null if kas.enabled is false.
     */
    externalUrl: string;
    /**
     * Version of KAS. It’s null if kas.enabled is false.
     */
    version: string;
}

export interface GetProjectBranchesBranch {
    canPush: boolean;
    commits: outputs.GetProjectBranchesBranchCommit[];
    default: boolean;
    developersCanMerge: boolean;
    developersCanPush: boolean;
    merged: boolean;
    name: string;
    protected: boolean;
    webUrl: string;
}

export interface GetProjectBranchesBranchCommit {
    authorEmail: string;
    authorName: string;
    authoredDate: string;
    committedDate: string;
    committerEmail: string;
    committerName: string;
    id: string;
    message: string;
    parentIds: string[];
    shortId: string;
    title: string;
}

export interface GetProjectContainerExpirationPolicy {
    cadence: string;
    enabled: boolean;
    keepN: number;
    /**
     * @deprecated `name_regex` has been deprecated. Use `name_regex_delete` instead.
     */
    nameRegex: string;
    nameRegexDelete: string;
    nameRegexKeep: string;
    nextRunAt: string;
    olderThan: string;
}

export interface GetProjectHooksHook {
    confidentialIssuesEvents: boolean;
    confidentialNoteEvents: boolean;
    deploymentEvents: boolean;
    enableSslVerification: boolean;
    hookId: number;
    issuesEvents: boolean;
    jobEvents: boolean;
    mergeRequestsEvents: boolean;
    noteEvents: boolean;
    pipelineEvents: boolean;
    project: string;
    projectId: number;
    pushEvents: boolean;
    pushEventsBranchFilter: string;
    releasesEvents: boolean;
    tagPushEvents: boolean;
    token: string;
    url: string;
    wikiPageEvents: boolean;
}

export interface GetProjectIssueTaskCompletionStatus {
    completedCount: number;
    count: number;
}

export interface GetProjectIssuesIssue {
    assigneeIds: number[];
    authorId: number;
    closedAt: string;
    closedByUserId: number;
    confidential: boolean;
    createdAt: string;
    description: string;
    discussionLocked: boolean;
    discussionToResolve: string;
    downvotes: number;
    dueDate: string;
    epicId: number;
    epicIssueId: number;
    externalId: string;
    humanTimeEstimate: string;
    humanTotalTimeSpent: string;
    iid: number;
    issueId: number;
    issueLinkId: number;
    issueType: string;
    labels: string[];
    links: {[key: string]: string};
    mergeRequestToResolveDiscussionsOf: number;
    mergeRequestsCount: number;
    milestoneId: number;
    movedToId: number;
    project: string;
    references: {[key: string]: string};
    state: string;
    subscribed: boolean;
    taskCompletionStatuses: outputs.GetProjectIssuesIssueTaskCompletionStatus[];
    timeEstimate: number;
    title: string;
    totalTimeSpent: number;
    updatedAt: string;
    upvotes: number;
    userNotesCount: number;
    webUrl: string;
    weight: number;
}

export interface GetProjectIssuesIssueTaskCompletionStatus {
    completedCount: number;
    count: number;
}

export interface GetProjectMembershipMember {
    accessLevel: string;
    avatarUrl: string;
    expiresAt: string;
    id: number;
    name: string;
    state: string;
    username: string;
    webUrl: string;
}

export interface GetProjectMilestonesMilestone {
    createdAt: string;
    description: string;
    dueDate: string;
    expired: boolean;
    iid: number;
    milestoneId: number;
    project: string;
    projectId: number;
    startDate: string;
    state: string;
    title: string;
    updatedAt: string;
    webUrl: string;
}

export interface GetProjectProtectedBranchMergeAccessLevel {
    accessLevel: string;
    accessLevelDescription: string;
    groupId: number;
    userId: number;
}

export interface GetProjectProtectedBranchPushAccessLevel {
    accessLevel: string;
    accessLevelDescription: string;
    groupId: number;
    userId: number;
}

export interface GetProjectProtectedBranchesProtectedBranch {
    allowForcePush: boolean;
    codeOwnerApprovalRequired: boolean;
    id: number;
    mergeAccessLevels: outputs.GetProjectProtectedBranchesProtectedBranchMergeAccessLevel[];
    name: string;
    pushAccessLevels: outputs.GetProjectProtectedBranchesProtectedBranchPushAccessLevel[];
}

export interface GetProjectProtectedBranchesProtectedBranchMergeAccessLevel {
    accessLevel: string;
    accessLevelDescription: string;
    groupId: number;
    userId: number;
}

export interface GetProjectProtectedBranchesProtectedBranchPushAccessLevel {
    accessLevel: string;
    accessLevelDescription: string;
    groupId: number;
    userId: number;
}

export interface GetProjectPushRule {
    authorEmailRegex: string;
    branchNameRegex: string;
    commitCommitterCheck: boolean;
    commitMessageNegativeRegex: string;
    commitMessageRegex: string;
    denyDeleteTag: boolean;
    fileNameRegex: string;
    maxFileSize: number;
    memberCheck: boolean;
    preventSecrets: boolean;
    rejectUnsignedCommits: boolean;
}

export interface GetProjectTagCommit {
    authorEmail: string;
    authorName: string;
    authoredDate: string;
    committedDate: string;
    committerEmail: string;
    committerName: string;
    id: string;
    message: string;
    parentIds: string[];
    shortId: string;
    title: string;
}

export interface GetProjectTagRelease {
    description: string;
    tagName: string;
}

export interface GetProjectTagsTag {
    commits: outputs.GetProjectTagsTagCommit[];
    message: string;
    name: string;
    protected: boolean;
    releases: outputs.GetProjectTagsTagRelease[];
    target: string;
}

export interface GetProjectTagsTagCommit {
    authorEmail: string;
    authorName: string;
    authoredDate: string;
    committedDate: string;
    committerEmail: string;
    committerName: string;
    id: string;
    message: string;
    parentIds: string[];
    shortId: string;
    title: string;
}

export interface GetProjectTagsTagRelease {
    description: string;
    tagName: string;
}

export interface GetProjectVariablesVariable {
    environmentScope: string;
    key: string;
    masked: boolean;
    project: string;
    protected: boolean;
    raw: boolean;
    value: string;
    variableType: string;
}

export interface GetProjectsProject {
    _links: {[key: string]: string};
    allowMergeOnSkippedPipeline: boolean;
    analyticsAccessLevel: string;
    approvalsBeforeMerge: number;
    archived: boolean;
    autoCancelPendingPipelines: string;
    autoDevopsDeployStrategy: string;
    autoDevopsEnabled: boolean;
    autocloseReferencedIssues: boolean;
    avatarUrl: string;
    buildCoverageRegex: string;
    buildGitStrategy: string;
    buildTimeout: number;
    buildsAccessLevel: string;
    ciConfigPath: string;
    ciDefaultGitDepth: number;
    ciForwardDeploymentEnabled: boolean;
    containerExpirationPolicies: outputs.GetProjectsProjectContainerExpirationPolicy[];
    containerRegistryAccessLevel: string;
    containerRegistryEnabled: boolean;
    createdAt: string;
    creatorId: number;
    customAttributes: {[key: string]: string}[];
    defaultBranch: string;
    description: string;
    emailsDisabled: boolean;
    emptyRepo: boolean;
    environmentsAccessLevel: string;
    externalAuthorizationClassificationLabel: string;
    featureFlagsAccessLevel: string;
    forkedFromProjects: outputs.GetProjectsProjectForkedFromProject[];
    forkingAccessLevel: string;
    forksCount: number;
    httpUrlToRepo: string;
    id: number;
    importError: string;
    importStatus: string;
    importUrl: string;
    infrastructureAccessLevel: string;
    issuesAccessLevel: string;
    issuesEnabled: boolean;
    jobsEnabled: boolean;
    keepLatestArtifact: boolean;
    lastActivityAt: string;
    lfsEnabled: boolean;
    mergeCommitTemplate: string;
    mergeMethod: string;
    mergePipelinesEnabled: boolean;
    mergeRequestsAccessLevel: string;
    mergeRequestsEnabled: boolean;
    mergeTrainsEnabled: boolean;
    mirror: boolean;
    mirrorOverwritesDivergedBranches: boolean;
    mirrorTriggerBuilds: boolean;
    mirrorUserId: number;
    monitorAccessLevel: string;
    name: string;
    nameWithNamespace: string;
    namespaces: outputs.GetProjectsProjectNamespace[];
    onlyAllowMergeIfAllDiscussionsAreResolved: boolean;
    onlyAllowMergeIfPipelineSucceeds: boolean;
    onlyMirrorProtectedBranches: boolean;
    openIssuesCount: number;
    owners: outputs.GetProjectsProjectOwner[];
    packagesEnabled: boolean;
    path: string;
    pathWithNamespace: string;
    permissions: outputs.GetProjectsProjectPermission[];
    public: boolean;
    publicBuilds: boolean;
    readmeUrl: string;
    releasesAccessLevel: string;
    repositoryAccessLevel: string;
    repositoryStorage: string;
    requestAccessEnabled: boolean;
    requirementsAccessLevel: string;
    resolveOutdatedDiffDiscussions: boolean;
    restrictUserDefinedVariables: boolean;
    runnersToken: string;
    securityAndComplianceAccessLevel: string;
    sharedRunnersEnabled: boolean;
    sharedWithGroups: outputs.GetProjectsProjectSharedWithGroup[];
    snippetsAccessLevel: string;
    snippetsEnabled: boolean;
    squashCommitTemplate: string;
    sshUrlToRepo: string;
    starCount: number;
    statistics: {[key: string]: number};
    suggestionCommitMessage: string;
    tagLists: string[];
    topics: string[];
    visibility: string;
    webUrl: string;
    wikiAccessLevel: string;
    wikiEnabled: boolean;
}

export interface GetProjectsProjectContainerExpirationPolicy {
    cadence: string;
    enabled: boolean;
    keepN: number;
    /**
     * @deprecated `name_regex` has been deprecated. Use `name_regex_delete` instead.
     */
    nameRegex: string;
    nameRegexDelete: string;
    nameRegexKeep: string;
    nextRunAt: string;
    olderThan: string;
}

export interface GetProjectsProjectForkedFromProject {
    httpUrlToRepo: string;
    id: number;
    name: string;
    nameWithNamespace: string;
    path: string;
    pathWithNamespace: string;
    webUrl: string;
}

export interface GetProjectsProjectNamespace {
    fullPath: string;
    id: number;
    kind: string;
    name: string;
    path: string;
}

export interface GetProjectsProjectOwner {
    avatarUrl: string;
    id: number;
    name: string;
    state: string;
    username: string;
    websiteUrl: string;
}

export interface GetProjectsProjectPermission {
    groupAccess: {[key: string]: number};
    projectAccess: {[key: string]: number};
}

export interface GetProjectsProjectSharedWithGroup {
    groupAccessLevel: string;
    groupId: number;
    groupName: string;
}

export interface GetReleaseLinksReleaseLink {
    directAssetUrl: string;
    external: boolean;
    filepath: string;
    linkId: number;
    linkType: string;
    name: string;
    project: string;
    tagName: string;
    url: string;
}

export interface GetRepositoryTreeTree {
    id: string;
    mode: string;
    name: string;
    path: string;
    type: string;
}

export interface GetUserSshkeysKey {
    createdAt: string;
    expiresAt: string;
    key: string;
    keyId: number;
    title: string;
    userId: number;
}

export interface GetUsersUser {
    avatarUrl: string;
    bio: string;
    canCreateGroup: boolean;
    canCreateProject: boolean;
    colorSchemeId: number;
    createdAt: string;
    currentSignInAt: string;
    email: string;
    externUid: string;
    external: boolean;
    id: number;
    isAdmin: boolean;
    lastSignInAt: string;
    linkedin: string;
    location: string;
    name: string;
    namespaceId: number;
    organization: string;
    projectsLimit: number;
    provider: string;
    skype: string;
    state: string;
    themeId: number;
    twitter: string;
    twoFactorEnabled: boolean;
    username: string;
    websiteUrl: string;
}

export interface GroupEpicBoardList {
    /**
     * The ID of the list.
     */
    id: number;
    /**
     * The ID of the label the list should be scoped to.
     */
    labelId?: number;
    /**
     * The position of the list within the board. The position for the list is sed on the its position in the `lists` array.
     */
    position: number;
}

export interface GroupIssueBoardList {
    /**
     * The ID of the list.
     */
    id: number;
    /**
     * The ID of the label the list should be scoped to.
     */
    labelId?: number;
    /**
     * The position of the list within the board. The position for the list is based on the its position in the `lists` array.
     */
    position: number;
}

export interface GroupProtectedEnvironmentApprovalRule {
    /**
     * Levels of access allowed to approve a deployment to this protected environment. Valid values are `developer`, `maintainer`.
     */
    accessLevel?: string;
    /**
     * Readable description of level of access.
     */
    accessLevelDescription: string;
    /**
     * The ID of the group allowed to approve a deployment to this protected environment. TThe group must be a sub-group under the given group. This is mutually exclusive with user_id.
     */
    groupId?: number;
    /**
     * The unique ID of the Approval Rules object.
     */
    id: number;
    /**
     * The number of approval required to allow deployment to this protected environment. This is mutually exclusive with user_id.
     */
    requiredApprovals: number;
    /**
     * The ID of the user allowed to approve a deployment to this protected environment. The user must be a member of the group with Maintainer role or higher. This is mutually exclusive with group*id and required*approvals.
     */
    userId?: number;
}

export interface GroupProtectedEnvironmentDeployAccessLevel {
    /**
     * Levels of access required to deploy to this protected environment. Valid values are `developer`, `maintainer`.
     */
    accessLevel?: string;
    /**
     * Readable description of level of access.
     */
    accessLevelDescription: string;
    /**
     * The ID of the group allowed to deploy to this protected environment. The group must be a sub-group under the given group.
     */
    groupId?: number;
    /**
     * The unique ID of the Deploy Access Level object.
     */
    id: number;
    /**
     * The ID of the user allowed to deploy to this protected environment. The user must be a member of the group with Maintainer role or higher.
     */
    userId?: number;
}

export interface GroupPushRules {
    /**
     * All commit author emails must match this regex, e.g. `@my-company.com$`.
     */
    authorEmailRegex: string;
    /**
     * All branch names must match this regex, e.g. `(feature|hotfix)\/*`.
     */
    branchNameRegex: string;
    /**
     * Only commits pushed using verified emails are allowed.  **Note** This attribute is only supported in GitLab versions >= 16.4.
     */
    commitCommitterCheck: boolean;
    /**
     * No commit message is allowed to match this regex, for example `ssh\:\/\/`.
     */
    commitMessageNegativeRegex: string;
    /**
     * All commit messages must match this regex, e.g. `Fixed \d+\..*`.
     */
    commitMessageRegex: string;
    /**
     * Deny deleting a tag.
     */
    denyDeleteTag: boolean;
    /**
     * Filenames matching the regular expression provided in this attribute are not allowed, for example, `(jar|exe)$`.
     */
    fileNameRegex: string;
    /**
     * Maximum file size (MB) allowed.
     */
    maxFileSize: number;
    /**
     * Allows only GitLab users to author commits.
     */
    memberCheck: boolean;
    /**
     * GitLab will reject any files that are likely to contain secrets.
     */
    preventSecrets: boolean;
    /**
     * Only commits signed through GPG are allowed.  **Note** This attribute is only supported in GitLab versions >= 16.4.
     */
    rejectUnsignedCommits: boolean;
}

export interface ProjectContainerExpirationPolicy {
    /**
     * The cadence of the policy. Valid values are: `1d`, `7d`, `14d`, `1month`, `3month`.
     */
    cadence: string;
    /**
     * If true, the policy is enabled.
     */
    enabled: boolean;
    /**
     * The number of images to keep.
     */
    keepN: number;
    /**
     * The regular expression to match image names to delete.
     *
     * @deprecated `name_regex` has been deprecated. Use `name_regex_delete` instead.
     */
    nameRegex: string;
    /**
     * The regular expression to match image names to delete.
     */
    nameRegexDelete: string;
    /**
     * The regular expression to match image names to keep.
     */
    nameRegexKeep: string;
    /**
     * The next time the policy will run.
     */
    nextRunAt: string;
    /**
     * The number of days to keep images.
     */
    olderThan: string;
}

export interface ProjectIssueBoardList {
    /**
     * The ID of the assignee the list should be scoped to. Requires a GitLab EE license.
     */
    assigneeId?: number;
    /**
     * The ID of the list
     */
    id: number;
    /**
     * The ID of the iteration the list should be scoped to. Requires a GitLab EE license.
     */
    iterationId?: number;
    /**
     * The ID of the label the list should be scoped to. Requires a GitLab EE license.
     */
    labelId?: number;
    /**
     * The ID of the milestone the list should be scoped to. Requires a GitLab EE license.
     */
    milestoneId?: number;
    /**
     * The position of the list within the board. The position for the list is based on the its position in the `lists` array.
     */
    position: number;
}

export interface ProjectIssueTaskCompletionStatus {
    completedCount: number;
    count: number;
}

export interface ProjectProtectedEnvironmentApprovalRule {
    /**
     * Levels of access allowed to approve a deployment to this protected environment. Valid values are `developer`, `maintainer`.
     */
    accessLevel?: string;
    /**
     * Readable description of level of access.
     */
    accessLevelDescription: string;
    /**
     * The ID of the group allowed to approve a deployment to this protected environment. The project must be shared with the group. This is mutually exclusive with user_id.
     */
    groupId?: number;
    /**
     * The unique ID of the Approval Rules object.
     */
    id: number;
    /**
     * The number of approval required to allow deployment to this protected environment. This is mutually exclusive with user_id.
     */
    requiredApprovals: number;
    /**
     * The ID of the user allowed to approve a deployment to this protected environment. The user must be a member of the project. This is mutually exclusive with group*id and required*approvals.
     */
    userId?: number;
}

export interface ProjectProtectedEnvironmentDeployAccessLevel {
    /**
     * Levels of access required to deploy to this protected environment. Valid values are `developer`, `maintainer`.
     */
    accessLevel?: string;
    /**
     * Readable description of level of access.
     */
    accessLevelDescription: string;
    /**
     * The ID of the group allowed to deploy to this protected environment. The project must be shared with the group.
     */
    groupId?: number;
    /**
     * The unique ID of the Deploy Access Level object.
     */
    id: number;
    /**
     * The ID of the user allowed to deploy to this protected environment. The user must be a member of the project.
     */
    userId?: number;
}

export interface ProjectPushRules {
    /**
     * All commit author emails must match this regex, e.g. `@my-company.com$`.
     */
    authorEmailRegex?: string;
    /**
     * All branch names must match this regex, e.g. `(feature|hotfix)\/*`.
     */
    branchNameRegex?: string;
    /**
     * Users can only push commits to this repository that were committed with one of their own verified emails.
     */
    commitCommitterCheck?: boolean;
    /**
     * No commit message is allowed to match this regex, for example `ssh\:\/\/`.
     */
    commitMessageNegativeRegex?: string;
    /**
     * All commit messages must match this regex, e.g. `Fixed \d+\..*`.
     */
    commitMessageRegex?: string;
    /**
     * Deny deleting a tag.
     */
    denyDeleteTag?: boolean;
    /**
     * All committed filenames must not match this regex, e.g. `(jar|exe)$`.
     */
    fileNameRegex?: string;
    /**
     * Maximum file size (MB).
     */
    maxFileSize?: number;
    /**
     * Restrict commits by author (email) to existing GitLab users.
     */
    memberCheck?: boolean;
    /**
     * GitLab will reject any files that are likely to contain secrets.
     */
    preventSecrets?: boolean;
    /**
     * Reject commit when it’s not signed through GPG.
     */
    rejectUnsignedCommits?: boolean;
}

export interface ProjectTagCommit {
    authorEmail: string;
    authorName: string;
    authoredDate: string;
    committedDate: string;
    committerEmail: string;
    committerName: string;
    id: string;
    message: string;
    parentIds: string[];
    shortId: string;
    title: string;
}

export interface ProjectTagRelease {
    description: string;
    tagName: string;
}

export interface TagProtectionAllowedToCreate {
    /**
     * Level of access.
     */
    accessLevel: string;
    /**
     * Readable description of level of access.
     */
    accessLevelDescription: string;
    /**
     * The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `userId`.
     */
    groupId?: number;
    /**
     * The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `groupId`.
     */
    userId?: number;
}

