// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ApplicationSettingsDefaultBranchProtectionDefaults {
    /**
     * Allow force push for all users with push access.
     */
    allowForcePush: boolean;
    /**
     * An array of access levels allowed to merge. Supports Developer (30) or Maintainer (40).
     */
    allowedToMerges: number[];
    /**
     * An array of access levels allowed to push. Supports Developer (30) or Maintainer (40).
     */
    allowedToPushes: number[];
    /**
     * Allow developers to initial push.
     */
    developerCanInitialPush: boolean;
}

export interface BranchCommit {
    /**
     * The email of the author.
     */
    authorEmail: string;
    /**
     * The name of the author.
     */
    authorName: string;
    /**
     * The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
     */
    authoredDate: string;
    /**
     * The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
     */
    committedDate: string;
    /**
     * The email of the user that committed.
     */
    committerEmail: string;
    /**
     * The name of the user that committed.
     */
    committerName: string;
    /**
     * The unique id assigned to the commit by Gitlab.
     */
    id: string;
    /**
     * The commit message
     */
    message: string;
    /**
     * The id of the parents of the commit
     */
    parentIds: string[];
    /**
     * The short id assigned to the commit by Gitlab.
     */
    shortId: string;
    /**
     * The title of the commit
     */
    title: string;
}

export interface BranchProtectionAllowedToMerge {
    /**
     * Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
     */
    accessLevel: string;
    /**
     * Readable description of access level.
     */
    accessLevelDescription: string;
    /**
     * The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `userId`.
     */
    groupId?: number;
    /**
     * The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `groupId`.
     */
    userId?: number;
}

export interface BranchProtectionAllowedToPush {
    /**
     * Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
     */
    accessLevel: string;
    /**
     * Readable description of access level.
     */
    accessLevelDescription: string;
    /**
     * The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `groupId` and `userId`. This field is read-only until Gitlab 17.5.
     */
    deployKeyId?: number;
    /**
     * The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deployKeyId` and `userId`.
     */
    groupId?: number;
    /**
     * The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deployKeyId` and `groupId`.
     */
    userId?: number;
}

export interface BranchProtectionAllowedToUnprotect {
    /**
     * Access levels allowed to unprotect push to protected branch. Valid values are: `developer`, `maintainer`, `admin`.
     */
    accessLevel: string;
    /**
     * Readable description of access level.
     */
    accessLevelDescription: string;
    /**
     * The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `userId`.
     */
    groupId?: number;
    /**
     * The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `groupId`.
     */
    userId?: number;
}

export interface GetBranchCommit {
    /**
     * The email of the author.
     */
    authorEmail: string;
    /**
     * The name of the author.
     */
    authorName: string;
    /**
     * The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
     */
    authoredDate: string;
    /**
     * The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
     */
    committedDate: string;
    /**
     * The email of the user that committed.
     */
    committerEmail: string;
    /**
     * The name of the user that committed.
     */
    committerName: string;
    /**
     * The unique id assigned to the commit by Gitlab.
     */
    id: string;
    /**
     * The commit message
     */
    message: string;
    /**
     * The id of the parents of the commit
     */
    parentIds: string[];
    /**
     * The short id assigned to the commit by Gitlab.
     */
    shortId: string;
    /**
     * The title of the commit
     */
    title: string;
}

export interface GetClusterAgentsClusterAgent {
    /**
     * The ID of the agent.
     */
    agentId: number;
    /**
     * The ISO8601 datetime when the agent was created.
     */
    createdAt: string;
    /**
     * The ID of the user who created the agent.
     */
    createdByUserId: number;
    /**
     * The Name of the agent.
     */
    name: string;
    /**
     * ID or full path of the project maintained by the authenticated user.
     */
    project: string;
}

export interface GetGroupAccessTokensAccessToken {
    accessLevel: string;
    active: boolean;
    createdAt: string;
    expiresAt: string;
    group: string;
    id: string;
    name: string;
    revoked: boolean;
    scopes: string[];
    userId: number;
}

export interface GetGroupBillableMemberMembershipsMembership {
    /**
     * Access-level of the member. For details see: https://docs.gitlab.com/api/access_requests/#valid-access-levels
     */
    accessLevel: string;
    /**
     * Datetime when the membership was first added.
     */
    createdAt: string;
    /**
     * Date when the membership will end.
     */
    expiresAt: string;
    /**
     * The id of the membership.
     */
    id: number;
    /**
     * Breadcrumb-style, full display-name of the group or project.
     */
    sourceFullName: string;
    /**
     * The id of the group or project, the user is a (direct) member of.
     */
    sourceId: number;
    /**
     * URL to the members-page of the group or project.
     */
    sourceMembersUrl: string;
}

export interface GetGroupHooksHook {
    /**
     * Invoke the hook for confidential issues events.
     */
    confidentialIssuesEvents: boolean;
    /**
     * Invoke the hook for confidential notes events.
     */
    confidentialNoteEvents: boolean;
    /**
     * Set a custom webhook template.
     */
    customWebhookTemplate: string;
    /**
     * Invoke the hook for deployment events.
     */
    deploymentEvents: boolean;
    /**
     * Invoke the hook for emoji events.
     */
    emojiEvents: boolean;
    /**
     * Enable ssl verification when invoking the hook.
     */
    enableSslVerification: boolean;
    /**
     * The ID or full path of the group.
     */
    group: string;
    /**
     * The id of the group for the hook.
     */
    groupId: number;
    /**
     * The id of the group hook.
     */
    hookId: number;
    /**
     * Invoke the hook for issues events.
     */
    issuesEvents: boolean;
    /**
     * Invoke the hook for job events.
     */
    jobEvents: boolean;
    /**
     * Invoke the hook for merge requests.
     */
    mergeRequestsEvents: boolean;
    /**
     * Invoke the hook for notes events.
     */
    noteEvents: boolean;
    /**
     * Invoke the hook for pipeline events.
     */
    pipelineEvents: boolean;
    /**
     * Invoke the hook for push events.
     */
    pushEvents: boolean;
    /**
     * Invoke the hook for push events on matching branches only.
     */
    pushEventsBranchFilter: string;
    /**
     * Invoke the hook for releases events.
     */
    releasesEvents: boolean;
    /**
     * Invoke the hook for subgroup events.
     */
    subgroupEvents: boolean;
    /**
     * Invoke the hook for tag push events.
     */
    tagPushEvents: boolean;
    /**
     * A token to present when invoking the hook. The token is not available for imported resources.
     */
    token: string;
    /**
     * The url of the hook to invoke.
     */
    url: string;
    /**
     * Invoke the hook for wiki page events.
     */
    wikiPageEvents: boolean;
}

export interface GetGroupMembershipMember {
    /**
     * The level of access to the group.
     */
    accessLevel: string;
    /**
     * The avatar URL of the user.
     */
    avatarUrl: string;
    /**
     * Expiration date for the group membership.
     */
    expiresAt: string;
    /**
     * The unique id assigned to the user by the gitlab server.
     */
    id: number;
    /**
     * The name of the user.
     */
    name: string;
    /**
     * Whether the user is active or blocked.
     */
    state: string;
    /**
     * The username of the user.
     */
    username: string;
    /**
     * User's website URL.
     */
    webUrl: string;
}

export interface GetGroupProvisionedUsersProvisionedUser {
    /**
     * The avatar URL of the provisioned user.
     */
    avatarUrl: string;
    /**
     * The bio of the provisioned user.
     */
    bio: string;
    /**
     * Whether the provisioned user is a bot.
     */
    bot: boolean;
    /**
     * The confirmation date of the provisioned user.
     */
    confirmedAt: string;
    /**
     * The creation date of the provisioned user.
     */
    createdAt: string;
    /**
     * The email of the provisioned user.
     */
    email: string;
    /**
     * Whether the provisioned user is external.
     */
    external: boolean;
    /**
     * The ID of the provisioned user.
     */
    id: string;
    /**
     * The job title of the provisioned user.
     */
    jobTitle: string;
    /**
     * The last activity date of the provisioned user.
     */
    lastActivityOn: string;
    /**
     * The last sign-in date of the provisioned user.
     */
    lastSignInAt: string;
    /**
     * The LinkedIn ID of the provisioned user.
     */
    linkedin: string;
    /**
     * The location of the provisioned user.
     */
    location: string;
    /**
     * The name of the provisioned user.
     */
    name: string;
    /**
     * The organization of the provisioned user.
     */
    organization: string;
    /**
     * Whether the provisioned user has a private profile.
     */
    privateProfile: boolean;
    /**
     * The pronouns of the provisioned user.
     */
    pronouns: string;
    /**
     * The public email of the provisioned user.
     */
    publicEmail: string;
    /**
     * The Skype ID of the provisioned user.
     */
    skype: string;
    /**
     * The state of the provisioned user.
     */
    state: string;
    /**
     * The Twitter ID of the provisioned user.
     */
    twitter: string;
    /**
     * Whether two-factor authentication is enabled for the provisioned user.
     */
    twoFactorEnabled: boolean;
    /**
     * The username of the provisioned user.
     */
    username: string;
    /**
     * The web URL of the provisioned user.
     */
    webUrl: string;
    /**
     * The website URL of the provisioned user.
     */
    websiteUrl: string;
}

export interface GetGroupSamlLinksSamlLink {
    /**
     * The base access level for members of the SAML group.
     */
    accessLevel: string;
    /**
     * Member Role ID (custom role for members of the SAML group.
     */
    memberRoleId: number;
    /**
     * Name of the SAML group.
     */
    name: string;
}

export interface GetGroupSharedWithGroup {
    /**
     * Share with group expiration date.
     */
    expiresAt: string;
    /**
     * The accessLevel permission level of the shared group.
     */
    groupAccessLevel: number;
    /**
     * The full path of the group shared with.
     */
    groupFullPath: string;
    /**
     * The ID of the group shared with.
     */
    groupId: number;
    /**
     * The name of the group shared with.
     */
    groupName: string;
}

export interface GetGroupSubgroupsSubgroup {
    allowedEmailDomainsList: string;
    autoDevopsEnabled: boolean;
    avatarUrl: string;
    createdAt: string;
    defaultBranchProtection: number;
    description: string;
    emailsEnabled: boolean;
    fileTemplateProjectId: number;
    fullName: string;
    fullPath: string;
    groupId: number;
    ipRestrictionRanges: string;
    lfsEnabled: boolean;
    mentionsDisabled: boolean;
    name: string;
    parentId: number;
    path: string;
    projectCreationLevel: string;
    requestAccessEnabled: boolean;
    requireTwoFactorAuthentication: boolean;
    shareWithGroupLock: boolean;
    sharedRunnersSetting: string;
    statistics: {[key: string]: string};
    subgroupCreationLevel: string;
    twoFactorGracePeriod: number;
    visibility: string;
    webUrl: string;
    wikiAccessLevel: string;
}

export interface GetGroupVariablesVariable {
    description: string;
    environmentScope: string;
    group: string;
    key: string;
    masked: boolean;
    protected: boolean;
    raw: boolean;
    value: string;
    variableType: string;
}

export interface GetGroupsGroup {
    /**
     * Whether developers and maintainers can push to the applicable default branch.
     */
    defaultBranchProtection: number;
    /**
     * The description of the group.
     */
    description: string;
    /**
     * The full name of the group.
     */
    fullName: string;
    /**
     * The full path of the group.
     */
    fullPath: string;
    /**
     * The ID of the group.
     */
    groupId: number;
    /**
     * Boolean, is LFS enabled for projects in this group.
     */
    lfsEnabled: boolean;
    /**
     * The name of this group.
     */
    name: string;
    /**
     * Integer, ID of the parent group.
     */
    parentId: number;
    /**
     * The path of the group.
     */
    path: string;
    /**
     * When enabled, users can not fork projects from this group to external namespaces.
     */
    preventForkingOutsideGroup: boolean;
    /**
     * Boolean, is request for access enabled to the group.
     */
    requestAccessEnabled: boolean;
    /**
     * The group level registration token to use during runner setup.
     */
    runnersToken: string;
    /**
     * Enable or disable shared runners for a group’s subgroups and projects. Valid values are: `enabled`, `disabledAndOverridable`, `disabledAndUnoverridable`, `disabledWithOverride`.
     */
    sharedRunnersSetting: string;
    /**
     * Visibility level of the group. Possible values are `private`, `internal`, `public`.
     */
    visibilityLevel: string;
    /**
     * Web URL of the group.
     */
    webUrl: string;
    /**
     * The group's wiki access level. Only available on Premium and Ultimate plans. Valid values are `disabled`, `private`, `enabled`.
     */
    wikiAccessLevel: string;
}

export interface GetInstanceDeployKeysDeployKey {
    /**
     * The creation date of the deploy key. In RFC3339 format.
     */
    createdAt: string;
    /**
     * The fingerprint of the deploy key.
     */
    fingerprint: string;
    /**
     * The ID of the deploy key.
     */
    id: number;
    /**
     * The deploy key.
     */
    key: string;
    /**
     * The list of projects that the deploy key has write access to.
     */
    projectsWithWriteAccesses: outputs.GetInstanceDeployKeysDeployKeyProjectsWithWriteAccess[];
    /**
     * The title of the deploy key.
     */
    title: string;
}

export interface GetInstanceDeployKeysDeployKeyProjectsWithWriteAccess {
    /**
     * The creation date of the project. In RFC3339 format.
     */
    createdAt: string;
    /**
     * The description of the project.
     */
    description: string;
    /**
     * The ID of the project.
     */
    id: number;
    /**
     * The name of the project.
     */
    name: string;
    /**
     * The name of the project with namespace.
     */
    nameWithNamespace: string;
    /**
     * The path of the project.
     */
    path: string;
    /**
     * The path of the project with namespace.
     */
    pathWithNamespace: string;
}

export interface GetInstanceVariablesVariable {
    /**
     * The description of the variable. Maximum of 255 characters.
     */
    description: string;
    /**
     * The name of the variable.
     */
    key: string;
    /**
     * If set to `true`, the value of the variable will be hidden in job logs.
     */
    masked: boolean;
    /**
     * If set to `true`, the variable will be passed only to pipelines running on protected branches and tags.
     */
    protected: boolean;
    /**
     * If set to `true`, the variable will be treated as a raw string.
     */
    raw: boolean;
    /**
     * The value of the variable.
     */
    value: string;
    /**
     * The type of the variable, either `envVar` or `file`.
     */
    variableType: string;
}

export interface GetMetadataKas {
    /**
     * Indicates whether KAS is enabled.
     */
    enabled: boolean;
    /**
     * URL used by the Kubernetes tooling to communicate with the KAS Kubernetes API proxy. It’s null if kas.enabled is false.
     */
    externalK8sProxyUrl: string;
    /**
     * URL used by the agents to communicate with KAS. It’s null if kas.enabled is false.
     */
    externalUrl: string;
    /**
     * Version of KAS. It’s null if kas.enabled is false.
     */
    version: string;
}

export interface GetPipelineScheduleLastPipeline {
    /**
     * The pipeline ID.
     */
    id: number;
    /**
     * The ref of the pipeline.
     */
    ref: string;
    /**
     * The SHA of the pipeline.
     */
    sha: string;
    /**
     * The status of pipelines, one of: created, waiting*for*resource, preparing, pending, running, success, failed, canceled, skipped, manual, scheduled.
     */
    status: string;
}

export interface GetPipelineScheduleOwner {
    /**
     * Image URL for the user's avatar.
     */
    avatarUrl: string;
    /**
     * The user ID.
     */
    id: number;
    /**
     * Name.
     */
    name: string;
    /**
     * User's state, one of: active, blocked.
     */
    state: string;
    /**
     * Username.
     */
    username: string;
    /**
     * URL to the user's profile.
     */
    webUrl: string;
}

export interface GetPipelineScheduleVariable {
    /**
     * The key of a variable.
     */
    key: string;
    /**
     * The value of a variable.
     */
    value: string;
    /**
     * The type of a variable, one of: envVar and file.
     */
    variableType: string;
}

export interface GetPipelineSchedulesPipelineSchedule {
    /**
     * The activation status of pipeline schedule.
     */
    active: boolean;
    /**
     * The datetime of when the schedule was created.
     */
    createdAt: string;
    /**
     * The cron (e.g. `0 1 * * *`).
     */
    cron: string;
    /**
     * The timezone.
     */
    cronTimezone: string;
    /**
     * The description of the pipeline schedule.
     */
    description: string;
    /**
     * The pipeline schedule id.
     */
    id: number;
    /**
     * The datetime of when the schedule will next run.
     */
    nextRunAt: string;
    /**
     * The details of the pipeline schedule owner.
     */
    owner: outputs.GetPipelineSchedulesPipelineScheduleOwner;
    /**
     * The branch/tag name to be triggered. This will be the full branch reference, for example: `refs/heads/main`, not `main`.
     */
    ref: string;
    /**
     * The datetime of when the schedule was last updated.
     */
    updatedAt: string;
}

export interface GetPipelineSchedulesPipelineScheduleOwner {
    /**
     * Image URL for the user's avatar.
     */
    avatarUrl: string;
    /**
     * The user ID.
     */
    id: number;
    /**
     * Name.
     */
    name: string;
    /**
     * User's state, one of: active, blocked.
     */
    state: string;
    /**
     * Username.
     */
    username: string;
    /**
     * URL to the user's profile.
     */
    webUrl: string;
}

export interface GetProjectAccessTokensAccessToken {
    accessLevel: string;
    active: boolean;
    createdAt: string;
    description: string;
    expiresAt: string;
    id: string;
    lastUsedAt: string;
    name: string;
    project: string;
    revoked: boolean;
    scopes: string[];
    userId: number;
}

export interface GetProjectBranchesBranch {
    /**
     * Bool, true if you can push to the branch.
     */
    canPush: boolean;
    /**
     * The commit associated with the branch ref.
     */
    commits: outputs.GetProjectBranchesBranchCommit[];
    /**
     * Bool, true if branch is the default branch for the project.
     */
    default: boolean;
    /**
     * Bool, true if developer level access allows to merge branch.
     */
    developersCanMerge: boolean;
    /**
     * Bool, true if developer level access allows git push.
     */
    developersCanPush: boolean;
    /**
     * Bool, true if the branch has been merged into its parent.
     */
    merged: boolean;
    /**
     * The name of the branch.
     */
    name: string;
    /**
     * Bool, true if branch has branch protection.
     */
    protected: boolean;
    /**
     * URL that can be used to find the branch in a browser.
     */
    webUrl: string;
}

export interface GetProjectBranchesBranchCommit {
    /**
     * The email of the author.
     */
    authorEmail: string;
    /**
     * The name of the author.
     */
    authorName: string;
    /**
     * The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
     */
    authoredDate: string;
    /**
     * The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
     */
    committedDate: string;
    /**
     * The email of the user that committed.
     */
    committerEmail: string;
    /**
     * The name of the user that committed.
     */
    committerName: string;
    /**
     * The unique id assigned to the commit by Gitlab.
     */
    id: string;
    /**
     * The commit message
     */
    message: string;
    /**
     * The id of the parents of the commit
     */
    parentIds: string[];
    /**
     * The short id assigned to the commit by Gitlab.
     */
    shortId: string;
    /**
     * The title of the commit
     */
    title: string;
}

export interface GetProjectContainerExpirationPolicy {
    /**
     * The cadence of the policy. Valid values are: `1d`, `7d`, `14d`, `1month`, `3month`.
     */
    cadence: string;
    /**
     * If true, the policy is enabled.
     */
    enabled: boolean;
    /**
     * The number of images to keep.
     */
    keepN: number;
    /**
     * The regular expression to match image names to delete.
     */
    nameRegexDelete: string;
    /**
     * The regular expression to match image names to keep.
     */
    nameRegexKeep: string;
    /**
     * The next time the policy will run.
     */
    nextRunAt: string;
    /**
     * The number of days to keep images.
     */
    olderThan: string;
}

export interface GetProjectEnvironmentsEnvironment {
    /**
     * Timestamp of when the environment is scheduled to stop, RFC3339 format.
     */
    autoStopAt: string;
    /**
     * The auto stop setting for the environment.
     */
    autoStopSetting: string;
    /**
     * The ID of the environments cluster agent or `null` if none is assigned.
     */
    clusterAgentId: number;
    /**
     * Timestamp of the environment creation, RFC3339 format.
     */
    createdAt: string;
    /**
     * The description of the environment.
     */
    description: string;
    /**
     * Place to link to for this environment.
     */
    externalUrl: string;
    /**
     * The Flux resource path to associate with this environment.
     */
    fluxResourcePath: string;
    /**
     * The ID of the environment.
     */
    id: number;
    /**
     * The Kubernetes namespace to associate with this environment.
     */
    kubernetesNamespace: string;
    /**
     * The name of the environment.
     */
    name: string;
    /**
     * The simplified version of the environment name, suitable for inclusion in DNS, URLs, Kubernetes labels, and so on. The slug is truncated to 24 characters. A random suffix is automatically added to uppercase environment names.
     */
    slug: string;
    /**
     * The state of the environment. Value can be one of `available`, `stopping`, `stopped`. Returns all environments if not set.
     */
    state: string;
    /**
     * The tier of the environment. Value can be one of `production`, `staging`, `testing`, `development`, `other`. Returns all environments if not set.
     */
    tier: string;
    /**
     * Timestamp of the last environment update, RFC3339 format.
     */
    updatedAt: string;
}

export interface GetProjectHooksHook {
    /**
     * Invoke the hook for confidential issues events.
     */
    confidentialIssuesEvents: boolean;
    /**
     * Invoke the hook for confidential notes events.
     */
    confidentialNoteEvents: boolean;
    /**
     * Set a custom webhook template.
     */
    customWebhookTemplate: string;
    /**
     * Invoke the hook for deployment events.
     */
    deploymentEvents: boolean;
    /**
     * Enable ssl verification when invoking the hook.
     */
    enableSslVerification: boolean;
    /**
     * The id of the project hook.
     */
    hookId: number;
    /**
     * Invoke the hook for issues events.
     */
    issuesEvents: boolean;
    /**
     * Invoke the hook for job events.
     */
    jobEvents: boolean;
    /**
     * Invoke the hook for merge requests.
     */
    mergeRequestsEvents: boolean;
    /**
     * Invoke the hook for notes events.
     */
    noteEvents: boolean;
    /**
     * Invoke the hook for pipeline events.
     */
    pipelineEvents: boolean;
    /**
     * The name or id of the project to add the hook to.
     */
    project: string;
    /**
     * The id of the project for the hook.
     */
    projectId: number;
    /**
     * Invoke the hook for push events.
     */
    pushEvents: boolean;
    /**
     * Invoke the hook for push events on matching branches only.
     */
    pushEventsBranchFilter: string;
    /**
     * Invoke the hook for releases events.
     */
    releasesEvents: boolean;
    /**
     * Invoke the hook for tag push events.
     */
    tagPushEvents: boolean;
    /**
     * A token to present when invoking the hook. The token is not available in this datasource.
     *
     * @deprecated The token is only available on resource creation, not in this datasource. It will always be blank.
     */
    token: string;
    /**
     * The url of the hook to invoke.
     */
    url: string;
    /**
     * Invoke the hook for wiki page events.
     */
    wikiPageEvents: boolean;
}

export interface GetProjectIssueTaskCompletionStatus {
    /**
     * The number of tasks that are completed.
     */
    completedCount: number;
    /**
     * The number of tasks.
     */
    count: number;
}

export interface GetProjectIssuesIssue {
    /**
     * The IDs of the users to assign the issue to.
     */
    assigneeIds: number[];
    /**
     * The ID of the author of the issue. Use `gitlab.User` data source to get more information about the user.
     */
    authorId: number;
    /**
     * When the issue was closed. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.
     */
    closedAt: string;
    /**
     * The ID of the user that closed the issue. Use `gitlab.User` data source to get more information about the user.
     */
    closedByUserId: number;
    /**
     * Set an issue to be confidential.
     */
    confidential: boolean;
    /**
     * When the issue was created. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z. Requires administrator or project/group owner rights.
     */
    createdAt: string;
    /**
     * The description of an issue. Limited to 1,048,576 characters.
     */
    description: string;
    /**
     * Whether the issue is locked for discussions or not.
     */
    discussionLocked: boolean;
    /**
     * The ID of a discussion to resolve. This fills out the issue with a default description and mark the discussion as resolved. Use in combination with merge_request_to_resolve_discussions_of.
     */
    discussionToResolve: string;
    /**
     * The number of downvotes the issue has received.
     */
    downvotes: number;
    /**
     * The due date. Date time string in the format YYYY-MM-DD, for example 2016-03-11.
     */
    dueDate: string;
    /**
     * ID of the epic to add the issue to. Valid values are greater than or equal to 0.
     */
    epicId: number;
    /**
     * The ID of the epic issue.
     */
    epicIssueId: number;
    /**
     * The external ID of the issue.
     */
    externalId: string;
    /**
     * The human-readable time estimate of the issue.
     */
    humanTimeEstimate: string;
    /**
     * The human-readable total time spent of the issue.
     */
    humanTotalTimeSpent: string;
    /**
     * The internal ID of the project's issue.
     */
    iid: number;
    /**
     * The instance-wide ID of the issue.
     */
    issueId: number;
    /**
     * The ID of the issue link.
     */
    issueLinkId: number;
    /**
     * The type of issue. Valid values are: `issue`, `incident`, `testCase`.
     */
    issueType: string;
    /**
     * The labels of an issue.
     */
    labels: string[];
    /**
     * The links of the issue.
     */
    links: {[key: string]: string};
    /**
     * The IID of a merge request in which to resolve all issues. This fills out the issue with a default description and mark all discussions as resolved. When passing a description or title, these values take precedence over the default values.
     */
    mergeRequestToResolveDiscussionsOf: number;
    /**
     * The number of merge requests associated with the issue.
     */
    mergeRequestsCount: number;
    /**
     * The global ID of a milestone to assign issue. To find the milestoneId associated with a milestone, view an issue with the milestone assigned and use the API to retrieve the issue's details.
     */
    milestoneId: number;
    /**
     * The ID of the issue that was moved to.
     */
    movedToId: number;
    /**
     * The name or ID of the project.
     */
    project: string;
    /**
     * The references of the issue.
     */
    references: {[key: string]: string};
    /**
     * The state of the issue. Valid values are: `opened`, `closed`.
     */
    state: string;
    /**
     * Whether the authenticated user is subscribed to the issue or not.
     */
    subscribed: boolean;
    /**
     * The task completion status. It's always a one element list.
     */
    taskCompletionStatuses: outputs.GetProjectIssuesIssueTaskCompletionStatus[];
    /**
     * The time estimate of the issue.
     */
    timeEstimate: number;
    /**
     * The title of the issue.
     */
    title: string;
    /**
     * The total time spent of the issue.
     */
    totalTimeSpent: number;
    /**
     * When the issue was updated. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.
     */
    updatedAt: string;
    /**
     * The number of upvotes the issue has received.
     */
    upvotes: number;
    /**
     * The number of user notes on the issue.
     */
    userNotesCount: number;
    /**
     * The web URL of the issue.
     */
    webUrl: string;
    /**
     * The weight of the issue. Valid values are greater than or equal to 0.
     */
    weight: number;
}

export interface GetProjectIssuesIssueTaskCompletionStatus {
    /**
     * The number of tasks that are completed.
     */
    completedCount: number;
    /**
     * The number of tasks.
     */
    count: number;
}

export interface GetProjectMembershipMember {
    /**
     * The level of access to the group.
     */
    accessLevel: string;
    /**
     * The avatar URL of the user.
     */
    avatarUrl: string;
    /**
     * Expiration date for the group membership.
     */
    expiresAt: string;
    /**
     * The unique id assigned to the user by the gitlab server.
     */
    id: number;
    /**
     * The name of the user.
     */
    name: string;
    /**
     * Whether the user is active or blocked.
     */
    state: string;
    /**
     * The username of the user.
     */
    username: string;
    /**
     * User's website URL.
     */
    webUrl: string;
}

export interface GetProjectMergeRequestAssignee {
    /**
     * A link to the user's avatar image.
     */
    avatarUrl: string;
    /**
     * The internal ID number of the user.
     */
    id: number;
    /**
     * The name of the user.
     */
    name: string;
    /**
     * The state of the user account.
     */
    state: string;
    /**
     * The username of the user.
     */
    username: string;
    /**
     * A link to the user's profile page.
     */
    webUrl: string;
}

export interface GetProjectMergeRequestAuthor {
    /**
     * A link to the user's avatar image.
     */
    avatarUrl: string;
    /**
     * The internal ID number of the user.
     */
    id: number;
    /**
     * The name of the user.
     */
    name: string;
    /**
     * The state of the user account.
     */
    state: string;
    /**
     * The username of the user.
     */
    username: string;
    /**
     * A link to the user's profile page.
     */
    webUrl: string;
}

export interface GetProjectMergeRequestClosedBy {
    /**
     * A link to the user's avatar image.
     */
    avatarUrl: string;
    /**
     * The internal ID number of the user.
     */
    id: number;
    /**
     * The name of the user.
     */
    name: string;
    /**
     * The state of the user account.
     */
    state: string;
    /**
     * The username of the user.
     */
    username: string;
    /**
     * A link to the user's profile page.
     */
    webUrl: string;
}

export interface GetProjectMergeRequestsMergeRequest {
    /**
     * First assignee of the merge request.
     */
    assignee: outputs.GetProjectMergeRequestsMergeRequestAssignee;
    /**
     * Assignees of the merge request.
     */
    assignees: outputs.GetProjectMergeRequestsMergeRequestAssignee[];
    /**
     * User who created this merge request.
     */
    author: outputs.GetProjectMergeRequestsMergeRequestAuthor;
    /**
     * Indicates if all discussions are resolved only if all are
     * required before merge request can be merged.
     */
    blockingDiscussionsResolved: boolean;
    /**
     * Timestamp of when the merge request was closed.
     */
    closedAt: string;
    /**
     * User who closed this merge request.
     */
    closedBy: outputs.GetProjectMergeRequestsMergeRequestClosedBy;
    /**
     * Timestamp of when the merge request was created.
     */
    createdAt: string;
    /**
     * The unique instance level ID of the merge request.
     */
    id: number;
    /**
     * The unique project level ID of the merge request.
     */
    iid: number;
}

export interface GetProjectMergeRequestsMergeRequestAssignee {
    /**
     * A link to the user's avatar image.
     */
    avatarUrl: string;
    /**
     * The internal ID number of the user.
     */
    id: number;
    /**
     * The name of the user.
     */
    name: string;
    /**
     * The state of the user account.
     */
    state: string;
    /**
     * The username of the user.
     */
    username: string;
    /**
     * A link to the user's profile page.
     */
    webUrl: string;
}

export interface GetProjectMergeRequestsMergeRequestAuthor {
    /**
     * A link to the user's avatar image.
     */
    avatarUrl: string;
    /**
     * The internal ID number of the user.
     */
    id: number;
    /**
     * The name of the user.
     */
    name: string;
    /**
     * The state of the user account.
     */
    state: string;
    /**
     * The username of the user.
     */
    username: string;
    /**
     * A link to the user's profile page.
     */
    webUrl: string;
}

export interface GetProjectMergeRequestsMergeRequestClosedBy {
    /**
     * A link to the user's avatar image.
     */
    avatarUrl: string;
    /**
     * The internal ID number of the user.
     */
    id: number;
    /**
     * The name of the user.
     */
    name: string;
    /**
     * The state of the user account.
     */
    state: string;
    /**
     * The username of the user.
     */
    username: string;
    /**
     * A link to the user's profile page.
     */
    webUrl: string;
}

export interface GetProjectMilestonesMilestone {
    /**
     * The time of creation of the milestone. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.
     */
    createdAt: string;
    /**
     * The description of the milestone.
     */
    description: string;
    /**
     * The due date of the milestone. Date time string in the format YYYY-MM-DD, for example 2016-03-11.
     */
    dueDate: string;
    /**
     * Bool, true if milestone expired.
     */
    expired: boolean;
    /**
     * The ID of the project's milestone.
     */
    iid: number;
    /**
     * The instance-wide ID of the project's milestone.
     */
    milestoneId: number;
    /**
     * The ID or URL-encoded path of the project owned by the authenticated user.
     */
    project: string;
    /**
     * The project ID of milestone.
     */
    projectId: number;
    /**
     * The start date of the milestone. Date time string in the format YYYY-MM-DD, for example 2016-03-11.
     */
    startDate: string;
    /**
     * The state of the milestone. Valid values are: `active`, `closed`.
     */
    state: string;
    /**
     * The title of a milestone.
     */
    title: string;
    /**
     * The last update time of the milestone. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.
     */
    updatedAt: string;
    /**
     * The web URL of the milestone.
     */
    webUrl: string;
}

export interface GetProjectProtectedBranchMergeAccessLevel {
    /**
     * Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
     */
    accessLevel: string;
    /**
     * Readable description of access level.
     */
    accessLevelDescription: string;
    /**
     * The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `userId`.
     */
    groupId?: number;
    /**
     * The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `groupId`.
     */
    userId?: number;
}

export interface GetProjectProtectedBranchPushAccessLevel {
    /**
     * Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
     */
    accessLevel: string;
    /**
     * Readable description of access level.
     */
    accessLevelDescription: string;
    /**
     * The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `groupId` and `userId`. This field is read-only until Gitlab 17.5.
     */
    deployKeyId?: number;
    /**
     * The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deployKeyId` and `userId`.
     */
    groupId?: number;
    /**
     * The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deployKeyId` and `groupId`.
     */
    userId?: number;
}

export interface GetProjectProtectedBranchesProtectedBranch {
    /**
     * Whether force push is allowed.
     */
    allowForcePush: boolean;
    /**
     * Reject code pushes that change files listed in the CODEOWNERS file.
     */
    codeOwnerApprovalRequired: boolean;
    /**
     * The ID of this resource.
     */
    id: number;
    /**
     * Array of access levels and user(s)/group(s) allowed to merge to protected branch.
     */
    mergeAccessLevels?: outputs.GetProjectProtectedBranchesProtectedBranchMergeAccessLevel[];
    /**
     * The name of the protected branch.
     */
    name: string;
    /**
     * Array of access levels and user(s)/group(s) allowed to push to protected branch.
     */
    pushAccessLevels?: outputs.GetProjectProtectedBranchesProtectedBranchPushAccessLevel[];
}

export interface GetProjectProtectedBranchesProtectedBranchMergeAccessLevel {
    /**
     * Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
     */
    accessLevel: string;
    /**
     * Readable description of access level.
     */
    accessLevelDescription: string;
    /**
     * The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `userId`.
     */
    groupId?: number;
    /**
     * The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `groupId`.
     */
    userId?: number;
}

export interface GetProjectProtectedBranchesProtectedBranchPushAccessLevel {
    /**
     * Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
     */
    accessLevel: string;
    /**
     * Readable description of access level.
     */
    accessLevelDescription: string;
    /**
     * The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `groupId` and `userId`. This field is read-only until Gitlab 17.5.
     */
    deployKeyId?: number;
    /**
     * The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deployKeyId` and `userId`.
     */
    groupId?: number;
    /**
     * The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deployKeyId` and `groupId`.
     */
    userId?: number;
}

export interface GetProjectProtectedTagCreateAccessLevel {
    /**
     * Access level allowed to create protected tags.
     */
    accessLevel: string;
    /**
     * Readable description of access level.
     */
    accessLevelDescription: string;
    /**
     * The ID of a GitLab group allowed to perform the relevant action.
     */
    groupId?: number;
    /**
     * The ID of the create access level.
     */
    id: number;
    /**
     * The ID of a GitLab user allowed to perform the relevant action.
     */
    userId?: number;
}

export interface GetProjectProtectedTagsProtectedTag {
    /**
     * Array of access levels/user(s)/group(s) allowed to create protected tags.
     */
    createAccessLevels: outputs.GetProjectProtectedTagsProtectedTagCreateAccessLevel[];
    /**
     * The name of the protected tag.
     */
    tag: string;
}

export interface GetProjectProtectedTagsProtectedTagCreateAccessLevel {
    /**
     * Access level allowed to create protected tags.
     */
    accessLevel: string;
    /**
     * Readable description of access level.
     */
    accessLevelDescription: string;
    /**
     * The ID of a GitLab group allowed to perform the relevant action.
     */
    groupId?: number;
    /**
     * The ID of the create access level.
     */
    id: number;
    /**
     * The ID of a GitLab user allowed to perform the relevant action.
     */
    userId?: number;
}

export interface GetProjectPushRule {
    /**
     * All commit author emails must match this regex, e.g. `@my-company.com$`.
     */
    authorEmailRegex: string;
    /**
     * All branch names must match this regex, e.g. `(feature|hotfix)\/*`.
     */
    branchNameRegex: string;
    /**
     * Users can only push commits to this repository that were committed with one of their own verified emails.
     */
    commitCommitterCheck: boolean;
    /**
     * Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
     */
    commitCommitterNameCheck: boolean;
    /**
     * No commit message is allowed to match this regex, for example `ssh\:\/\/`.
     */
    commitMessageNegativeRegex: string;
    /**
     * All commit messages must match this regex, e.g. `Fixed \d+\..*`.
     */
    commitMessageRegex: string;
    /**
     * Deny deleting a tag.
     */
    denyDeleteTag: boolean;
    /**
     * All committed filenames must not match this regex, e.g. `(jar|exe)$`.
     */
    fileNameRegex: string;
    /**
     * Maximum file size (MB).
     */
    maxFileSize: number;
    /**
     * Restrict commits by author (email) to existing GitLab users.
     */
    memberCheck: boolean;
    /**
     * GitLab will reject any files that are likely to contain secrets.
     */
    preventSecrets: boolean;
    /**
     * Reject commit when it’s not DCO certified.
     */
    rejectNonDcoCommits: boolean;
    /**
     * Reject commit when it’s not signed through GPG.
     */
    rejectUnsignedCommits: boolean;
}

export interface GetProjectSharedWithGroup {
    /**
     * The accessLevel permission level of the shared group.
     */
    groupAccessLevel: number;
    /**
     * The full path of the group shared with.
     */
    groupFullPath: string;
    /**
     * The ID of the group shared with.
     */
    groupId: number;
    /**
     * The name of the group shared with.
     */
    groupName: string;
}

export interface GetProjectTagCommit {
    /**
     * The email of the author.
     */
    authorEmail: string;
    /**
     * The name of the author.
     */
    authorName: string;
    /**
     * The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
     */
    authoredDate: string;
    /**
     * The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
     */
    committedDate: string;
    /**
     * The email of the user that committed.
     */
    committerEmail: string;
    /**
     * The name of the user that committed.
     */
    committerName: string;
    /**
     * The unique id assigned to the commit by Gitlab.
     */
    id: string;
    /**
     * The commit message
     */
    message: string;
    /**
     * The id of the parents of the commit
     */
    parentIds: string[];
    /**
     * The short id assigned to the commit by Gitlab.
     */
    shortId: string;
    /**
     * The title of the commit
     */
    title: string;
}

export interface GetProjectTagRelease {
    /**
     * The description of release.
     */
    description: string;
    /**
     * The name of the tag.
     */
    tagName: string;
}

export interface GetProjectTagsTag {
    /**
     * The commit associated with the tag.
     */
    commits: outputs.GetProjectTagsTagCommit[];
    /**
     * The message of the annotated tag.
     */
    message: string;
    /**
     * The name of a tag.
     */
    name: string;
    /**
     * Bool, true if tag has tag protection.
     */
    protected: boolean;
    /**
     * The release associated with the tag.
     */
    releases: outputs.GetProjectTagsTagRelease[];
    /**
     * The unique id assigned to the commit by Gitlab.
     */
    target: string;
}

export interface GetProjectTagsTagCommit {
    /**
     * The email of the author.
     */
    authorEmail: string;
    /**
     * The name of the author.
     */
    authorName: string;
    /**
     * The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
     */
    authoredDate: string;
    /**
     * The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
     */
    committedDate: string;
    /**
     * The email of the user that committed.
     */
    committerEmail: string;
    /**
     * The name of the user that committed.
     */
    committerName: string;
    /**
     * The unique id assigned to the commit by Gitlab.
     */
    id: string;
    /**
     * The commit message
     */
    message: string;
    /**
     * The id of the parents of the commit
     */
    parentIds: string[];
    /**
     * The short id assigned to the commit by Gitlab.
     */
    shortId: string;
    /**
     * The title of the commit
     */
    title: string;
}

export interface GetProjectTagsTagRelease {
    /**
     * The description of release.
     */
    description: string;
    /**
     * The name of the tag.
     */
    tagName: string;
}

export interface GetProjectVariablesVariable {
    /**
     * The description of the variable. Maximum of 255 characters.
     */
    description: string;
    /**
     * The environment scope of the variable. Defaults to all environment (`*`).
     */
    environmentScope: string;
    /**
     * The name of the variable.
     */
    key: string;
    /**
     * If set to `true`, the value of the variable will be hidden in job logs.
     */
    masked: boolean;
    /**
     * The name or path of the project.
     */
    project: string;
    /**
     * If set to `true`, the variable will be passed only to pipelines running on protected branches and tags.
     */
    protected: boolean;
    /**
     * If set to `true`, the variable will be treated as a raw string.
     */
    raw: boolean;
    /**
     * The value of the variable.
     */
    value: string;
    /**
     * The type of the variable, either `envVar` or `file`.
     */
    variableType: string;
}

export interface GetProjectsProject {
    /**
     * Links for the project.
     */
    _links: {[key: string]: string};
    /**
     * Whether allowMergeOnSkippedPipeline is enabled for the project.
     */
    allowMergeOnSkippedPipeline: boolean;
    /**
     * Set whether or not a pipeline triggerer is allowed to approve deployments. Premium and Ultimate only.
     */
    allowPipelineTriggerApproveDeployment: boolean;
    /**
     * Set the analytics access level. Valid values are `disabled`, `private`, `enabled`.
     */
    analyticsAccessLevel: string;
    /**
     * The numbers of approvals needed in a merge requests.
     */
    approvalsBeforeMerge: number;
    /**
     * Whether the project is archived.
     */
    archived: boolean;
    /**
     * Auto-cancel pending pipelines. This isn’t a boolean, but enabled/disabled.
     */
    autoCancelPendingPipelines: string;
    /**
     * Auto Deploy strategy. Valid values are `continuous`, `manual`, `timedIncremental`.
     */
    autoDevopsDeployStrategy: string;
    /**
     * Enable Auto DevOps for this project.
     */
    autoDevopsEnabled: boolean;
    /**
     * Set whether auto-closing referenced issues on default branch.
     */
    autocloseReferencedIssues: boolean;
    /**
     * The avatar url of the project.
     */
    avatarUrl: string;
    /**
     * Build coverage regex for the project.
     */
    buildCoverageRegex: string;
    /**
     * The Git strategy. Defaults to fetch.
     */
    buildGitStrategy: string;
    /**
     * The maximum amount of time, in seconds, that a job can run.
     */
    buildTimeout: number;
    /**
     * Set the builds access level. Valid values are `disabled`, `private`, `enabled`.
     */
    buildsAccessLevel: string;
    /**
     * CI config file path for the project.
     */
    ciConfigPath: string;
    /**
     * Default number of revisions for shallow cloning.
     */
    ciDefaultGitDepth: number;
    /**
     * Pipelines older than the configured time are deleted.
     */
    ciDeletePipelinesInSeconds: number;
    /**
     * When a new deployment job starts, skip older deployment jobs that are still pending.
     */
    ciForwardDeploymentEnabled: boolean;
    /**
     * Allow job retries even if the deployment job is outdated.
     */
    ciForwardDeploymentRollbackAllowed: boolean;
    /**
     * Fields included in the sub claim of the ID Token. Accepts an array starting with project_path. The array might also include refType and ref. Defaults to ["projectPath", "refType", "ref"]. Introduced in GitLab 17.10.
     */
    ciIdTokenSubClaimComponents: string[];
    /**
     * The minimum role required to set variables when running pipelines and jobs. Introduced in GitLab 17.1. Valid values are `developer`, `maintainer`, `owner`, `noOneAllowed`
     */
    ciPipelineVariablesMinimumOverrideRole: string;
    /**
     * The role required to cancel a pipeline or job. Premium and Ultimate only. Valid values are `developer`, `maintainer`, `no one`
     */
    ciRestrictPipelineCancellationRole: string;
    /**
     * Set the image cleanup policy for this project. **Note**: this field is sometimes named `containerExpirationPolicyAttributes` in the GitLab Upstream API.
     */
    containerExpirationPolicies: outputs.GetProjectsProjectContainerExpirationPolicy[];
    /**
     * Set visibility of container registry, for this project. Valid values are `disabled`, `private`, `enabled`.
     */
    containerRegistryAccessLevel: string;
    /**
     * Whether the container registry is enabled for the project.
     */
    containerRegistryEnabled: boolean;
    /**
     * Creation time for the project.
     */
    createdAt: string;
    /**
     * Creator ID for the project.
     */
    creatorId: number;
    /**
     * Custom attributes for the project.
     */
    customAttributes: {[key: string]: string}[];
    /**
     * The default branch name of the project.
     */
    defaultBranch: string;
    /**
     * The description of the project.
     */
    description: string;
    /**
     * Enable email notifications.
     */
    emailsEnabled: boolean;
    /**
     * Whether the project is empty.
     */
    emptyRepo: boolean;
    /**
     * Set the environments access level. Valid values are `disabled`, `private`, `enabled`.
     */
    environmentsAccessLevel: string;
    /**
     * The classification label for the project.
     */
    externalAuthorizationClassificationLabel: string;
    /**
     * Set the feature flags access level. Valid values are `disabled`, `private`, `enabled`.
     */
    featureFlagsAccessLevel: string;
    /**
     * Present if the project is a fork. Contains information about the upstream project.
     */
    forkedFromProjects: outputs.GetProjectsProjectForkedFromProject[];
    /**
     * Set the forking access level. Valid values are `disabled`, `private`, `enabled`.
     */
    forkingAccessLevel: string;
    /**
     * The number of forks of the project.
     */
    forksCount: number;
    /**
     * Whether group runners are enabled for the project.
     */
    groupRunnersEnabled: boolean;
    /**
     * The HTTP clone URL of the project.
     */
    httpUrlToRepo: string;
    /**
     * The ID of the project.
     */
    id: number;
    /**
     * The import error, if it exists, for the project.
     */
    importError: string;
    /**
     * The import status of the project.
     */
    importStatus: string;
    /**
     * URL the project was imported from.
     */
    importUrl: string;
    /**
     * Set the infrastructure access level. Valid values are `disabled`, `private`, `enabled`.
     */
    infrastructureAccessLevel: string;
    /**
     * Set the issues access level. Valid values are `disabled`, `private`, `enabled`.
     */
    issuesAccessLevel: string;
    /**
     * Whether issues are enabled for the project.
     */
    issuesEnabled: boolean;
    /**
     * Whether pipelines are enabled for the project.
     */
    jobsEnabled: boolean;
    /**
     * Disable or enable the ability to keep the latest artifact for this project.
     */
    keepLatestArtifact: boolean;
    /**
     * Last activirty time for the project.
     */
    lastActivityAt: string;
    /**
     * Whether LFS (large file storage) is enabled for the project.
     */
    lfsEnabled: boolean;
    /**
     * Template used to create merge commit message in merge requests.
     */
    mergeCommitTemplate: string;
    /**
     * Merge method for the project.
     */
    mergeMethod: string;
    /**
     * Enable or disable merge pipelines.
     */
    mergePipelinesEnabled: boolean;
    /**
     * Set the merge requests access level. Valid values are `disabled`, `private`, `enabled`.
     */
    mergeRequestsAccessLevel: string;
    /**
     * Whether merge requests are enabled for the project.
     */
    mergeRequestsEnabled: boolean;
    /**
     * Enable or disable merge trains.
     */
    mergeTrainsEnabled: boolean;
    /**
     * Whether the pull mirroring is enabled for the project.
     */
    mirror: boolean;
    /**
     * Whether mirrorOverwritesDivergedBranches is enabled for the project.
     */
    mirrorOverwritesDivergedBranches: boolean;
    /**
     * Whether pull mirroring triggers builds for the project.
     */
    mirrorTriggerBuilds: boolean;
    /**
     * The mirror user ID for the project.
     */
    mirrorUserId: number;
    /**
     * The visibility of machine learning model experiments.
     */
    modelExperimentsAccessLevel: string;
    /**
     * The visibility of machine learning model registry.
     */
    modelRegistryAccessLevel: string;
    /**
     * Set the monitor access level. Valid values are `disabled`, `private`, `enabled`.
     */
    monitorAccessLevel: string;
    /**
     * The name of the project.
     */
    name: string;
    /**
     * In `group / subgroup / project` or `user / project` format.
     */
    nameWithNamespace: string;
    /**
     * Namespace of the project (parent group/s).
     */
    namespaces: outputs.GetProjectsProjectNamespace[];
    /**
     * Whether onlyAllowMergeIfAllDiscussionsAreResolved is enabled for the project.
     */
    onlyAllowMergeIfAllDiscussionsAreResolved: boolean;
    /**
     * Whether onlyAllowMergeIfPipelineSucceeds is enabled for the project.
     */
    onlyAllowMergeIfPipelineSucceeds: boolean;
    /**
     * Whether onlyMirrorProtectedBranches is enabled for the project.
     */
    onlyMirrorProtectedBranches: boolean;
    /**
     * The number of open issies for the project.
     */
    openIssuesCount: number;
    owners: outputs.GetProjectsProjectOwner[];
    /**
     * Whether packages are enabled for the project.
     */
    packagesEnabled: boolean;
    /**
     * The path of the project.
     */
    path: string;
    /**
     * In `group/subgroup/project` or `user/project` format.
     */
    pathWithNamespace: string;
    /**
     * Permissions for the project.
     */
    permissions: outputs.GetProjectsProjectPermission[];
    /**
     * Whether merge requests require an associated issue from Jira. Premium and Ultimate only.
     */
    preventMergeWithoutJiraIssue: boolean;
    /**
     * Whether public builds are enabled for the project.
     */
    publicBuilds: boolean;
    /**
     * The remote url of the project.
     */
    readmeUrl: string;
    /**
     * Set the releases access level. Valid values are `disabled`, `private`, `enabled`.
     */
    releasesAccessLevel: string;
    /**
     * Set the repository access level. Valid values are `disabled`, `private`, `enabled`.
     */
    repositoryAccessLevel: string;
    /**
     * Which storage shard the repository is on. (administrator only)
     */
    repositoryStorage: string;
    /**
     * Whether requesting access is enabled for the project.
     */
    requestAccessEnabled: boolean;
    /**
     * Set the requirements access level. Valid values are `disabled`, `private`, `enabled`.
     */
    requirementsAccessLevel: string;
    /**
     * Whether resolveOutdatedDiffDiscussions is enabled for the project
     */
    resolveOutdatedDiffDiscussions: boolean;
    /**
     * Allow only users with the Maintainer role to pass user-defined variables when triggering a pipeline.
     */
    restrictUserDefinedVariables: boolean;
    /**
     * The runners token for the project.
     */
    runnersToken: string;
    /**
     * Set the security and compliance access level. Valid values are `disabled`, `private`, `enabled`.
     */
    securityAndComplianceAccessLevel: string;
    /**
     * Whether shared runners are enabled for the project.
     */
    sharedRunnersEnabled: boolean;
    /**
     * Groups the the project is shared with.
     */
    sharedWithGroups: outputs.GetProjectsProjectSharedWithGroup[];
    /**
     * Set the snippets access level. Valid values are `disabled`, `private`, `enabled`.
     */
    snippetsAccessLevel: string;
    /**
     * Whether snippets are enabled for the project.
     */
    snippetsEnabled: boolean;
    /**
     * Template used to create squash commit message in merge requests.
     */
    squashCommitTemplate: string;
    /**
     * The SSH clone URL of the project.
     */
    sshUrlToRepo: string;
    /**
     * The number of stars on the project.
     */
    starCount: number;
    /**
     * Statistics for the project.
     */
    statistics: {[key: string]: number};
    /**
     * The commit message used to apply merge request suggestions.
     */
    suggestionCommitMessage: string;
    /**
     * A set of the project topics (formerly called "project tags").
     */
    tagLists: string[];
    /**
     * The list of topics for the project.
     */
    topics: string[];
    /**
     * The visibility of the project.
     */
    visibility: string;
    /**
     * The web url of the project.
     */
    webUrl: string;
    /**
     * Set the wiki access level. Valid values are `disabled`, `private`, `enabled`.
     */
    wikiAccessLevel: string;
    /**
     * Whether wiki is enabled for the project.
     */
    wikiEnabled: boolean;
}

export interface GetProjectsProjectContainerExpirationPolicy {
    /**
     * The cadence of the policy. Valid values are: `1d`, `7d`, `14d`, `1month`, `3month`.
     */
    cadence: string;
    /**
     * If true, the policy is enabled.
     */
    enabled: boolean;
    /**
     * The number of images to keep.
     */
    keepN: number;
    /**
     * The regular expression to match image names to delete.
     */
    nameRegexDelete: string;
    /**
     * The regular expression to match image names to keep.
     */
    nameRegexKeep: string;
    /**
     * The next time the policy will run.
     */
    nextRunAt: string;
    /**
     * The number of days to keep images.
     */
    olderThan: string;
}

export interface GetProjectsProjectForkedFromProject {
    /**
     * The HTTP clone URL of the upstream project.
     */
    httpUrlToRepo: string;
    /**
     * The ID of the upstream project.
     */
    id: number;
    /**
     * The name of the upstream project.
     */
    name: string;
    /**
     * In `group / subgroup / project` or `user / project` format.
     */
    nameWithNamespace: string;
    /**
     * The path of the upstream project.
     */
    path: string;
    /**
     * In `group/subgroup/project` or `user/project` format.
     */
    pathWithNamespace: string;
    /**
     * The web url of the upstream project.
     */
    webUrl: string;
}

export interface GetProjectsProjectNamespace {
    /**
     * The full path of the namespace.
     */
    fullPath: string;
    /**
     * The ID of the namespace.
     */
    id: number;
    /**
     * The kind of the namespace.
     */
    kind: string;
    /**
     * The name of the namespace.
     */
    name: string;
    /**
     * The path of the namespace.
     */
    path: string;
}

export interface GetProjectsProjectOwner {
    /**
     * The avatar url of the owner.
     */
    avatarUrl: string;
    /**
     * The ID of the owner.
     */
    id: number;
    /**
     * The name of the owner.
     */
    name: string;
    /**
     * The state of the owner.
     */
    state: string;
    /**
     * The username of the owner.
     */
    username: string;
    /**
     * The website url of the owner.
     */
    websiteUrl: string;
}

export interface GetProjectsProjectPermission {
    /**
     * Group access level.
     */
    groupAccess: {[key: string]: number};
    /**
     * Project access level.
     */
    projectAccess: {[key: string]: number};
}

export interface GetProjectsProjectSharedWithGroup {
    /**
     * The group access level.
     */
    groupAccessLevel: string;
    /**
     * The group ID.
     */
    groupId: number;
    /**
     * The group name.
     */
    groupName: string;
}

export interface GetReleaseAssets {
    /**
     * The number of assets for a release
     */
    count: number;
    /**
     * The links for a release
     */
    links?: outputs.GetReleaseAssetsLink[];
    /**
     * The sources for a release
     */
    sources?: outputs.GetReleaseAssetsSource[];
}

export interface GetReleaseAssetsLink {
    /**
     * The ID of the link
     */
    id: number;
    /**
     * The type of the link
     */
    linkType: string;
    /**
     * The name of the link
     */
    name: string;
    /**
     * The URL of the link
     */
    url: string;
}

export interface GetReleaseAssetsSource {
    /**
     * The format of the source
     */
    format: string;
    /**
     * The URL of the source
     */
    url: string;
}

export interface GetReleaseLinksReleaseLink {
    /**
     * Full path for a [Direct Asset link](https://docs.gitlab.com/user/project/releases/index/#permanent-links-to-release-assets).
     */
    directAssetUrl: string;
    /**
     * External or internal link.
     */
    external: boolean;
    /**
     * Relative path for a [Direct Asset link](https://docs.gitlab.com/user/project/releases/index/#permanent-links-to-release-assets).
     */
    filepath: string;
    /**
     * The ID of the link.
     */
    linkId: number;
    /**
     * The type of the link. Valid values are `other`, `runbook`, `image`, `package`.
     */
    linkType: string;
    /**
     * The name of the link. Link names must be unique within the release.
     */
    name: string;
    /**
     * The ID or [URL-encoded path of the project](https://docs.gitlab.com/api/index/#namespaced-path-encoding).
     */
    project: string;
    /**
     * The tag associated with the Release.
     */
    tagName: string;
    /**
     * The URL of the link. Link URLs must be unique within the release.
     */
    url: string;
}

export interface GetRepositoryTreeTree {
    /**
     * The project ID.
     *
     * @deprecated Use `nodeId` instead. To be removed in version 19.0.
     */
    id: string;
    /**
     * Unix access mode of the file in the repository.
     */
    mode: string;
    /**
     * Name of the blob or tree in the repository
     */
    name: string;
    /**
     * The SHA-1 hash of the tree or blob in the repository.
     */
    nodeId: string;
    /**
     * Path of the object inside of the repository.
     */
    path: string;
    /**
     * Type of object in the repository. Can be either type tree or of type blob
     */
    type: string;
}

export interface GetRunnersRunner {
    /**
     * The description of the runner.
     */
    description: string;
    /**
     * The runner id.
     */
    id: number;
    /**
     * Indicates if this is a shared runner
     */
    isShared: boolean;
    /**
     * The connectivity status of the runner.
     */
    online: boolean;
    /**
     * Indicates if the runner is accepting or ignoring new jobs.
     */
    paused: boolean;
    /**
     * The runner type. Values are `instanceType`, `groupType` and `projectType`.
     */
    runnerType: string;
    /**
     * The status of the runner. Values can be `online`, `offline`, `stale`, and `neverContacted`.
     */
    status: string;
}

export interface GetUserSshkeysKey {
    /**
     * The time when this key was created in GitLab.
     */
    createdAt: string;
    /**
     * The expiration date of the SSH key in ISO 8601 format (YYYY-MM-DDTHH:MM:SSZ)
     */
    expiresAt: string;
    /**
     * The ssh key. The SSH key `comment` (trailing part) is optional and ignored for diffing, because GitLab overrides it with the username and GitLab hostname.
     */
    key: string;
    /**
     * The ID of the ssh key.
     */
    keyId: number;
    /**
     * The title of the ssh key.
     */
    title: string;
    /**
     * The ID or username of the user. If this field is omitted, this resource manages a SSH key for the current user. Otherwise, this resource manages a SSH key for the specified user, and an admin token is required.
     */
    userId: number;
}

export interface GetUsersUser {
    /**
     * The avatar URL of the user.
     */
    avatarUrl: string;
    /**
     * The bio of the user.
     */
    bio: string;
    /**
     * Whether the user can create groups.
     */
    canCreateGroup: boolean;
    /**
     * Whether the user can create projects.
     */
    canCreateProject: boolean;
    /**
     * User's color scheme ID.
     */
    colorSchemeId: number;
    /**
     * Date the user was created at.
     */
    createdAt: string;
    /**
     * Current user's sign-in date.
     */
    currentSignInAt: string;
    /**
     * The public email address of the user.
     */
    email: string;
    /**
     * The external UID of the user.
     */
    externUid: string;
    /**
     * Whether the user is external.
     */
    external: boolean;
    /**
     * The unique id assigned to the user by the gitlab server.
     */
    id: number;
    /**
     * Whether the user is an admin.
     */
    isAdmin: boolean;
    /**
     * Whether the user is a bot.
     */
    isBot: boolean;
    /**
     * Last user's sign-in date.
     */
    lastSignInAt: string;
    /**
     * LinkedIn profile of the user.
     */
    linkedin: string;
    /**
     * The location of the user.
     */
    location: string;
    /**
     * The name of the user.
     */
    name: string;
    /**
     * The ID of the user's namespace. Requires admin token to access this field.
     */
    namespaceId: number;
    /**
     * The organization of the user.
     */
    organization: string;
    /**
     * Number of projects the user can create.
     */
    projectsLimit: number;
    /**
     * The UID provider of the user.
     */
    provider: string;
    /**
     * Skype username of the user.
     */
    skype: string;
    /**
     * Whether the user is active or blocked.
     */
    state: string;
    /**
     * User's theme ID.
     */
    themeId: number;
    /**
     * Twitter username of the user.
     */
    twitter: string;
    /**
     * Whether user's two-factor auth is enabled.
     */
    twoFactorEnabled: boolean;
    /**
     * The username of the user.
     */
    username: string;
    /**
     * User's website URL.
     */
    websiteUrl: string;
}

export interface GroupAccessTokenRotationConfiguration {
    /**
     * The duration (in days) the new token should be valid for.
     */
    expirationDays: number;
    /**
     * The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
     */
    rotateBeforeDays: number;
}

export interface GroupDefaultBranchProtectionDefaults {
    /**
     * Allow force push for all users with push access.
     */
    allowForcePush: boolean;
    /**
     * An array of access levels allowed to merge. Valid values are: `developer`, `maintainer`, `no one`.
     */
    allowedToMerges: string[];
    /**
     * An array of access levels allowed to push. Valid values are: `developer`, `maintainer`, `no one`.
     */
    allowedToPushes: string[];
    /**
     * Allow developers to initial push.
     */
    developerCanInitialPush: boolean;
}

export interface GroupEpicBoardList {
    /**
     * The ID of the list.
     */
    id: number;
    /**
     * The ID of the label the list should be scoped to.
     */
    labelId?: number;
    /**
     * The position of the list within the board. The position for the list is sed on the its position in the `lists` array.
     */
    position: number;
}

export interface GroupHookCustomHeader {
    /**
     * Key of the custom header.
     */
    key: string;
    /**
     * Value of the custom header. This value cannot be imported.
     */
    value: string;
}

export interface GroupIssueBoardList {
    /**
     * The ID of the list.
     */
    id: number;
    /**
     * The ID of the label the list should be scoped to.
     */
    labelId?: number;
    /**
     * The explicit position of the list within the board, zero based.
     */
    position: number;
}

export interface GroupProtectedEnvironmentApprovalRule {
    /**
     * Levels of access allowed to approve a deployment to this protected environment. Mutually exclusive with `userId` and `groupId`. Valid values are `developer`, `maintainer`.
     */
    accessLevel?: string;
    /**
     * Readable description of level of access.
     */
    accessLevelDescription: string;
    /**
     * The ID of the group allowed to approve a deployment to this protected environment. TThe group must be a sub-group under the given group. Mutually exclusive with `accessLevel` and `userId`.
     */
    groupId?: number;
    /**
     * Group inheritance allows access rules to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
     */
    groupInheritanceType: number;
    /**
     * The unique ID of the Approval Rules object.
     */
    id: number;
    /**
     * The number of approval required to allow deployment to this protected environment. This is mutually exclusive with user_id.
     */
    requiredApprovals: number;
    /**
     * The ID of the user allowed to approve a deployment to this protected environment. The user must be a member of the group with Maintainer role or higher. Mutually exclusive with `accessLevel` and `groupId`.
     */
    userId?: number;
}

export interface GroupProtectedEnvironmentDeployAccessLevel {
    /**
     * Levels of access required to deploy to this protected environment. Mutually exclusive with `userId` and `groupId`. Valid values are `developer`, `maintainer`.
     */
    accessLevel?: string;
    /**
     * Readable description of level of access.
     */
    accessLevelDescription: string;
    /**
     * The ID of the group allowed to deploy to this protected environment. The group must be a sub-group under the given group. Mutually exclusive with `accessLevel` and `userId`.
     */
    groupId?: number;
    /**
     * Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
     */
    groupInheritanceType: number;
    /**
     * The unique ID of the Deploy Access Level object.
     */
    id: number;
    /**
     * The ID of the user allowed to deploy to this protected environment. The user must be a member of the group with Maintainer role or higher. Mutually exclusive with `accessLevel` and `groupId`.
     */
    userId?: number;
}

export interface GroupPushRules {
    /**
     * All commit author emails must match this regex, e.g. `@my-company.com$`.
     */
    authorEmailRegex: string;
    /**
     * All branch names must match this regex, e.g. `(feature|hotfix)\/*`.
     */
    branchNameRegex: string;
    /**
     * Only commits pushed using verified emails are allowed.
     */
    commitCommitterCheck: boolean;
    /**
     * Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
     */
    commitCommitterNameCheck: boolean;
    /**
     * No commit message is allowed to match this regex, for example `ssh\:\/\/`.
     */
    commitMessageNegativeRegex: string;
    /**
     * All commit messages must match this regex, e.g. `Fixed \d+\..*`.
     */
    commitMessageRegex: string;
    /**
     * Deny deleting a tag.
     */
    denyDeleteTag: boolean;
    /**
     * Filenames matching the regular expression provided in this attribute are not allowed, for example, `(jar|exe)$`.
     */
    fileNameRegex: string;
    /**
     * Maximum file size (MB) allowed.
     */
    maxFileSize: number;
    /**
     * Allows only GitLab users to author commits.
     */
    memberCheck: boolean;
    /**
     * GitLab will reject any files that are likely to contain secrets.
     */
    preventSecrets: boolean;
    /**
     * Reject commit when it’s not DCO certified.
     */
    rejectNonDcoCommits: boolean;
    /**
     * Only commits signed through GPG are allowed.
     */
    rejectUnsignedCommits: boolean;
}

export interface GroupServiceAccountAccessTokenRotationConfiguration {
    /**
     * The duration (in days) the new token should be valid for.
     */
    expirationDays?: number;
    /**
     * The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
     */
    rotateBeforeDays: number;
}

export interface InstanceServiceAccountTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
}

export interface PersonalAccessTokenRotationConfiguration {
    /**
     * The duration (in days) the new token should be valid for.
     */
    expirationDays: number;
    /**
     * The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
     */
    rotateBeforeDays: number;
}

export interface ProjectAccessTokenRotationConfiguration {
    /**
     * The duration (in days) the new token should be valid for.
     */
    expirationDays: number;
    /**
     * The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
     */
    rotateBeforeDays: number;
}

export interface ProjectContainerExpirationPolicy {
    /**
     * The cadence of the policy. Valid values are: `1d`, `7d`, `14d`, `1month`, `3month`.
     */
    cadence: string;
    /**
     * If true, the policy is enabled.
     */
    enabled: boolean;
    /**
     * The number of images to keep.
     */
    keepN: number;
    /**
     * The regular expression to match image names to delete.
     */
    nameRegexDelete: string;
    /**
     * The regular expression to match image names to keep.
     */
    nameRegexKeep: string;
    /**
     * The next time the policy will run.
     */
    nextRunAt: string;
    /**
     * The number of days to keep images.
     */
    olderThan: string;
}

export interface ProjectHookCustomHeader {
    /**
     * Key of the custom header.
     */
    key: string;
    /**
     * Value of the custom header. This value cannot be imported.
     */
    value: string;
}

export interface ProjectIssueBoardList {
    /**
     * The ID of the assignee the list should be scoped to. Requires a GitLab EE license.
     */
    assigneeId?: number;
    /**
     * The ID of the list
     */
    id: number;
    /**
     * The ID of the iteration the list should be scoped to. Requires a GitLab EE license.
     */
    iterationId?: number;
    /**
     * The ID of the label the list should be scoped to. Requires a GitLab EE license.
     */
    labelId?: number;
    /**
     * The ID of the milestone the list should be scoped to. Requires a GitLab EE license.
     */
    milestoneId?: number;
    /**
     * The position of the list within the board. The position for the list is based on the its position in the `lists` array.
     */
    position: number;
}

export interface ProjectIssueTaskCompletionStatus {
    /**
     * The number of tasks that are completed.
     */
    completedCount: number;
    /**
     * The number of tasks.
     */
    count: number;
}

export interface ProjectPagesSettingsDeployment {
    /**
     * Date the deployment was created.
     */
    createdAt: string;
    /**
     * The path prefix of the deployment when using parallel deployments.
     */
    pathPrefix: string;
    /**
     * The root directory of the deployment.
     */
    rootDirectory: string;
    /**
     * The URL of the deployment.
     */
    url: string;
}

export interface ProjectProtectedEnvironmentApprovalRule {
    /**
     * Levels of access allowed to approve a deployment to this protected environment. Mutually exclusive with `userId` and `groupId`. Valid values are `developer`, `maintainer`.
     */
    accessLevel?: string;
    /**
     * Readable description of level of access.
     */
    accessLevelDescription: string;
    /**
     * The ID of the group allowed to approve a deployment to this protected environment. The project must be shared with the group. Mutually exclusive with `accessLevel` and `userId`.
     */
    groupId?: number;
    /**
     * Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
     */
    groupInheritanceType: number;
    /**
     * The unique ID of the Approval Rules object.
     */
    id: number;
    /**
     * The number of approval required to allow deployment to this protected environment. This is mutually exclusive with user_id.
     */
    requiredApprovals: number;
    /**
     * The ID of the user allowed to approve a deployment to this protected environment. The user must be a member of the project. Mutually exclusive with `accessLevel` and `groupId`.
     */
    userId?: number;
}

export interface ProjectProtectedEnvironmentDeployAccessLevel {
    /**
     * Levels of access required to deploy to this protected environment. Mutually exclusive with `userId` and `groupId`. Valid values are `developer`, `maintainer`.
     */
    accessLevel?: string;
    /**
     * Readable description of level of access.
     */
    accessLevelDescription: string;
    /**
     * The ID of the group allowed to deploy to this protected environment. The project must be shared with the group. Mutually exclusive with `accessLevel` and `userId`.
     */
    groupId?: number;
    /**
     * Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
     */
    groupInheritanceType: number;
    /**
     * The unique ID of the Deploy Access Level object.
     */
    id: number;
    /**
     * The ID of the user allowed to deploy to this protected environment. The user must be a member of the project. Mutually exclusive with `accessLevel` and `groupId`.
     */
    userId?: number;
}

export interface ProjectProtectedEnvironmentDeployAccessLevelsAttribute {
    /**
     * Levels of access required to deploy to this protected environment. Mutually exclusive with `userId` and `groupId`. Valid values are `developer`, `maintainer`.
     */
    accessLevel?: string;
    /**
     * Readable description of level of access.
     */
    accessLevelDescription: string;
    /**
     * The ID of the group allowed to deploy to this protected environment. The project must be shared with the group. Mutually exclusive with `accessLevel` and `userId`.
     */
    groupId?: number;
    /**
     * Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
     */
    groupInheritanceType: number;
    /**
     * The unique ID of the Deploy Access Level object.
     */
    id: number;
    /**
     * The ID of the user allowed to deploy to this protected environment. The user must be a member of the project. Mutually exclusive with `accessLevel` and `groupId`.
     */
    userId?: number;
}

export interface ProjectPushRules {
    /**
     * All commit author emails must match this regex, e.g. `@my-company.com$`.
     */
    authorEmailRegex?: string;
    /**
     * All branch names must match this regex, e.g. `(feature|hotfix)\/*`.
     */
    branchNameRegex?: string;
    /**
     * Users can only push commits to this repository that were committed with one of their own verified emails.
     */
    commitCommitterCheck?: boolean;
    /**
     * Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
     */
    commitCommitterNameCheck?: boolean;
    /**
     * No commit message is allowed to match this regex, e.g. `ssh\:\/\/`.
     */
    commitMessageNegativeRegex?: string;
    /**
     * All commit messages must match this regex, e.g. `Fixed \d+\..*`.
     */
    commitMessageRegex?: string;
    /**
     * Deny deleting a tag.
     */
    denyDeleteTag?: boolean;
    /**
     * All committed filenames must not match this regex, e.g. `(jar|exe)$`.
     */
    fileNameRegex?: string;
    /**
     * Maximum file size (MB).
     */
    maxFileSize?: number;
    /**
     * Restrict commits by author (email) to existing GitLab users.
     */
    memberCheck?: boolean;
    /**
     * GitLab will reject any files that are likely to contain secrets.
     */
    preventSecrets?: boolean;
    /**
     * Reject commit when it’s not DCO certified.
     */
    rejectNonDcoCommits?: boolean;
    /**
     * Reject commit when it’s not signed through GPG.
     */
    rejectUnsignedCommits?: boolean;
}

export interface ProjectTagCommit {
    /**
     * The email of the author.
     */
    authorEmail: string;
    /**
     * The name of the author.
     */
    authorName: string;
    /**
     * The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
     */
    authoredDate: string;
    /**
     * The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
     */
    committedDate: string;
    /**
     * The email of the user that committed.
     */
    committerEmail: string;
    /**
     * The name of the user that committed.
     */
    committerName: string;
    /**
     * The unique id assigned to the commit by Gitlab.
     */
    id: string;
    /**
     * The commit message
     */
    message: string;
    /**
     * The id of the parents of the commit
     */
    parentIds: string[];
    /**
     * The short id assigned to the commit by Gitlab.
     */
    shortId: string;
    /**
     * The title of the commit
     */
    title: string;
}

export interface ProjectTagRelease {
    /**
     * The description of release.
     */
    description: string;
    /**
     * The name of the tag.
     */
    tagName: string;
}

export interface ReleaseAssets {
    /**
     * The total count of assets in this release.
     */
    count: number;
}

export interface ReleaseAuthor {
    /**
     * The url of the author's' user avatar.
     */
    avatarUrl: string;
    /**
     * The ID of the author's user.
     */
    id: number;
    /**
     * The name of the author.
     */
    name: string;
    /**
     * The state of the author's user.
     */
    state: string;
    /**
     * The username of the author.
     */
    username: string;
    /**
     * The url to the author's user profile.
     */
    webUrl: string;
}

export interface ReleaseCommit {
    /**
     * The email address of the commit author.
     */
    authorEmail: string;
    /**
     * The name of the commit author.
     */
    authorName: string;
    /**
     * The date and time the commit was authored. In ISO 8601 format (2019-03-15T08:00:00Z).
     */
    authoredDate: string;
    /**
     * The date and time the commit was made. In ISO 8601 format (2019-03-15T08:00:00Z).
     */
    committedDate: string;
    /**
     * The email address of the committer.
     */
    committerEmail: string;
    /**
     * The name of the committer.
     */
    committerName: string;
    /**
     * The date and time the commit was created. In ISO 8601 format (2019-03-15T08:00:00Z).
     */
    createdAt: string;
    /**
     * The git commit full SHA
     */
    id: string;
    /**
     * The commit message.
     */
    message: string;
    /**
     * The full SHA of any parent commits.
     */
    parentIds: string[];
    /**
     * The git commit short SHA.
     */
    shortId: string;
    /**
     * The title of the commit.
     */
    title: string;
}

export interface ReleaseLinks {
    /**
     * URL of the release's closed issues.
     */
    closedIssuesUrl: string;
    /**
     * URL of the release's closed merge requests.
     */
    closedMergeRequestsUrl: string;
    /**
     * URL of the release's edit page.
     */
    editUrl: string;
    /**
     * URL of the release's merged merge requests.
     */
    mergedMergeRequestsUrl: string;
    /**
     * URL of the release's open issues.
     */
    openedIssuesUrl: string;
    /**
     * URL of the release's open merge requests.
     */
    openedMergeRequestsUrl: string;
    /**
     * URL of the release.
     */
    self: string;
}

export interface TagProtectionAllowedToCreate {
    /**
     * Access levels allowed to create protected tags. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
     */
    accessLevel: string;
    /**
     * Readable description of access level.
     */
    accessLevelDescription: string;
    /**
     * The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `userId`.
     */
    groupId?: number;
    /**
     * The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `groupId`.
     */
    userId?: number;
}

export interface ValueStreamAnalyticsStage {
    /**
     * Boolean whether the stage is customized. If false, it assigns a built-in default stage by name.
     */
    custom?: boolean;
    /**
     * End event identifier. Valid values are: `CODE_STAGE_START`, `ISSUE_CLOSED`, `ISSUE_CREATED`, `ISSUE_DEPLOYED_TO_PRODUCTION`, `ISSUE_FIRST_ADDED_TO_BOARD`, `ISSUE_FIRST_ADDED_TO_ITERATION`, `ISSUE_FIRST_ASSIGNED_AT`, `ISSUE_FIRST_ASSOCIATED_WITH_MILESTONE`, `ISSUE_FIRST_MENTIONED_IN_COMMIT`, `ISSUE_LABEL_ADDED`, `ISSUE_LABEL_REMOVED`, `ISSUE_LAST_EDITED`, `ISSUE_STAGE_END`, `MERGE_REQUEST_CLOSED`, `MERGE_REQUEST_CREATED`, `MERGE_REQUEST_FIRST_ASSIGNED_AT`, `MERGE_REQUEST_FIRST_COMMIT_AT`, `MERGE_REQUEST_FIRST_DEPLOYED_TO_PRODUCTION`, `MERGE_REQUEST_LABEL_ADDED`, `MERGE_REQUEST_LABEL_REMOVED`, `MERGE_REQUEST_LAST_BUILD_FINISHED`, `MERGE_REQUEST_LAST_BUILD_STARTED`, `MERGE_REQUEST_LAST_EDITED`, `MERGE_REQUEST_MERGED`, `MERGE_REQUEST_REVIEWER_FIRST_ASSIGNED`, `MERGE_REQUEST_PLAN_STAGE_START`
     */
    endEventIdentifier: string;
    /**
     * Label ID associated with the end event identifier. In the format of `gid://gitlab/GroupLabel/<id>` or `gid://gitlab/ProjectLabel/<id>`
     */
    endEventLabelId: string;
    /**
     * Boolean whether the stage is hidden, GitLab provided default stages are hidden by default.
     */
    hidden?: boolean;
    /**
     * The ID of the value stream stage.
     */
    id: string;
    /**
     * The name of the value stream stage.
     */
    name: string;
    /**
     * Start event identifier. Valid values are: `CODE_STAGE_START`, `ISSUE_CLOSED`, `ISSUE_CREATED`, `ISSUE_DEPLOYED_TO_PRODUCTION`, `ISSUE_FIRST_ADDED_TO_BOARD`, `ISSUE_FIRST_ADDED_TO_ITERATION`, `ISSUE_FIRST_ASSIGNED_AT`, `ISSUE_FIRST_ASSOCIATED_WITH_MILESTONE`, `ISSUE_FIRST_MENTIONED_IN_COMMIT`, `ISSUE_LABEL_ADDED`, `ISSUE_LABEL_REMOVED`, `ISSUE_LAST_EDITED`, `ISSUE_STAGE_END`, `MERGE_REQUEST_CLOSED`, `MERGE_REQUEST_CREATED`, `MERGE_REQUEST_FIRST_ASSIGNED_AT`, `MERGE_REQUEST_FIRST_COMMIT_AT`, `MERGE_REQUEST_FIRST_DEPLOYED_TO_PRODUCTION`, `MERGE_REQUEST_LABEL_ADDED`, `MERGE_REQUEST_LABEL_REMOVED`, `MERGE_REQUEST_LAST_BUILD_FINISHED`, `MERGE_REQUEST_LAST_BUILD_STARTED`, `MERGE_REQUEST_LAST_EDITED`, `MERGE_REQUEST_MERGED`, `MERGE_REQUEST_REVIEWER_FIRST_ASSIGNED`, `MERGE_REQUEST_PLAN_STAGE_START`
     */
    startEventIdentifier: string;
    /**
     * Label ID associated with the start event identifier. In the format of `gid://gitlab/GroupLabel/<id>` or `gid://gitlab/ProjectLabel/<id>`
     */
    startEventLabelId: string;
}

