// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package gitlab

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gitlab/sdk/v9/go/gitlab/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// The `UserAvatar` resource allows users to manage the lifecycle of a user avatar.
// The resource can also be used to set the avatar on project or group access tokens, as well as on service accounts.
//
// > The `token` attribute is optional only when the GitLab token used by the provider has an administrator scope, as this allows an administrator to manage user avatars.
//
// > The provided `token` must have the `api` scope in order to set the avatar.
//
// **Upstream API**: [GitLab API docs](https://docs.gitlab.com/api/users/#upload-an-avatar-for-yourself)
//
// ## Import
//
// Starting in Terraform v1.5.0, you can use an import block to import `gitlab_user_avatar`. For example:
//
// terraform
//
// import {
//
//	to = gitlab_user_avatar.example
//
//	id = "see CLI command below for ID"
//
// }
//
// Importing using the CLI is supported with the following syntax:
//
// A GitLab User Avatar can be imported using the user id, e.g.
//
// ```sh
// $ pulumi import gitlab:index/userAvatar:UserAvatar example "12345"
// ```
//
// NOTE: the `token` and `avatar` resource attributes are not available for imported resources as this information cannot be read from the GitLab API.
type UserAvatar struct {
	pulumi.CustomResourceState

	// A local path to the avatar image to upload. **Note**: the avatar is not available for imported resources.
	Avatar pulumi.StringOutput `pulumi:"avatar"`
	// The hash of the avatar image.  This is used to track changes to the avatar image if the image contents change but the image name remains the same. Use `filesha256("path/to/avatar.png")` whenever possible.
	AvatarHash pulumi.StringPtrOutput `pulumi:"avatarHash"`
	// The URL of the avatar image.
	AvatarUrl pulumi.StringOutput `pulumi:"avatarUrl"`
	// The access token of the user. If this field is omitted, a GitLab token with administrator scope is required to manage the avatar for the specified user. **Note**: the token is not available for imported resources.
	Token pulumi.StringPtrOutput `pulumi:"token"`
	// The ID of the user.
	UserId pulumi.IntOutput `pulumi:"userId"`
}

// NewUserAvatar registers a new resource with the given unique name, arguments, and options.
func NewUserAvatar(ctx *pulumi.Context,
	name string, args *UserAvatarArgs, opts ...pulumi.ResourceOption) (*UserAvatar, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Avatar == nil {
		return nil, errors.New("invalid value for required argument 'Avatar'")
	}
	if args.UserId == nil {
		return nil, errors.New("invalid value for required argument 'UserId'")
	}
	if args.Token != nil {
		args.Token = pulumi.ToSecret(args.Token).(pulumi.StringPtrInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"token",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource UserAvatar
	err := ctx.RegisterResource("gitlab:index/userAvatar:UserAvatar", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetUserAvatar gets an existing UserAvatar resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetUserAvatar(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *UserAvatarState, opts ...pulumi.ResourceOption) (*UserAvatar, error) {
	var resource UserAvatar
	err := ctx.ReadResource("gitlab:index/userAvatar:UserAvatar", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering UserAvatar resources.
type userAvatarState struct {
	// A local path to the avatar image to upload. **Note**: the avatar is not available for imported resources.
	Avatar *string `pulumi:"avatar"`
	// The hash of the avatar image.  This is used to track changes to the avatar image if the image contents change but the image name remains the same. Use `filesha256("path/to/avatar.png")` whenever possible.
	AvatarHash *string `pulumi:"avatarHash"`
	// The URL of the avatar image.
	AvatarUrl *string `pulumi:"avatarUrl"`
	// The access token of the user. If this field is omitted, a GitLab token with administrator scope is required to manage the avatar for the specified user. **Note**: the token is not available for imported resources.
	Token *string `pulumi:"token"`
	// The ID of the user.
	UserId *int `pulumi:"userId"`
}

type UserAvatarState struct {
	// A local path to the avatar image to upload. **Note**: the avatar is not available for imported resources.
	Avatar pulumi.StringPtrInput
	// The hash of the avatar image.  This is used to track changes to the avatar image if the image contents change but the image name remains the same. Use `filesha256("path/to/avatar.png")` whenever possible.
	AvatarHash pulumi.StringPtrInput
	// The URL of the avatar image.
	AvatarUrl pulumi.StringPtrInput
	// The access token of the user. If this field is omitted, a GitLab token with administrator scope is required to manage the avatar for the specified user. **Note**: the token is not available for imported resources.
	Token pulumi.StringPtrInput
	// The ID of the user.
	UserId pulumi.IntPtrInput
}

func (UserAvatarState) ElementType() reflect.Type {
	return reflect.TypeOf((*userAvatarState)(nil)).Elem()
}

type userAvatarArgs struct {
	// A local path to the avatar image to upload. **Note**: the avatar is not available for imported resources.
	Avatar string `pulumi:"avatar"`
	// The hash of the avatar image.  This is used to track changes to the avatar image if the image contents change but the image name remains the same. Use `filesha256("path/to/avatar.png")` whenever possible.
	AvatarHash *string `pulumi:"avatarHash"`
	// The access token of the user. If this field is omitted, a GitLab token with administrator scope is required to manage the avatar for the specified user. **Note**: the token is not available for imported resources.
	Token *string `pulumi:"token"`
	// The ID of the user.
	UserId int `pulumi:"userId"`
}

// The set of arguments for constructing a UserAvatar resource.
type UserAvatarArgs struct {
	// A local path to the avatar image to upload. **Note**: the avatar is not available for imported resources.
	Avatar pulumi.StringInput
	// The hash of the avatar image.  This is used to track changes to the avatar image if the image contents change but the image name remains the same. Use `filesha256("path/to/avatar.png")` whenever possible.
	AvatarHash pulumi.StringPtrInput
	// The access token of the user. If this field is omitted, a GitLab token with administrator scope is required to manage the avatar for the specified user. **Note**: the token is not available for imported resources.
	Token pulumi.StringPtrInput
	// The ID of the user.
	UserId pulumi.IntInput
}

func (UserAvatarArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*userAvatarArgs)(nil)).Elem()
}

type UserAvatarInput interface {
	pulumi.Input

	ToUserAvatarOutput() UserAvatarOutput
	ToUserAvatarOutputWithContext(ctx context.Context) UserAvatarOutput
}

func (*UserAvatar) ElementType() reflect.Type {
	return reflect.TypeOf((**UserAvatar)(nil)).Elem()
}

func (i *UserAvatar) ToUserAvatarOutput() UserAvatarOutput {
	return i.ToUserAvatarOutputWithContext(context.Background())
}

func (i *UserAvatar) ToUserAvatarOutputWithContext(ctx context.Context) UserAvatarOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserAvatarOutput)
}

// UserAvatarArrayInput is an input type that accepts UserAvatarArray and UserAvatarArrayOutput values.
// You can construct a concrete instance of `UserAvatarArrayInput` via:
//
//	UserAvatarArray{ UserAvatarArgs{...} }
type UserAvatarArrayInput interface {
	pulumi.Input

	ToUserAvatarArrayOutput() UserAvatarArrayOutput
	ToUserAvatarArrayOutputWithContext(context.Context) UserAvatarArrayOutput
}

type UserAvatarArray []UserAvatarInput

func (UserAvatarArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*UserAvatar)(nil)).Elem()
}

func (i UserAvatarArray) ToUserAvatarArrayOutput() UserAvatarArrayOutput {
	return i.ToUserAvatarArrayOutputWithContext(context.Background())
}

func (i UserAvatarArray) ToUserAvatarArrayOutputWithContext(ctx context.Context) UserAvatarArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserAvatarArrayOutput)
}

// UserAvatarMapInput is an input type that accepts UserAvatarMap and UserAvatarMapOutput values.
// You can construct a concrete instance of `UserAvatarMapInput` via:
//
//	UserAvatarMap{ "key": UserAvatarArgs{...} }
type UserAvatarMapInput interface {
	pulumi.Input

	ToUserAvatarMapOutput() UserAvatarMapOutput
	ToUserAvatarMapOutputWithContext(context.Context) UserAvatarMapOutput
}

type UserAvatarMap map[string]UserAvatarInput

func (UserAvatarMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*UserAvatar)(nil)).Elem()
}

func (i UserAvatarMap) ToUserAvatarMapOutput() UserAvatarMapOutput {
	return i.ToUserAvatarMapOutputWithContext(context.Background())
}

func (i UserAvatarMap) ToUserAvatarMapOutputWithContext(ctx context.Context) UserAvatarMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserAvatarMapOutput)
}

type UserAvatarOutput struct{ *pulumi.OutputState }

func (UserAvatarOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UserAvatar)(nil)).Elem()
}

func (o UserAvatarOutput) ToUserAvatarOutput() UserAvatarOutput {
	return o
}

func (o UserAvatarOutput) ToUserAvatarOutputWithContext(ctx context.Context) UserAvatarOutput {
	return o
}

// A local path to the avatar image to upload. **Note**: the avatar is not available for imported resources.
func (o UserAvatarOutput) Avatar() pulumi.StringOutput {
	return o.ApplyT(func(v *UserAvatar) pulumi.StringOutput { return v.Avatar }).(pulumi.StringOutput)
}

// The hash of the avatar image.  This is used to track changes to the avatar image if the image contents change but the image name remains the same. Use `filesha256("path/to/avatar.png")` whenever possible.
func (o UserAvatarOutput) AvatarHash() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UserAvatar) pulumi.StringPtrOutput { return v.AvatarHash }).(pulumi.StringPtrOutput)
}

// The URL of the avatar image.
func (o UserAvatarOutput) AvatarUrl() pulumi.StringOutput {
	return o.ApplyT(func(v *UserAvatar) pulumi.StringOutput { return v.AvatarUrl }).(pulumi.StringOutput)
}

// The access token of the user. If this field is omitted, a GitLab token with administrator scope is required to manage the avatar for the specified user. **Note**: the token is not available for imported resources.
func (o UserAvatarOutput) Token() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UserAvatar) pulumi.StringPtrOutput { return v.Token }).(pulumi.StringPtrOutput)
}

// The ID of the user.
func (o UserAvatarOutput) UserId() pulumi.IntOutput {
	return o.ApplyT(func(v *UserAvatar) pulumi.IntOutput { return v.UserId }).(pulumi.IntOutput)
}

type UserAvatarArrayOutput struct{ *pulumi.OutputState }

func (UserAvatarArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*UserAvatar)(nil)).Elem()
}

func (o UserAvatarArrayOutput) ToUserAvatarArrayOutput() UserAvatarArrayOutput {
	return o
}

func (o UserAvatarArrayOutput) ToUserAvatarArrayOutputWithContext(ctx context.Context) UserAvatarArrayOutput {
	return o
}

func (o UserAvatarArrayOutput) Index(i pulumi.IntInput) UserAvatarOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *UserAvatar {
		return vs[0].([]*UserAvatar)[vs[1].(int)]
	}).(UserAvatarOutput)
}

type UserAvatarMapOutput struct{ *pulumi.OutputState }

func (UserAvatarMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*UserAvatar)(nil)).Elem()
}

func (o UserAvatarMapOutput) ToUserAvatarMapOutput() UserAvatarMapOutput {
	return o
}

func (o UserAvatarMapOutput) ToUserAvatarMapOutputWithContext(ctx context.Context) UserAvatarMapOutput {
	return o
}

func (o UserAvatarMapOutput) MapIndex(k pulumi.StringInput) UserAvatarOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *UserAvatar {
		return vs[0].(map[string]*UserAvatar)[vs[1].(string)]
	}).(UserAvatarOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*UserAvatarInput)(nil)).Elem(), &UserAvatar{})
	pulumi.RegisterInputType(reflect.TypeOf((*UserAvatarArrayInput)(nil)).Elem(), UserAvatarArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UserAvatarMapInput)(nil)).Elem(), UserAvatarMap{})
	pulumi.RegisterOutputType(UserAvatarOutput{})
	pulumi.RegisterOutputType(UserAvatarArrayOutput{})
	pulumi.RegisterOutputType(UserAvatarMapOutput{})
}
