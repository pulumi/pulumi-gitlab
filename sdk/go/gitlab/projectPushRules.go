// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package gitlab

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gitlab/sdk/v9/go/gitlab/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gitlab/sdk/v9/go/gitlab"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := gitlab.NewProjectPushRules(ctx, "sample", &gitlab.ProjectPushRulesArgs{
//				Project:                    pulumi.String("42"),
//				AuthorEmailRegex:           pulumi.String("@gitlab.com$"),
//				BranchNameRegex:            pulumi.String("(feat|fix)\\/*"),
//				CommitCommitterCheck:       pulumi.Bool(true),
//				CommitCommitterNameCheck:   pulumi.Bool(true),
//				CommitMessageNegativeRegex: pulumi.String("ssh\\:\\/\\/"),
//				CommitMessageRegex:         pulumi.String("(feat|fix):.*"),
//				DenyDeleteTag:              pulumi.Bool(false),
//				FileNameRegex:              pulumi.String("(jar|exe)$"),
//				MaxFileSize:                pulumi.Int(4),
//				MemberCheck:                pulumi.Bool(true),
//				PreventSecrets:             pulumi.Bool(true),
//				RejectUnsignedCommits:      pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Starting in Terraform v1.5.0 you can use an import block to import `gitlab_project_push_rules`. For example:
//
// terraform
//
// import {
//
//	to = gitlab_project_push_rules.example
//
//	id = "see CLI command below for ID"
//
// }
//
// Import using the CLI is supported using the following syntax:
//
// Gitlab project push rules can be imported with a key composed of `<project_id>`, e.g.
//
// ```sh
// $ pulumi import gitlab:index/projectPushRules:ProjectPushRules sample "42"
// ```
type ProjectPushRules struct {
	pulumi.CustomResourceState

	// All commit author emails must match this regex, e.g. `@my-company.com$`.
	AuthorEmailRegex pulumi.StringOutput `pulumi:"authorEmailRegex"`
	// All branch names must match this regex, e.g. `(feature|hotfix)\/*`.
	BranchNameRegex pulumi.StringOutput `pulumi:"branchNameRegex"`
	// Users can only push commits to this repository that were committed with one of their own verified emails.
	CommitCommitterCheck pulumi.BoolOutput `pulumi:"commitCommitterCheck"`
	// Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
	CommitCommitterNameCheck pulumi.BoolOutput `pulumi:"commitCommitterNameCheck"`
	// No commit message is allowed to match this regex, e.g. `ssh\:\/\/`.
	CommitMessageNegativeRegex pulumi.StringOutput `pulumi:"commitMessageNegativeRegex"`
	// All commit messages must match this regex, e.g. `Fixed \d+\..*`.
	CommitMessageRegex pulumi.StringOutput `pulumi:"commitMessageRegex"`
	// Deny deleting a tag.
	DenyDeleteTag pulumi.BoolOutput `pulumi:"denyDeleteTag"`
	// All committed filenames must not match this regex, e.g. `(jar|exe)$`.
	FileNameRegex pulumi.StringOutput `pulumi:"fileNameRegex"`
	// Maximum file size (MB).
	MaxFileSize pulumi.IntOutput `pulumi:"maxFileSize"`
	// Restrict commits by author (email) to existing GitLab users.
	MemberCheck pulumi.BoolOutput `pulumi:"memberCheck"`
	// GitLab will reject any files that are likely to contain secrets.
	PreventSecrets pulumi.BoolOutput `pulumi:"preventSecrets"`
	// The ID or URL-encoded path of the project.
	Project pulumi.StringOutput `pulumi:"project"`
	// Reject commit when it’s not DCO certified.
	RejectNonDcoCommits pulumi.BoolOutput `pulumi:"rejectNonDcoCommits"`
	// Reject commit when it’s not signed.
	RejectUnsignedCommits pulumi.BoolOutput `pulumi:"rejectUnsignedCommits"`
}

// NewProjectPushRules registers a new resource with the given unique name, arguments, and options.
func NewProjectPushRules(ctx *pulumi.Context,
	name string, args *ProjectPushRulesArgs, opts ...pulumi.ResourceOption) (*ProjectPushRules, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Project == nil {
		return nil, errors.New("invalid value for required argument 'Project'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ProjectPushRules
	err := ctx.RegisterResource("gitlab:index/projectPushRules:ProjectPushRules", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetProjectPushRules gets an existing ProjectPushRules resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetProjectPushRules(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ProjectPushRulesState, opts ...pulumi.ResourceOption) (*ProjectPushRules, error) {
	var resource ProjectPushRules
	err := ctx.ReadResource("gitlab:index/projectPushRules:ProjectPushRules", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ProjectPushRules resources.
type projectPushRulesState struct {
	// All commit author emails must match this regex, e.g. `@my-company.com$`.
	AuthorEmailRegex *string `pulumi:"authorEmailRegex"`
	// All branch names must match this regex, e.g. `(feature|hotfix)\/*`.
	BranchNameRegex *string `pulumi:"branchNameRegex"`
	// Users can only push commits to this repository that were committed with one of their own verified emails.
	CommitCommitterCheck *bool `pulumi:"commitCommitterCheck"`
	// Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
	CommitCommitterNameCheck *bool `pulumi:"commitCommitterNameCheck"`
	// No commit message is allowed to match this regex, e.g. `ssh\:\/\/`.
	CommitMessageNegativeRegex *string `pulumi:"commitMessageNegativeRegex"`
	// All commit messages must match this regex, e.g. `Fixed \d+\..*`.
	CommitMessageRegex *string `pulumi:"commitMessageRegex"`
	// Deny deleting a tag.
	DenyDeleteTag *bool `pulumi:"denyDeleteTag"`
	// All committed filenames must not match this regex, e.g. `(jar|exe)$`.
	FileNameRegex *string `pulumi:"fileNameRegex"`
	// Maximum file size (MB).
	MaxFileSize *int `pulumi:"maxFileSize"`
	// Restrict commits by author (email) to existing GitLab users.
	MemberCheck *bool `pulumi:"memberCheck"`
	// GitLab will reject any files that are likely to contain secrets.
	PreventSecrets *bool `pulumi:"preventSecrets"`
	// The ID or URL-encoded path of the project.
	Project *string `pulumi:"project"`
	// Reject commit when it’s not DCO certified.
	RejectNonDcoCommits *bool `pulumi:"rejectNonDcoCommits"`
	// Reject commit when it’s not signed.
	RejectUnsignedCommits *bool `pulumi:"rejectUnsignedCommits"`
}

type ProjectPushRulesState struct {
	// All commit author emails must match this regex, e.g. `@my-company.com$`.
	AuthorEmailRegex pulumi.StringPtrInput
	// All branch names must match this regex, e.g. `(feature|hotfix)\/*`.
	BranchNameRegex pulumi.StringPtrInput
	// Users can only push commits to this repository that were committed with one of their own verified emails.
	CommitCommitterCheck pulumi.BoolPtrInput
	// Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
	CommitCommitterNameCheck pulumi.BoolPtrInput
	// No commit message is allowed to match this regex, e.g. `ssh\:\/\/`.
	CommitMessageNegativeRegex pulumi.StringPtrInput
	// All commit messages must match this regex, e.g. `Fixed \d+\..*`.
	CommitMessageRegex pulumi.StringPtrInput
	// Deny deleting a tag.
	DenyDeleteTag pulumi.BoolPtrInput
	// All committed filenames must not match this regex, e.g. `(jar|exe)$`.
	FileNameRegex pulumi.StringPtrInput
	// Maximum file size (MB).
	MaxFileSize pulumi.IntPtrInput
	// Restrict commits by author (email) to existing GitLab users.
	MemberCheck pulumi.BoolPtrInput
	// GitLab will reject any files that are likely to contain secrets.
	PreventSecrets pulumi.BoolPtrInput
	// The ID or URL-encoded path of the project.
	Project pulumi.StringPtrInput
	// Reject commit when it’s not DCO certified.
	RejectNonDcoCommits pulumi.BoolPtrInput
	// Reject commit when it’s not signed.
	RejectUnsignedCommits pulumi.BoolPtrInput
}

func (ProjectPushRulesState) ElementType() reflect.Type {
	return reflect.TypeOf((*projectPushRulesState)(nil)).Elem()
}

type projectPushRulesArgs struct {
	// All commit author emails must match this regex, e.g. `@my-company.com$`.
	AuthorEmailRegex *string `pulumi:"authorEmailRegex"`
	// All branch names must match this regex, e.g. `(feature|hotfix)\/*`.
	BranchNameRegex *string `pulumi:"branchNameRegex"`
	// Users can only push commits to this repository that were committed with one of their own verified emails.
	CommitCommitterCheck *bool `pulumi:"commitCommitterCheck"`
	// Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
	CommitCommitterNameCheck *bool `pulumi:"commitCommitterNameCheck"`
	// No commit message is allowed to match this regex, e.g. `ssh\:\/\/`.
	CommitMessageNegativeRegex *string `pulumi:"commitMessageNegativeRegex"`
	// All commit messages must match this regex, e.g. `Fixed \d+\..*`.
	CommitMessageRegex *string `pulumi:"commitMessageRegex"`
	// Deny deleting a tag.
	DenyDeleteTag *bool `pulumi:"denyDeleteTag"`
	// All committed filenames must not match this regex, e.g. `(jar|exe)$`.
	FileNameRegex *string `pulumi:"fileNameRegex"`
	// Maximum file size (MB).
	MaxFileSize *int `pulumi:"maxFileSize"`
	// Restrict commits by author (email) to existing GitLab users.
	MemberCheck *bool `pulumi:"memberCheck"`
	// GitLab will reject any files that are likely to contain secrets.
	PreventSecrets *bool `pulumi:"preventSecrets"`
	// The ID or URL-encoded path of the project.
	Project string `pulumi:"project"`
	// Reject commit when it’s not DCO certified.
	RejectNonDcoCommits *bool `pulumi:"rejectNonDcoCommits"`
	// Reject commit when it’s not signed.
	RejectUnsignedCommits *bool `pulumi:"rejectUnsignedCommits"`
}

// The set of arguments for constructing a ProjectPushRules resource.
type ProjectPushRulesArgs struct {
	// All commit author emails must match this regex, e.g. `@my-company.com$`.
	AuthorEmailRegex pulumi.StringPtrInput
	// All branch names must match this regex, e.g. `(feature|hotfix)\/*`.
	BranchNameRegex pulumi.StringPtrInput
	// Users can only push commits to this repository that were committed with one of their own verified emails.
	CommitCommitterCheck pulumi.BoolPtrInput
	// Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
	CommitCommitterNameCheck pulumi.BoolPtrInput
	// No commit message is allowed to match this regex, e.g. `ssh\:\/\/`.
	CommitMessageNegativeRegex pulumi.StringPtrInput
	// All commit messages must match this regex, e.g. `Fixed \d+\..*`.
	CommitMessageRegex pulumi.StringPtrInput
	// Deny deleting a tag.
	DenyDeleteTag pulumi.BoolPtrInput
	// All committed filenames must not match this regex, e.g. `(jar|exe)$`.
	FileNameRegex pulumi.StringPtrInput
	// Maximum file size (MB).
	MaxFileSize pulumi.IntPtrInput
	// Restrict commits by author (email) to existing GitLab users.
	MemberCheck pulumi.BoolPtrInput
	// GitLab will reject any files that are likely to contain secrets.
	PreventSecrets pulumi.BoolPtrInput
	// The ID or URL-encoded path of the project.
	Project pulumi.StringInput
	// Reject commit when it’s not DCO certified.
	RejectNonDcoCommits pulumi.BoolPtrInput
	// Reject commit when it’s not signed.
	RejectUnsignedCommits pulumi.BoolPtrInput
}

func (ProjectPushRulesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*projectPushRulesArgs)(nil)).Elem()
}

type ProjectPushRulesInput interface {
	pulumi.Input

	ToProjectPushRulesOutput() ProjectPushRulesOutput
	ToProjectPushRulesOutputWithContext(ctx context.Context) ProjectPushRulesOutput
}

func (*ProjectPushRules) ElementType() reflect.Type {
	return reflect.TypeOf((**ProjectPushRules)(nil)).Elem()
}

func (i *ProjectPushRules) ToProjectPushRulesOutput() ProjectPushRulesOutput {
	return i.ToProjectPushRulesOutputWithContext(context.Background())
}

func (i *ProjectPushRules) ToProjectPushRulesOutputWithContext(ctx context.Context) ProjectPushRulesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectPushRulesOutput)
}

// ProjectPushRulesArrayInput is an input type that accepts ProjectPushRulesArray and ProjectPushRulesArrayOutput values.
// You can construct a concrete instance of `ProjectPushRulesArrayInput` via:
//
//	ProjectPushRulesArray{ ProjectPushRulesArgs{...} }
type ProjectPushRulesArrayInput interface {
	pulumi.Input

	ToProjectPushRulesArrayOutput() ProjectPushRulesArrayOutput
	ToProjectPushRulesArrayOutputWithContext(context.Context) ProjectPushRulesArrayOutput
}

type ProjectPushRulesArray []ProjectPushRulesInput

func (ProjectPushRulesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ProjectPushRules)(nil)).Elem()
}

func (i ProjectPushRulesArray) ToProjectPushRulesArrayOutput() ProjectPushRulesArrayOutput {
	return i.ToProjectPushRulesArrayOutputWithContext(context.Background())
}

func (i ProjectPushRulesArray) ToProjectPushRulesArrayOutputWithContext(ctx context.Context) ProjectPushRulesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectPushRulesArrayOutput)
}

// ProjectPushRulesMapInput is an input type that accepts ProjectPushRulesMap and ProjectPushRulesMapOutput values.
// You can construct a concrete instance of `ProjectPushRulesMapInput` via:
//
//	ProjectPushRulesMap{ "key": ProjectPushRulesArgs{...} }
type ProjectPushRulesMapInput interface {
	pulumi.Input

	ToProjectPushRulesMapOutput() ProjectPushRulesMapOutput
	ToProjectPushRulesMapOutputWithContext(context.Context) ProjectPushRulesMapOutput
}

type ProjectPushRulesMap map[string]ProjectPushRulesInput

func (ProjectPushRulesMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ProjectPushRules)(nil)).Elem()
}

func (i ProjectPushRulesMap) ToProjectPushRulesMapOutput() ProjectPushRulesMapOutput {
	return i.ToProjectPushRulesMapOutputWithContext(context.Background())
}

func (i ProjectPushRulesMap) ToProjectPushRulesMapOutputWithContext(ctx context.Context) ProjectPushRulesMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectPushRulesMapOutput)
}

type ProjectPushRulesOutput struct{ *pulumi.OutputState }

func (ProjectPushRulesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ProjectPushRules)(nil)).Elem()
}

func (o ProjectPushRulesOutput) ToProjectPushRulesOutput() ProjectPushRulesOutput {
	return o
}

func (o ProjectPushRulesOutput) ToProjectPushRulesOutputWithContext(ctx context.Context) ProjectPushRulesOutput {
	return o
}

// All commit author emails must match this regex, e.g. `@my-company.com$`.
func (o ProjectPushRulesOutput) AuthorEmailRegex() pulumi.StringOutput {
	return o.ApplyT(func(v *ProjectPushRules) pulumi.StringOutput { return v.AuthorEmailRegex }).(pulumi.StringOutput)
}

// All branch names must match this regex, e.g. `(feature|hotfix)\/*`.
func (o ProjectPushRulesOutput) BranchNameRegex() pulumi.StringOutput {
	return o.ApplyT(func(v *ProjectPushRules) pulumi.StringOutput { return v.BranchNameRegex }).(pulumi.StringOutput)
}

// Users can only push commits to this repository that were committed with one of their own verified emails.
func (o ProjectPushRulesOutput) CommitCommitterCheck() pulumi.BoolOutput {
	return o.ApplyT(func(v *ProjectPushRules) pulumi.BoolOutput { return v.CommitCommitterCheck }).(pulumi.BoolOutput)
}

// Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
func (o ProjectPushRulesOutput) CommitCommitterNameCheck() pulumi.BoolOutput {
	return o.ApplyT(func(v *ProjectPushRules) pulumi.BoolOutput { return v.CommitCommitterNameCheck }).(pulumi.BoolOutput)
}

// No commit message is allowed to match this regex, e.g. `ssh\:\/\/`.
func (o ProjectPushRulesOutput) CommitMessageNegativeRegex() pulumi.StringOutput {
	return o.ApplyT(func(v *ProjectPushRules) pulumi.StringOutput { return v.CommitMessageNegativeRegex }).(pulumi.StringOutput)
}

// All commit messages must match this regex, e.g. `Fixed \d+\..*`.
func (o ProjectPushRulesOutput) CommitMessageRegex() pulumi.StringOutput {
	return o.ApplyT(func(v *ProjectPushRules) pulumi.StringOutput { return v.CommitMessageRegex }).(pulumi.StringOutput)
}

// Deny deleting a tag.
func (o ProjectPushRulesOutput) DenyDeleteTag() pulumi.BoolOutput {
	return o.ApplyT(func(v *ProjectPushRules) pulumi.BoolOutput { return v.DenyDeleteTag }).(pulumi.BoolOutput)
}

// All committed filenames must not match this regex, e.g. `(jar|exe)$`.
func (o ProjectPushRulesOutput) FileNameRegex() pulumi.StringOutput {
	return o.ApplyT(func(v *ProjectPushRules) pulumi.StringOutput { return v.FileNameRegex }).(pulumi.StringOutput)
}

// Maximum file size (MB).
func (o ProjectPushRulesOutput) MaxFileSize() pulumi.IntOutput {
	return o.ApplyT(func(v *ProjectPushRules) pulumi.IntOutput { return v.MaxFileSize }).(pulumi.IntOutput)
}

// Restrict commits by author (email) to existing GitLab users.
func (o ProjectPushRulesOutput) MemberCheck() pulumi.BoolOutput {
	return o.ApplyT(func(v *ProjectPushRules) pulumi.BoolOutput { return v.MemberCheck }).(pulumi.BoolOutput)
}

// GitLab will reject any files that are likely to contain secrets.
func (o ProjectPushRulesOutput) PreventSecrets() pulumi.BoolOutput {
	return o.ApplyT(func(v *ProjectPushRules) pulumi.BoolOutput { return v.PreventSecrets }).(pulumi.BoolOutput)
}

// The ID or URL-encoded path of the project.
func (o ProjectPushRulesOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *ProjectPushRules) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// Reject commit when it’s not DCO certified.
func (o ProjectPushRulesOutput) RejectNonDcoCommits() pulumi.BoolOutput {
	return o.ApplyT(func(v *ProjectPushRules) pulumi.BoolOutput { return v.RejectNonDcoCommits }).(pulumi.BoolOutput)
}

// Reject commit when it’s not signed.
func (o ProjectPushRulesOutput) RejectUnsignedCommits() pulumi.BoolOutput {
	return o.ApplyT(func(v *ProjectPushRules) pulumi.BoolOutput { return v.RejectUnsignedCommits }).(pulumi.BoolOutput)
}

type ProjectPushRulesArrayOutput struct{ *pulumi.OutputState }

func (ProjectPushRulesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ProjectPushRules)(nil)).Elem()
}

func (o ProjectPushRulesArrayOutput) ToProjectPushRulesArrayOutput() ProjectPushRulesArrayOutput {
	return o
}

func (o ProjectPushRulesArrayOutput) ToProjectPushRulesArrayOutputWithContext(ctx context.Context) ProjectPushRulesArrayOutput {
	return o
}

func (o ProjectPushRulesArrayOutput) Index(i pulumi.IntInput) ProjectPushRulesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ProjectPushRules {
		return vs[0].([]*ProjectPushRules)[vs[1].(int)]
	}).(ProjectPushRulesOutput)
}

type ProjectPushRulesMapOutput struct{ *pulumi.OutputState }

func (ProjectPushRulesMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ProjectPushRules)(nil)).Elem()
}

func (o ProjectPushRulesMapOutput) ToProjectPushRulesMapOutput() ProjectPushRulesMapOutput {
	return o
}

func (o ProjectPushRulesMapOutput) ToProjectPushRulesMapOutputWithContext(ctx context.Context) ProjectPushRulesMapOutput {
	return o
}

func (o ProjectPushRulesMapOutput) MapIndex(k pulumi.StringInput) ProjectPushRulesOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ProjectPushRules {
		return vs[0].(map[string]*ProjectPushRules)[vs[1].(string)]
	}).(ProjectPushRulesOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ProjectPushRulesInput)(nil)).Elem(), &ProjectPushRules{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProjectPushRulesArrayInput)(nil)).Elem(), ProjectPushRulesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProjectPushRulesMapInput)(nil)).Elem(), ProjectPushRulesMap{})
	pulumi.RegisterOutputType(ProjectPushRulesOutput{})
	pulumi.RegisterOutputType(ProjectPushRulesArrayOutput{})
	pulumi.RegisterOutputType(ProjectPushRulesMapOutput{})
}
