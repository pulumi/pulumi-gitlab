// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package gitlab

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gitlab/sdk/v9/go/gitlab/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// The `ProjectSecureFile` resource allows users to manage the lifecycle of a secure file in gitlab.
//
// **Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/api/secure_files/)
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gitlab/sdk/v9/go/gitlab"
//	"github.com/pulumi/pulumi-std/sdk/go/std"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			this, err := gitlab.NewGroup(ctx, "this", &gitlab.GroupArgs{
//				Name:        pulumi.String("example"),
//				Path:        pulumi.String("example"),
//				Description: pulumi.String("An example group"),
//			})
//			if err != nil {
//				return err
//			}
//			thisProject, err := gitlab.NewProject(ctx, "this", &gitlab.ProjectArgs{
//				Name:                 pulumi.String("example"),
//				NamespaceId:          this.ID(),
//				InitializeWithReadme: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			invokeFile, err := std.File(ctx, &std.FileArgs{
//				Input: "example.txt",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = gitlab.NewProjectSecureFile(ctx, "this", &gitlab.ProjectSecureFileArgs{
//				Name:    pulumi.String("my-secure-file"),
//				Project: thisProject.ID(),
//				Content: pulumi.String(invokeFile.Result),
//			})
//			if err != nil {
//				return err
//			}
//			invokeFile1, err := std.File(ctx, &std.FileArgs{
//				Input: "example.txt",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = gitlab.NewProjectSecureFile(ctx, "disable_poll_for_metadata", &gitlab.ProjectSecureFileArgs{
//				Name:                             pulumi.String("my-secure-file"),
//				Project:                          thisProject.ID(),
//				Content:                          pulumi.String(invokeFile1.Result),
//				PollForMetadataDurationInSeconds: 0,
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Starting in Terraform v1.5.0, you can use an import block to import `gitlab_project_secure_file`. For example:
//
// terraform
//
// import {
//
//	to = gitlab_project_secure_file.example
//
//	id = "see CLI command below for ID"
//
// }
//
// Importing using the CLI is supported with the following syntax:
//
// GitLab secure files can be imported using an id made up of `projectId:secureFileId`, e.g.
//
// ```sh
// $ pulumi import gitlab:index/projectSecureFile:ProjectSecureFile bar 123:321
// ```
type ProjectSecureFile struct {
	pulumi.CustomResourceState

	// The checksum of the file
	Checksum pulumi.StringOutput `pulumi:"checksum"`
	// The checksum algorithm used
	ChecksumAlgorithm pulumi.StringOutput `pulumi:"checksumAlgorithm"`
	// The contents of the secure file
	Content pulumi.StringOutput `pulumi:"content"`
	// The time the secure file was uploaded
	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`
	// The time the secure file will expire
	ExpiresAt pulumi.StringOutput `pulumi:"expiresAt"`
	// The name for the secure file, unique per project
	Name pulumi.StringOutput `pulumi:"name"`
	// The ID or full path of the project to environment is created for.
	Project pulumi.StringOutput `pulumi:"project"`
	// The id of the secure file in gitlab
	SecureFileId pulumi.IntOutput `pulumi:"secureFileId"`
}

// NewProjectSecureFile registers a new resource with the given unique name, arguments, and options.
func NewProjectSecureFile(ctx *pulumi.Context,
	name string, args *ProjectSecureFileArgs, opts ...pulumi.ResourceOption) (*ProjectSecureFile, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Content == nil {
		return nil, errors.New("invalid value for required argument 'Content'")
	}
	if args.Project == nil {
		return nil, errors.New("invalid value for required argument 'Project'")
	}
	if args.Content != nil {
		args.Content = pulumi.ToSecret(args.Content).(pulumi.StringInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"content",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ProjectSecureFile
	err := ctx.RegisterResource("gitlab:index/projectSecureFile:ProjectSecureFile", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetProjectSecureFile gets an existing ProjectSecureFile resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetProjectSecureFile(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ProjectSecureFileState, opts ...pulumi.ResourceOption) (*ProjectSecureFile, error) {
	var resource ProjectSecureFile
	err := ctx.ReadResource("gitlab:index/projectSecureFile:ProjectSecureFile", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ProjectSecureFile resources.
type projectSecureFileState struct {
	// The checksum of the file
	Checksum *string `pulumi:"checksum"`
	// The checksum algorithm used
	ChecksumAlgorithm *string `pulumi:"checksumAlgorithm"`
	// The contents of the secure file
	Content *string `pulumi:"content"`
	// The time the secure file was uploaded
	CreatedAt *string `pulumi:"createdAt"`
	// The time the secure file will expire
	ExpiresAt *string `pulumi:"expiresAt"`
	// The name for the secure file, unique per project
	Name *string `pulumi:"name"`
	// The ID or full path of the project to environment is created for.
	Project *string `pulumi:"project"`
	// The id of the secure file in gitlab
	SecureFileId *int `pulumi:"secureFileId"`
}

type ProjectSecureFileState struct {
	// The checksum of the file
	Checksum pulumi.StringPtrInput
	// The checksum algorithm used
	ChecksumAlgorithm pulumi.StringPtrInput
	// The contents of the secure file
	Content pulumi.StringPtrInput
	// The time the secure file was uploaded
	CreatedAt pulumi.StringPtrInput
	// The time the secure file will expire
	ExpiresAt pulumi.StringPtrInput
	// The name for the secure file, unique per project
	Name pulumi.StringPtrInput
	// The ID or full path of the project to environment is created for.
	Project pulumi.StringPtrInput
	// The id of the secure file in gitlab
	SecureFileId pulumi.IntPtrInput
}

func (ProjectSecureFileState) ElementType() reflect.Type {
	return reflect.TypeOf((*projectSecureFileState)(nil)).Elem()
}

type projectSecureFileArgs struct {
	// The contents of the secure file
	Content string `pulumi:"content"`
	// The name for the secure file, unique per project
	Name *string `pulumi:"name"`
	// The ID or full path of the project to environment is created for.
	Project string `pulumi:"project"`
}

// The set of arguments for constructing a ProjectSecureFile resource.
type ProjectSecureFileArgs struct {
	// The contents of the secure file
	Content pulumi.StringInput
	// The name for the secure file, unique per project
	Name pulumi.StringPtrInput
	// The ID or full path of the project to environment is created for.
	Project pulumi.StringInput
}

func (ProjectSecureFileArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*projectSecureFileArgs)(nil)).Elem()
}

type ProjectSecureFileInput interface {
	pulumi.Input

	ToProjectSecureFileOutput() ProjectSecureFileOutput
	ToProjectSecureFileOutputWithContext(ctx context.Context) ProjectSecureFileOutput
}

func (*ProjectSecureFile) ElementType() reflect.Type {
	return reflect.TypeOf((**ProjectSecureFile)(nil)).Elem()
}

func (i *ProjectSecureFile) ToProjectSecureFileOutput() ProjectSecureFileOutput {
	return i.ToProjectSecureFileOutputWithContext(context.Background())
}

func (i *ProjectSecureFile) ToProjectSecureFileOutputWithContext(ctx context.Context) ProjectSecureFileOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectSecureFileOutput)
}

// ProjectSecureFileArrayInput is an input type that accepts ProjectSecureFileArray and ProjectSecureFileArrayOutput values.
// You can construct a concrete instance of `ProjectSecureFileArrayInput` via:
//
//	ProjectSecureFileArray{ ProjectSecureFileArgs{...} }
type ProjectSecureFileArrayInput interface {
	pulumi.Input

	ToProjectSecureFileArrayOutput() ProjectSecureFileArrayOutput
	ToProjectSecureFileArrayOutputWithContext(context.Context) ProjectSecureFileArrayOutput
}

type ProjectSecureFileArray []ProjectSecureFileInput

func (ProjectSecureFileArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ProjectSecureFile)(nil)).Elem()
}

func (i ProjectSecureFileArray) ToProjectSecureFileArrayOutput() ProjectSecureFileArrayOutput {
	return i.ToProjectSecureFileArrayOutputWithContext(context.Background())
}

func (i ProjectSecureFileArray) ToProjectSecureFileArrayOutputWithContext(ctx context.Context) ProjectSecureFileArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectSecureFileArrayOutput)
}

// ProjectSecureFileMapInput is an input type that accepts ProjectSecureFileMap and ProjectSecureFileMapOutput values.
// You can construct a concrete instance of `ProjectSecureFileMapInput` via:
//
//	ProjectSecureFileMap{ "key": ProjectSecureFileArgs{...} }
type ProjectSecureFileMapInput interface {
	pulumi.Input

	ToProjectSecureFileMapOutput() ProjectSecureFileMapOutput
	ToProjectSecureFileMapOutputWithContext(context.Context) ProjectSecureFileMapOutput
}

type ProjectSecureFileMap map[string]ProjectSecureFileInput

func (ProjectSecureFileMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ProjectSecureFile)(nil)).Elem()
}

func (i ProjectSecureFileMap) ToProjectSecureFileMapOutput() ProjectSecureFileMapOutput {
	return i.ToProjectSecureFileMapOutputWithContext(context.Background())
}

func (i ProjectSecureFileMap) ToProjectSecureFileMapOutputWithContext(ctx context.Context) ProjectSecureFileMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectSecureFileMapOutput)
}

type ProjectSecureFileOutput struct{ *pulumi.OutputState }

func (ProjectSecureFileOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ProjectSecureFile)(nil)).Elem()
}

func (o ProjectSecureFileOutput) ToProjectSecureFileOutput() ProjectSecureFileOutput {
	return o
}

func (o ProjectSecureFileOutput) ToProjectSecureFileOutputWithContext(ctx context.Context) ProjectSecureFileOutput {
	return o
}

// The checksum of the file
func (o ProjectSecureFileOutput) Checksum() pulumi.StringOutput {
	return o.ApplyT(func(v *ProjectSecureFile) pulumi.StringOutput { return v.Checksum }).(pulumi.StringOutput)
}

// The checksum algorithm used
func (o ProjectSecureFileOutput) ChecksumAlgorithm() pulumi.StringOutput {
	return o.ApplyT(func(v *ProjectSecureFile) pulumi.StringOutput { return v.ChecksumAlgorithm }).(pulumi.StringOutput)
}

// The contents of the secure file
func (o ProjectSecureFileOutput) Content() pulumi.StringOutput {
	return o.ApplyT(func(v *ProjectSecureFile) pulumi.StringOutput { return v.Content }).(pulumi.StringOutput)
}

// The time the secure file was uploaded
func (o ProjectSecureFileOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *ProjectSecureFile) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

// The time the secure file will expire
func (o ProjectSecureFileOutput) ExpiresAt() pulumi.StringOutput {
	return o.ApplyT(func(v *ProjectSecureFile) pulumi.StringOutput { return v.ExpiresAt }).(pulumi.StringOutput)
}

// The name for the secure file, unique per project
func (o ProjectSecureFileOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ProjectSecureFile) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The ID or full path of the project to environment is created for.
func (o ProjectSecureFileOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *ProjectSecureFile) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// The id of the secure file in gitlab
func (o ProjectSecureFileOutput) SecureFileId() pulumi.IntOutput {
	return o.ApplyT(func(v *ProjectSecureFile) pulumi.IntOutput { return v.SecureFileId }).(pulumi.IntOutput)
}

type ProjectSecureFileArrayOutput struct{ *pulumi.OutputState }

func (ProjectSecureFileArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ProjectSecureFile)(nil)).Elem()
}

func (o ProjectSecureFileArrayOutput) ToProjectSecureFileArrayOutput() ProjectSecureFileArrayOutput {
	return o
}

func (o ProjectSecureFileArrayOutput) ToProjectSecureFileArrayOutputWithContext(ctx context.Context) ProjectSecureFileArrayOutput {
	return o
}

func (o ProjectSecureFileArrayOutput) Index(i pulumi.IntInput) ProjectSecureFileOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ProjectSecureFile {
		return vs[0].([]*ProjectSecureFile)[vs[1].(int)]
	}).(ProjectSecureFileOutput)
}

type ProjectSecureFileMapOutput struct{ *pulumi.OutputState }

func (ProjectSecureFileMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ProjectSecureFile)(nil)).Elem()
}

func (o ProjectSecureFileMapOutput) ToProjectSecureFileMapOutput() ProjectSecureFileMapOutput {
	return o
}

func (o ProjectSecureFileMapOutput) ToProjectSecureFileMapOutputWithContext(ctx context.Context) ProjectSecureFileMapOutput {
	return o
}

func (o ProjectSecureFileMapOutput) MapIndex(k pulumi.StringInput) ProjectSecureFileOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ProjectSecureFile {
		return vs[0].(map[string]*ProjectSecureFile)[vs[1].(string)]
	}).(ProjectSecureFileOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ProjectSecureFileInput)(nil)).Elem(), &ProjectSecureFile{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProjectSecureFileArrayInput)(nil)).Elem(), ProjectSecureFileArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProjectSecureFileMapInput)(nil)).Elem(), ProjectSecureFileMap{})
	pulumi.RegisterOutputType(ProjectSecureFileOutput{})
	pulumi.RegisterOutputType(ProjectSecureFileArrayOutput{})
	pulumi.RegisterOutputType(ProjectSecureFileMapOutput{})
}
