// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package gitlab

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// The `ProjectTargetBranchRule` resource allows to configure default target branch rules when creating a merge request.
//
// **Upstream API**: [GitLab GraphQL API docs](https://docs.gitlab.com/ee/api/graphql/reference/#mutationprojecttargetbranchrulecreate)
type ProjectTargetBranchRule struct {
	pulumi.CustomResourceState

	// The ID or URL-encoded path of the project.
	Project pulumi.StringOutput `pulumi:"project"`
	// A pattern matching the branch name for which the merge request should have a default target branch configured.
	SourceBranchPattern pulumi.StringOutput `pulumi:"sourceBranchPattern"`
	// The name of the branch to which the merge request should be addressed.
	TargetBranchName pulumi.StringOutput `pulumi:"targetBranchName"`
}

// NewProjectTargetBranchRule registers a new resource with the given unique name, arguments, and options.
func NewProjectTargetBranchRule(ctx *pulumi.Context,
	name string, args *ProjectTargetBranchRuleArgs, opts ...pulumi.ResourceOption) (*ProjectTargetBranchRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Project == nil {
		return nil, errors.New("invalid value for required argument 'Project'")
	}
	if args.SourceBranchPattern == nil {
		return nil, errors.New("invalid value for required argument 'SourceBranchPattern'")
	}
	if args.TargetBranchName == nil {
		return nil, errors.New("invalid value for required argument 'TargetBranchName'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ProjectTargetBranchRule
	err := ctx.RegisterResource("gitlab:index/projectTargetBranchRule:ProjectTargetBranchRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetProjectTargetBranchRule gets an existing ProjectTargetBranchRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetProjectTargetBranchRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ProjectTargetBranchRuleState, opts ...pulumi.ResourceOption) (*ProjectTargetBranchRule, error) {
	var resource ProjectTargetBranchRule
	err := ctx.ReadResource("gitlab:index/projectTargetBranchRule:ProjectTargetBranchRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ProjectTargetBranchRule resources.
type projectTargetBranchRuleState struct {
	// The ID or URL-encoded path of the project.
	Project *string `pulumi:"project"`
	// A pattern matching the branch name for which the merge request should have a default target branch configured.
	SourceBranchPattern *string `pulumi:"sourceBranchPattern"`
	// The name of the branch to which the merge request should be addressed.
	TargetBranchName *string `pulumi:"targetBranchName"`
}

type ProjectTargetBranchRuleState struct {
	// The ID or URL-encoded path of the project.
	Project pulumi.StringPtrInput
	// A pattern matching the branch name for which the merge request should have a default target branch configured.
	SourceBranchPattern pulumi.StringPtrInput
	// The name of the branch to which the merge request should be addressed.
	TargetBranchName pulumi.StringPtrInput
}

func (ProjectTargetBranchRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*projectTargetBranchRuleState)(nil)).Elem()
}

type projectTargetBranchRuleArgs struct {
	// The ID or URL-encoded path of the project.
	Project string `pulumi:"project"`
	// A pattern matching the branch name for which the merge request should have a default target branch configured.
	SourceBranchPattern string `pulumi:"sourceBranchPattern"`
	// The name of the branch to which the merge request should be addressed.
	TargetBranchName string `pulumi:"targetBranchName"`
}

// The set of arguments for constructing a ProjectTargetBranchRule resource.
type ProjectTargetBranchRuleArgs struct {
	// The ID or URL-encoded path of the project.
	Project pulumi.StringInput
	// A pattern matching the branch name for which the merge request should have a default target branch configured.
	SourceBranchPattern pulumi.StringInput
	// The name of the branch to which the merge request should be addressed.
	TargetBranchName pulumi.StringInput
}

func (ProjectTargetBranchRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*projectTargetBranchRuleArgs)(nil)).Elem()
}

type ProjectTargetBranchRuleInput interface {
	pulumi.Input

	ToProjectTargetBranchRuleOutput() ProjectTargetBranchRuleOutput
	ToProjectTargetBranchRuleOutputWithContext(ctx context.Context) ProjectTargetBranchRuleOutput
}

func (*ProjectTargetBranchRule) ElementType() reflect.Type {
	return reflect.TypeOf((**ProjectTargetBranchRule)(nil)).Elem()
}

func (i *ProjectTargetBranchRule) ToProjectTargetBranchRuleOutput() ProjectTargetBranchRuleOutput {
	return i.ToProjectTargetBranchRuleOutputWithContext(context.Background())
}

func (i *ProjectTargetBranchRule) ToProjectTargetBranchRuleOutputWithContext(ctx context.Context) ProjectTargetBranchRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectTargetBranchRuleOutput)
}

// ProjectTargetBranchRuleArrayInput is an input type that accepts ProjectTargetBranchRuleArray and ProjectTargetBranchRuleArrayOutput values.
// You can construct a concrete instance of `ProjectTargetBranchRuleArrayInput` via:
//
//	ProjectTargetBranchRuleArray{ ProjectTargetBranchRuleArgs{...} }
type ProjectTargetBranchRuleArrayInput interface {
	pulumi.Input

	ToProjectTargetBranchRuleArrayOutput() ProjectTargetBranchRuleArrayOutput
	ToProjectTargetBranchRuleArrayOutputWithContext(context.Context) ProjectTargetBranchRuleArrayOutput
}

type ProjectTargetBranchRuleArray []ProjectTargetBranchRuleInput

func (ProjectTargetBranchRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ProjectTargetBranchRule)(nil)).Elem()
}

func (i ProjectTargetBranchRuleArray) ToProjectTargetBranchRuleArrayOutput() ProjectTargetBranchRuleArrayOutput {
	return i.ToProjectTargetBranchRuleArrayOutputWithContext(context.Background())
}

func (i ProjectTargetBranchRuleArray) ToProjectTargetBranchRuleArrayOutputWithContext(ctx context.Context) ProjectTargetBranchRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectTargetBranchRuleArrayOutput)
}

// ProjectTargetBranchRuleMapInput is an input type that accepts ProjectTargetBranchRuleMap and ProjectTargetBranchRuleMapOutput values.
// You can construct a concrete instance of `ProjectTargetBranchRuleMapInput` via:
//
//	ProjectTargetBranchRuleMap{ "key": ProjectTargetBranchRuleArgs{...} }
type ProjectTargetBranchRuleMapInput interface {
	pulumi.Input

	ToProjectTargetBranchRuleMapOutput() ProjectTargetBranchRuleMapOutput
	ToProjectTargetBranchRuleMapOutputWithContext(context.Context) ProjectTargetBranchRuleMapOutput
}

type ProjectTargetBranchRuleMap map[string]ProjectTargetBranchRuleInput

func (ProjectTargetBranchRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ProjectTargetBranchRule)(nil)).Elem()
}

func (i ProjectTargetBranchRuleMap) ToProjectTargetBranchRuleMapOutput() ProjectTargetBranchRuleMapOutput {
	return i.ToProjectTargetBranchRuleMapOutputWithContext(context.Background())
}

func (i ProjectTargetBranchRuleMap) ToProjectTargetBranchRuleMapOutputWithContext(ctx context.Context) ProjectTargetBranchRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectTargetBranchRuleMapOutput)
}

type ProjectTargetBranchRuleOutput struct{ *pulumi.OutputState }

func (ProjectTargetBranchRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ProjectTargetBranchRule)(nil)).Elem()
}

func (o ProjectTargetBranchRuleOutput) ToProjectTargetBranchRuleOutput() ProjectTargetBranchRuleOutput {
	return o
}

func (o ProjectTargetBranchRuleOutput) ToProjectTargetBranchRuleOutputWithContext(ctx context.Context) ProjectTargetBranchRuleOutput {
	return o
}

// The ID or URL-encoded path of the project.
func (o ProjectTargetBranchRuleOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *ProjectTargetBranchRule) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// A pattern matching the branch name for which the merge request should have a default target branch configured.
func (o ProjectTargetBranchRuleOutput) SourceBranchPattern() pulumi.StringOutput {
	return o.ApplyT(func(v *ProjectTargetBranchRule) pulumi.StringOutput { return v.SourceBranchPattern }).(pulumi.StringOutput)
}

// The name of the branch to which the merge request should be addressed.
func (o ProjectTargetBranchRuleOutput) TargetBranchName() pulumi.StringOutput {
	return o.ApplyT(func(v *ProjectTargetBranchRule) pulumi.StringOutput { return v.TargetBranchName }).(pulumi.StringOutput)
}

type ProjectTargetBranchRuleArrayOutput struct{ *pulumi.OutputState }

func (ProjectTargetBranchRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ProjectTargetBranchRule)(nil)).Elem()
}

func (o ProjectTargetBranchRuleArrayOutput) ToProjectTargetBranchRuleArrayOutput() ProjectTargetBranchRuleArrayOutput {
	return o
}

func (o ProjectTargetBranchRuleArrayOutput) ToProjectTargetBranchRuleArrayOutputWithContext(ctx context.Context) ProjectTargetBranchRuleArrayOutput {
	return o
}

func (o ProjectTargetBranchRuleArrayOutput) Index(i pulumi.IntInput) ProjectTargetBranchRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ProjectTargetBranchRule {
		return vs[0].([]*ProjectTargetBranchRule)[vs[1].(int)]
	}).(ProjectTargetBranchRuleOutput)
}

type ProjectTargetBranchRuleMapOutput struct{ *pulumi.OutputState }

func (ProjectTargetBranchRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ProjectTargetBranchRule)(nil)).Elem()
}

func (o ProjectTargetBranchRuleMapOutput) ToProjectTargetBranchRuleMapOutput() ProjectTargetBranchRuleMapOutput {
	return o
}

func (o ProjectTargetBranchRuleMapOutput) ToProjectTargetBranchRuleMapOutputWithContext(ctx context.Context) ProjectTargetBranchRuleMapOutput {
	return o
}

func (o ProjectTargetBranchRuleMapOutput) MapIndex(k pulumi.StringInput) ProjectTargetBranchRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ProjectTargetBranchRule {
		return vs[0].(map[string]*ProjectTargetBranchRule)[vs[1].(string)]
	}).(ProjectTargetBranchRuleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ProjectTargetBranchRuleInput)(nil)).Elem(), &ProjectTargetBranchRule{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProjectTargetBranchRuleArrayInput)(nil)).Elem(), ProjectTargetBranchRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProjectTargetBranchRuleMapInput)(nil)).Elem(), ProjectTargetBranchRuleMap{})
	pulumi.RegisterOutputType(ProjectTargetBranchRuleOutput{})
	pulumi.RegisterOutputType(ProjectTargetBranchRuleArrayOutput{})
	pulumi.RegisterOutputType(ProjectTargetBranchRuleMapOutput{})
}
