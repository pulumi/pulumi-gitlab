// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package gitlab

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gitlab/sdk/v9/go/gitlab/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// The `UserImpersonationToken` resource allows to manage impersonation tokens of users.
// Requires administrator access. Token values are returned once. You are only able to create impersonation tokens to impersonate the user and perform both API calls and Git reads and writes. The user canâ€™t see these tokens in their profile settings page.
//
// **Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/api/user_tokens/#create-an-impersonation-token)
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gitlab/sdk/v9/go/gitlab"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := gitlab.NewUserImpersonationToken(ctx, "this", &gitlab.UserImpersonationTokenArgs{
//				UserId: pulumi.Int(12345),
//				Name:   pulumi.String("token_name"),
//				Scopes: pulumi.StringArray{
//					pulumi.String("api"),
//				},
//				ExpiresAt: pulumi.String("2024-08-27"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Starting in Terraform v1.5.0, you can use an import block to import `gitlab_user_impersonation_token`. For example:
//
// terraform
//
// import {
//
//	to = gitlab_user_impersonation_token.example
//
//	id = "see CLI command below for ID"
//
// }
//
// Importing using the CLI is supported with the following syntax:
//
// A GitLab User Impersonation Token can be imported using a key composed of `<user-id>:<token-id>`, e.g.
//
// ```sh
// $ pulumi import gitlab:index/userImpersonationToken:UserImpersonationToken example "12345:1"
// ```
//
// NOTE: the `token` resource attribute is not available for imported resources as this information cannot be read from the GitLab API.
type UserImpersonationToken struct {
	pulumi.CustomResourceState

	// True if the token is active.
	Active pulumi.BoolOutput `pulumi:"active"`
	// Time the token has been created, RFC3339 format.
	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`
	// Expiration date of the impersonation token in ISO format (YYYY-MM-DD).
	ExpiresAt pulumi.StringOutput `pulumi:"expiresAt"`
	// True as the token is always an impersonation token.
	Impersonation pulumi.BoolOutput `pulumi:"impersonation"`
	// The name of the impersonation token.
	Name pulumi.StringOutput `pulumi:"name"`
	// True if the token is revoked.
	Revoked pulumi.BoolOutput `pulumi:"revoked"`
	// Array of scopes of the impersonation token. valid values are: `api`, `readUser`, `readApi`, `readRepository`, `writeRepository`, `readRegistry`, `writeRegistry`, `readVirtualRegistry`, `writeVirtualRegistry`, `sudo`, `adminMode`, `createRunner`, `manageRunner`, `aiFeatures`, `k8sProxy`, `selfRotate`, `readServicePing`
	Scopes pulumi.StringArrayOutput `pulumi:"scopes"`
	// The token of the user impersonation token. **Note**: the token is not available for imported resources.
	Token pulumi.StringOutput `pulumi:"token"`
	// ID of the impersonation token.
	TokenId pulumi.IntOutput `pulumi:"tokenId"`
	// The ID of the user.
	UserId pulumi.IntOutput `pulumi:"userId"`
	// Wether to validate if the expiration date is in the future.
	ValidatePastExpirationDate pulumi.BoolOutput `pulumi:"validatePastExpirationDate"`
}

// NewUserImpersonationToken registers a new resource with the given unique name, arguments, and options.
func NewUserImpersonationToken(ctx *pulumi.Context,
	name string, args *UserImpersonationTokenArgs, opts ...pulumi.ResourceOption) (*UserImpersonationToken, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ExpiresAt == nil {
		return nil, errors.New("invalid value for required argument 'ExpiresAt'")
	}
	if args.Scopes == nil {
		return nil, errors.New("invalid value for required argument 'Scopes'")
	}
	if args.UserId == nil {
		return nil, errors.New("invalid value for required argument 'UserId'")
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"token",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource UserImpersonationToken
	err := ctx.RegisterResource("gitlab:index/userImpersonationToken:UserImpersonationToken", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetUserImpersonationToken gets an existing UserImpersonationToken resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetUserImpersonationToken(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *UserImpersonationTokenState, opts ...pulumi.ResourceOption) (*UserImpersonationToken, error) {
	var resource UserImpersonationToken
	err := ctx.ReadResource("gitlab:index/userImpersonationToken:UserImpersonationToken", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering UserImpersonationToken resources.
type userImpersonationTokenState struct {
	// True if the token is active.
	Active *bool `pulumi:"active"`
	// Time the token has been created, RFC3339 format.
	CreatedAt *string `pulumi:"createdAt"`
	// Expiration date of the impersonation token in ISO format (YYYY-MM-DD).
	ExpiresAt *string `pulumi:"expiresAt"`
	// True as the token is always an impersonation token.
	Impersonation *bool `pulumi:"impersonation"`
	// The name of the impersonation token.
	Name *string `pulumi:"name"`
	// True if the token is revoked.
	Revoked *bool `pulumi:"revoked"`
	// Array of scopes of the impersonation token. valid values are: `api`, `readUser`, `readApi`, `readRepository`, `writeRepository`, `readRegistry`, `writeRegistry`, `readVirtualRegistry`, `writeVirtualRegistry`, `sudo`, `adminMode`, `createRunner`, `manageRunner`, `aiFeatures`, `k8sProxy`, `selfRotate`, `readServicePing`
	Scopes []string `pulumi:"scopes"`
	// The token of the user impersonation token. **Note**: the token is not available for imported resources.
	Token *string `pulumi:"token"`
	// ID of the impersonation token.
	TokenId *int `pulumi:"tokenId"`
	// The ID of the user.
	UserId *int `pulumi:"userId"`
	// Wether to validate if the expiration date is in the future.
	ValidatePastExpirationDate *bool `pulumi:"validatePastExpirationDate"`
}

type UserImpersonationTokenState struct {
	// True if the token is active.
	Active pulumi.BoolPtrInput
	// Time the token has been created, RFC3339 format.
	CreatedAt pulumi.StringPtrInput
	// Expiration date of the impersonation token in ISO format (YYYY-MM-DD).
	ExpiresAt pulumi.StringPtrInput
	// True as the token is always an impersonation token.
	Impersonation pulumi.BoolPtrInput
	// The name of the impersonation token.
	Name pulumi.StringPtrInput
	// True if the token is revoked.
	Revoked pulumi.BoolPtrInput
	// Array of scopes of the impersonation token. valid values are: `api`, `readUser`, `readApi`, `readRepository`, `writeRepository`, `readRegistry`, `writeRegistry`, `readVirtualRegistry`, `writeVirtualRegistry`, `sudo`, `adminMode`, `createRunner`, `manageRunner`, `aiFeatures`, `k8sProxy`, `selfRotate`, `readServicePing`
	Scopes pulumi.StringArrayInput
	// The token of the user impersonation token. **Note**: the token is not available for imported resources.
	Token pulumi.StringPtrInput
	// ID of the impersonation token.
	TokenId pulumi.IntPtrInput
	// The ID of the user.
	UserId pulumi.IntPtrInput
	// Wether to validate if the expiration date is in the future.
	ValidatePastExpirationDate pulumi.BoolPtrInput
}

func (UserImpersonationTokenState) ElementType() reflect.Type {
	return reflect.TypeOf((*userImpersonationTokenState)(nil)).Elem()
}

type userImpersonationTokenArgs struct {
	// Expiration date of the impersonation token in ISO format (YYYY-MM-DD).
	ExpiresAt string `pulumi:"expiresAt"`
	// The name of the impersonation token.
	Name *string `pulumi:"name"`
	// Array of scopes of the impersonation token. valid values are: `api`, `readUser`, `readApi`, `readRepository`, `writeRepository`, `readRegistry`, `writeRegistry`, `readVirtualRegistry`, `writeVirtualRegistry`, `sudo`, `adminMode`, `createRunner`, `manageRunner`, `aiFeatures`, `k8sProxy`, `selfRotate`, `readServicePing`
	Scopes []string `pulumi:"scopes"`
	// The ID of the user.
	UserId int `pulumi:"userId"`
	// Wether to validate if the expiration date is in the future.
	ValidatePastExpirationDate *bool `pulumi:"validatePastExpirationDate"`
}

// The set of arguments for constructing a UserImpersonationToken resource.
type UserImpersonationTokenArgs struct {
	// Expiration date of the impersonation token in ISO format (YYYY-MM-DD).
	ExpiresAt pulumi.StringInput
	// The name of the impersonation token.
	Name pulumi.StringPtrInput
	// Array of scopes of the impersonation token. valid values are: `api`, `readUser`, `readApi`, `readRepository`, `writeRepository`, `readRegistry`, `writeRegistry`, `readVirtualRegistry`, `writeVirtualRegistry`, `sudo`, `adminMode`, `createRunner`, `manageRunner`, `aiFeatures`, `k8sProxy`, `selfRotate`, `readServicePing`
	Scopes pulumi.StringArrayInput
	// The ID of the user.
	UserId pulumi.IntInput
	// Wether to validate if the expiration date is in the future.
	ValidatePastExpirationDate pulumi.BoolPtrInput
}

func (UserImpersonationTokenArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*userImpersonationTokenArgs)(nil)).Elem()
}

type UserImpersonationTokenInput interface {
	pulumi.Input

	ToUserImpersonationTokenOutput() UserImpersonationTokenOutput
	ToUserImpersonationTokenOutputWithContext(ctx context.Context) UserImpersonationTokenOutput
}

func (*UserImpersonationToken) ElementType() reflect.Type {
	return reflect.TypeOf((**UserImpersonationToken)(nil)).Elem()
}

func (i *UserImpersonationToken) ToUserImpersonationTokenOutput() UserImpersonationTokenOutput {
	return i.ToUserImpersonationTokenOutputWithContext(context.Background())
}

func (i *UserImpersonationToken) ToUserImpersonationTokenOutputWithContext(ctx context.Context) UserImpersonationTokenOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserImpersonationTokenOutput)
}

// UserImpersonationTokenArrayInput is an input type that accepts UserImpersonationTokenArray and UserImpersonationTokenArrayOutput values.
// You can construct a concrete instance of `UserImpersonationTokenArrayInput` via:
//
//	UserImpersonationTokenArray{ UserImpersonationTokenArgs{...} }
type UserImpersonationTokenArrayInput interface {
	pulumi.Input

	ToUserImpersonationTokenArrayOutput() UserImpersonationTokenArrayOutput
	ToUserImpersonationTokenArrayOutputWithContext(context.Context) UserImpersonationTokenArrayOutput
}

type UserImpersonationTokenArray []UserImpersonationTokenInput

func (UserImpersonationTokenArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*UserImpersonationToken)(nil)).Elem()
}

func (i UserImpersonationTokenArray) ToUserImpersonationTokenArrayOutput() UserImpersonationTokenArrayOutput {
	return i.ToUserImpersonationTokenArrayOutputWithContext(context.Background())
}

func (i UserImpersonationTokenArray) ToUserImpersonationTokenArrayOutputWithContext(ctx context.Context) UserImpersonationTokenArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserImpersonationTokenArrayOutput)
}

// UserImpersonationTokenMapInput is an input type that accepts UserImpersonationTokenMap and UserImpersonationTokenMapOutput values.
// You can construct a concrete instance of `UserImpersonationTokenMapInput` via:
//
//	UserImpersonationTokenMap{ "key": UserImpersonationTokenArgs{...} }
type UserImpersonationTokenMapInput interface {
	pulumi.Input

	ToUserImpersonationTokenMapOutput() UserImpersonationTokenMapOutput
	ToUserImpersonationTokenMapOutputWithContext(context.Context) UserImpersonationTokenMapOutput
}

type UserImpersonationTokenMap map[string]UserImpersonationTokenInput

func (UserImpersonationTokenMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*UserImpersonationToken)(nil)).Elem()
}

func (i UserImpersonationTokenMap) ToUserImpersonationTokenMapOutput() UserImpersonationTokenMapOutput {
	return i.ToUserImpersonationTokenMapOutputWithContext(context.Background())
}

func (i UserImpersonationTokenMap) ToUserImpersonationTokenMapOutputWithContext(ctx context.Context) UserImpersonationTokenMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserImpersonationTokenMapOutput)
}

type UserImpersonationTokenOutput struct{ *pulumi.OutputState }

func (UserImpersonationTokenOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UserImpersonationToken)(nil)).Elem()
}

func (o UserImpersonationTokenOutput) ToUserImpersonationTokenOutput() UserImpersonationTokenOutput {
	return o
}

func (o UserImpersonationTokenOutput) ToUserImpersonationTokenOutputWithContext(ctx context.Context) UserImpersonationTokenOutput {
	return o
}

// True if the token is active.
func (o UserImpersonationTokenOutput) Active() pulumi.BoolOutput {
	return o.ApplyT(func(v *UserImpersonationToken) pulumi.BoolOutput { return v.Active }).(pulumi.BoolOutput)
}

// Time the token has been created, RFC3339 format.
func (o UserImpersonationTokenOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *UserImpersonationToken) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

// Expiration date of the impersonation token in ISO format (YYYY-MM-DD).
func (o UserImpersonationTokenOutput) ExpiresAt() pulumi.StringOutput {
	return o.ApplyT(func(v *UserImpersonationToken) pulumi.StringOutput { return v.ExpiresAt }).(pulumi.StringOutput)
}

// True as the token is always an impersonation token.
func (o UserImpersonationTokenOutput) Impersonation() pulumi.BoolOutput {
	return o.ApplyT(func(v *UserImpersonationToken) pulumi.BoolOutput { return v.Impersonation }).(pulumi.BoolOutput)
}

// The name of the impersonation token.
func (o UserImpersonationTokenOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *UserImpersonationToken) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// True if the token is revoked.
func (o UserImpersonationTokenOutput) Revoked() pulumi.BoolOutput {
	return o.ApplyT(func(v *UserImpersonationToken) pulumi.BoolOutput { return v.Revoked }).(pulumi.BoolOutput)
}

// Array of scopes of the impersonation token. valid values are: `api`, `readUser`, `readApi`, `readRepository`, `writeRepository`, `readRegistry`, `writeRegistry`, `readVirtualRegistry`, `writeVirtualRegistry`, `sudo`, `adminMode`, `createRunner`, `manageRunner`, `aiFeatures`, `k8sProxy`, `selfRotate`, `readServicePing`
func (o UserImpersonationTokenOutput) Scopes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *UserImpersonationToken) pulumi.StringArrayOutput { return v.Scopes }).(pulumi.StringArrayOutput)
}

// The token of the user impersonation token. **Note**: the token is not available for imported resources.
func (o UserImpersonationTokenOutput) Token() pulumi.StringOutput {
	return o.ApplyT(func(v *UserImpersonationToken) pulumi.StringOutput { return v.Token }).(pulumi.StringOutput)
}

// ID of the impersonation token.
func (o UserImpersonationTokenOutput) TokenId() pulumi.IntOutput {
	return o.ApplyT(func(v *UserImpersonationToken) pulumi.IntOutput { return v.TokenId }).(pulumi.IntOutput)
}

// The ID of the user.
func (o UserImpersonationTokenOutput) UserId() pulumi.IntOutput {
	return o.ApplyT(func(v *UserImpersonationToken) pulumi.IntOutput { return v.UserId }).(pulumi.IntOutput)
}

// Wether to validate if the expiration date is in the future.
func (o UserImpersonationTokenOutput) ValidatePastExpirationDate() pulumi.BoolOutput {
	return o.ApplyT(func(v *UserImpersonationToken) pulumi.BoolOutput { return v.ValidatePastExpirationDate }).(pulumi.BoolOutput)
}

type UserImpersonationTokenArrayOutput struct{ *pulumi.OutputState }

func (UserImpersonationTokenArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*UserImpersonationToken)(nil)).Elem()
}

func (o UserImpersonationTokenArrayOutput) ToUserImpersonationTokenArrayOutput() UserImpersonationTokenArrayOutput {
	return o
}

func (o UserImpersonationTokenArrayOutput) ToUserImpersonationTokenArrayOutputWithContext(ctx context.Context) UserImpersonationTokenArrayOutput {
	return o
}

func (o UserImpersonationTokenArrayOutput) Index(i pulumi.IntInput) UserImpersonationTokenOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *UserImpersonationToken {
		return vs[0].([]*UserImpersonationToken)[vs[1].(int)]
	}).(UserImpersonationTokenOutput)
}

type UserImpersonationTokenMapOutput struct{ *pulumi.OutputState }

func (UserImpersonationTokenMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*UserImpersonationToken)(nil)).Elem()
}

func (o UserImpersonationTokenMapOutput) ToUserImpersonationTokenMapOutput() UserImpersonationTokenMapOutput {
	return o
}

func (o UserImpersonationTokenMapOutput) ToUserImpersonationTokenMapOutputWithContext(ctx context.Context) UserImpersonationTokenMapOutput {
	return o
}

func (o UserImpersonationTokenMapOutput) MapIndex(k pulumi.StringInput) UserImpersonationTokenOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *UserImpersonationToken {
		return vs[0].(map[string]*UserImpersonationToken)[vs[1].(string)]
	}).(UserImpersonationTokenOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*UserImpersonationTokenInput)(nil)).Elem(), &UserImpersonationToken{})
	pulumi.RegisterInputType(reflect.TypeOf((*UserImpersonationTokenArrayInput)(nil)).Elem(), UserImpersonationTokenArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UserImpersonationTokenMapInput)(nil)).Elem(), UserImpersonationTokenMap{})
	pulumi.RegisterOutputType(UserImpersonationTokenOutput{})
	pulumi.RegisterOutputType(UserImpersonationTokenArrayOutput{})
	pulumi.RegisterOutputType(UserImpersonationTokenMapOutput{})
}
