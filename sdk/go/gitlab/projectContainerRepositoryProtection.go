// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package gitlab

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-gitlab/sdk/v9/go/gitlab/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// The `ProjectContainerRepositoryProtection` resource allows managing the lifecycle of a container repository protection rule.
//
// You can use a wildcard (*) to protect multiple container repositories with the same container protection rule.
// You can apply several protection rules to the same container repository. A container repository is protected if at least one protection rule matches.
//
// **Upstream API**: [GitLab API docs](https://docs.gitlab.com/api/container_repository_protection_rules/)
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-gitlab/sdk/v9/go/gitlab"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := gitlab.NewProjectContainerRepositoryProtection(ctx, "this", &gitlab.ProjectContainerRepositoryProtectionArgs{
//				Project:                     pulumi.String("123"),
//				RepositoryPathPattern:       pulumi.String("my_namespace/project*"),
//				MinimumAccessLevelForPush:   pulumi.String("owner"),
//				MinimumAccessLevelForDelete: pulumi.String("admin"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Starting in Terraform v1.5.0, you can use an import block to import `gitlab_project_container_repository_protection`. For example:
//
// terraform
//
// import {
//
//	to = gitlab_project_container_repository_protection.example
//
//	id = "see CLI command below for ID"
//
// }
//
// Importing using the CLI is supported with the following syntax:
//
// GitLab project container repository protection rules can be imported using an id made up of `<project_id>:<protection_rule_id>`, e.g.
//
// ```sh
// $ pulumi import gitlab:index/projectContainerRepositoryProtection:ProjectContainerRepositoryProtection this 123:321
// ```
type ProjectContainerRepositoryProtection struct {
	pulumi.CustomResourceState

	// Minimum GitLab access level required to delete container images in the container registry. For example maintainer, owner, admin. Must be provided when `minimumAccessLevelForPush` is not set.
	MinimumAccessLevelForDelete pulumi.StringPtrOutput `pulumi:"minimumAccessLevelForDelete"`
	// Minimum GitLab access level required to push container images to the container registry. For example maintainer, owner or admin. Must be provided when `minimumAccessLevelForDelete` is not set.
	MinimumAccessLevelForPush pulumi.StringPtrOutput `pulumi:"minimumAccessLevelForPush"`
	// ID or URL-encoded path of the project.
	Project pulumi.StringOutput `pulumi:"project"`
	// Unique ID of the protection rule.
	ProtectionRuleId pulumi.IntOutput `pulumi:"protectionRuleId"`
	// Container repository path pattern protected by the protection rule. Wildcard character * allowed. Repository path pattern should start with the project's full path
	RepositoryPathPattern pulumi.StringOutput `pulumi:"repositoryPathPattern"`
}

// NewProjectContainerRepositoryProtection registers a new resource with the given unique name, arguments, and options.
func NewProjectContainerRepositoryProtection(ctx *pulumi.Context,
	name string, args *ProjectContainerRepositoryProtectionArgs, opts ...pulumi.ResourceOption) (*ProjectContainerRepositoryProtection, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Project == nil {
		return nil, errors.New("invalid value for required argument 'Project'")
	}
	if args.RepositoryPathPattern == nil {
		return nil, errors.New("invalid value for required argument 'RepositoryPathPattern'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ProjectContainerRepositoryProtection
	err := ctx.RegisterResource("gitlab:index/projectContainerRepositoryProtection:ProjectContainerRepositoryProtection", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetProjectContainerRepositoryProtection gets an existing ProjectContainerRepositoryProtection resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetProjectContainerRepositoryProtection(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ProjectContainerRepositoryProtectionState, opts ...pulumi.ResourceOption) (*ProjectContainerRepositoryProtection, error) {
	var resource ProjectContainerRepositoryProtection
	err := ctx.ReadResource("gitlab:index/projectContainerRepositoryProtection:ProjectContainerRepositoryProtection", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ProjectContainerRepositoryProtection resources.
type projectContainerRepositoryProtectionState struct {
	// Minimum GitLab access level required to delete container images in the container registry. For example maintainer, owner, admin. Must be provided when `minimumAccessLevelForPush` is not set.
	MinimumAccessLevelForDelete *string `pulumi:"minimumAccessLevelForDelete"`
	// Minimum GitLab access level required to push container images to the container registry. For example maintainer, owner or admin. Must be provided when `minimumAccessLevelForDelete` is not set.
	MinimumAccessLevelForPush *string `pulumi:"minimumAccessLevelForPush"`
	// ID or URL-encoded path of the project.
	Project *string `pulumi:"project"`
	// Unique ID of the protection rule.
	ProtectionRuleId *int `pulumi:"protectionRuleId"`
	// Container repository path pattern protected by the protection rule. Wildcard character * allowed. Repository path pattern should start with the project's full path
	RepositoryPathPattern *string `pulumi:"repositoryPathPattern"`
}

type ProjectContainerRepositoryProtectionState struct {
	// Minimum GitLab access level required to delete container images in the container registry. For example maintainer, owner, admin. Must be provided when `minimumAccessLevelForPush` is not set.
	MinimumAccessLevelForDelete pulumi.StringPtrInput
	// Minimum GitLab access level required to push container images to the container registry. For example maintainer, owner or admin. Must be provided when `minimumAccessLevelForDelete` is not set.
	MinimumAccessLevelForPush pulumi.StringPtrInput
	// ID or URL-encoded path of the project.
	Project pulumi.StringPtrInput
	// Unique ID of the protection rule.
	ProtectionRuleId pulumi.IntPtrInput
	// Container repository path pattern protected by the protection rule. Wildcard character * allowed. Repository path pattern should start with the project's full path
	RepositoryPathPattern pulumi.StringPtrInput
}

func (ProjectContainerRepositoryProtectionState) ElementType() reflect.Type {
	return reflect.TypeOf((*projectContainerRepositoryProtectionState)(nil)).Elem()
}

type projectContainerRepositoryProtectionArgs struct {
	// Minimum GitLab access level required to delete container images in the container registry. For example maintainer, owner, admin. Must be provided when `minimumAccessLevelForPush` is not set.
	MinimumAccessLevelForDelete *string `pulumi:"minimumAccessLevelForDelete"`
	// Minimum GitLab access level required to push container images to the container registry. For example maintainer, owner or admin. Must be provided when `minimumAccessLevelForDelete` is not set.
	MinimumAccessLevelForPush *string `pulumi:"minimumAccessLevelForPush"`
	// ID or URL-encoded path of the project.
	Project string `pulumi:"project"`
	// Container repository path pattern protected by the protection rule. Wildcard character * allowed. Repository path pattern should start with the project's full path
	RepositoryPathPattern string `pulumi:"repositoryPathPattern"`
}

// The set of arguments for constructing a ProjectContainerRepositoryProtection resource.
type ProjectContainerRepositoryProtectionArgs struct {
	// Minimum GitLab access level required to delete container images in the container registry. For example maintainer, owner, admin. Must be provided when `minimumAccessLevelForPush` is not set.
	MinimumAccessLevelForDelete pulumi.StringPtrInput
	// Minimum GitLab access level required to push container images to the container registry. For example maintainer, owner or admin. Must be provided when `minimumAccessLevelForDelete` is not set.
	MinimumAccessLevelForPush pulumi.StringPtrInput
	// ID or URL-encoded path of the project.
	Project pulumi.StringInput
	// Container repository path pattern protected by the protection rule. Wildcard character * allowed. Repository path pattern should start with the project's full path
	RepositoryPathPattern pulumi.StringInput
}

func (ProjectContainerRepositoryProtectionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*projectContainerRepositoryProtectionArgs)(nil)).Elem()
}

type ProjectContainerRepositoryProtectionInput interface {
	pulumi.Input

	ToProjectContainerRepositoryProtectionOutput() ProjectContainerRepositoryProtectionOutput
	ToProjectContainerRepositoryProtectionOutputWithContext(ctx context.Context) ProjectContainerRepositoryProtectionOutput
}

func (*ProjectContainerRepositoryProtection) ElementType() reflect.Type {
	return reflect.TypeOf((**ProjectContainerRepositoryProtection)(nil)).Elem()
}

func (i *ProjectContainerRepositoryProtection) ToProjectContainerRepositoryProtectionOutput() ProjectContainerRepositoryProtectionOutput {
	return i.ToProjectContainerRepositoryProtectionOutputWithContext(context.Background())
}

func (i *ProjectContainerRepositoryProtection) ToProjectContainerRepositoryProtectionOutputWithContext(ctx context.Context) ProjectContainerRepositoryProtectionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectContainerRepositoryProtectionOutput)
}

// ProjectContainerRepositoryProtectionArrayInput is an input type that accepts ProjectContainerRepositoryProtectionArray and ProjectContainerRepositoryProtectionArrayOutput values.
// You can construct a concrete instance of `ProjectContainerRepositoryProtectionArrayInput` via:
//
//	ProjectContainerRepositoryProtectionArray{ ProjectContainerRepositoryProtectionArgs{...} }
type ProjectContainerRepositoryProtectionArrayInput interface {
	pulumi.Input

	ToProjectContainerRepositoryProtectionArrayOutput() ProjectContainerRepositoryProtectionArrayOutput
	ToProjectContainerRepositoryProtectionArrayOutputWithContext(context.Context) ProjectContainerRepositoryProtectionArrayOutput
}

type ProjectContainerRepositoryProtectionArray []ProjectContainerRepositoryProtectionInput

func (ProjectContainerRepositoryProtectionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ProjectContainerRepositoryProtection)(nil)).Elem()
}

func (i ProjectContainerRepositoryProtectionArray) ToProjectContainerRepositoryProtectionArrayOutput() ProjectContainerRepositoryProtectionArrayOutput {
	return i.ToProjectContainerRepositoryProtectionArrayOutputWithContext(context.Background())
}

func (i ProjectContainerRepositoryProtectionArray) ToProjectContainerRepositoryProtectionArrayOutputWithContext(ctx context.Context) ProjectContainerRepositoryProtectionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectContainerRepositoryProtectionArrayOutput)
}

// ProjectContainerRepositoryProtectionMapInput is an input type that accepts ProjectContainerRepositoryProtectionMap and ProjectContainerRepositoryProtectionMapOutput values.
// You can construct a concrete instance of `ProjectContainerRepositoryProtectionMapInput` via:
//
//	ProjectContainerRepositoryProtectionMap{ "key": ProjectContainerRepositoryProtectionArgs{...} }
type ProjectContainerRepositoryProtectionMapInput interface {
	pulumi.Input

	ToProjectContainerRepositoryProtectionMapOutput() ProjectContainerRepositoryProtectionMapOutput
	ToProjectContainerRepositoryProtectionMapOutputWithContext(context.Context) ProjectContainerRepositoryProtectionMapOutput
}

type ProjectContainerRepositoryProtectionMap map[string]ProjectContainerRepositoryProtectionInput

func (ProjectContainerRepositoryProtectionMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ProjectContainerRepositoryProtection)(nil)).Elem()
}

func (i ProjectContainerRepositoryProtectionMap) ToProjectContainerRepositoryProtectionMapOutput() ProjectContainerRepositoryProtectionMapOutput {
	return i.ToProjectContainerRepositoryProtectionMapOutputWithContext(context.Background())
}

func (i ProjectContainerRepositoryProtectionMap) ToProjectContainerRepositoryProtectionMapOutputWithContext(ctx context.Context) ProjectContainerRepositoryProtectionMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectContainerRepositoryProtectionMapOutput)
}

type ProjectContainerRepositoryProtectionOutput struct{ *pulumi.OutputState }

func (ProjectContainerRepositoryProtectionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ProjectContainerRepositoryProtection)(nil)).Elem()
}

func (o ProjectContainerRepositoryProtectionOutput) ToProjectContainerRepositoryProtectionOutput() ProjectContainerRepositoryProtectionOutput {
	return o
}

func (o ProjectContainerRepositoryProtectionOutput) ToProjectContainerRepositoryProtectionOutputWithContext(ctx context.Context) ProjectContainerRepositoryProtectionOutput {
	return o
}

// Minimum GitLab access level required to delete container images in the container registry. For example maintainer, owner, admin. Must be provided when `minimumAccessLevelForPush` is not set.
func (o ProjectContainerRepositoryProtectionOutput) MinimumAccessLevelForDelete() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ProjectContainerRepositoryProtection) pulumi.StringPtrOutput {
		return v.MinimumAccessLevelForDelete
	}).(pulumi.StringPtrOutput)
}

// Minimum GitLab access level required to push container images to the container registry. For example maintainer, owner or admin. Must be provided when `minimumAccessLevelForDelete` is not set.
func (o ProjectContainerRepositoryProtectionOutput) MinimumAccessLevelForPush() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ProjectContainerRepositoryProtection) pulumi.StringPtrOutput {
		return v.MinimumAccessLevelForPush
	}).(pulumi.StringPtrOutput)
}

// ID or URL-encoded path of the project.
func (o ProjectContainerRepositoryProtectionOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *ProjectContainerRepositoryProtection) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

// Unique ID of the protection rule.
func (o ProjectContainerRepositoryProtectionOutput) ProtectionRuleId() pulumi.IntOutput {
	return o.ApplyT(func(v *ProjectContainerRepositoryProtection) pulumi.IntOutput { return v.ProtectionRuleId }).(pulumi.IntOutput)
}

// Container repository path pattern protected by the protection rule. Wildcard character * allowed. Repository path pattern should start with the project's full path
func (o ProjectContainerRepositoryProtectionOutput) RepositoryPathPattern() pulumi.StringOutput {
	return o.ApplyT(func(v *ProjectContainerRepositoryProtection) pulumi.StringOutput { return v.RepositoryPathPattern }).(pulumi.StringOutput)
}

type ProjectContainerRepositoryProtectionArrayOutput struct{ *pulumi.OutputState }

func (ProjectContainerRepositoryProtectionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ProjectContainerRepositoryProtection)(nil)).Elem()
}

func (o ProjectContainerRepositoryProtectionArrayOutput) ToProjectContainerRepositoryProtectionArrayOutput() ProjectContainerRepositoryProtectionArrayOutput {
	return o
}

func (o ProjectContainerRepositoryProtectionArrayOutput) ToProjectContainerRepositoryProtectionArrayOutputWithContext(ctx context.Context) ProjectContainerRepositoryProtectionArrayOutput {
	return o
}

func (o ProjectContainerRepositoryProtectionArrayOutput) Index(i pulumi.IntInput) ProjectContainerRepositoryProtectionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ProjectContainerRepositoryProtection {
		return vs[0].([]*ProjectContainerRepositoryProtection)[vs[1].(int)]
	}).(ProjectContainerRepositoryProtectionOutput)
}

type ProjectContainerRepositoryProtectionMapOutput struct{ *pulumi.OutputState }

func (ProjectContainerRepositoryProtectionMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ProjectContainerRepositoryProtection)(nil)).Elem()
}

func (o ProjectContainerRepositoryProtectionMapOutput) ToProjectContainerRepositoryProtectionMapOutput() ProjectContainerRepositoryProtectionMapOutput {
	return o
}

func (o ProjectContainerRepositoryProtectionMapOutput) ToProjectContainerRepositoryProtectionMapOutputWithContext(ctx context.Context) ProjectContainerRepositoryProtectionMapOutput {
	return o
}

func (o ProjectContainerRepositoryProtectionMapOutput) MapIndex(k pulumi.StringInput) ProjectContainerRepositoryProtectionOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ProjectContainerRepositoryProtection {
		return vs[0].(map[string]*ProjectContainerRepositoryProtection)[vs[1].(string)]
	}).(ProjectContainerRepositoryProtectionOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ProjectContainerRepositoryProtectionInput)(nil)).Elem(), &ProjectContainerRepositoryProtection{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProjectContainerRepositoryProtectionArrayInput)(nil)).Elem(), ProjectContainerRepositoryProtectionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProjectContainerRepositoryProtectionMapInput)(nil)).Elem(), ProjectContainerRepositoryProtectionMap{})
	pulumi.RegisterOutputType(ProjectContainerRepositoryProtectionOutput{})
	pulumi.RegisterOutputType(ProjectContainerRepositoryProtectionArrayOutput{})
	pulumi.RegisterOutputType(ProjectContainerRepositoryProtectionMapOutput{})
}
