// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gitlab;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.gitlab.ProjectArgs;
import com.pulumi.gitlab.Utilities;
import com.pulumi.gitlab.inputs.ProjectState;
import com.pulumi.gitlab.outputs.ProjectContainerExpirationPolicy;
import com.pulumi.gitlab.outputs.ProjectPushRules;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * ## Example Usage
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.gitlab.Project;
 * import com.pulumi.gitlab.ProjectArgs;
 * import com.pulumi.gitlab.inputs.ProjectPushRulesArgs;
 * import com.pulumi.gitlab.GitlabFunctions;
 * import com.pulumi.gitlab.inputs.GetUserArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new Project(&#34;example&#34;, ProjectArgs.builder()        
 *             .description(&#34;My awesome codebase&#34;)
 *             .visibilityLevel(&#34;public&#34;)
 *             .build());
 * 
 *         // Project with custom push rules
 *         var example_two = new Project(&#34;example-two&#34;, ProjectArgs.builder()        
 *             .pushRules(ProjectPushRulesArgs.builder()
 *                 .authorEmailRegex(&#34;@example\\.com$&#34;)
 *                 .commitCommitterCheck(true)
 *                 .memberCheck(true)
 *                 .preventSecrets(true)
 *                 .build())
 *             .build());
 * 
 *         final var peterParker = GitlabFunctions.getUser(GetUserArgs.builder()
 *             .username(&#34;peter_parker&#34;)
 *             .build());
 * 
 *         var petersRepo = new Project(&#34;petersRepo&#34;, ProjectArgs.builder()        
 *             .description(&#34;This is a description&#34;)
 *             .namespaceId(peterParker.applyValue(getUserResult -&gt; getUserResult.namespaceId()))
 *             .build());
 * 
 *         // Fork a project
 *         var forkProject = new Project(&#34;forkProject&#34;, ProjectArgs.builder()        
 *             .description(&#34;This is a fork&#34;)
 *             .forkedFromProjectId(example.id())
 *             .build());
 * 
 *         // Fork a project and setup a pull mirror
 *         var forkIndex_projectProject = new Project(&#34;forkIndex/projectProject&#34;, ProjectArgs.builder()        
 *             .description(&#34;This is a fork&#34;)
 *             .forkedFromProjectId(example.id())
 *             .importUrl(example.httpUrlToRepo())
 *             .mirror(true)
 *             .build());
 * 
 *         // Create a project by importing it from a public project
 *         var importPublic = new Project(&#34;importPublic&#34;, ProjectArgs.builder()        
 *             .importUrl(&#34;https://gitlab.example.com/repo.git&#34;)
 *             .build());
 * 
 *         // Create a project by importing it from a public project and setup the pull mirror
 *         var importPublicWithMirror = new Project(&#34;importPublicWithMirror&#34;, ProjectArgs.builder()        
 *             .importUrl(&#34;https://gitlab.example.com/repo.git&#34;)
 *             .mirror(true)
 *             .build());
 * 
 *         // Create a project by importing it from a private project
 *         var importPrivateProject = new Project(&#34;importPrivateProject&#34;, ProjectArgs.builder()        
 *             .importUrl(&#34;https://gitlab.example.com/repo.git&#34;)
 *             .importUrlUsername(&#34;user&#34;)
 *             .importUrlPassword(&#34;pass&#34;)
 *             .build());
 * 
 *         // Create a project by importing it from a private project and setup the pull mirror
 *         var importPrivateWithMirror = new Project(&#34;importPrivateWithMirror&#34;, ProjectArgs.builder()        
 *             .importUrl(&#34;https://gitlab.example.com/repo.git&#34;)
 *             .importUrlUsername(&#34;user&#34;)
 *             .importUrlPassword(&#34;pass&#34;)
 *             .mirror(true)
 *             .build());
 * 
 *         // Create a project by importing it from a private project and provide credentials in `import_url`
 *         // NOTE: only use this if you really must, use `import_url_username` and `import_url_password` whenever possible
 *         //       GitLab API will always return the `import_url` without credentials, therefore you must ignore the `import_url` for changes:
 *         var importPrivateIndex_projectProject = new Project(&#34;importPrivateIndex/projectProject&#34;, ProjectArgs.builder()        
 *             .importUrl(&#34;https://user:pass@gitlab.example.com/repo.git&#34;)
 *             .build());
 * 
 *     }
 * }
 * ```
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ## Import
 * 
 * ```sh
 * $ pulumi import gitlab:index/project:Project You can import a project state using `&lt;resource&gt; &lt;id&gt;`. The
 * ```
 * 
 * `id` can be whatever the [get single project api][get_single_project] takes for
 * 
 * its `:id` value, so for example:
 * 
 * ```sh
 * $ pulumi import gitlab:index/project:Project example richardc/example
 * ```
 * 
 * NOTE: the `import_url_username` and `import_url_password` cannot be imported.
 * 
 */
@ResourceType(type="gitlab:index/project:Project")
public class Project extends com.pulumi.resources.CustomResource {
    /**
     * Set to true if you want to treat skipped pipelines as if they finished with success.
     * 
     */
    @Export(name="allowMergeOnSkippedPipeline", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> allowMergeOnSkippedPipeline;

    /**
     * @return Set to true if you want to treat skipped pipelines as if they finished with success.
     * 
     */
    public Output<Boolean> allowMergeOnSkippedPipeline() {
        return this.allowMergeOnSkippedPipeline;
    }
    /**
     * Set the analytics access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    @Export(name="analyticsAccessLevel", refs={String.class}, tree="[0]")
    private Output<String> analyticsAccessLevel;

    /**
     * @return Set the analytics access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    public Output<String> analyticsAccessLevel() {
        return this.analyticsAccessLevel;
    }
    /**
     * Number of merge request approvals required for merging. Default is 0.
     * This field **does not** work well in combination with the `gitlab.ProjectApprovalRule` resource
     * and is most likely gonna be deprecated in a future GitLab version (see [this upstream epic](https://gitlab.com/groups/gitlab-org/-/epics/7572)).
     * In the meantime we recommend against using this attribute and use `gitlab.ProjectApprovalRule` instead.
     * 
     */
    @Export(name="approvalsBeforeMerge", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> approvalsBeforeMerge;

    /**
     * @return Number of merge request approvals required for merging. Default is 0.
     * This field **does not** work well in combination with the `gitlab.ProjectApprovalRule` resource
     * and is most likely gonna be deprecated in a future GitLab version (see [this upstream epic](https://gitlab.com/groups/gitlab-org/-/epics/7572)).
     * In the meantime we recommend against using this attribute and use `gitlab.ProjectApprovalRule` instead.
     * 
     */
    public Output<Optional<Integer>> approvalsBeforeMerge() {
        return Codegen.optional(this.approvalsBeforeMerge);
    }
    /**
     * Set to `true` to archive the project instead of deleting on destroy. If set to `true` it will entire omit the `DELETE` operation.
     * 
     */
    @Export(name="archiveOnDestroy", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> archiveOnDestroy;

    /**
     * @return Set to `true` to archive the project instead of deleting on destroy. If set to `true` it will entire omit the `DELETE` operation.
     * 
     */
    public Output<Optional<Boolean>> archiveOnDestroy() {
        return Codegen.optional(this.archiveOnDestroy);
    }
    /**
     * Whether the project is in read-only mode (archived). Repositories can be archived/unarchived by toggling this parameter.
     * 
     */
    @Export(name="archived", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> archived;

    /**
     * @return Whether the project is in read-only mode (archived). Repositories can be archived/unarchived by toggling this parameter.
     * 
     */
    public Output<Optional<Boolean>> archived() {
        return Codegen.optional(this.archived);
    }
    /**
     * Auto-cancel pending pipelines. This isn’t a boolean, but enabled/disabled.
     * 
     */
    @Export(name="autoCancelPendingPipelines", refs={String.class}, tree="[0]")
    private Output<String> autoCancelPendingPipelines;

    /**
     * @return Auto-cancel pending pipelines. This isn’t a boolean, but enabled/disabled.
     * 
     */
    public Output<String> autoCancelPendingPipelines() {
        return this.autoCancelPendingPipelines;
    }
    /**
     * Auto Deploy strategy. Valid values are `continuous`, `manual`, `timed_incremental`.
     * 
     */
    @Export(name="autoDevopsDeployStrategy", refs={String.class}, tree="[0]")
    private Output<String> autoDevopsDeployStrategy;

    /**
     * @return Auto Deploy strategy. Valid values are `continuous`, `manual`, `timed_incremental`.
     * 
     */
    public Output<String> autoDevopsDeployStrategy() {
        return this.autoDevopsDeployStrategy;
    }
    /**
     * Enable Auto DevOps for this project.
     * 
     */
    @Export(name="autoDevopsEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> autoDevopsEnabled;

    /**
     * @return Enable Auto DevOps for this project.
     * 
     */
    public Output<Boolean> autoDevopsEnabled() {
        return this.autoDevopsEnabled;
    }
    /**
     * Set whether auto-closing referenced issues on default branch.
     * 
     */
    @Export(name="autocloseReferencedIssues", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> autocloseReferencedIssues;

    /**
     * @return Set whether auto-closing referenced issues on default branch.
     * 
     */
    public Output<Boolean> autocloseReferencedIssues() {
        return this.autocloseReferencedIssues;
    }
    /**
     * A local path to the avatar image to upload. **Note**: not available for imported resources.
     * 
     */
    @Export(name="avatar", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> avatar;

    /**
     * @return A local path to the avatar image to upload. **Note**: not available for imported resources.
     * 
     */
    public Output<Optional<String>> avatar() {
        return Codegen.optional(this.avatar);
    }
    /**
     * The hash of the avatar image. Use `filesha256(&#34;path/to/avatar.png&#34;)` whenever possible. **Note**: this is used to trigger an update of the avatar. If it&#39;s not given, but an avatar is given, the avatar will be updated each time.
     * 
     */
    @Export(name="avatarHash", refs={String.class}, tree="[0]")
    private Output<String> avatarHash;

    /**
     * @return The hash of the avatar image. Use `filesha256(&#34;path/to/avatar.png&#34;)` whenever possible. **Note**: this is used to trigger an update of the avatar. If it&#39;s not given, but an avatar is given, the avatar will be updated each time.
     * 
     */
    public Output<String> avatarHash() {
        return this.avatarHash;
    }
    /**
     * The URL of the avatar image.
     * 
     */
    @Export(name="avatarUrl", refs={String.class}, tree="[0]")
    private Output<String> avatarUrl;

    /**
     * @return The URL of the avatar image.
     * 
     */
    public Output<String> avatarUrl() {
        return this.avatarUrl;
    }
    /**
     * Test coverage parsing for the project. This is deprecated feature in GitLab 15.0.
     * 
     * @deprecated
     * build_coverage_regex is removed in GitLab 15.0.
     * 
     */
    @Deprecated /* build_coverage_regex is removed in GitLab 15.0. */
    @Export(name="buildCoverageRegex", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> buildCoverageRegex;

    /**
     * @return Test coverage parsing for the project. This is deprecated feature in GitLab 15.0.
     * 
     */
    public Output<Optional<String>> buildCoverageRegex() {
        return Codegen.optional(this.buildCoverageRegex);
    }
    /**
     * The Git strategy. Defaults to fetch. Valid values are `clone`, `fetch`.
     * 
     */
    @Export(name="buildGitStrategy", refs={String.class}, tree="[0]")
    private Output<String> buildGitStrategy;

    /**
     * @return The Git strategy. Defaults to fetch. Valid values are `clone`, `fetch`.
     * 
     */
    public Output<String> buildGitStrategy() {
        return this.buildGitStrategy;
    }
    /**
     * The maximum amount of time, in seconds, that a job can run.
     * 
     */
    @Export(name="buildTimeout", refs={Integer.class}, tree="[0]")
    private Output<Integer> buildTimeout;

    /**
     * @return The maximum amount of time, in seconds, that a job can run.
     * 
     */
    public Output<Integer> buildTimeout() {
        return this.buildTimeout;
    }
    /**
     * Set the builds access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    @Export(name="buildsAccessLevel", refs={String.class}, tree="[0]")
    private Output<String> buildsAccessLevel;

    /**
     * @return Set the builds access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    public Output<String> buildsAccessLevel() {
        return this.buildsAccessLevel;
    }
    /**
     * Custom Path to CI config file.
     * 
     */
    @Export(name="ciConfigPath", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ciConfigPath;

    /**
     * @return Custom Path to CI config file.
     * 
     */
    public Output<Optional<String>> ciConfigPath() {
        return Codegen.optional(this.ciConfigPath);
    }
    /**
     * Default number of revisions for shallow cloning.
     * 
     */
    @Export(name="ciDefaultGitDepth", refs={Integer.class}, tree="[0]")
    private Output<Integer> ciDefaultGitDepth;

    /**
     * @return Default number of revisions for shallow cloning.
     * 
     */
    public Output<Integer> ciDefaultGitDepth() {
        return this.ciDefaultGitDepth;
    }
    /**
     * When a new deployment job starts, skip older deployment jobs that are still pending.
     * 
     */
    @Export(name="ciForwardDeploymentEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> ciForwardDeploymentEnabled;

    /**
     * @return When a new deployment job starts, skip older deployment jobs that are still pending.
     * 
     */
    public Output<Boolean> ciForwardDeploymentEnabled() {
        return this.ciForwardDeploymentEnabled;
    }
    /**
     * The role required to cancel a pipeline or job. Introduced in GitLab 16.8. Premium and Ultimate only. Valid values are `developer`, `maintainer`, `no one`
     * 
     */
    @Export(name="ciRestrictPipelineCancellationRole", refs={String.class}, tree="[0]")
    private Output<String> ciRestrictPipelineCancellationRole;

    /**
     * @return The role required to cancel a pipeline or job. Introduced in GitLab 16.8. Premium and Ultimate only. Valid values are `developer`, `maintainer`, `no one`
     * 
     */
    public Output<String> ciRestrictPipelineCancellationRole() {
        return this.ciRestrictPipelineCancellationRole;
    }
    /**
     * Use separate caches for protected branches.
     * 
     */
    @Export(name="ciSeparatedCaches", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> ciSeparatedCaches;

    /**
     * @return Use separate caches for protected branches.
     * 
     */
    public Output<Boolean> ciSeparatedCaches() {
        return this.ciSeparatedCaches;
    }
    /**
     * Set the image cleanup policy for this project. **Note**: this field is sometimes named `container_expiration_policy_attributes` in the GitLab Upstream API.
     * 
     */
    @Export(name="containerExpirationPolicy", refs={ProjectContainerExpirationPolicy.class}, tree="[0]")
    private Output<ProjectContainerExpirationPolicy> containerExpirationPolicy;

    /**
     * @return Set the image cleanup policy for this project. **Note**: this field is sometimes named `container_expiration_policy_attributes` in the GitLab Upstream API.
     * 
     */
    public Output<ProjectContainerExpirationPolicy> containerExpirationPolicy() {
        return this.containerExpirationPolicy;
    }
    /**
     * Set visibility of container registry, for this project. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    @Export(name="containerRegistryAccessLevel", refs={String.class}, tree="[0]")
    private Output<String> containerRegistryAccessLevel;

    /**
     * @return Set visibility of container registry, for this project. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    public Output<String> containerRegistryAccessLevel() {
        return this.containerRegistryAccessLevel;
    }
    /**
     * Enable container registry for the project.
     * 
     * @deprecated
     * Use `container_registry_access_level` instead.
     * 
     */
    @Deprecated /* Use `container_registry_access_level` instead. */
    @Export(name="containerRegistryEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> containerRegistryEnabled;

    /**
     * @return Enable container registry for the project.
     * 
     */
    public Output<Boolean> containerRegistryEnabled() {
        return this.containerRegistryEnabled;
    }
    /**
     * The default branch for the project.
     * 
     */
    @Export(name="defaultBranch", refs={String.class}, tree="[0]")
    private Output<String> defaultBranch;

    /**
     * @return The default branch for the project.
     * 
     */
    public Output<String> defaultBranch() {
        return this.defaultBranch;
    }
    /**
     * A description of the project.
     * 
     */
    @Export(name="description", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> description;

    /**
     * @return A description of the project.
     * 
     */
    public Output<Optional<String>> description() {
        return Codegen.optional(this.description);
    }
    /**
     * Disable email notifications.
     * 
     */
    @Export(name="emailsDisabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> emailsDisabled;

    /**
     * @return Disable email notifications.
     * 
     */
    public Output<Boolean> emailsDisabled() {
        return this.emailsDisabled;
    }
    /**
     * Whether the project is empty.
     * 
     */
    @Export(name="emptyRepo", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> emptyRepo;

    /**
     * @return Whether the project is empty.
     * 
     */
    public Output<Boolean> emptyRepo() {
        return this.emptyRepo;
    }
    /**
     * Set the environments access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    @Export(name="environmentsAccessLevel", refs={String.class}, tree="[0]")
    private Output<String> environmentsAccessLevel;

    /**
     * @return Set the environments access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    public Output<String> environmentsAccessLevel() {
        return this.environmentsAccessLevel;
    }
    /**
     * The classification label for the project.
     * 
     */
    @Export(name="externalAuthorizationClassificationLabel", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> externalAuthorizationClassificationLabel;

    /**
     * @return The classification label for the project.
     * 
     */
    public Output<Optional<String>> externalAuthorizationClassificationLabel() {
        return Codegen.optional(this.externalAuthorizationClassificationLabel);
    }
    /**
     * Set the feature flags access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    @Export(name="featureFlagsAccessLevel", refs={String.class}, tree="[0]")
    private Output<String> featureFlagsAccessLevel;

    /**
     * @return Set the feature flags access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    public Output<String> featureFlagsAccessLevel() {
        return this.featureFlagsAccessLevel;
    }
    /**
     * The id of the project to fork. During create the project is forked and during an update the fork relation is changed.
     * 
     */
    @Export(name="forkedFromProjectId", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> forkedFromProjectId;

    /**
     * @return The id of the project to fork. During create the project is forked and during an update the fork relation is changed.
     * 
     */
    public Output<Optional<Integer>> forkedFromProjectId() {
        return Codegen.optional(this.forkedFromProjectId);
    }
    /**
     * Set the forking access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    @Export(name="forkingAccessLevel", refs={String.class}, tree="[0]")
    private Output<String> forkingAccessLevel;

    /**
     * @return Set the forking access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    public Output<String> forkingAccessLevel() {
        return this.forkingAccessLevel;
    }
    /**
     * Enable group runners for this project.
     * 
     */
    @Export(name="groupRunnersEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> groupRunnersEnabled;

    /**
     * @return Enable group runners for this project.
     * 
     */
    public Output<Boolean> groupRunnersEnabled() {
        return this.groupRunnersEnabled;
    }
    /**
     * For group-level custom templates, specifies ID of group from which all the custom project templates are sourced. Leave empty for instance-level templates. Requires use*custom*template to be true (enterprise edition).
     * 
     */
    @Export(name="groupWithProjectTemplatesId", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> groupWithProjectTemplatesId;

    /**
     * @return For group-level custom templates, specifies ID of group from which all the custom project templates are sourced. Leave empty for instance-level templates. Requires use*custom*template to be true (enterprise edition).
     * 
     */
    public Output<Optional<Integer>> groupWithProjectTemplatesId() {
        return Codegen.optional(this.groupWithProjectTemplatesId);
    }
    /**
     * URL that can be provided to `git clone` to clone the
     * 
     */
    @Export(name="httpUrlToRepo", refs={String.class}, tree="[0]")
    private Output<String> httpUrlToRepo;

    /**
     * @return URL that can be provided to `git clone` to clone the
     * 
     */
    public Output<String> httpUrlToRepo() {
        return this.httpUrlToRepo;
    }
    /**
     * Git URL to a repository to be imported. Together with `mirror = true` it will setup a Pull Mirror. This can also be used together with `forked_from_project_id` to setup a Pull Mirror for a fork. The fork takes precedence over the import. Make sure to provide the credentials in `import_url_username` and `import_url_password`. GitLab never returns the credentials, thus the provider cannot detect configuration drift in the credentials. They can also not be imported using `pulumi import`. See the examples section for how to properly use it.
     * 
     */
    @Export(name="importUrl", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> importUrl;

    /**
     * @return Git URL to a repository to be imported. Together with `mirror = true` it will setup a Pull Mirror. This can also be used together with `forked_from_project_id` to setup a Pull Mirror for a fork. The fork takes precedence over the import. Make sure to provide the credentials in `import_url_username` and `import_url_password`. GitLab never returns the credentials, thus the provider cannot detect configuration drift in the credentials. They can also not be imported using `pulumi import`. See the examples section for how to properly use it.
     * 
     */
    public Output<Optional<String>> importUrl() {
        return Codegen.optional(this.importUrl);
    }
    /**
     * The password for the `import_url`. The value of this field is used to construct a valid `import_url` and is only related to the provider. This field cannot be imported using `pulumi import`. See the examples section for how to properly use it.
     * 
     */
    @Export(name="importUrlPassword", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> importUrlPassword;

    /**
     * @return The password for the `import_url`. The value of this field is used to construct a valid `import_url` and is only related to the provider. This field cannot be imported using `pulumi import`. See the examples section for how to properly use it.
     * 
     */
    public Output<Optional<String>> importUrlPassword() {
        return Codegen.optional(this.importUrlPassword);
    }
    /**
     * The username for the `import_url`. The value of this field is used to construct a valid `import_url` and is only related to the provider. This field cannot be imported using `pulumi import`.  See the examples section for how to properly use it.
     * 
     */
    @Export(name="importUrlUsername", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> importUrlUsername;

    /**
     * @return The username for the `import_url`. The value of this field is used to construct a valid `import_url` and is only related to the provider. This field cannot be imported using `pulumi import`.  See the examples section for how to properly use it.
     * 
     */
    public Output<Optional<String>> importUrlUsername() {
        return Codegen.optional(this.importUrlUsername);
    }
    /**
     * Set the infrastructure access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    @Export(name="infrastructureAccessLevel", refs={String.class}, tree="[0]")
    private Output<String> infrastructureAccessLevel;

    /**
     * @return Set the infrastructure access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    public Output<String> infrastructureAccessLevel() {
        return this.infrastructureAccessLevel;
    }
    /**
     * Create main branch with first commit containing a README.md file.
     * 
     */
    @Export(name="initializeWithReadme", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> initializeWithReadme;

    /**
     * @return Create main branch with first commit containing a README.md file.
     * 
     */
    public Output<Optional<Boolean>> initializeWithReadme() {
        return Codegen.optional(this.initializeWithReadme);
    }
    /**
     * Set the issues access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    @Export(name="issuesAccessLevel", refs={String.class}, tree="[0]")
    private Output<String> issuesAccessLevel;

    /**
     * @return Set the issues access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    public Output<String> issuesAccessLevel() {
        return this.issuesAccessLevel;
    }
    /**
     * Enable issue tracking for the project.
     * 
     */
    @Export(name="issuesEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> issuesEnabled;

    /**
     * @return Enable issue tracking for the project.
     * 
     */
    public Output<Boolean> issuesEnabled() {
        return this.issuesEnabled;
    }
    /**
     * Sets the template for new issues in the project.
     * 
     */
    @Export(name="issuesTemplate", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> issuesTemplate;

    /**
     * @return Sets the template for new issues in the project.
     * 
     */
    public Output<Optional<String>> issuesTemplate() {
        return Codegen.optional(this.issuesTemplate);
    }
    /**
     * Disable or enable the ability to keep the latest artifact for this project.
     * 
     */
    @Export(name="keepLatestArtifact", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> keepLatestArtifact;

    /**
     * @return Disable or enable the ability to keep the latest artifact for this project.
     * 
     */
    public Output<Boolean> keepLatestArtifact() {
        return this.keepLatestArtifact;
    }
    /**
     * Enable LFS for the project.
     * 
     */
    @Export(name="lfsEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> lfsEnabled;

    /**
     * @return Enable LFS for the project.
     * 
     */
    public Output<Boolean> lfsEnabled() {
        return this.lfsEnabled;
    }
    /**
     * Template used to create merge commit message in merge requests. (Introduced in GitLab 14.5.)
     * 
     */
    @Export(name="mergeCommitTemplate", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> mergeCommitTemplate;

    /**
     * @return Template used to create merge commit message in merge requests. (Introduced in GitLab 14.5.)
     * 
     */
    public Output<Optional<String>> mergeCommitTemplate() {
        return Codegen.optional(this.mergeCommitTemplate);
    }
    /**
     * Set the merge method. Valid values are `merge`, `rebase_merge`, `ff`.
     * 
     */
    @Export(name="mergeMethod", refs={String.class}, tree="[0]")
    private Output<String> mergeMethod;

    /**
     * @return Set the merge method. Valid values are `merge`, `rebase_merge`, `ff`.
     * 
     */
    public Output<String> mergeMethod() {
        return this.mergeMethod;
    }
    /**
     * Enable or disable merge pipelines.
     * 
     */
    @Export(name="mergePipelinesEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> mergePipelinesEnabled;

    /**
     * @return Enable or disable merge pipelines.
     * 
     */
    public Output<Boolean> mergePipelinesEnabled() {
        return this.mergePipelinesEnabled;
    }
    /**
     * Set the merge requests access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    @Export(name="mergeRequestsAccessLevel", refs={String.class}, tree="[0]")
    private Output<String> mergeRequestsAccessLevel;

    /**
     * @return Set the merge requests access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    public Output<String> mergeRequestsAccessLevel() {
        return this.mergeRequestsAccessLevel;
    }
    /**
     * Enable merge requests for the project.
     * 
     */
    @Export(name="mergeRequestsEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> mergeRequestsEnabled;

    /**
     * @return Enable merge requests for the project.
     * 
     */
    public Output<Boolean> mergeRequestsEnabled() {
        return this.mergeRequestsEnabled;
    }
    /**
     * Sets the template for new merge requests in the project.
     * 
     */
    @Export(name="mergeRequestsTemplate", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> mergeRequestsTemplate;

    /**
     * @return Sets the template for new merge requests in the project.
     * 
     */
    public Output<Optional<String>> mergeRequestsTemplate() {
        return Codegen.optional(this.mergeRequestsTemplate);
    }
    /**
     * Enable or disable merge trains. Requires `merge_pipelines_enabled` to be set to `true` to take effect.
     * 
     */
    @Export(name="mergeTrainsEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> mergeTrainsEnabled;

    /**
     * @return Enable or disable merge trains. Requires `merge_pipelines_enabled` to be set to `true` to take effect.
     * 
     */
    public Output<Boolean> mergeTrainsEnabled() {
        return this.mergeTrainsEnabled;
    }
    /**
     * Enable project pull mirror.
     * 
     */
    @Export(name="mirror", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> mirror;

    /**
     * @return Enable project pull mirror.
     * 
     */
    public Output<Optional<Boolean>> mirror() {
        return Codegen.optional(this.mirror);
    }
    /**
     * Enable overwrite diverged branches for a mirrored project.
     * 
     */
    @Export(name="mirrorOverwritesDivergedBranches", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> mirrorOverwritesDivergedBranches;

    /**
     * @return Enable overwrite diverged branches for a mirrored project.
     * 
     */
    public Output<Boolean> mirrorOverwritesDivergedBranches() {
        return this.mirrorOverwritesDivergedBranches;
    }
    /**
     * Enable trigger builds on pushes for a mirrored project.
     * 
     */
    @Export(name="mirrorTriggerBuilds", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> mirrorTriggerBuilds;

    /**
     * @return Enable trigger builds on pushes for a mirrored project.
     * 
     */
    public Output<Boolean> mirrorTriggerBuilds() {
        return this.mirrorTriggerBuilds;
    }
    /**
     * Set the monitor access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    @Export(name="monitorAccessLevel", refs={String.class}, tree="[0]")
    private Output<String> monitorAccessLevel;

    /**
     * @return Set the monitor access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    public Output<String> monitorAccessLevel() {
        return this.monitorAccessLevel;
    }
    /**
     * For forked projects, target merge requests to this project. If false, the target will be the upstream project.
     * 
     */
    @Export(name="mrDefaultTargetSelf", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> mrDefaultTargetSelf;

    /**
     * @return For forked projects, target merge requests to this project. If false, the target will be the upstream project.
     * 
     */
    public Output<Optional<Boolean>> mrDefaultTargetSelf() {
        return Codegen.optional(this.mrDefaultTargetSelf);
    }
    /**
     * The name of the project.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The name of the project.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * The namespace (group or user) of the project. Defaults to your user.
     * 
     */
    @Export(name="namespaceId", refs={Integer.class}, tree="[0]")
    private Output<Integer> namespaceId;

    /**
     * @return The namespace (group or user) of the project. Defaults to your user.
     * 
     */
    public Output<Integer> namespaceId() {
        return this.namespaceId;
    }
    /**
     * Set to true if you want allow merges only if all discussions are resolved.
     * 
     */
    @Export(name="onlyAllowMergeIfAllDiscussionsAreResolved", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> onlyAllowMergeIfAllDiscussionsAreResolved;

    /**
     * @return Set to true if you want allow merges only if all discussions are resolved.
     * 
     */
    public Output<Boolean> onlyAllowMergeIfAllDiscussionsAreResolved() {
        return this.onlyAllowMergeIfAllDiscussionsAreResolved;
    }
    /**
     * Set to true if you want allow merges only if a pipeline succeeds.
     * 
     */
    @Export(name="onlyAllowMergeIfPipelineSucceeds", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> onlyAllowMergeIfPipelineSucceeds;

    /**
     * @return Set to true if you want allow merges only if a pipeline succeeds.
     * 
     */
    public Output<Boolean> onlyAllowMergeIfPipelineSucceeds() {
        return this.onlyAllowMergeIfPipelineSucceeds;
    }
    /**
     * Enable only mirror protected branches for a mirrored project.
     * 
     */
    @Export(name="onlyMirrorProtectedBranches", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> onlyMirrorProtectedBranches;

    /**
     * @return Enable only mirror protected branches for a mirrored project.
     * 
     */
    public Output<Boolean> onlyMirrorProtectedBranches() {
        return this.onlyMirrorProtectedBranches;
    }
    /**
     * Enable packages repository for the project.
     * 
     */
    @Export(name="packagesEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> packagesEnabled;

    /**
     * @return Enable packages repository for the project.
     * 
     */
    public Output<Boolean> packagesEnabled() {
        return this.packagesEnabled;
    }
    /**
     * Enable pages access control. Valid values are `public`, `private`, `enabled`, `disabled`.
     * 
     */
    @Export(name="pagesAccessLevel", refs={String.class}, tree="[0]")
    private Output<String> pagesAccessLevel;

    /**
     * @return Enable pages access control. Valid values are `public`, `private`, `enabled`, `disabled`.
     * 
     */
    public Output<String> pagesAccessLevel() {
        return this.pagesAccessLevel;
    }
    /**
     * The path of the repository.
     * 
     */
    @Export(name="path", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> path;

    /**
     * @return The path of the repository.
     * 
     */
    public Output<Optional<String>> path() {
        return Codegen.optional(this.path);
    }
    /**
     * The path of the repository with namespace.
     * 
     */
    @Export(name="pathWithNamespace", refs={String.class}, tree="[0]")
    private Output<String> pathWithNamespace;

    /**
     * @return The path of the repository with namespace.
     * 
     */
    public Output<String> pathWithNamespace() {
        return this.pathWithNamespace;
    }
    /**
     * Enable pipelines for the project. The `pipelines_enabled` field is being sent as `jobs_enabled` in the GitLab API calls.
     * 
     * @deprecated
     * Deprecated in favor of `builds_access_level`
     * 
     */
    @Deprecated /* Deprecated in favor of `builds_access_level` */
    @Export(name="pipelinesEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> pipelinesEnabled;

    /**
     * @return Enable pipelines for the project. The `pipelines_enabled` field is being sent as `jobs_enabled` in the GitLab API calls.
     * 
     */
    public Output<Boolean> pipelinesEnabled() {
        return this.pipelinesEnabled;
    }
    /**
     * Show link to create/view merge request when pushing from the command line
     * 
     */
    @Export(name="printingMergeRequestLinkEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> printingMergeRequestLinkEnabled;

    /**
     * @return Show link to create/view merge request when pushing from the command line
     * 
     */
    public Output<Boolean> printingMergeRequestLinkEnabled() {
        return this.printingMergeRequestLinkEnabled;
    }
    /**
     * If true, jobs can be viewed by non-project members.
     * 
     * @deprecated
     * The `public_builds` attribute has been deprecated in favor of `public_jobs` and will be removed in the next major version of the provider.
     * 
     */
    @Deprecated /* The `public_builds` attribute has been deprecated in favor of `public_jobs` and will be removed in the next major version of the provider. */
    @Export(name="publicBuilds", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> publicBuilds;

    /**
     * @return If true, jobs can be viewed by non-project members.
     * 
     */
    public Output<Boolean> publicBuilds() {
        return this.publicBuilds;
    }
    /**
     * If true, jobs can be viewed by non-project members.
     * 
     */
    @Export(name="publicJobs", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> publicJobs;

    /**
     * @return If true, jobs can be viewed by non-project members.
     * 
     */
    public Output<Boolean> publicJobs() {
        return this.publicJobs;
    }
    /**
     * Push rules for the project.
     * 
     */
    @Export(name="pushRules", refs={ProjectPushRules.class}, tree="[0]")
    private Output<ProjectPushRules> pushRules;

    /**
     * @return Push rules for the project.
     * 
     */
    public Output<ProjectPushRules> pushRules() {
        return this.pushRules;
    }
    /**
     * Set the releases access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    @Export(name="releasesAccessLevel", refs={String.class}, tree="[0]")
    private Output<String> releasesAccessLevel;

    /**
     * @return Set the releases access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    public Output<String> releasesAccessLevel() {
        return this.releasesAccessLevel;
    }
    /**
     * Enable `Delete source branch` option by default for all new merge requests.
     * 
     */
    @Export(name="removeSourceBranchAfterMerge", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> removeSourceBranchAfterMerge;

    /**
     * @return Enable `Delete source branch` option by default for all new merge requests.
     * 
     */
    public Output<Boolean> removeSourceBranchAfterMerge() {
        return this.removeSourceBranchAfterMerge;
    }
    /**
     * Set the repository access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    @Export(name="repositoryAccessLevel", refs={String.class}, tree="[0]")
    private Output<String> repositoryAccessLevel;

    /**
     * @return Set the repository access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    public Output<String> repositoryAccessLevel() {
        return this.repositoryAccessLevel;
    }
    /**
     * Which storage shard the repository is on. (administrator only)
     * 
     */
    @Export(name="repositoryStorage", refs={String.class}, tree="[0]")
    private Output<String> repositoryStorage;

    /**
     * @return Which storage shard the repository is on. (administrator only)
     * 
     */
    public Output<String> repositoryStorage() {
        return this.repositoryStorage;
    }
    /**
     * Allow users to request member access.
     * 
     */
    @Export(name="requestAccessEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> requestAccessEnabled;

    /**
     * @return Allow users to request member access.
     * 
     */
    public Output<Boolean> requestAccessEnabled() {
        return this.requestAccessEnabled;
    }
    /**
     * Set the requirements access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    @Export(name="requirementsAccessLevel", refs={String.class}, tree="[0]")
    private Output<String> requirementsAccessLevel;

    /**
     * @return Set the requirements access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    public Output<String> requirementsAccessLevel() {
        return this.requirementsAccessLevel;
    }
    /**
     * Automatically resolve merge request diffs discussions on lines changed with a push.
     * 
     */
    @Export(name="resolveOutdatedDiffDiscussions", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> resolveOutdatedDiffDiscussions;

    /**
     * @return Automatically resolve merge request diffs discussions on lines changed with a push.
     * 
     */
    public Output<Optional<Boolean>> resolveOutdatedDiffDiscussions() {
        return Codegen.optional(this.resolveOutdatedDiffDiscussions);
    }
    /**
     * Allow only users with the Maintainer role to pass user-defined variables when triggering a pipeline.
     * 
     */
    @Export(name="restrictUserDefinedVariables", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> restrictUserDefinedVariables;

    /**
     * @return Allow only users with the Maintainer role to pass user-defined variables when triggering a pipeline.
     * 
     */
    public Output<Optional<Boolean>> restrictUserDefinedVariables() {
        return Codegen.optional(this.restrictUserDefinedVariables);
    }
    /**
     * Registration token to use during runner setup.
     * 
     */
    @Export(name="runnersToken", refs={String.class}, tree="[0]")
    private Output<String> runnersToken;

    /**
     * @return Registration token to use during runner setup.
     * 
     */
    public Output<String> runnersToken() {
        return this.runnersToken;
    }
    /**
     * Set the security and compliance access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    @Export(name="securityAndComplianceAccessLevel", refs={String.class}, tree="[0]")
    private Output<String> securityAndComplianceAccessLevel;

    /**
     * @return Set the security and compliance access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    public Output<String> securityAndComplianceAccessLevel() {
        return this.securityAndComplianceAccessLevel;
    }
    /**
     * Enable shared runners for this project.
     * 
     */
    @Export(name="sharedRunnersEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> sharedRunnersEnabled;

    /**
     * @return Enable shared runners for this project.
     * 
     */
    public Output<Boolean> sharedRunnersEnabled() {
        return this.sharedRunnersEnabled;
    }
    /**
     * If `true`, the default behavior to wait for the default branch protection to be created is skipped.
     * This is necessary if the current user is not an admin and the default branch protection is disabled on an instance-level.
     * There is currently no known way to determine if the default branch protection is disabled on an instance-level for non-admin users.
     * This attribute is only used during resource creation, thus changes are suppressed and the attribute cannot be imported.
     * 
     */
    @Export(name="skipWaitForDefaultBranchProtection", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> skipWaitForDefaultBranchProtection;

    /**
     * @return If `true`, the default behavior to wait for the default branch protection to be created is skipped.
     * This is necessary if the current user is not an admin and the default branch protection is disabled on an instance-level.
     * There is currently no known way to determine if the default branch protection is disabled on an instance-level for non-admin users.
     * This attribute is only used during resource creation, thus changes are suppressed and the attribute cannot be imported.
     * 
     */
    public Output<Optional<Boolean>> skipWaitForDefaultBranchProtection() {
        return Codegen.optional(this.skipWaitForDefaultBranchProtection);
    }
    /**
     * Set the snippets access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    @Export(name="snippetsAccessLevel", refs={String.class}, tree="[0]")
    private Output<String> snippetsAccessLevel;

    /**
     * @return Set the snippets access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    public Output<String> snippetsAccessLevel() {
        return this.snippetsAccessLevel;
    }
    /**
     * Enable snippets for the project.
     * 
     */
    @Export(name="snippetsEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> snippetsEnabled;

    /**
     * @return Enable snippets for the project.
     * 
     */
    public Output<Boolean> snippetsEnabled() {
        return this.snippetsEnabled;
    }
    /**
     * Template used to create squash commit message in merge requests. (Introduced in GitLab 14.6.)
     * 
     */
    @Export(name="squashCommitTemplate", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> squashCommitTemplate;

    /**
     * @return Template used to create squash commit message in merge requests. (Introduced in GitLab 14.6.)
     * 
     */
    public Output<Optional<String>> squashCommitTemplate() {
        return Codegen.optional(this.squashCommitTemplate);
    }
    /**
     * Squash commits when merge request. Valid values are `never`, `always`, `default_on`, or `default_off`. The default value is `default_off`. [GitLab &gt;= 14.1]
     * 
     */
    @Export(name="squashOption", refs={String.class}, tree="[0]")
    private Output<String> squashOption;

    /**
     * @return Squash commits when merge request. Valid values are `never`, `always`, `default_on`, or `default_off`. The default value is `default_off`. [GitLab &gt;= 14.1]
     * 
     */
    public Output<String> squashOption() {
        return this.squashOption;
    }
    /**
     * URL that can be provided to `git clone` to clone the
     * 
     */
    @Export(name="sshUrlToRepo", refs={String.class}, tree="[0]")
    private Output<String> sshUrlToRepo;

    /**
     * @return URL that can be provided to `git clone` to clone the
     * 
     */
    public Output<String> sshUrlToRepo() {
        return this.sshUrlToRepo;
    }
    /**
     * The commit message used to apply merge request suggestions.
     * 
     */
    @Export(name="suggestionCommitMessage", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> suggestionCommitMessage;

    /**
     * @return The commit message used to apply merge request suggestions.
     * 
     */
    public Output<Optional<String>> suggestionCommitMessage() {
        return Codegen.optional(this.suggestionCommitMessage);
    }
    /**
     * The list of tags for a project; put array of tags, that should be finally assigned to a project. Use topics instead.
     * 
     */
    @Export(name="tags", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> tags;

    /**
     * @return The list of tags for a project; put array of tags, that should be finally assigned to a project. Use topics instead.
     * 
     */
    public Output<List<String>> tags() {
        return this.tags;
    }
    /**
     * When used without use*custom*template, name of a built-in project template. When used with use*custom*template, name of a custom project template. This option is mutually exclusive with `template_project_id`.
     * 
     */
    @Export(name="templateName", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> templateName;

    /**
     * @return When used without use*custom*template, name of a built-in project template. When used with use*custom*template, name of a custom project template. This option is mutually exclusive with `template_project_id`.
     * 
     */
    public Output<Optional<String>> templateName() {
        return Codegen.optional(this.templateName);
    }
    /**
     * When used with use*custom*template, project ID of a custom project template. This is preferable to using template*name since template*name may be ambiguous (enterprise edition). This option is mutually exclusive with `template_name`. See `gitlab.GroupProjectFileTemplate` to set a project as a template project. If a project has not been set as a template, using it here will result in an error.
     * 
     */
    @Export(name="templateProjectId", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> templateProjectId;

    /**
     * @return When used with use*custom*template, project ID of a custom project template. This is preferable to using template*name since template*name may be ambiguous (enterprise edition). This option is mutually exclusive with `template_name`. See `gitlab.GroupProjectFileTemplate` to set a project as a template project. If a project has not been set as a template, using it here will result in an error.
     * 
     */
    public Output<Optional<Integer>> templateProjectId() {
        return Codegen.optional(this.templateProjectId);
    }
    /**
     * The list of topics for the project.
     * 
     */
    @Export(name="topics", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> topics;

    /**
     * @return The list of topics for the project.
     * 
     */
    public Output<List<String>> topics() {
        return this.topics;
    }
    /**
     * Use either custom instance or group (with group*with*project*templates*id) project template (enterprise edition).
     * 	&gt; When using a custom template, [Group Tokens won&#39;t work](https://docs.gitlab.com/15.7/ee/user/project/settings/import_export_troubleshooting.html#import-using-the-rest-api-fails-when-using-a-group-access-token). You must use a real user&#39;s Personal Access Token.
     * 
     */
    @Export(name="useCustomTemplate", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> useCustomTemplate;

    /**
     * @return Use either custom instance or group (with group*with*project*templates*id) project template (enterprise edition).
     * 	&gt; When using a custom template, [Group Tokens won&#39;t work](https://docs.gitlab.com/15.7/ee/user/project/settings/import_export_troubleshooting.html#import-using-the-rest-api-fails-when-using-a-group-access-token). You must use a real user&#39;s Personal Access Token.
     * 
     */
    public Output<Optional<Boolean>> useCustomTemplate() {
        return Codegen.optional(this.useCustomTemplate);
    }
    /**
     * Set to `public` to create a public project. Valid values are `private`, `internal`, `public`.
     * 
     */
    @Export(name="visibilityLevel", refs={String.class}, tree="[0]")
    private Output<String> visibilityLevel;

    /**
     * @return Set to `public` to create a public project. Valid values are `private`, `internal`, `public`.
     * 
     */
    public Output<String> visibilityLevel() {
        return this.visibilityLevel;
    }
    /**
     * URL that can be used to find the project in a browser.
     * 
     */
    @Export(name="webUrl", refs={String.class}, tree="[0]")
    private Output<String> webUrl;

    /**
     * @return URL that can be used to find the project in a browser.
     * 
     */
    public Output<String> webUrl() {
        return this.webUrl;
    }
    /**
     * Set the wiki access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    @Export(name="wikiAccessLevel", refs={String.class}, tree="[0]")
    private Output<String> wikiAccessLevel;

    /**
     * @return Set the wiki access level. Valid values are `disabled`, `private`, `enabled`.
     * 
     */
    public Output<String> wikiAccessLevel() {
        return this.wikiAccessLevel;
    }
    /**
     * Enable wiki for the project.
     * 
     */
    @Export(name="wikiEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> wikiEnabled;

    /**
     * @return Enable wiki for the project.
     * 
     */
    public Output<Boolean> wikiEnabled() {
        return this.wikiEnabled;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Project(String name) {
        this(name, ProjectArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Project(String name, @Nullable ProjectArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Project(String name, @Nullable ProjectArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gitlab:index/project:Project", name, args == null ? ProjectArgs.Empty : args, makeResourceOptions(options, Codegen.empty()));
    }

    private Project(String name, Output<String> id, @Nullable ProjectState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("gitlab:index/project:Project", name, state, makeResourceOptions(options, id));
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .additionalSecretOutputs(List.of(
                "importUrlPassword",
                "runnersToken"
            ))
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Project get(String name, Output<String> id, @Nullable ProjectState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Project(name, id, state, options);
    }
}
