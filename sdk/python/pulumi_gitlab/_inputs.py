# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'ApplicationSettingsDefaultBranchProtectionDefaultsArgs',
    'ApplicationSettingsDefaultBranchProtectionDefaultsArgsDict',
    'BranchCommitArgs',
    'BranchCommitArgsDict',
    'BranchProtectionAllowedToMergeArgs',
    'BranchProtectionAllowedToMergeArgsDict',
    'BranchProtectionAllowedToPushArgs',
    'BranchProtectionAllowedToPushArgsDict',
    'BranchProtectionAllowedToUnprotectArgs',
    'BranchProtectionAllowedToUnprotectArgsDict',
    'GroupAccessTokenRotationConfigurationArgs',
    'GroupAccessTokenRotationConfigurationArgsDict',
    'GroupDefaultBranchProtectionDefaultsArgs',
    'GroupDefaultBranchProtectionDefaultsArgsDict',
    'GroupEpicBoardListArgs',
    'GroupEpicBoardListArgsDict',
    'GroupHookCustomHeaderArgs',
    'GroupHookCustomHeaderArgsDict',
    'GroupIssueBoardListArgs',
    'GroupIssueBoardListArgsDict',
    'GroupProtectedEnvironmentApprovalRuleArgs',
    'GroupProtectedEnvironmentApprovalRuleArgsDict',
    'GroupProtectedEnvironmentDeployAccessLevelArgs',
    'GroupProtectedEnvironmentDeployAccessLevelArgsDict',
    'GroupPushRulesArgs',
    'GroupPushRulesArgsDict',
    'GroupServiceAccountAccessTokenRotationConfigurationArgs',
    'GroupServiceAccountAccessTokenRotationConfigurationArgsDict',
    'InstanceServiceAccountTimeoutsArgs',
    'InstanceServiceAccountTimeoutsArgsDict',
    'PersonalAccessTokenRotationConfigurationArgs',
    'PersonalAccessTokenRotationConfigurationArgsDict',
    'ProjectAccessTokenRotationConfigurationArgs',
    'ProjectAccessTokenRotationConfigurationArgsDict',
    'ProjectContainerExpirationPolicyArgs',
    'ProjectContainerExpirationPolicyArgsDict',
    'ProjectHookCustomHeaderArgs',
    'ProjectHookCustomHeaderArgsDict',
    'ProjectIssueBoardListArgs',
    'ProjectIssueBoardListArgsDict',
    'ProjectIssueTaskCompletionStatusArgs',
    'ProjectIssueTaskCompletionStatusArgsDict',
    'ProjectProtectedEnvironmentApprovalRuleArgs',
    'ProjectProtectedEnvironmentApprovalRuleArgsDict',
    'ProjectProtectedEnvironmentDeployAccessLevelArgs',
    'ProjectProtectedEnvironmentDeployAccessLevelArgsDict',
    'ProjectPushRulesArgs',
    'ProjectPushRulesArgsDict',
    'ProjectTagCommitArgs',
    'ProjectTagCommitArgsDict',
    'ProjectTagReleaseArgs',
    'ProjectTagReleaseArgsDict',
    'ReleaseAssetsArgs',
    'ReleaseAssetsArgsDict',
    'ReleaseAuthorArgs',
    'ReleaseAuthorArgsDict',
    'ReleaseCommitArgs',
    'ReleaseCommitArgsDict',
    'ReleaseLinksArgs',
    'ReleaseLinksArgsDict',
    'TagProtectionAllowedToCreateArgs',
    'TagProtectionAllowedToCreateArgsDict',
    'ValueStreamAnalyticsStageArgs',
    'ValueStreamAnalyticsStageArgsDict',
    'GetGroupProvisionedUsersProvisionedUserArgs',
    'GetGroupProvisionedUsersProvisionedUserArgsDict',
    'GetProjectProtectedBranchMergeAccessLevelArgs',
    'GetProjectProtectedBranchMergeAccessLevelArgsDict',
    'GetProjectProtectedBranchPushAccessLevelArgs',
    'GetProjectProtectedBranchPushAccessLevelArgsDict',
    'GetProjectProtectedBranchesProtectedBranchArgs',
    'GetProjectProtectedBranchesProtectedBranchArgsDict',
    'GetProjectProtectedBranchesProtectedBranchMergeAccessLevelArgs',
    'GetProjectProtectedBranchesProtectedBranchMergeAccessLevelArgsDict',
    'GetProjectProtectedBranchesProtectedBranchPushAccessLevelArgs',
    'GetProjectProtectedBranchesProtectedBranchPushAccessLevelArgsDict',
    'GetReleaseAssetsArgs',
    'GetReleaseAssetsArgsDict',
    'GetReleaseAssetsLinkArgs',
    'GetReleaseAssetsLinkArgsDict',
    'GetReleaseAssetsSourceArgs',
    'GetReleaseAssetsSourceArgsDict',
]

MYPY = False

if not MYPY:
    class ApplicationSettingsDefaultBranchProtectionDefaultsArgsDict(TypedDict):
        allow_force_push: NotRequired[pulumi.Input[bool]]
        """
        Allow force push for all users with push access.
        """
        allowed_to_merges: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        An array of access levels allowed to merge. Supports Developer (30) or Maintainer (40).
        """
        allowed_to_pushes: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        An array of access levels allowed to push. Supports Developer (30) or Maintainer (40).
        """
        developer_can_initial_push: NotRequired[pulumi.Input[bool]]
        """
        Allow developers to initial push.
        """
elif False:
    ApplicationSettingsDefaultBranchProtectionDefaultsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationSettingsDefaultBranchProtectionDefaultsArgs:
    def __init__(__self__, *,
                 allow_force_push: Optional[pulumi.Input[bool]] = None,
                 allowed_to_merges: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 allowed_to_pushes: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 developer_can_initial_push: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] allow_force_push: Allow force push for all users with push access.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] allowed_to_merges: An array of access levels allowed to merge. Supports Developer (30) or Maintainer (40).
        :param pulumi.Input[Sequence[pulumi.Input[int]]] allowed_to_pushes: An array of access levels allowed to push. Supports Developer (30) or Maintainer (40).
        :param pulumi.Input[bool] developer_can_initial_push: Allow developers to initial push.
        """
        if allow_force_push is not None:
            pulumi.set(__self__, "allow_force_push", allow_force_push)
        if allowed_to_merges is not None:
            pulumi.set(__self__, "allowed_to_merges", allowed_to_merges)
        if allowed_to_pushes is not None:
            pulumi.set(__self__, "allowed_to_pushes", allowed_to_pushes)
        if developer_can_initial_push is not None:
            pulumi.set(__self__, "developer_can_initial_push", developer_can_initial_push)

    @property
    @pulumi.getter(name="allowForcePush")
    def allow_force_push(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow force push for all users with push access.
        """
        return pulumi.get(self, "allow_force_push")

    @allow_force_push.setter
    def allow_force_push(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_force_push", value)

    @property
    @pulumi.getter(name="allowedToMerges")
    def allowed_to_merges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        An array of access levels allowed to merge. Supports Developer (30) or Maintainer (40).
        """
        return pulumi.get(self, "allowed_to_merges")

    @allowed_to_merges.setter
    def allowed_to_merges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "allowed_to_merges", value)

    @property
    @pulumi.getter(name="allowedToPushes")
    def allowed_to_pushes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        An array of access levels allowed to push. Supports Developer (30) or Maintainer (40).
        """
        return pulumi.get(self, "allowed_to_pushes")

    @allowed_to_pushes.setter
    def allowed_to_pushes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "allowed_to_pushes", value)

    @property
    @pulumi.getter(name="developerCanInitialPush")
    def developer_can_initial_push(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow developers to initial push.
        """
        return pulumi.get(self, "developer_can_initial_push")

    @developer_can_initial_push.setter
    def developer_can_initial_push(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "developer_can_initial_push", value)


if not MYPY:
    class BranchCommitArgsDict(TypedDict):
        author_email: NotRequired[pulumi.Input[str]]
        """
        The email of the author.
        """
        author_name: NotRequired[pulumi.Input[str]]
        """
        The name of the author.
        """
        authored_date: NotRequired[pulumi.Input[str]]
        """
        The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
        """
        committed_date: NotRequired[pulumi.Input[str]]
        """
        The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
        """
        committer_email: NotRequired[pulumi.Input[str]]
        """
        The email of the user that committed.
        """
        committer_name: NotRequired[pulumi.Input[str]]
        """
        The name of the user that committed.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The unique id assigned to the commit by Gitlab.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        The commit message
        """
        parent_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The id of the parents of the commit
        """
        short_id: NotRequired[pulumi.Input[str]]
        """
        The short id assigned to the commit by Gitlab.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        The title of the commit
        """
elif False:
    BranchCommitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchCommitArgs:
    def __init__(__self__, *,
                 author_email: Optional[pulumi.Input[str]] = None,
                 author_name: Optional[pulumi.Input[str]] = None,
                 authored_date: Optional[pulumi.Input[str]] = None,
                 committed_date: Optional[pulumi.Input[str]] = None,
                 committer_email: Optional[pulumi.Input[str]] = None,
                 committer_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 parent_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 short_id: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] author_email: The email of the author.
        :param pulumi.Input[str] author_name: The name of the author.
        :param pulumi.Input[str] authored_date: The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
        :param pulumi.Input[str] committed_date: The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
        :param pulumi.Input[str] committer_email: The email of the user that committed.
        :param pulumi.Input[str] committer_name: The name of the user that committed.
        :param pulumi.Input[str] id: The unique id assigned to the commit by Gitlab.
        :param pulumi.Input[str] message: The commit message
        :param pulumi.Input[Sequence[pulumi.Input[str]]] parent_ids: The id of the parents of the commit
        :param pulumi.Input[str] short_id: The short id assigned to the commit by Gitlab.
        :param pulumi.Input[str] title: The title of the commit
        """
        if author_email is not None:
            pulumi.set(__self__, "author_email", author_email)
        if author_name is not None:
            pulumi.set(__self__, "author_name", author_name)
        if authored_date is not None:
            pulumi.set(__self__, "authored_date", authored_date)
        if committed_date is not None:
            pulumi.set(__self__, "committed_date", committed_date)
        if committer_email is not None:
            pulumi.set(__self__, "committer_email", committer_email)
        if committer_name is not None:
            pulumi.set(__self__, "committer_name", committer_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if parent_ids is not None:
            pulumi.set(__self__, "parent_ids", parent_ids)
        if short_id is not None:
            pulumi.set(__self__, "short_id", short_id)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="authorEmail")
    def author_email(self) -> Optional[pulumi.Input[str]]:
        """
        The email of the author.
        """
        return pulumi.get(self, "author_email")

    @author_email.setter
    def author_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "author_email", value)

    @property
    @pulumi.getter(name="authorName")
    def author_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the author.
        """
        return pulumi.get(self, "author_name")

    @author_name.setter
    def author_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "author_name", value)

    @property
    @pulumi.getter(name="authoredDate")
    def authored_date(self) -> Optional[pulumi.Input[str]]:
        """
        The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
        """
        return pulumi.get(self, "authored_date")

    @authored_date.setter
    def authored_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authored_date", value)

    @property
    @pulumi.getter(name="committedDate")
    def committed_date(self) -> Optional[pulumi.Input[str]]:
        """
        The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
        """
        return pulumi.get(self, "committed_date")

    @committed_date.setter
    def committed_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "committed_date", value)

    @property
    @pulumi.getter(name="committerEmail")
    def committer_email(self) -> Optional[pulumi.Input[str]]:
        """
        The email of the user that committed.
        """
        return pulumi.get(self, "committer_email")

    @committer_email.setter
    def committer_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "committer_email", value)

    @property
    @pulumi.getter(name="committerName")
    def committer_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the user that committed.
        """
        return pulumi.get(self, "committer_name")

    @committer_name.setter
    def committer_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "committer_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique id assigned to the commit by Gitlab.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The commit message
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="parentIds")
    def parent_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The id of the parents of the commit
        """
        return pulumi.get(self, "parent_ids")

    @parent_ids.setter
    def parent_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "parent_ids", value)

    @property
    @pulumi.getter(name="shortId")
    def short_id(self) -> Optional[pulumi.Input[str]]:
        """
        The short id assigned to the commit by Gitlab.
        """
        return pulumi.get(self, "short_id")

    @short_id.setter
    def short_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "short_id", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the commit
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class BranchProtectionAllowedToMergeArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[str]]
        """
        Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`.
        """
        access_level_description: NotRequired[pulumi.Input[str]]
        """
        Readable description of access level.
        """
        group_id: NotRequired[pulumi.Input[int]]
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        user_id: NotRequired[pulumi.Input[int]]
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
elif False:
    BranchProtectionAllowedToMergeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchProtectionAllowedToMergeArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[str]] = None,
                 access_level_description: Optional[pulumi.Input[str]] = None,
                 group_id: Optional[pulumi.Input[int]] = None,
                 user_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] access_level: Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`.
        :param pulumi.Input[str] access_level_description: Readable description of access level.
        :param pulumi.Input[int] group_id: The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        :param pulumi.Input[int] user_id: The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_level_description is not None:
            pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[str]]:
        """
        Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[pulumi.Input[str]]:
        """
        Readable description of access level.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level_description", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class BranchProtectionAllowedToPushArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[str]]
        """
        Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`.
        """
        access_level_description: NotRequired[pulumi.Input[str]]
        """
        Readable description of access level.
        """
        deploy_key_id: NotRequired[pulumi.Input[int]]
        """
        The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `group_id` and `user_id`. This field is read-only until Gitlab 17.5.
        """
        group_id: NotRequired[pulumi.Input[int]]
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `user_id`.
        """
        user_id: NotRequired[pulumi.Input[int]]
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `group_id`.
        """
elif False:
    BranchProtectionAllowedToPushArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchProtectionAllowedToPushArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[str]] = None,
                 access_level_description: Optional[pulumi.Input[str]] = None,
                 deploy_key_id: Optional[pulumi.Input[int]] = None,
                 group_id: Optional[pulumi.Input[int]] = None,
                 user_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] access_level: Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`.
        :param pulumi.Input[str] access_level_description: Readable description of access level.
        :param pulumi.Input[int] deploy_key_id: The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `group_id` and `user_id`. This field is read-only until Gitlab 17.5.
        :param pulumi.Input[int] group_id: The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `user_id`.
        :param pulumi.Input[int] user_id: The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `group_id`.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_level_description is not None:
            pulumi.set(__self__, "access_level_description", access_level_description)
        if deploy_key_id is not None:
            pulumi.set(__self__, "deploy_key_id", deploy_key_id)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[str]]:
        """
        Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[pulumi.Input[str]]:
        """
        Readable description of access level.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level_description", value)

    @property
    @pulumi.getter(name="deployKeyId")
    def deploy_key_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `group_id` and `user_id`. This field is read-only until Gitlab 17.5.
        """
        return pulumi.get(self, "deploy_key_id")

    @deploy_key_id.setter
    def deploy_key_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "deploy_key_id", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class BranchProtectionAllowedToUnprotectArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[str]]
        """
        Access levels allowed to unprotect push to protected branch. Valid values are: `developer`, `maintainer`, `admin`.
        """
        access_level_description: NotRequired[pulumi.Input[str]]
        """
        Readable description of access level.
        """
        group_id: NotRequired[pulumi.Input[int]]
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        user_id: NotRequired[pulumi.Input[int]]
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
elif False:
    BranchProtectionAllowedToUnprotectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchProtectionAllowedToUnprotectArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[str]] = None,
                 access_level_description: Optional[pulumi.Input[str]] = None,
                 group_id: Optional[pulumi.Input[int]] = None,
                 user_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] access_level: Access levels allowed to unprotect push to protected branch. Valid values are: `developer`, `maintainer`, `admin`.
        :param pulumi.Input[str] access_level_description: Readable description of access level.
        :param pulumi.Input[int] group_id: The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        :param pulumi.Input[int] user_id: The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_level_description is not None:
            pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[str]]:
        """
        Access levels allowed to unprotect push to protected branch. Valid values are: `developer`, `maintainer`, `admin`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[pulumi.Input[str]]:
        """
        Readable description of access level.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level_description", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class GroupAccessTokenRotationConfigurationArgsDict(TypedDict):
        expiration_days: pulumi.Input[int]
        """
        The duration (in days) the new token should be valid for.
        """
        rotate_before_days: pulumi.Input[int]
        """
        The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
elif False:
    GroupAccessTokenRotationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupAccessTokenRotationConfigurationArgs:
    def __init__(__self__, *,
                 expiration_days: pulumi.Input[int],
                 rotate_before_days: pulumi.Input[int]):
        """
        :param pulumi.Input[int] expiration_days: The duration (in days) the new token should be valid for.
        :param pulumi.Input[int] rotate_before_days: The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
        pulumi.set(__self__, "expiration_days", expiration_days)
        pulumi.set(__self__, "rotate_before_days", rotate_before_days)

    @property
    @pulumi.getter(name="expirationDays")
    def expiration_days(self) -> pulumi.Input[int]:
        """
        The duration (in days) the new token should be valid for.
        """
        return pulumi.get(self, "expiration_days")

    @expiration_days.setter
    def expiration_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "expiration_days", value)

    @property
    @pulumi.getter(name="rotateBeforeDays")
    def rotate_before_days(self) -> pulumi.Input[int]:
        """
        The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
        return pulumi.get(self, "rotate_before_days")

    @rotate_before_days.setter
    def rotate_before_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "rotate_before_days", value)


if not MYPY:
    class GroupDefaultBranchProtectionDefaultsArgsDict(TypedDict):
        allow_force_push: NotRequired[pulumi.Input[bool]]
        """
        Allow force push for all users with push access.
        """
        allowed_to_merges: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of access levels allowed to merge. Valid values are: `developer`, `maintainer`, `no one`.
        """
        allowed_to_pushes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of access levels allowed to push. Valid values are: `developer`, `maintainer`, `no one`.
        """
        developer_can_initial_push: NotRequired[pulumi.Input[bool]]
        """
        Allow developers to initial push.
        """
elif False:
    GroupDefaultBranchProtectionDefaultsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupDefaultBranchProtectionDefaultsArgs:
    def __init__(__self__, *,
                 allow_force_push: Optional[pulumi.Input[bool]] = None,
                 allowed_to_merges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_to_pushes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 developer_can_initial_push: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] allow_force_push: Allow force push for all users with push access.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_to_merges: An array of access levels allowed to merge. Valid values are: `developer`, `maintainer`, `no one`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_to_pushes: An array of access levels allowed to push. Valid values are: `developer`, `maintainer`, `no one`.
        :param pulumi.Input[bool] developer_can_initial_push: Allow developers to initial push.
        """
        if allow_force_push is not None:
            pulumi.set(__self__, "allow_force_push", allow_force_push)
        if allowed_to_merges is not None:
            pulumi.set(__self__, "allowed_to_merges", allowed_to_merges)
        if allowed_to_pushes is not None:
            pulumi.set(__self__, "allowed_to_pushes", allowed_to_pushes)
        if developer_can_initial_push is not None:
            pulumi.set(__self__, "developer_can_initial_push", developer_can_initial_push)

    @property
    @pulumi.getter(name="allowForcePush")
    def allow_force_push(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow force push for all users with push access.
        """
        return pulumi.get(self, "allow_force_push")

    @allow_force_push.setter
    def allow_force_push(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_force_push", value)

    @property
    @pulumi.getter(name="allowedToMerges")
    def allowed_to_merges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of access levels allowed to merge. Valid values are: `developer`, `maintainer`, `no one`.
        """
        return pulumi.get(self, "allowed_to_merges")

    @allowed_to_merges.setter
    def allowed_to_merges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_to_merges", value)

    @property
    @pulumi.getter(name="allowedToPushes")
    def allowed_to_pushes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of access levels allowed to push. Valid values are: `developer`, `maintainer`, `no one`.
        """
        return pulumi.get(self, "allowed_to_pushes")

    @allowed_to_pushes.setter
    def allowed_to_pushes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_to_pushes", value)

    @property
    @pulumi.getter(name="developerCanInitialPush")
    def developer_can_initial_push(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow developers to initial push.
        """
        return pulumi.get(self, "developer_can_initial_push")

    @developer_can_initial_push.setter
    def developer_can_initial_push(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "developer_can_initial_push", value)


if not MYPY:
    class GroupEpicBoardListArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[int]]
        """
        The ID of the list.
        """
        label_id: NotRequired[pulumi.Input[int]]
        """
        The ID of the label the list should be scoped to.
        """
        position: NotRequired[pulumi.Input[int]]
        """
        The position of the list within the board. The position for the list is sed on the its position in the `lists` array.
        """
elif False:
    GroupEpicBoardListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupEpicBoardListArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[int]] = None,
                 label_id: Optional[pulumi.Input[int]] = None,
                 position: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] id: The ID of the list.
        :param pulumi.Input[int] label_id: The ID of the label the list should be scoped to.
        :param pulumi.Input[int] position: The position of the list within the board. The position for the list is sed on the its position in the `lists` array.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if label_id is not None:
            pulumi.set(__self__, "label_id", label_id)
        if position is not None:
            pulumi.set(__self__, "position", position)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="labelId")
    def label_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the label the list should be scoped to.
        """
        return pulumi.get(self, "label_id")

    @label_id.setter
    def label_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "label_id", value)

    @property
    @pulumi.getter
    def position(self) -> Optional[pulumi.Input[int]]:
        """
        The position of the list within the board. The position for the list is sed on the its position in the `lists` array.
        """
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "position", value)


if not MYPY:
    class GroupHookCustomHeaderArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Key of the custom header.
        """
        value: pulumi.Input[str]
        """
        Value of the custom header. This value cannot be imported.
        """
elif False:
    GroupHookCustomHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupHookCustomHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Key of the custom header.
        :param pulumi.Input[str] value: Value of the custom header. This value cannot be imported.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key of the custom header.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header. This value cannot be imported.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GroupIssueBoardListArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[int]]
        """
        The ID of the list.
        """
        label_id: NotRequired[pulumi.Input[int]]
        """
        The ID of the label the list should be scoped to.
        """
        position: NotRequired[pulumi.Input[int]]
        """
        The explicit position of the list within the board, zero based.
        """
elif False:
    GroupIssueBoardListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupIssueBoardListArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[int]] = None,
                 label_id: Optional[pulumi.Input[int]] = None,
                 position: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] id: The ID of the list.
        :param pulumi.Input[int] label_id: The ID of the label the list should be scoped to.
        :param pulumi.Input[int] position: The explicit position of the list within the board, zero based.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if label_id is not None:
            pulumi.set(__self__, "label_id", label_id)
        if position is not None:
            pulumi.set(__self__, "position", position)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="labelId")
    def label_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the label the list should be scoped to.
        """
        return pulumi.get(self, "label_id")

    @label_id.setter
    def label_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "label_id", value)

    @property
    @pulumi.getter
    def position(self) -> Optional[pulumi.Input[int]]:
        """
        The explicit position of the list within the board, zero based.
        """
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "position", value)


if not MYPY:
    class GroupProtectedEnvironmentApprovalRuleArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[str]]
        """
        Levels of access allowed to approve a deployment to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        """
        access_level_description: NotRequired[pulumi.Input[str]]
        """
        Readable description of level of access.
        """
        group_id: NotRequired[pulumi.Input[int]]
        """
        The ID of the group allowed to approve a deployment to this protected environment. TThe group must be a sub-group under the given group. Mutually exclusive with `access_level` and `user_id`.
        """
        group_inheritance_type: NotRequired[pulumi.Input[int]]
        """
        Group inheritance allows access rules to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        """
        id: NotRequired[pulumi.Input[int]]
        """
        The unique ID of the Approval Rules object.
        """
        required_approvals: NotRequired[pulumi.Input[int]]
        """
        The number of approval required to allow deployment to this protected environment. This is mutually exclusive with user_id.
        """
        user_id: NotRequired[pulumi.Input[int]]
        """
        The ID of the user allowed to approve a deployment to this protected environment. The user must be a member of the group with Maintainer role or higher. Mutually exclusive with `access_level` and `group_id`.
        """
elif False:
    GroupProtectedEnvironmentApprovalRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupProtectedEnvironmentApprovalRuleArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[str]] = None,
                 access_level_description: Optional[pulumi.Input[str]] = None,
                 group_id: Optional[pulumi.Input[int]] = None,
                 group_inheritance_type: Optional[pulumi.Input[int]] = None,
                 id: Optional[pulumi.Input[int]] = None,
                 required_approvals: Optional[pulumi.Input[int]] = None,
                 user_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] access_level: Levels of access allowed to approve a deployment to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        :param pulumi.Input[str] access_level_description: Readable description of level of access.
        :param pulumi.Input[int] group_id: The ID of the group allowed to approve a deployment to this protected environment. TThe group must be a sub-group under the given group. Mutually exclusive with `access_level` and `user_id`.
        :param pulumi.Input[int] group_inheritance_type: Group inheritance allows access rules to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        :param pulumi.Input[int] id: The unique ID of the Approval Rules object.
        :param pulumi.Input[int] required_approvals: The number of approval required to allow deployment to this protected environment. This is mutually exclusive with user_id.
        :param pulumi.Input[int] user_id: The ID of the user allowed to approve a deployment to this protected environment. The user must be a member of the group with Maintainer role or higher. Mutually exclusive with `access_level` and `group_id`.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_level_description is not None:
            pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if group_inheritance_type is not None:
            pulumi.set(__self__, "group_inheritance_type", group_inheritance_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if required_approvals is not None:
            pulumi.set(__self__, "required_approvals", required_approvals)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[str]]:
        """
        Levels of access allowed to approve a deployment to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[pulumi.Input[str]]:
        """
        Readable description of level of access.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level_description", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the group allowed to approve a deployment to this protected environment. TThe group must be a sub-group under the given group. Mutually exclusive with `access_level` and `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="groupInheritanceType")
    def group_inheritance_type(self) -> Optional[pulumi.Input[int]]:
        """
        Group inheritance allows access rules to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        """
        return pulumi.get(self, "group_inheritance_type")

    @group_inheritance_type.setter
    def group_inheritance_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_inheritance_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        The unique ID of the Approval Rules object.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="requiredApprovals")
    def required_approvals(self) -> Optional[pulumi.Input[int]]:
        """
        The number of approval required to allow deployment to this protected environment. This is mutually exclusive with user_id.
        """
        return pulumi.get(self, "required_approvals")

    @required_approvals.setter
    def required_approvals(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "required_approvals", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the user allowed to approve a deployment to this protected environment. The user must be a member of the group with Maintainer role or higher. Mutually exclusive with `access_level` and `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class GroupProtectedEnvironmentDeployAccessLevelArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[str]]
        """
        Levels of access required to deploy to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        """
        access_level_description: NotRequired[pulumi.Input[str]]
        """
        Readable description of level of access.
        """
        group_id: NotRequired[pulumi.Input[int]]
        """
        The ID of the group allowed to deploy to this protected environment. The group must be a sub-group under the given group. Mutually exclusive with `access_level` and `user_id`.
        """
        group_inheritance_type: NotRequired[pulumi.Input[int]]
        """
        Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        """
        id: NotRequired[pulumi.Input[int]]
        """
        The unique ID of the Deploy Access Level object.
        """
        user_id: NotRequired[pulumi.Input[int]]
        """
        The ID of the user allowed to deploy to this protected environment. The user must be a member of the group with Maintainer role or higher. Mutually exclusive with `access_level` and `group_id`.
        """
elif False:
    GroupProtectedEnvironmentDeployAccessLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupProtectedEnvironmentDeployAccessLevelArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[str]] = None,
                 access_level_description: Optional[pulumi.Input[str]] = None,
                 group_id: Optional[pulumi.Input[int]] = None,
                 group_inheritance_type: Optional[pulumi.Input[int]] = None,
                 id: Optional[pulumi.Input[int]] = None,
                 user_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] access_level: Levels of access required to deploy to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        :param pulumi.Input[str] access_level_description: Readable description of level of access.
        :param pulumi.Input[int] group_id: The ID of the group allowed to deploy to this protected environment. The group must be a sub-group under the given group. Mutually exclusive with `access_level` and `user_id`.
        :param pulumi.Input[int] group_inheritance_type: Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        :param pulumi.Input[int] id: The unique ID of the Deploy Access Level object.
        :param pulumi.Input[int] user_id: The ID of the user allowed to deploy to this protected environment. The user must be a member of the group with Maintainer role or higher. Mutually exclusive with `access_level` and `group_id`.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_level_description is not None:
            pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if group_inheritance_type is not None:
            pulumi.set(__self__, "group_inheritance_type", group_inheritance_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[str]]:
        """
        Levels of access required to deploy to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[pulumi.Input[str]]:
        """
        Readable description of level of access.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level_description", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the group allowed to deploy to this protected environment. The group must be a sub-group under the given group. Mutually exclusive with `access_level` and `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="groupInheritanceType")
    def group_inheritance_type(self) -> Optional[pulumi.Input[int]]:
        """
        Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        """
        return pulumi.get(self, "group_inheritance_type")

    @group_inheritance_type.setter
    def group_inheritance_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_inheritance_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        The unique ID of the Deploy Access Level object.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the user allowed to deploy to this protected environment. The user must be a member of the group with Maintainer role or higher. Mutually exclusive with `access_level` and `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class GroupPushRulesArgsDict(TypedDict):
        author_email_regex: NotRequired[pulumi.Input[str]]
        """
        All commit author emails must match this regex, e.g. `@my-company.com$`.
        """
        branch_name_regex: NotRequired[pulumi.Input[str]]
        """
        All branch names must match this regex, e.g. `(feature|hotfix)\\/*`.
        """
        commit_committer_check: NotRequired[pulumi.Input[bool]]
        """
        Only commits pushed using verified emails are allowed.
        """
        commit_committer_name_check: NotRequired[pulumi.Input[bool]]
        """
        Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
        """
        commit_message_negative_regex: NotRequired[pulumi.Input[str]]
        """
        No commit message is allowed to match this regex, for example `ssh\\:\\/\\/`.
        """
        commit_message_regex: NotRequired[pulumi.Input[str]]
        """
        All commit messages must match this regex, e.g. `Fixed \\d+\\..*`.
        """
        deny_delete_tag: NotRequired[pulumi.Input[bool]]
        """
        Deny deleting a tag.
        """
        file_name_regex: NotRequired[pulumi.Input[str]]
        """
        Filenames matching the regular expression provided in this attribute are not allowed, for example, `(jar|exe)$`.
        """
        max_file_size: NotRequired[pulumi.Input[int]]
        """
        Maximum file size (MB) allowed.
        """
        member_check: NotRequired[pulumi.Input[bool]]
        """
        Allows only GitLab users to author commits.
        """
        prevent_secrets: NotRequired[pulumi.Input[bool]]
        """
        GitLab will reject any files that are likely to contain secrets.
        """
        reject_non_dco_commits: NotRequired[pulumi.Input[bool]]
        """
        Reject commit when its not DCO certified.
        """
        reject_unsigned_commits: NotRequired[pulumi.Input[bool]]
        """
        Only commits signed through GPG are allowed.
        """
elif False:
    GroupPushRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPushRulesArgs:
    def __init__(__self__, *,
                 author_email_regex: Optional[pulumi.Input[str]] = None,
                 branch_name_regex: Optional[pulumi.Input[str]] = None,
                 commit_committer_check: Optional[pulumi.Input[bool]] = None,
                 commit_committer_name_check: Optional[pulumi.Input[bool]] = None,
                 commit_message_negative_regex: Optional[pulumi.Input[str]] = None,
                 commit_message_regex: Optional[pulumi.Input[str]] = None,
                 deny_delete_tag: Optional[pulumi.Input[bool]] = None,
                 file_name_regex: Optional[pulumi.Input[str]] = None,
                 max_file_size: Optional[pulumi.Input[int]] = None,
                 member_check: Optional[pulumi.Input[bool]] = None,
                 prevent_secrets: Optional[pulumi.Input[bool]] = None,
                 reject_non_dco_commits: Optional[pulumi.Input[bool]] = None,
                 reject_unsigned_commits: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] author_email_regex: All commit author emails must match this regex, e.g. `@my-company.com$`.
        :param pulumi.Input[str] branch_name_regex: All branch names must match this regex, e.g. `(feature|hotfix)\\/*`.
        :param pulumi.Input[bool] commit_committer_check: Only commits pushed using verified emails are allowed.
        :param pulumi.Input[bool] commit_committer_name_check: Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
        :param pulumi.Input[str] commit_message_negative_regex: No commit message is allowed to match this regex, for example `ssh\\:\\/\\/`.
        :param pulumi.Input[str] commit_message_regex: All commit messages must match this regex, e.g. `Fixed \\d+\\..*`.
        :param pulumi.Input[bool] deny_delete_tag: Deny deleting a tag.
        :param pulumi.Input[str] file_name_regex: Filenames matching the regular expression provided in this attribute are not allowed, for example, `(jar|exe)$`.
        :param pulumi.Input[int] max_file_size: Maximum file size (MB) allowed.
        :param pulumi.Input[bool] member_check: Allows only GitLab users to author commits.
        :param pulumi.Input[bool] prevent_secrets: GitLab will reject any files that are likely to contain secrets.
        :param pulumi.Input[bool] reject_non_dco_commits: Reject commit when its not DCO certified.
        :param pulumi.Input[bool] reject_unsigned_commits: Only commits signed through GPG are allowed.
        """
        if author_email_regex is not None:
            pulumi.set(__self__, "author_email_regex", author_email_regex)
        if branch_name_regex is not None:
            pulumi.set(__self__, "branch_name_regex", branch_name_regex)
        if commit_committer_check is not None:
            pulumi.set(__self__, "commit_committer_check", commit_committer_check)
        if commit_committer_name_check is not None:
            pulumi.set(__self__, "commit_committer_name_check", commit_committer_name_check)
        if commit_message_negative_regex is not None:
            pulumi.set(__self__, "commit_message_negative_regex", commit_message_negative_regex)
        if commit_message_regex is not None:
            pulumi.set(__self__, "commit_message_regex", commit_message_regex)
        if deny_delete_tag is not None:
            pulumi.set(__self__, "deny_delete_tag", deny_delete_tag)
        if file_name_regex is not None:
            pulumi.set(__self__, "file_name_regex", file_name_regex)
        if max_file_size is not None:
            pulumi.set(__self__, "max_file_size", max_file_size)
        if member_check is not None:
            pulumi.set(__self__, "member_check", member_check)
        if prevent_secrets is not None:
            pulumi.set(__self__, "prevent_secrets", prevent_secrets)
        if reject_non_dco_commits is not None:
            pulumi.set(__self__, "reject_non_dco_commits", reject_non_dco_commits)
        if reject_unsigned_commits is not None:
            pulumi.set(__self__, "reject_unsigned_commits", reject_unsigned_commits)

    @property
    @pulumi.getter(name="authorEmailRegex")
    def author_email_regex(self) -> Optional[pulumi.Input[str]]:
        """
        All commit author emails must match this regex, e.g. `@my-company.com$`.
        """
        return pulumi.get(self, "author_email_regex")

    @author_email_regex.setter
    def author_email_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "author_email_regex", value)

    @property
    @pulumi.getter(name="branchNameRegex")
    def branch_name_regex(self) -> Optional[pulumi.Input[str]]:
        """
        All branch names must match this regex, e.g. `(feature|hotfix)\\/*`.
        """
        return pulumi.get(self, "branch_name_regex")

    @branch_name_regex.setter
    def branch_name_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch_name_regex", value)

    @property
    @pulumi.getter(name="commitCommitterCheck")
    def commit_committer_check(self) -> Optional[pulumi.Input[bool]]:
        """
        Only commits pushed using verified emails are allowed.
        """
        return pulumi.get(self, "commit_committer_check")

    @commit_committer_check.setter
    def commit_committer_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "commit_committer_check", value)

    @property
    @pulumi.getter(name="commitCommitterNameCheck")
    def commit_committer_name_check(self) -> Optional[pulumi.Input[bool]]:
        """
        Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
        """
        return pulumi.get(self, "commit_committer_name_check")

    @commit_committer_name_check.setter
    def commit_committer_name_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "commit_committer_name_check", value)

    @property
    @pulumi.getter(name="commitMessageNegativeRegex")
    def commit_message_negative_regex(self) -> Optional[pulumi.Input[str]]:
        """
        No commit message is allowed to match this regex, for example `ssh\\:\\/\\/`.
        """
        return pulumi.get(self, "commit_message_negative_regex")

    @commit_message_negative_regex.setter
    def commit_message_negative_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "commit_message_negative_regex", value)

    @property
    @pulumi.getter(name="commitMessageRegex")
    def commit_message_regex(self) -> Optional[pulumi.Input[str]]:
        """
        All commit messages must match this regex, e.g. `Fixed \\d+\\..*`.
        """
        return pulumi.get(self, "commit_message_regex")

    @commit_message_regex.setter
    def commit_message_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "commit_message_regex", value)

    @property
    @pulumi.getter(name="denyDeleteTag")
    def deny_delete_tag(self) -> Optional[pulumi.Input[bool]]:
        """
        Deny deleting a tag.
        """
        return pulumi.get(self, "deny_delete_tag")

    @deny_delete_tag.setter
    def deny_delete_tag(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deny_delete_tag", value)

    @property
    @pulumi.getter(name="fileNameRegex")
    def file_name_regex(self) -> Optional[pulumi.Input[str]]:
        """
        Filenames matching the regular expression provided in this attribute are not allowed, for example, `(jar|exe)$`.
        """
        return pulumi.get(self, "file_name_regex")

    @file_name_regex.setter
    def file_name_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_name_regex", value)

    @property
    @pulumi.getter(name="maxFileSize")
    def max_file_size(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum file size (MB) allowed.
        """
        return pulumi.get(self, "max_file_size")

    @max_file_size.setter
    def max_file_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_file_size", value)

    @property
    @pulumi.getter(name="memberCheck")
    def member_check(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows only GitLab users to author commits.
        """
        return pulumi.get(self, "member_check")

    @member_check.setter
    def member_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "member_check", value)

    @property
    @pulumi.getter(name="preventSecrets")
    def prevent_secrets(self) -> Optional[pulumi.Input[bool]]:
        """
        GitLab will reject any files that are likely to contain secrets.
        """
        return pulumi.get(self, "prevent_secrets")

    @prevent_secrets.setter
    def prevent_secrets(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "prevent_secrets", value)

    @property
    @pulumi.getter(name="rejectNonDcoCommits")
    def reject_non_dco_commits(self) -> Optional[pulumi.Input[bool]]:
        """
        Reject commit when its not DCO certified.
        """
        return pulumi.get(self, "reject_non_dco_commits")

    @reject_non_dco_commits.setter
    def reject_non_dco_commits(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "reject_non_dco_commits", value)

    @property
    @pulumi.getter(name="rejectUnsignedCommits")
    def reject_unsigned_commits(self) -> Optional[pulumi.Input[bool]]:
        """
        Only commits signed through GPG are allowed.
        """
        return pulumi.get(self, "reject_unsigned_commits")

    @reject_unsigned_commits.setter
    def reject_unsigned_commits(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "reject_unsigned_commits", value)


if not MYPY:
    class GroupServiceAccountAccessTokenRotationConfigurationArgsDict(TypedDict):
        rotate_before_days: pulumi.Input[int]
        """
        The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
elif False:
    GroupServiceAccountAccessTokenRotationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupServiceAccountAccessTokenRotationConfigurationArgs:
    def __init__(__self__, *,
                 rotate_before_days: pulumi.Input[int]):
        """
        :param pulumi.Input[int] rotate_before_days: The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
        pulumi.set(__self__, "rotate_before_days", rotate_before_days)

    @property
    @pulumi.getter(name="rotateBeforeDays")
    def rotate_before_days(self) -> pulumi.Input[int]:
        """
        The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
        return pulumi.get(self, "rotate_before_days")

    @rotate_before_days.setter
    def rotate_before_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "rotate_before_days", value)


if not MYPY:
    class InstanceServiceAccountTimeoutsArgsDict(TypedDict):
        delete: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    InstanceServiceAccountTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceServiceAccountTimeoutsArgs:
    def __init__(__self__, *,
                 delete: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class PersonalAccessTokenRotationConfigurationArgsDict(TypedDict):
        expiration_days: pulumi.Input[int]
        """
        The duration (in days) the new token should be valid for.
        """
        rotate_before_days: pulumi.Input[int]
        """
        The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
elif False:
    PersonalAccessTokenRotationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PersonalAccessTokenRotationConfigurationArgs:
    def __init__(__self__, *,
                 expiration_days: pulumi.Input[int],
                 rotate_before_days: pulumi.Input[int]):
        """
        :param pulumi.Input[int] expiration_days: The duration (in days) the new token should be valid for.
        :param pulumi.Input[int] rotate_before_days: The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
        pulumi.set(__self__, "expiration_days", expiration_days)
        pulumi.set(__self__, "rotate_before_days", rotate_before_days)

    @property
    @pulumi.getter(name="expirationDays")
    def expiration_days(self) -> pulumi.Input[int]:
        """
        The duration (in days) the new token should be valid for.
        """
        return pulumi.get(self, "expiration_days")

    @expiration_days.setter
    def expiration_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "expiration_days", value)

    @property
    @pulumi.getter(name="rotateBeforeDays")
    def rotate_before_days(self) -> pulumi.Input[int]:
        """
        The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
        return pulumi.get(self, "rotate_before_days")

    @rotate_before_days.setter
    def rotate_before_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "rotate_before_days", value)


if not MYPY:
    class ProjectAccessTokenRotationConfigurationArgsDict(TypedDict):
        expiration_days: pulumi.Input[int]
        """
        The duration (in days) the new token should be valid for.
        """
        rotate_before_days: pulumi.Input[int]
        """
        The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
elif False:
    ProjectAccessTokenRotationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAccessTokenRotationConfigurationArgs:
    def __init__(__self__, *,
                 expiration_days: pulumi.Input[int],
                 rotate_before_days: pulumi.Input[int]):
        """
        :param pulumi.Input[int] expiration_days: The duration (in days) the new token should be valid for.
        :param pulumi.Input[int] rotate_before_days: The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
        pulumi.set(__self__, "expiration_days", expiration_days)
        pulumi.set(__self__, "rotate_before_days", rotate_before_days)

    @property
    @pulumi.getter(name="expirationDays")
    def expiration_days(self) -> pulumi.Input[int]:
        """
        The duration (in days) the new token should be valid for.
        """
        return pulumi.get(self, "expiration_days")

    @expiration_days.setter
    def expiration_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "expiration_days", value)

    @property
    @pulumi.getter(name="rotateBeforeDays")
    def rotate_before_days(self) -> pulumi.Input[int]:
        """
        The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
        return pulumi.get(self, "rotate_before_days")

    @rotate_before_days.setter
    def rotate_before_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "rotate_before_days", value)


if not MYPY:
    class ProjectContainerExpirationPolicyArgsDict(TypedDict):
        cadence: NotRequired[pulumi.Input[str]]
        """
        The cadence of the policy. Valid values are: `1d`, `7d`, `14d`, `1month`, `3month`.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        If true, the policy is enabled.
        """
        keep_n: NotRequired[pulumi.Input[int]]
        """
        The number of images to keep.
        """
        name_regex: NotRequired[pulumi.Input[str]]
        """
        The regular expression to match image names to delete.
        """
        name_regex_delete: NotRequired[pulumi.Input[str]]
        """
        The regular expression to match image names to delete.
        """
        name_regex_keep: NotRequired[pulumi.Input[str]]
        """
        The regular expression to match image names to keep.
        """
        next_run_at: NotRequired[pulumi.Input[str]]
        """
        The next time the policy will run.
        """
        older_than: NotRequired[pulumi.Input[str]]
        """
        The number of days to keep images.
        """
elif False:
    ProjectContainerExpirationPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectContainerExpirationPolicyArgs:
    def __init__(__self__, *,
                 cadence: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 keep_n: Optional[pulumi.Input[int]] = None,
                 name_regex: Optional[pulumi.Input[str]] = None,
                 name_regex_delete: Optional[pulumi.Input[str]] = None,
                 name_regex_keep: Optional[pulumi.Input[str]] = None,
                 next_run_at: Optional[pulumi.Input[str]] = None,
                 older_than: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cadence: The cadence of the policy. Valid values are: `1d`, `7d`, `14d`, `1month`, `3month`.
        :param pulumi.Input[bool] enabled: If true, the policy is enabled.
        :param pulumi.Input[int] keep_n: The number of images to keep.
        :param pulumi.Input[str] name_regex: The regular expression to match image names to delete.
        :param pulumi.Input[str] name_regex_delete: The regular expression to match image names to delete.
        :param pulumi.Input[str] name_regex_keep: The regular expression to match image names to keep.
        :param pulumi.Input[str] next_run_at: The next time the policy will run.
        :param pulumi.Input[str] older_than: The number of days to keep images.
        """
        if cadence is not None:
            pulumi.set(__self__, "cadence", cadence)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if keep_n is not None:
            pulumi.set(__self__, "keep_n", keep_n)
        if name_regex is not None:
            warnings.warn("""`name_regex` has been deprecated. Use `name_regex_delete` instead.""", DeprecationWarning)
            pulumi.log.warn("""name_regex is deprecated: `name_regex` has been deprecated. Use `name_regex_delete` instead.""")
        if name_regex is not None:
            pulumi.set(__self__, "name_regex", name_regex)
        if name_regex_delete is not None:
            pulumi.set(__self__, "name_regex_delete", name_regex_delete)
        if name_regex_keep is not None:
            pulumi.set(__self__, "name_regex_keep", name_regex_keep)
        if next_run_at is not None:
            pulumi.set(__self__, "next_run_at", next_run_at)
        if older_than is not None:
            pulumi.set(__self__, "older_than", older_than)

    @property
    @pulumi.getter
    def cadence(self) -> Optional[pulumi.Input[str]]:
        """
        The cadence of the policy. Valid values are: `1d`, `7d`, `14d`, `1month`, `3month`.
        """
        return pulumi.get(self, "cadence")

    @cadence.setter
    def cadence(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cadence", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the policy is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="keepN")
    def keep_n(self) -> Optional[pulumi.Input[int]]:
        """
        The number of images to keep.
        """
        return pulumi.get(self, "keep_n")

    @keep_n.setter
    def keep_n(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "keep_n", value)

    @property
    @pulumi.getter(name="nameRegex")
    @_utilities.deprecated("""`name_regex` has been deprecated. Use `name_regex_delete` instead.""")
    def name_regex(self) -> Optional[pulumi.Input[str]]:
        """
        The regular expression to match image names to delete.
        """
        return pulumi.get(self, "name_regex")

    @name_regex.setter
    def name_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_regex", value)

    @property
    @pulumi.getter(name="nameRegexDelete")
    def name_regex_delete(self) -> Optional[pulumi.Input[str]]:
        """
        The regular expression to match image names to delete.
        """
        return pulumi.get(self, "name_regex_delete")

    @name_regex_delete.setter
    def name_regex_delete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_regex_delete", value)

    @property
    @pulumi.getter(name="nameRegexKeep")
    def name_regex_keep(self) -> Optional[pulumi.Input[str]]:
        """
        The regular expression to match image names to keep.
        """
        return pulumi.get(self, "name_regex_keep")

    @name_regex_keep.setter
    def name_regex_keep(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_regex_keep", value)

    @property
    @pulumi.getter(name="nextRunAt")
    def next_run_at(self) -> Optional[pulumi.Input[str]]:
        """
        The next time the policy will run.
        """
        return pulumi.get(self, "next_run_at")

    @next_run_at.setter
    def next_run_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "next_run_at", value)

    @property
    @pulumi.getter(name="olderThan")
    def older_than(self) -> Optional[pulumi.Input[str]]:
        """
        The number of days to keep images.
        """
        return pulumi.get(self, "older_than")

    @older_than.setter
    def older_than(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "older_than", value)


if not MYPY:
    class ProjectHookCustomHeaderArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Key of the custom header.
        """
        value: pulumi.Input[str]
        """
        Value of the custom header. This value cannot be imported.
        """
elif False:
    ProjectHookCustomHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectHookCustomHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Key of the custom header.
        :param pulumi.Input[str] value: Value of the custom header. This value cannot be imported.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key of the custom header.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the custom header. This value cannot be imported.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ProjectIssueBoardListArgsDict(TypedDict):
        assignee_id: NotRequired[pulumi.Input[int]]
        """
        The ID of the assignee the list should be scoped to. Requires a GitLab EE license.
        """
        id: NotRequired[pulumi.Input[int]]
        """
        The ID of the list
        """
        iteration_id: NotRequired[pulumi.Input[int]]
        """
        The ID of the iteration the list should be scoped to. Requires a GitLab EE license.
        """
        label_id: NotRequired[pulumi.Input[int]]
        """
        The ID of the label the list should be scoped to. Requires a GitLab EE license.
        """
        milestone_id: NotRequired[pulumi.Input[int]]
        """
        The ID of the milestone the list should be scoped to. Requires a GitLab EE license.
        """
        position: NotRequired[pulumi.Input[int]]
        """
        The position of the list within the board. The position for the list is based on the its position in the `lists` array.
        """
elif False:
    ProjectIssueBoardListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectIssueBoardListArgs:
    def __init__(__self__, *,
                 assignee_id: Optional[pulumi.Input[int]] = None,
                 id: Optional[pulumi.Input[int]] = None,
                 iteration_id: Optional[pulumi.Input[int]] = None,
                 label_id: Optional[pulumi.Input[int]] = None,
                 milestone_id: Optional[pulumi.Input[int]] = None,
                 position: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] assignee_id: The ID of the assignee the list should be scoped to. Requires a GitLab EE license.
        :param pulumi.Input[int] id: The ID of the list
        :param pulumi.Input[int] iteration_id: The ID of the iteration the list should be scoped to. Requires a GitLab EE license.
        :param pulumi.Input[int] label_id: The ID of the label the list should be scoped to. Requires a GitLab EE license.
        :param pulumi.Input[int] milestone_id: The ID of the milestone the list should be scoped to. Requires a GitLab EE license.
        :param pulumi.Input[int] position: The position of the list within the board. The position for the list is based on the its position in the `lists` array.
        """
        if assignee_id is not None:
            pulumi.set(__self__, "assignee_id", assignee_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if iteration_id is not None:
            pulumi.set(__self__, "iteration_id", iteration_id)
        if label_id is not None:
            pulumi.set(__self__, "label_id", label_id)
        if milestone_id is not None:
            pulumi.set(__self__, "milestone_id", milestone_id)
        if position is not None:
            pulumi.set(__self__, "position", position)

    @property
    @pulumi.getter(name="assigneeId")
    def assignee_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the assignee the list should be scoped to. Requires a GitLab EE license.
        """
        return pulumi.get(self, "assignee_id")

    @assignee_id.setter
    def assignee_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "assignee_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the list
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="iterationId")
    def iteration_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the iteration the list should be scoped to. Requires a GitLab EE license.
        """
        return pulumi.get(self, "iteration_id")

    @iteration_id.setter
    def iteration_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iteration_id", value)

    @property
    @pulumi.getter(name="labelId")
    def label_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the label the list should be scoped to. Requires a GitLab EE license.
        """
        return pulumi.get(self, "label_id")

    @label_id.setter
    def label_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "label_id", value)

    @property
    @pulumi.getter(name="milestoneId")
    def milestone_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the milestone the list should be scoped to. Requires a GitLab EE license.
        """
        return pulumi.get(self, "milestone_id")

    @milestone_id.setter
    def milestone_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "milestone_id", value)

    @property
    @pulumi.getter
    def position(self) -> Optional[pulumi.Input[int]]:
        """
        The position of the list within the board. The position for the list is based on the its position in the `lists` array.
        """
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "position", value)


if not MYPY:
    class ProjectIssueTaskCompletionStatusArgsDict(TypedDict):
        completed_count: NotRequired[pulumi.Input[int]]
        """
        The number of tasks that are completed.
        """
        count: NotRequired[pulumi.Input[int]]
        """
        The number of tasks.
        """
elif False:
    ProjectIssueTaskCompletionStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectIssueTaskCompletionStatusArgs:
    def __init__(__self__, *,
                 completed_count: Optional[pulumi.Input[int]] = None,
                 count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] completed_count: The number of tasks that are completed.
        :param pulumi.Input[int] count: The number of tasks.
        """
        if completed_count is not None:
            pulumi.set(__self__, "completed_count", completed_count)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter(name="completedCount")
    def completed_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of tasks that are completed.
        """
        return pulumi.get(self, "completed_count")

    @completed_count.setter
    def completed_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "completed_count", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of tasks.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)


if not MYPY:
    class ProjectProtectedEnvironmentApprovalRuleArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[str]]
        """
        Levels of access allowed to approve a deployment to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        """
        access_level_description: NotRequired[pulumi.Input[str]]
        """
        Readable description of level of access.
        """
        group_id: NotRequired[pulumi.Input[int]]
        """
        The ID of the group allowed to approve a deployment to this protected environment. The project must be shared with the group. Mutually exclusive with `access_level` and `user_id`.
        """
        group_inheritance_type: NotRequired[pulumi.Input[int]]
        """
        Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        """
        id: NotRequired[pulumi.Input[int]]
        """
        The unique ID of the Approval Rules object.
        """
        required_approvals: NotRequired[pulumi.Input[int]]
        """
        The number of approval required to allow deployment to this protected environment. This is mutually exclusive with user_id.
        """
        user_id: NotRequired[pulumi.Input[int]]
        """
        The ID of the user allowed to approve a deployment to this protected environment. The user must be a member of the project. Mutually exclusive with `access_level` and `group_id`.
        """
elif False:
    ProjectProtectedEnvironmentApprovalRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectProtectedEnvironmentApprovalRuleArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[str]] = None,
                 access_level_description: Optional[pulumi.Input[str]] = None,
                 group_id: Optional[pulumi.Input[int]] = None,
                 group_inheritance_type: Optional[pulumi.Input[int]] = None,
                 id: Optional[pulumi.Input[int]] = None,
                 required_approvals: Optional[pulumi.Input[int]] = None,
                 user_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] access_level: Levels of access allowed to approve a deployment to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        :param pulumi.Input[str] access_level_description: Readable description of level of access.
        :param pulumi.Input[int] group_id: The ID of the group allowed to approve a deployment to this protected environment. The project must be shared with the group. Mutually exclusive with `access_level` and `user_id`.
        :param pulumi.Input[int] group_inheritance_type: Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        :param pulumi.Input[int] id: The unique ID of the Approval Rules object.
        :param pulumi.Input[int] required_approvals: The number of approval required to allow deployment to this protected environment. This is mutually exclusive with user_id.
        :param pulumi.Input[int] user_id: The ID of the user allowed to approve a deployment to this protected environment. The user must be a member of the project. Mutually exclusive with `access_level` and `group_id`.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_level_description is not None:
            pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if group_inheritance_type is not None:
            pulumi.set(__self__, "group_inheritance_type", group_inheritance_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if required_approvals is not None:
            pulumi.set(__self__, "required_approvals", required_approvals)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[str]]:
        """
        Levels of access allowed to approve a deployment to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[pulumi.Input[str]]:
        """
        Readable description of level of access.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level_description", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the group allowed to approve a deployment to this protected environment. The project must be shared with the group. Mutually exclusive with `access_level` and `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="groupInheritanceType")
    def group_inheritance_type(self) -> Optional[pulumi.Input[int]]:
        """
        Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        """
        return pulumi.get(self, "group_inheritance_type")

    @group_inheritance_type.setter
    def group_inheritance_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_inheritance_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        The unique ID of the Approval Rules object.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="requiredApprovals")
    def required_approvals(self) -> Optional[pulumi.Input[int]]:
        """
        The number of approval required to allow deployment to this protected environment. This is mutually exclusive with user_id.
        """
        return pulumi.get(self, "required_approvals")

    @required_approvals.setter
    def required_approvals(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "required_approvals", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the user allowed to approve a deployment to this protected environment. The user must be a member of the project. Mutually exclusive with `access_level` and `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class ProjectProtectedEnvironmentDeployAccessLevelArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[str]]
        """
        Levels of access required to deploy to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        """
        access_level_description: NotRequired[pulumi.Input[str]]
        """
        Readable description of level of access.
        """
        group_id: NotRequired[pulumi.Input[int]]
        """
        The ID of the group allowed to deploy to this protected environment. The project must be shared with the group. Mutually exclusive with `access_level` and `user_id`.
        """
        group_inheritance_type: NotRequired[pulumi.Input[int]]
        """
        Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        """
        id: NotRequired[pulumi.Input[int]]
        """
        The unique ID of the Deploy Access Level object.
        """
        user_id: NotRequired[pulumi.Input[int]]
        """
        The ID of the user allowed to deploy to this protected environment. The user must be a member of the project. Mutually exclusive with `access_level` and `group_id`.
        """
elif False:
    ProjectProtectedEnvironmentDeployAccessLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectProtectedEnvironmentDeployAccessLevelArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[str]] = None,
                 access_level_description: Optional[pulumi.Input[str]] = None,
                 group_id: Optional[pulumi.Input[int]] = None,
                 group_inheritance_type: Optional[pulumi.Input[int]] = None,
                 id: Optional[pulumi.Input[int]] = None,
                 user_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] access_level: Levels of access required to deploy to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        :param pulumi.Input[str] access_level_description: Readable description of level of access.
        :param pulumi.Input[int] group_id: The ID of the group allowed to deploy to this protected environment. The project must be shared with the group. Mutually exclusive with `access_level` and `user_id`.
        :param pulumi.Input[int] group_inheritance_type: Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        :param pulumi.Input[int] id: The unique ID of the Deploy Access Level object.
        :param pulumi.Input[int] user_id: The ID of the user allowed to deploy to this protected environment. The user must be a member of the project. Mutually exclusive with `access_level` and `group_id`.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_level_description is not None:
            pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if group_inheritance_type is not None:
            pulumi.set(__self__, "group_inheritance_type", group_inheritance_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[str]]:
        """
        Levels of access required to deploy to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[pulumi.Input[str]]:
        """
        Readable description of level of access.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level_description", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the group allowed to deploy to this protected environment. The project must be shared with the group. Mutually exclusive with `access_level` and `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="groupInheritanceType")
    def group_inheritance_type(self) -> Optional[pulumi.Input[int]]:
        """
        Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        """
        return pulumi.get(self, "group_inheritance_type")

    @group_inheritance_type.setter
    def group_inheritance_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_inheritance_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        The unique ID of the Deploy Access Level object.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the user allowed to deploy to this protected environment. The user must be a member of the project. Mutually exclusive with `access_level` and `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class ProjectPushRulesArgsDict(TypedDict):
        author_email_regex: NotRequired[pulumi.Input[str]]
        """
        All commit author emails must match this regex, e.g. `@my-company.com$`.
        """
        branch_name_regex: NotRequired[pulumi.Input[str]]
        """
        All branch names must match this regex, e.g. `(feature|hotfix)\\/*`.
        """
        commit_committer_check: NotRequired[pulumi.Input[bool]]
        """
        Users can only push commits to this repository that were committed with one of their own verified emails.
        """
        commit_committer_name_check: NotRequired[pulumi.Input[bool]]
        """
        Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
        """
        commit_message_negative_regex: NotRequired[pulumi.Input[str]]
        """
        No commit message is allowed to match this regex, e.g. `ssh\\:\\/\\/`.
        """
        commit_message_regex: NotRequired[pulumi.Input[str]]
        """
        All commit messages must match this regex, e.g. `Fixed \\d+\\..*`.
        """
        deny_delete_tag: NotRequired[pulumi.Input[bool]]
        """
        Deny deleting a tag.
        """
        file_name_regex: NotRequired[pulumi.Input[str]]
        """
        All committed filenames must not match this regex, e.g. `(jar|exe)$`.
        """
        max_file_size: NotRequired[pulumi.Input[int]]
        """
        Maximum file size (MB).
        """
        member_check: NotRequired[pulumi.Input[bool]]
        """
        Restrict commits by author (email) to existing GitLab users.
        """
        prevent_secrets: NotRequired[pulumi.Input[bool]]
        """
        GitLab will reject any files that are likely to contain secrets.
        """
        reject_non_dco_commits: NotRequired[pulumi.Input[bool]]
        """
        Reject commit when its not DCO certified.
        """
        reject_unsigned_commits: NotRequired[pulumi.Input[bool]]
        """
        Reject commit when its not signed through GPG.
        """
elif False:
    ProjectPushRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectPushRulesArgs:
    def __init__(__self__, *,
                 author_email_regex: Optional[pulumi.Input[str]] = None,
                 branch_name_regex: Optional[pulumi.Input[str]] = None,
                 commit_committer_check: Optional[pulumi.Input[bool]] = None,
                 commit_committer_name_check: Optional[pulumi.Input[bool]] = None,
                 commit_message_negative_regex: Optional[pulumi.Input[str]] = None,
                 commit_message_regex: Optional[pulumi.Input[str]] = None,
                 deny_delete_tag: Optional[pulumi.Input[bool]] = None,
                 file_name_regex: Optional[pulumi.Input[str]] = None,
                 max_file_size: Optional[pulumi.Input[int]] = None,
                 member_check: Optional[pulumi.Input[bool]] = None,
                 prevent_secrets: Optional[pulumi.Input[bool]] = None,
                 reject_non_dco_commits: Optional[pulumi.Input[bool]] = None,
                 reject_unsigned_commits: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] author_email_regex: All commit author emails must match this regex, e.g. `@my-company.com$`.
        :param pulumi.Input[str] branch_name_regex: All branch names must match this regex, e.g. `(feature|hotfix)\\/*`.
        :param pulumi.Input[bool] commit_committer_check: Users can only push commits to this repository that were committed with one of their own verified emails.
        :param pulumi.Input[bool] commit_committer_name_check: Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
        :param pulumi.Input[str] commit_message_negative_regex: No commit message is allowed to match this regex, e.g. `ssh\\:\\/\\/`.
        :param pulumi.Input[str] commit_message_regex: All commit messages must match this regex, e.g. `Fixed \\d+\\..*`.
        :param pulumi.Input[bool] deny_delete_tag: Deny deleting a tag.
        :param pulumi.Input[str] file_name_regex: All committed filenames must not match this regex, e.g. `(jar|exe)$`.
        :param pulumi.Input[int] max_file_size: Maximum file size (MB).
        :param pulumi.Input[bool] member_check: Restrict commits by author (email) to existing GitLab users.
        :param pulumi.Input[bool] prevent_secrets: GitLab will reject any files that are likely to contain secrets.
        :param pulumi.Input[bool] reject_non_dco_commits: Reject commit when its not DCO certified.
        :param pulumi.Input[bool] reject_unsigned_commits: Reject commit when its not signed through GPG.
        """
        if author_email_regex is not None:
            pulumi.set(__self__, "author_email_regex", author_email_regex)
        if branch_name_regex is not None:
            pulumi.set(__self__, "branch_name_regex", branch_name_regex)
        if commit_committer_check is not None:
            pulumi.set(__self__, "commit_committer_check", commit_committer_check)
        if commit_committer_name_check is not None:
            pulumi.set(__self__, "commit_committer_name_check", commit_committer_name_check)
        if commit_message_negative_regex is not None:
            pulumi.set(__self__, "commit_message_negative_regex", commit_message_negative_regex)
        if commit_message_regex is not None:
            pulumi.set(__self__, "commit_message_regex", commit_message_regex)
        if deny_delete_tag is not None:
            pulumi.set(__self__, "deny_delete_tag", deny_delete_tag)
        if file_name_regex is not None:
            pulumi.set(__self__, "file_name_regex", file_name_regex)
        if max_file_size is not None:
            pulumi.set(__self__, "max_file_size", max_file_size)
        if member_check is not None:
            pulumi.set(__self__, "member_check", member_check)
        if prevent_secrets is not None:
            pulumi.set(__self__, "prevent_secrets", prevent_secrets)
        if reject_non_dco_commits is not None:
            pulumi.set(__self__, "reject_non_dco_commits", reject_non_dco_commits)
        if reject_unsigned_commits is not None:
            pulumi.set(__self__, "reject_unsigned_commits", reject_unsigned_commits)

    @property
    @pulumi.getter(name="authorEmailRegex")
    def author_email_regex(self) -> Optional[pulumi.Input[str]]:
        """
        All commit author emails must match this regex, e.g. `@my-company.com$`.
        """
        return pulumi.get(self, "author_email_regex")

    @author_email_regex.setter
    def author_email_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "author_email_regex", value)

    @property
    @pulumi.getter(name="branchNameRegex")
    def branch_name_regex(self) -> Optional[pulumi.Input[str]]:
        """
        All branch names must match this regex, e.g. `(feature|hotfix)\\/*`.
        """
        return pulumi.get(self, "branch_name_regex")

    @branch_name_regex.setter
    def branch_name_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch_name_regex", value)

    @property
    @pulumi.getter(name="commitCommitterCheck")
    def commit_committer_check(self) -> Optional[pulumi.Input[bool]]:
        """
        Users can only push commits to this repository that were committed with one of their own verified emails.
        """
        return pulumi.get(self, "commit_committer_check")

    @commit_committer_check.setter
    def commit_committer_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "commit_committer_check", value)

    @property
    @pulumi.getter(name="commitCommitterNameCheck")
    def commit_committer_name_check(self) -> Optional[pulumi.Input[bool]]:
        """
        Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
        """
        return pulumi.get(self, "commit_committer_name_check")

    @commit_committer_name_check.setter
    def commit_committer_name_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "commit_committer_name_check", value)

    @property
    @pulumi.getter(name="commitMessageNegativeRegex")
    def commit_message_negative_regex(self) -> Optional[pulumi.Input[str]]:
        """
        No commit message is allowed to match this regex, e.g. `ssh\\:\\/\\/`.
        """
        return pulumi.get(self, "commit_message_negative_regex")

    @commit_message_negative_regex.setter
    def commit_message_negative_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "commit_message_negative_regex", value)

    @property
    @pulumi.getter(name="commitMessageRegex")
    def commit_message_regex(self) -> Optional[pulumi.Input[str]]:
        """
        All commit messages must match this regex, e.g. `Fixed \\d+\\..*`.
        """
        return pulumi.get(self, "commit_message_regex")

    @commit_message_regex.setter
    def commit_message_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "commit_message_regex", value)

    @property
    @pulumi.getter(name="denyDeleteTag")
    def deny_delete_tag(self) -> Optional[pulumi.Input[bool]]:
        """
        Deny deleting a tag.
        """
        return pulumi.get(self, "deny_delete_tag")

    @deny_delete_tag.setter
    def deny_delete_tag(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deny_delete_tag", value)

    @property
    @pulumi.getter(name="fileNameRegex")
    def file_name_regex(self) -> Optional[pulumi.Input[str]]:
        """
        All committed filenames must not match this regex, e.g. `(jar|exe)$`.
        """
        return pulumi.get(self, "file_name_regex")

    @file_name_regex.setter
    def file_name_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_name_regex", value)

    @property
    @pulumi.getter(name="maxFileSize")
    def max_file_size(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum file size (MB).
        """
        return pulumi.get(self, "max_file_size")

    @max_file_size.setter
    def max_file_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_file_size", value)

    @property
    @pulumi.getter(name="memberCheck")
    def member_check(self) -> Optional[pulumi.Input[bool]]:
        """
        Restrict commits by author (email) to existing GitLab users.
        """
        return pulumi.get(self, "member_check")

    @member_check.setter
    def member_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "member_check", value)

    @property
    @pulumi.getter(name="preventSecrets")
    def prevent_secrets(self) -> Optional[pulumi.Input[bool]]:
        """
        GitLab will reject any files that are likely to contain secrets.
        """
        return pulumi.get(self, "prevent_secrets")

    @prevent_secrets.setter
    def prevent_secrets(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "prevent_secrets", value)

    @property
    @pulumi.getter(name="rejectNonDcoCommits")
    def reject_non_dco_commits(self) -> Optional[pulumi.Input[bool]]:
        """
        Reject commit when its not DCO certified.
        """
        return pulumi.get(self, "reject_non_dco_commits")

    @reject_non_dco_commits.setter
    def reject_non_dco_commits(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "reject_non_dco_commits", value)

    @property
    @pulumi.getter(name="rejectUnsignedCommits")
    def reject_unsigned_commits(self) -> Optional[pulumi.Input[bool]]:
        """
        Reject commit when its not signed through GPG.
        """
        return pulumi.get(self, "reject_unsigned_commits")

    @reject_unsigned_commits.setter
    def reject_unsigned_commits(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "reject_unsigned_commits", value)


if not MYPY:
    class ProjectTagCommitArgsDict(TypedDict):
        author_email: NotRequired[pulumi.Input[str]]
        """
        The email of the author.
        """
        author_name: NotRequired[pulumi.Input[str]]
        """
        The name of the author.
        """
        authored_date: NotRequired[pulumi.Input[str]]
        """
        The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
        """
        committed_date: NotRequired[pulumi.Input[str]]
        """
        The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
        """
        committer_email: NotRequired[pulumi.Input[str]]
        """
        The email of the user that committed.
        """
        committer_name: NotRequired[pulumi.Input[str]]
        """
        The name of the user that committed.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The unique id assigned to the commit by Gitlab.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        The commit message
        """
        parent_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The id of the parents of the commit
        """
        short_id: NotRequired[pulumi.Input[str]]
        """
        The short id assigned to the commit by Gitlab.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        The title of the commit
        """
elif False:
    ProjectTagCommitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectTagCommitArgs:
    def __init__(__self__, *,
                 author_email: Optional[pulumi.Input[str]] = None,
                 author_name: Optional[pulumi.Input[str]] = None,
                 authored_date: Optional[pulumi.Input[str]] = None,
                 committed_date: Optional[pulumi.Input[str]] = None,
                 committer_email: Optional[pulumi.Input[str]] = None,
                 committer_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 parent_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 short_id: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] author_email: The email of the author.
        :param pulumi.Input[str] author_name: The name of the author.
        :param pulumi.Input[str] authored_date: The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
        :param pulumi.Input[str] committed_date: The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
        :param pulumi.Input[str] committer_email: The email of the user that committed.
        :param pulumi.Input[str] committer_name: The name of the user that committed.
        :param pulumi.Input[str] id: The unique id assigned to the commit by Gitlab.
        :param pulumi.Input[str] message: The commit message
        :param pulumi.Input[Sequence[pulumi.Input[str]]] parent_ids: The id of the parents of the commit
        :param pulumi.Input[str] short_id: The short id assigned to the commit by Gitlab.
        :param pulumi.Input[str] title: The title of the commit
        """
        if author_email is not None:
            pulumi.set(__self__, "author_email", author_email)
        if author_name is not None:
            pulumi.set(__self__, "author_name", author_name)
        if authored_date is not None:
            pulumi.set(__self__, "authored_date", authored_date)
        if committed_date is not None:
            pulumi.set(__self__, "committed_date", committed_date)
        if committer_email is not None:
            pulumi.set(__self__, "committer_email", committer_email)
        if committer_name is not None:
            pulumi.set(__self__, "committer_name", committer_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if parent_ids is not None:
            pulumi.set(__self__, "parent_ids", parent_ids)
        if short_id is not None:
            pulumi.set(__self__, "short_id", short_id)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="authorEmail")
    def author_email(self) -> Optional[pulumi.Input[str]]:
        """
        The email of the author.
        """
        return pulumi.get(self, "author_email")

    @author_email.setter
    def author_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "author_email", value)

    @property
    @pulumi.getter(name="authorName")
    def author_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the author.
        """
        return pulumi.get(self, "author_name")

    @author_name.setter
    def author_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "author_name", value)

    @property
    @pulumi.getter(name="authoredDate")
    def authored_date(self) -> Optional[pulumi.Input[str]]:
        """
        The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
        """
        return pulumi.get(self, "authored_date")

    @authored_date.setter
    def authored_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authored_date", value)

    @property
    @pulumi.getter(name="committedDate")
    def committed_date(self) -> Optional[pulumi.Input[str]]:
        """
        The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
        """
        return pulumi.get(self, "committed_date")

    @committed_date.setter
    def committed_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "committed_date", value)

    @property
    @pulumi.getter(name="committerEmail")
    def committer_email(self) -> Optional[pulumi.Input[str]]:
        """
        The email of the user that committed.
        """
        return pulumi.get(self, "committer_email")

    @committer_email.setter
    def committer_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "committer_email", value)

    @property
    @pulumi.getter(name="committerName")
    def committer_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the user that committed.
        """
        return pulumi.get(self, "committer_name")

    @committer_name.setter
    def committer_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "committer_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique id assigned to the commit by Gitlab.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The commit message
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="parentIds")
    def parent_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The id of the parents of the commit
        """
        return pulumi.get(self, "parent_ids")

    @parent_ids.setter
    def parent_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "parent_ids", value)

    @property
    @pulumi.getter(name="shortId")
    def short_id(self) -> Optional[pulumi.Input[str]]:
        """
        The short id assigned to the commit by Gitlab.
        """
        return pulumi.get(self, "short_id")

    @short_id.setter
    def short_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "short_id", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the commit
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class ProjectTagReleaseArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        The description of release.
        """
        tag_name: NotRequired[pulumi.Input[str]]
        """
        The name of the tag.
        """
elif False:
    ProjectTagReleaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectTagReleaseArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 tag_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: The description of release.
        :param pulumi.Input[str] tag_name: The name of the tag.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of release.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the tag.
        """
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)


if not MYPY:
    class ReleaseAssetsArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[int]]
        """
        The total count of assets in this release.
        """
elif False:
    ReleaseAssetsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseAssetsArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] count: The total count of assets in this release.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The total count of assets in this release.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)


if not MYPY:
    class ReleaseAuthorArgsDict(TypedDict):
        avatar_url: NotRequired[pulumi.Input[str]]
        """
        The url of the author's' user avatar.
        """
        id: NotRequired[pulumi.Input[int]]
        """
        The ID of the author's user.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the author.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        The state of the author's user.
        """
        username: NotRequired[pulumi.Input[str]]
        """
        The username of the author.
        """
        web_url: NotRequired[pulumi.Input[str]]
        """
        The url to the author's user profile.
        """
elif False:
    ReleaseAuthorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseAuthorArgs:
    def __init__(__self__, *,
                 avatar_url: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None,
                 web_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] avatar_url: The url of the author's' user avatar.
        :param pulumi.Input[int] id: The ID of the author's user.
        :param pulumi.Input[str] name: The name of the author.
        :param pulumi.Input[str] state: The state of the author's user.
        :param pulumi.Input[str] username: The username of the author.
        :param pulumi.Input[str] web_url: The url to the author's user profile.
        """
        if avatar_url is not None:
            pulumi.set(__self__, "avatar_url", avatar_url)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if web_url is not None:
            pulumi.set(__self__, "web_url", web_url)

    @property
    @pulumi.getter(name="avatarUrl")
    def avatar_url(self) -> Optional[pulumi.Input[str]]:
        """
        The url of the author's' user avatar.
        """
        return pulumi.get(self, "avatar_url")

    @avatar_url.setter
    def avatar_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "avatar_url", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the author's user.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the author.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The state of the author's user.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The username of the author.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> Optional[pulumi.Input[str]]:
        """
        The url to the author's user profile.
        """
        return pulumi.get(self, "web_url")

    @web_url.setter
    def web_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "web_url", value)


if not MYPY:
    class ReleaseCommitArgsDict(TypedDict):
        author_email: NotRequired[pulumi.Input[str]]
        """
        The email address of the commit author.
        """
        author_name: NotRequired[pulumi.Input[str]]
        """
        The name of the commit author.
        """
        authored_date: NotRequired[pulumi.Input[str]]
        """
        The date and time the commit was authored. In ISO 8601 format (2019-03-15T08:00:00Z).
        """
        committed_date: NotRequired[pulumi.Input[str]]
        """
        The date and time the commit was made. In ISO 8601 format (2019-03-15T08:00:00Z).
        """
        committer_email: NotRequired[pulumi.Input[str]]
        """
        The email address of the committer.
        """
        committer_name: NotRequired[pulumi.Input[str]]
        """
        The name of the committer.
        """
        created_at: NotRequired[pulumi.Input[str]]
        """
        The date and time the commit was created. In ISO 8601 format (2019-03-15T08:00:00Z).
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The git commit full SHA
        """
        message: NotRequired[pulumi.Input[str]]
        """
        The commit message.
        """
        parent_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The full SHA of any parent commits.
        """
        short_id: NotRequired[pulumi.Input[str]]
        """
        The git commit short SHA.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        The title of the commit.
        """
elif False:
    ReleaseCommitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseCommitArgs:
    def __init__(__self__, *,
                 author_email: Optional[pulumi.Input[str]] = None,
                 author_name: Optional[pulumi.Input[str]] = None,
                 authored_date: Optional[pulumi.Input[str]] = None,
                 committed_date: Optional[pulumi.Input[str]] = None,
                 committer_email: Optional[pulumi.Input[str]] = None,
                 committer_name: Optional[pulumi.Input[str]] = None,
                 created_at: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 parent_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 short_id: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] author_email: The email address of the commit author.
        :param pulumi.Input[str] author_name: The name of the commit author.
        :param pulumi.Input[str] authored_date: The date and time the commit was authored. In ISO 8601 format (2019-03-15T08:00:00Z).
        :param pulumi.Input[str] committed_date: The date and time the commit was made. In ISO 8601 format (2019-03-15T08:00:00Z).
        :param pulumi.Input[str] committer_email: The email address of the committer.
        :param pulumi.Input[str] committer_name: The name of the committer.
        :param pulumi.Input[str] created_at: The date and time the commit was created. In ISO 8601 format (2019-03-15T08:00:00Z).
        :param pulumi.Input[str] id: The git commit full SHA
        :param pulumi.Input[str] message: The commit message.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] parent_ids: The full SHA of any parent commits.
        :param pulumi.Input[str] short_id: The git commit short SHA.
        :param pulumi.Input[str] title: The title of the commit.
        """
        if author_email is not None:
            pulumi.set(__self__, "author_email", author_email)
        if author_name is not None:
            pulumi.set(__self__, "author_name", author_name)
        if authored_date is not None:
            pulumi.set(__self__, "authored_date", authored_date)
        if committed_date is not None:
            pulumi.set(__self__, "committed_date", committed_date)
        if committer_email is not None:
            pulumi.set(__self__, "committer_email", committer_email)
        if committer_name is not None:
            pulumi.set(__self__, "committer_name", committer_name)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if parent_ids is not None:
            pulumi.set(__self__, "parent_ids", parent_ids)
        if short_id is not None:
            pulumi.set(__self__, "short_id", short_id)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="authorEmail")
    def author_email(self) -> Optional[pulumi.Input[str]]:
        """
        The email address of the commit author.
        """
        return pulumi.get(self, "author_email")

    @author_email.setter
    def author_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "author_email", value)

    @property
    @pulumi.getter(name="authorName")
    def author_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the commit author.
        """
        return pulumi.get(self, "author_name")

    @author_name.setter
    def author_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "author_name", value)

    @property
    @pulumi.getter(name="authoredDate")
    def authored_date(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the commit was authored. In ISO 8601 format (2019-03-15T08:00:00Z).
        """
        return pulumi.get(self, "authored_date")

    @authored_date.setter
    def authored_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authored_date", value)

    @property
    @pulumi.getter(name="committedDate")
    def committed_date(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the commit was made. In ISO 8601 format (2019-03-15T08:00:00Z).
        """
        return pulumi.get(self, "committed_date")

    @committed_date.setter
    def committed_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "committed_date", value)

    @property
    @pulumi.getter(name="committerEmail")
    def committer_email(self) -> Optional[pulumi.Input[str]]:
        """
        The email address of the committer.
        """
        return pulumi.get(self, "committer_email")

    @committer_email.setter
    def committer_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "committer_email", value)

    @property
    @pulumi.getter(name="committerName")
    def committer_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the committer.
        """
        return pulumi.get(self, "committer_name")

    @committer_name.setter
    def committer_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "committer_name", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the commit was created. In ISO 8601 format (2019-03-15T08:00:00Z).
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The git commit full SHA
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The commit message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="parentIds")
    def parent_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The full SHA of any parent commits.
        """
        return pulumi.get(self, "parent_ids")

    @parent_ids.setter
    def parent_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "parent_ids", value)

    @property
    @pulumi.getter(name="shortId")
    def short_id(self) -> Optional[pulumi.Input[str]]:
        """
        The git commit short SHA.
        """
        return pulumi.get(self, "short_id")

    @short_id.setter
    def short_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "short_id", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the commit.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class ReleaseLinksArgsDict(TypedDict):
        closed_issues_url: NotRequired[pulumi.Input[str]]
        """
        URL of the release's closed issues.
        """
        closed_merge_requests_url: NotRequired[pulumi.Input[str]]
        """
        URL of the release's closed merge requests.
        """
        edit_url: NotRequired[pulumi.Input[str]]
        """
        URL of the release's edit page.
        """
        merged_merge_requests_url: NotRequired[pulumi.Input[str]]
        """
        URL of the release's merged merge requests.
        """
        opened_issues_url: NotRequired[pulumi.Input[str]]
        """
        URL of the release's open issues.
        """
        opened_merge_requests_url: NotRequired[pulumi.Input[str]]
        """
        URL of the release's open merge requests.
        """
        self: NotRequired[pulumi.Input[str]]
        """
        URL of the release.
        """
elif False:
    ReleaseLinksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseLinksArgs:
    def __init__(__self__, *,
                 closed_issues_url: Optional[pulumi.Input[str]] = None,
                 closed_merge_requests_url: Optional[pulumi.Input[str]] = None,
                 edit_url: Optional[pulumi.Input[str]] = None,
                 merged_merge_requests_url: Optional[pulumi.Input[str]] = None,
                 opened_issues_url: Optional[pulumi.Input[str]] = None,
                 opened_merge_requests_url: Optional[pulumi.Input[str]] = None,
                 self: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] closed_issues_url: URL of the release's closed issues.
        :param pulumi.Input[str] closed_merge_requests_url: URL of the release's closed merge requests.
        :param pulumi.Input[str] edit_url: URL of the release's edit page.
        :param pulumi.Input[str] merged_merge_requests_url: URL of the release's merged merge requests.
        :param pulumi.Input[str] opened_issues_url: URL of the release's open issues.
        :param pulumi.Input[str] opened_merge_requests_url: URL of the release's open merge requests.
        :param pulumi.Input[str] self: URL of the release.
        """
        if closed_issues_url is not None:
            pulumi.set(__self__, "closed_issues_url", closed_issues_url)
        if closed_merge_requests_url is not None:
            pulumi.set(__self__, "closed_merge_requests_url", closed_merge_requests_url)
        if edit_url is not None:
            pulumi.set(__self__, "edit_url", edit_url)
        if merged_merge_requests_url is not None:
            pulumi.set(__self__, "merged_merge_requests_url", merged_merge_requests_url)
        if opened_issues_url is not None:
            pulumi.set(__self__, "opened_issues_url", opened_issues_url)
        if opened_merge_requests_url is not None:
            pulumi.set(__self__, "opened_merge_requests_url", opened_merge_requests_url)
        if self is not None:
            pulumi.set(__self__, "self", self)

    @property
    @pulumi.getter(name="closedIssuesUrl")
    def closed_issues_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL of the release's closed issues.
        """
        return pulumi.get(self, "closed_issues_url")

    @closed_issues_url.setter
    def closed_issues_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "closed_issues_url", value)

    @property
    @pulumi.getter(name="closedMergeRequestsUrl")
    def closed_merge_requests_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL of the release's closed merge requests.
        """
        return pulumi.get(self, "closed_merge_requests_url")

    @closed_merge_requests_url.setter
    def closed_merge_requests_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "closed_merge_requests_url", value)

    @property
    @pulumi.getter(name="editUrl")
    def edit_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL of the release's edit page.
        """
        return pulumi.get(self, "edit_url")

    @edit_url.setter
    def edit_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "edit_url", value)

    @property
    @pulumi.getter(name="mergedMergeRequestsUrl")
    def merged_merge_requests_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL of the release's merged merge requests.
        """
        return pulumi.get(self, "merged_merge_requests_url")

    @merged_merge_requests_url.setter
    def merged_merge_requests_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "merged_merge_requests_url", value)

    @property
    @pulumi.getter(name="openedIssuesUrl")
    def opened_issues_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL of the release's open issues.
        """
        return pulumi.get(self, "opened_issues_url")

    @opened_issues_url.setter
    def opened_issues_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "opened_issues_url", value)

    @property
    @pulumi.getter(name="openedMergeRequestsUrl")
    def opened_merge_requests_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL of the release's open merge requests.
        """
        return pulumi.get(self, "opened_merge_requests_url")

    @opened_merge_requests_url.setter
    def opened_merge_requests_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "opened_merge_requests_url", value)

    @property
    @pulumi.getter
    def self(self) -> Optional[pulumi.Input[str]]:
        """
        URL of the release.
        """
        return pulumi.get(self, "self")

    @self.setter
    def self(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "self", value)


if not MYPY:
    class TagProtectionAllowedToCreateArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[str]]
        """
        Access levels allowed to create protected tags. Valid values are: `no one`, `developer`, `maintainer`.
        """
        access_level_description: NotRequired[pulumi.Input[str]]
        """
        Readable description of access level.
        """
        group_id: NotRequired[pulumi.Input[int]]
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        user_id: NotRequired[pulumi.Input[int]]
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
elif False:
    TagProtectionAllowedToCreateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TagProtectionAllowedToCreateArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[str]] = None,
                 access_level_description: Optional[pulumi.Input[str]] = None,
                 group_id: Optional[pulumi.Input[int]] = None,
                 user_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] access_level: Access levels allowed to create protected tags. Valid values are: `no one`, `developer`, `maintainer`.
        :param pulumi.Input[str] access_level_description: Readable description of access level.
        :param pulumi.Input[int] group_id: The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        :param pulumi.Input[int] user_id: The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_level_description is not None:
            pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[str]]:
        """
        Access levels allowed to create protected tags. Valid values are: `no one`, `developer`, `maintainer`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[pulumi.Input[str]]:
        """
        Readable description of access level.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level_description", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class ValueStreamAnalyticsStageArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the value stream stage.
        """
        custom: NotRequired[pulumi.Input[bool]]
        """
        Boolean whether the stage is customized. If false, it assigns a built-in default stage by name.
        """
        end_event_identifier: NotRequired[pulumi.Input[str]]
        """
        End event identifier. Valid values are: `CODE_STAGE_START`, `ISSUE_CLOSED`, `ISSUE_CREATED`, `ISSUE_DEPLOYED_TO_PRODUCTION`, `ISSUE_FIRST_ADDED_TO_BOARD`, `ISSUE_FIRST_ADDED_TO_ITERATION`, `ISSUE_FIRST_ASSIGNED_AT`, `ISSUE_FIRST_ASSOCIATED_WITH_MILESTONE`, `ISSUE_FIRST_MENTIONED_IN_COMMIT`, `ISSUE_LABEL_ADDED`, `ISSUE_LABEL_REMOVED`, `ISSUE_LAST_EDITED`, `ISSUE_STAGE_END`, `MERGE_REQUEST_CLOSED`, `MERGE_REQUEST_CREATED`, `MERGE_REQUEST_FIRST_ASSIGNED_AT`, `MERGE_REQUEST_FIRST_COMMIT_AT`, `MERGE_REQUEST_FIRST_DEPLOYED_TO_PRODUCTION`, `MERGE_REQUEST_LABEL_ADDED`, `MERGE_REQUEST_LABEL_REMOVED`, `MERGE_REQUEST_LAST_BUILD_FINISHED`, `MERGE_REQUEST_LAST_BUILD_STARTED`, `MERGE_REQUEST_LAST_EDITED`, `MERGE_REQUEST_MERGED`, `MERGE_REQUEST_REVIEWER_FIRST_ASSIGNED`, `MERGE_REQUEST_PLAN_STAGE_START`
        """
        end_event_label_id: NotRequired[pulumi.Input[str]]
        """
        Label ID associated with the end event identifier. In the format of `gid://gitlab/GroupLabel/<id>` or `gid://gitlab/ProjectLabel/<id>`
        """
        hidden: NotRequired[pulumi.Input[bool]]
        """
        Boolean whether the stage is hidden, GitLab provided default stages are hidden by default.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ID of the value stream stage.
        """
        start_event_identifier: NotRequired[pulumi.Input[str]]
        """
        Start event identifier. Valid values are: `CODE_STAGE_START`, `ISSUE_CLOSED`, `ISSUE_CREATED`, `ISSUE_DEPLOYED_TO_PRODUCTION`, `ISSUE_FIRST_ADDED_TO_BOARD`, `ISSUE_FIRST_ADDED_TO_ITERATION`, `ISSUE_FIRST_ASSIGNED_AT`, `ISSUE_FIRST_ASSOCIATED_WITH_MILESTONE`, `ISSUE_FIRST_MENTIONED_IN_COMMIT`, `ISSUE_LABEL_ADDED`, `ISSUE_LABEL_REMOVED`, `ISSUE_LAST_EDITED`, `ISSUE_STAGE_END`, `MERGE_REQUEST_CLOSED`, `MERGE_REQUEST_CREATED`, `MERGE_REQUEST_FIRST_ASSIGNED_AT`, `MERGE_REQUEST_FIRST_COMMIT_AT`, `MERGE_REQUEST_FIRST_DEPLOYED_TO_PRODUCTION`, `MERGE_REQUEST_LABEL_ADDED`, `MERGE_REQUEST_LABEL_REMOVED`, `MERGE_REQUEST_LAST_BUILD_FINISHED`, `MERGE_REQUEST_LAST_BUILD_STARTED`, `MERGE_REQUEST_LAST_EDITED`, `MERGE_REQUEST_MERGED`, `MERGE_REQUEST_REVIEWER_FIRST_ASSIGNED`, `MERGE_REQUEST_PLAN_STAGE_START`
        """
        start_event_label_id: NotRequired[pulumi.Input[str]]
        """
        Label ID associated with the start event identifier. In the format of `gid://gitlab/GroupLabel/<id>` or `gid://gitlab/ProjectLabel/<id>`
        """
elif False:
    ValueStreamAnalyticsStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ValueStreamAnalyticsStageArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 custom: Optional[pulumi.Input[bool]] = None,
                 end_event_identifier: Optional[pulumi.Input[str]] = None,
                 end_event_label_id: Optional[pulumi.Input[str]] = None,
                 hidden: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 start_event_identifier: Optional[pulumi.Input[str]] = None,
                 start_event_label_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the value stream stage.
        :param pulumi.Input[bool] custom: Boolean whether the stage is customized. If false, it assigns a built-in default stage by name.
        :param pulumi.Input[str] end_event_identifier: End event identifier. Valid values are: `CODE_STAGE_START`, `ISSUE_CLOSED`, `ISSUE_CREATED`, `ISSUE_DEPLOYED_TO_PRODUCTION`, `ISSUE_FIRST_ADDED_TO_BOARD`, `ISSUE_FIRST_ADDED_TO_ITERATION`, `ISSUE_FIRST_ASSIGNED_AT`, `ISSUE_FIRST_ASSOCIATED_WITH_MILESTONE`, `ISSUE_FIRST_MENTIONED_IN_COMMIT`, `ISSUE_LABEL_ADDED`, `ISSUE_LABEL_REMOVED`, `ISSUE_LAST_EDITED`, `ISSUE_STAGE_END`, `MERGE_REQUEST_CLOSED`, `MERGE_REQUEST_CREATED`, `MERGE_REQUEST_FIRST_ASSIGNED_AT`, `MERGE_REQUEST_FIRST_COMMIT_AT`, `MERGE_REQUEST_FIRST_DEPLOYED_TO_PRODUCTION`, `MERGE_REQUEST_LABEL_ADDED`, `MERGE_REQUEST_LABEL_REMOVED`, `MERGE_REQUEST_LAST_BUILD_FINISHED`, `MERGE_REQUEST_LAST_BUILD_STARTED`, `MERGE_REQUEST_LAST_EDITED`, `MERGE_REQUEST_MERGED`, `MERGE_REQUEST_REVIEWER_FIRST_ASSIGNED`, `MERGE_REQUEST_PLAN_STAGE_START`
        :param pulumi.Input[str] end_event_label_id: Label ID associated with the end event identifier. In the format of `gid://gitlab/GroupLabel/<id>` or `gid://gitlab/ProjectLabel/<id>`
        :param pulumi.Input[bool] hidden: Boolean whether the stage is hidden, GitLab provided default stages are hidden by default.
        :param pulumi.Input[str] id: The ID of the value stream stage.
        :param pulumi.Input[str] start_event_identifier: Start event identifier. Valid values are: `CODE_STAGE_START`, `ISSUE_CLOSED`, `ISSUE_CREATED`, `ISSUE_DEPLOYED_TO_PRODUCTION`, `ISSUE_FIRST_ADDED_TO_BOARD`, `ISSUE_FIRST_ADDED_TO_ITERATION`, `ISSUE_FIRST_ASSIGNED_AT`, `ISSUE_FIRST_ASSOCIATED_WITH_MILESTONE`, `ISSUE_FIRST_MENTIONED_IN_COMMIT`, `ISSUE_LABEL_ADDED`, `ISSUE_LABEL_REMOVED`, `ISSUE_LAST_EDITED`, `ISSUE_STAGE_END`, `MERGE_REQUEST_CLOSED`, `MERGE_REQUEST_CREATED`, `MERGE_REQUEST_FIRST_ASSIGNED_AT`, `MERGE_REQUEST_FIRST_COMMIT_AT`, `MERGE_REQUEST_FIRST_DEPLOYED_TO_PRODUCTION`, `MERGE_REQUEST_LABEL_ADDED`, `MERGE_REQUEST_LABEL_REMOVED`, `MERGE_REQUEST_LAST_BUILD_FINISHED`, `MERGE_REQUEST_LAST_BUILD_STARTED`, `MERGE_REQUEST_LAST_EDITED`, `MERGE_REQUEST_MERGED`, `MERGE_REQUEST_REVIEWER_FIRST_ASSIGNED`, `MERGE_REQUEST_PLAN_STAGE_START`
        :param pulumi.Input[str] start_event_label_id: Label ID associated with the start event identifier. In the format of `gid://gitlab/GroupLabel/<id>` or `gid://gitlab/ProjectLabel/<id>`
        """
        pulumi.set(__self__, "name", name)
        if custom is not None:
            pulumi.set(__self__, "custom", custom)
        if end_event_identifier is not None:
            pulumi.set(__self__, "end_event_identifier", end_event_identifier)
        if end_event_label_id is not None:
            pulumi.set(__self__, "end_event_label_id", end_event_label_id)
        if hidden is not None:
            pulumi.set(__self__, "hidden", hidden)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if start_event_identifier is not None:
            pulumi.set(__self__, "start_event_identifier", start_event_identifier)
        if start_event_label_id is not None:
            pulumi.set(__self__, "start_event_label_id", start_event_label_id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the value stream stage.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def custom(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean whether the stage is customized. If false, it assigns a built-in default stage by name.
        """
        return pulumi.get(self, "custom")

    @custom.setter
    def custom(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "custom", value)

    @property
    @pulumi.getter(name="endEventIdentifier")
    def end_event_identifier(self) -> Optional[pulumi.Input[str]]:
        """
        End event identifier. Valid values are: `CODE_STAGE_START`, `ISSUE_CLOSED`, `ISSUE_CREATED`, `ISSUE_DEPLOYED_TO_PRODUCTION`, `ISSUE_FIRST_ADDED_TO_BOARD`, `ISSUE_FIRST_ADDED_TO_ITERATION`, `ISSUE_FIRST_ASSIGNED_AT`, `ISSUE_FIRST_ASSOCIATED_WITH_MILESTONE`, `ISSUE_FIRST_MENTIONED_IN_COMMIT`, `ISSUE_LABEL_ADDED`, `ISSUE_LABEL_REMOVED`, `ISSUE_LAST_EDITED`, `ISSUE_STAGE_END`, `MERGE_REQUEST_CLOSED`, `MERGE_REQUEST_CREATED`, `MERGE_REQUEST_FIRST_ASSIGNED_AT`, `MERGE_REQUEST_FIRST_COMMIT_AT`, `MERGE_REQUEST_FIRST_DEPLOYED_TO_PRODUCTION`, `MERGE_REQUEST_LABEL_ADDED`, `MERGE_REQUEST_LABEL_REMOVED`, `MERGE_REQUEST_LAST_BUILD_FINISHED`, `MERGE_REQUEST_LAST_BUILD_STARTED`, `MERGE_REQUEST_LAST_EDITED`, `MERGE_REQUEST_MERGED`, `MERGE_REQUEST_REVIEWER_FIRST_ASSIGNED`, `MERGE_REQUEST_PLAN_STAGE_START`
        """
        return pulumi.get(self, "end_event_identifier")

    @end_event_identifier.setter
    def end_event_identifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_event_identifier", value)

    @property
    @pulumi.getter(name="endEventLabelId")
    def end_event_label_id(self) -> Optional[pulumi.Input[str]]:
        """
        Label ID associated with the end event identifier. In the format of `gid://gitlab/GroupLabel/<id>` or `gid://gitlab/ProjectLabel/<id>`
        """
        return pulumi.get(self, "end_event_label_id")

    @end_event_label_id.setter
    def end_event_label_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_event_label_id", value)

    @property
    @pulumi.getter
    def hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean whether the stage is hidden, GitLab provided default stages are hidden by default.
        """
        return pulumi.get(self, "hidden")

    @hidden.setter
    def hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hidden", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the value stream stage.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="startEventIdentifier")
    def start_event_identifier(self) -> Optional[pulumi.Input[str]]:
        """
        Start event identifier. Valid values are: `CODE_STAGE_START`, `ISSUE_CLOSED`, `ISSUE_CREATED`, `ISSUE_DEPLOYED_TO_PRODUCTION`, `ISSUE_FIRST_ADDED_TO_BOARD`, `ISSUE_FIRST_ADDED_TO_ITERATION`, `ISSUE_FIRST_ASSIGNED_AT`, `ISSUE_FIRST_ASSOCIATED_WITH_MILESTONE`, `ISSUE_FIRST_MENTIONED_IN_COMMIT`, `ISSUE_LABEL_ADDED`, `ISSUE_LABEL_REMOVED`, `ISSUE_LAST_EDITED`, `ISSUE_STAGE_END`, `MERGE_REQUEST_CLOSED`, `MERGE_REQUEST_CREATED`, `MERGE_REQUEST_FIRST_ASSIGNED_AT`, `MERGE_REQUEST_FIRST_COMMIT_AT`, `MERGE_REQUEST_FIRST_DEPLOYED_TO_PRODUCTION`, `MERGE_REQUEST_LABEL_ADDED`, `MERGE_REQUEST_LABEL_REMOVED`, `MERGE_REQUEST_LAST_BUILD_FINISHED`, `MERGE_REQUEST_LAST_BUILD_STARTED`, `MERGE_REQUEST_LAST_EDITED`, `MERGE_REQUEST_MERGED`, `MERGE_REQUEST_REVIEWER_FIRST_ASSIGNED`, `MERGE_REQUEST_PLAN_STAGE_START`
        """
        return pulumi.get(self, "start_event_identifier")

    @start_event_identifier.setter
    def start_event_identifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_event_identifier", value)

    @property
    @pulumi.getter(name="startEventLabelId")
    def start_event_label_id(self) -> Optional[pulumi.Input[str]]:
        """
        Label ID associated with the start event identifier. In the format of `gid://gitlab/GroupLabel/<id>` or `gid://gitlab/ProjectLabel/<id>`
        """
        return pulumi.get(self, "start_event_label_id")

    @start_event_label_id.setter
    def start_event_label_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_event_label_id", value)


if not MYPY:
    class GetGroupProvisionedUsersProvisionedUserArgsDict(TypedDict):
        avatar_url: str
        """
        The avatar URL of the provisioned user.
        """
        bio: str
        """
        The bio of the provisioned user.
        """
        bot: bool
        """
        Whether the provisioned user is a bot.
        """
        confirmed_at: str
        """
        The confirmation date of the provisioned user.
        """
        created_at: str
        """
        The creation date of the provisioned user.
        """
        email: str
        """
        The email of the provisioned user.
        """
        external: bool
        """
        Whether the provisioned user is external.
        """
        id: str
        """
        The ID of the provisioned user.
        """
        job_title: str
        """
        The job title of the provisioned user.
        """
        last_activity_on: str
        """
        The last activity date of the provisioned user.
        """
        last_sign_in_at: str
        """
        The last sign-in date of the provisioned user.
        """
        linkedin: str
        """
        The LinkedIn ID of the provisioned user.
        """
        location: str
        """
        The location of the provisioned user.
        """
        name: str
        """
        The name of the provisioned user.
        """
        organization: str
        """
        The organization of the provisioned user.
        """
        private_profile: bool
        """
        Whether the provisioned user has a private profile.
        """
        pronouns: str
        """
        The pronouns of the provisioned user.
        """
        public_email: str
        """
        The public email of the provisioned user.
        """
        skype: str
        """
        The Skype ID of the provisioned user.
        """
        state: str
        """
        The state of the provisioned user.
        """
        twitter: str
        """
        The Twitter ID of the provisioned user.
        """
        two_factor_enabled: bool
        """
        Whether two-factor authentication is enabled for the provisioned user.
        """
        username: str
        """
        The username of the provisioned user.
        """
        web_url: str
        """
        The web URL of the provisioned user.
        """
        website_url: str
        """
        The website URL of the provisioned user.
        """
elif False:
    GetGroupProvisionedUsersProvisionedUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGroupProvisionedUsersProvisionedUserArgs:
    def __init__(__self__, *,
                 avatar_url: str,
                 bio: str,
                 bot: bool,
                 confirmed_at: str,
                 created_at: str,
                 email: str,
                 external: bool,
                 id: str,
                 job_title: str,
                 last_activity_on: str,
                 last_sign_in_at: str,
                 linkedin: str,
                 location: str,
                 name: str,
                 organization: str,
                 private_profile: bool,
                 pronouns: str,
                 public_email: str,
                 skype: str,
                 state: str,
                 twitter: str,
                 two_factor_enabled: bool,
                 username: str,
                 web_url: str,
                 website_url: str):
        """
        :param str avatar_url: The avatar URL of the provisioned user.
        :param str bio: The bio of the provisioned user.
        :param bool bot: Whether the provisioned user is a bot.
        :param str confirmed_at: The confirmation date of the provisioned user.
        :param str created_at: The creation date of the provisioned user.
        :param str email: The email of the provisioned user.
        :param bool external: Whether the provisioned user is external.
        :param str id: The ID of the provisioned user.
        :param str job_title: The job title of the provisioned user.
        :param str last_activity_on: The last activity date of the provisioned user.
        :param str last_sign_in_at: The last sign-in date of the provisioned user.
        :param str linkedin: The LinkedIn ID of the provisioned user.
        :param str location: The location of the provisioned user.
        :param str name: The name of the provisioned user.
        :param str organization: The organization of the provisioned user.
        :param bool private_profile: Whether the provisioned user has a private profile.
        :param str pronouns: The pronouns of the provisioned user.
        :param str public_email: The public email of the provisioned user.
        :param str skype: The Skype ID of the provisioned user.
        :param str state: The state of the provisioned user.
        :param str twitter: The Twitter ID of the provisioned user.
        :param bool two_factor_enabled: Whether two-factor authentication is enabled for the provisioned user.
        :param str username: The username of the provisioned user.
        :param str web_url: The web URL of the provisioned user.
        :param str website_url: The website URL of the provisioned user.
        """
        pulumi.set(__self__, "avatar_url", avatar_url)
        pulumi.set(__self__, "bio", bio)
        pulumi.set(__self__, "bot", bot)
        pulumi.set(__self__, "confirmed_at", confirmed_at)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "external", external)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "job_title", job_title)
        pulumi.set(__self__, "last_activity_on", last_activity_on)
        pulumi.set(__self__, "last_sign_in_at", last_sign_in_at)
        pulumi.set(__self__, "linkedin", linkedin)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "organization", organization)
        pulumi.set(__self__, "private_profile", private_profile)
        pulumi.set(__self__, "pronouns", pronouns)
        pulumi.set(__self__, "public_email", public_email)
        pulumi.set(__self__, "skype", skype)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "twitter", twitter)
        pulumi.set(__self__, "two_factor_enabled", two_factor_enabled)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "web_url", web_url)
        pulumi.set(__self__, "website_url", website_url)

    @property
    @pulumi.getter(name="avatarUrl")
    def avatar_url(self) -> str:
        """
        The avatar URL of the provisioned user.
        """
        return pulumi.get(self, "avatar_url")

    @avatar_url.setter
    def avatar_url(self, value: str):
        pulumi.set(self, "avatar_url", value)

    @property
    @pulumi.getter
    def bio(self) -> str:
        """
        The bio of the provisioned user.
        """
        return pulumi.get(self, "bio")

    @bio.setter
    def bio(self, value: str):
        pulumi.set(self, "bio", value)

    @property
    @pulumi.getter
    def bot(self) -> bool:
        """
        Whether the provisioned user is a bot.
        """
        return pulumi.get(self, "bot")

    @bot.setter
    def bot(self, value: bool):
        pulumi.set(self, "bot", value)

    @property
    @pulumi.getter(name="confirmedAt")
    def confirmed_at(self) -> str:
        """
        The confirmation date of the provisioned user.
        """
        return pulumi.get(self, "confirmed_at")

    @confirmed_at.setter
    def confirmed_at(self, value: str):
        pulumi.set(self, "confirmed_at", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        The creation date of the provisioned user.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: str):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the provisioned user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: str):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter
    def external(self) -> bool:
        """
        Whether the provisioned user is external.
        """
        return pulumi.get(self, "external")

    @external.setter
    def external(self, value: bool):
        pulumi.set(self, "external", value)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the provisioned user.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="jobTitle")
    def job_title(self) -> str:
        """
        The job title of the provisioned user.
        """
        return pulumi.get(self, "job_title")

    @job_title.setter
    def job_title(self, value: str):
        pulumi.set(self, "job_title", value)

    @property
    @pulumi.getter(name="lastActivityOn")
    def last_activity_on(self) -> str:
        """
        The last activity date of the provisioned user.
        """
        return pulumi.get(self, "last_activity_on")

    @last_activity_on.setter
    def last_activity_on(self, value: str):
        pulumi.set(self, "last_activity_on", value)

    @property
    @pulumi.getter(name="lastSignInAt")
    def last_sign_in_at(self) -> str:
        """
        The last sign-in date of the provisioned user.
        """
        return pulumi.get(self, "last_sign_in_at")

    @last_sign_in_at.setter
    def last_sign_in_at(self, value: str):
        pulumi.set(self, "last_sign_in_at", value)

    @property
    @pulumi.getter
    def linkedin(self) -> str:
        """
        The LinkedIn ID of the provisioned user.
        """
        return pulumi.get(self, "linkedin")

    @linkedin.setter
    def linkedin(self, value: str):
        pulumi.set(self, "linkedin", value)

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        The location of the provisioned user.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: str):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the provisioned user.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def organization(self) -> str:
        """
        The organization of the provisioned user.
        """
        return pulumi.get(self, "organization")

    @organization.setter
    def organization(self, value: str):
        pulumi.set(self, "organization", value)

    @property
    @pulumi.getter(name="privateProfile")
    def private_profile(self) -> bool:
        """
        Whether the provisioned user has a private profile.
        """
        return pulumi.get(self, "private_profile")

    @private_profile.setter
    def private_profile(self, value: bool):
        pulumi.set(self, "private_profile", value)

    @property
    @pulumi.getter
    def pronouns(self) -> str:
        """
        The pronouns of the provisioned user.
        """
        return pulumi.get(self, "pronouns")

    @pronouns.setter
    def pronouns(self, value: str):
        pulumi.set(self, "pronouns", value)

    @property
    @pulumi.getter(name="publicEmail")
    def public_email(self) -> str:
        """
        The public email of the provisioned user.
        """
        return pulumi.get(self, "public_email")

    @public_email.setter
    def public_email(self, value: str):
        pulumi.set(self, "public_email", value)

    @property
    @pulumi.getter
    def skype(self) -> str:
        """
        The Skype ID of the provisioned user.
        """
        return pulumi.get(self, "skype")

    @skype.setter
    def skype(self, value: str):
        pulumi.set(self, "skype", value)

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the provisioned user.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: str):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def twitter(self) -> str:
        """
        The Twitter ID of the provisioned user.
        """
        return pulumi.get(self, "twitter")

    @twitter.setter
    def twitter(self, value: str):
        pulumi.set(self, "twitter", value)

    @property
    @pulumi.getter(name="twoFactorEnabled")
    def two_factor_enabled(self) -> bool:
        """
        Whether two-factor authentication is enabled for the provisioned user.
        """
        return pulumi.get(self, "two_factor_enabled")

    @two_factor_enabled.setter
    def two_factor_enabled(self, value: bool):
        pulumi.set(self, "two_factor_enabled", value)

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username of the provisioned user.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: str):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> str:
        """
        The web URL of the provisioned user.
        """
        return pulumi.get(self, "web_url")

    @web_url.setter
    def web_url(self, value: str):
        pulumi.set(self, "web_url", value)

    @property
    @pulumi.getter(name="websiteUrl")
    def website_url(self) -> str:
        """
        The website URL of the provisioned user.
        """
        return pulumi.get(self, "website_url")

    @website_url.setter
    def website_url(self, value: str):
        pulumi.set(self, "website_url", value)


if not MYPY:
    class GetProjectProtectedBranchMergeAccessLevelArgsDict(TypedDict):
        access_level: str
        """
        Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`.
        """
        access_level_description: str
        """
        Readable description of access level.
        """
        group_id: NotRequired[int]
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        user_id: NotRequired[int]
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
elif False:
    GetProjectProtectedBranchMergeAccessLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProjectProtectedBranchMergeAccessLevelArgs:
    def __init__(__self__, *,
                 access_level: str,
                 access_level_description: str,
                 group_id: Optional[int] = None,
                 user_id: Optional[int] = None):
        """
        :param str access_level: Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`.
        :param str access_level_description: Readable description of access level.
        :param int group_id: The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        :param int user_id: The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        pulumi.set(__self__, "access_level", access_level)
        pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> str:
        """
        Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: str):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> str:
        """
        Readable description of access level.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: str):
        pulumi.set(self, "access_level_description", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[int]:
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[int]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[int]:
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[int]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class GetProjectProtectedBranchPushAccessLevelArgsDict(TypedDict):
        access_level: str
        """
        Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`.
        """
        access_level_description: str
        """
        Readable description of access level.
        """
        deploy_key_id: NotRequired[int]
        """
        The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `group_id` and `user_id`. This field is read-only until Gitlab 17.5.
        """
        group_id: NotRequired[int]
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `user_id`.
        """
        user_id: NotRequired[int]
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `group_id`.
        """
elif False:
    GetProjectProtectedBranchPushAccessLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProjectProtectedBranchPushAccessLevelArgs:
    def __init__(__self__, *,
                 access_level: str,
                 access_level_description: str,
                 deploy_key_id: Optional[int] = None,
                 group_id: Optional[int] = None,
                 user_id: Optional[int] = None):
        """
        :param str access_level: Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`.
        :param str access_level_description: Readable description of access level.
        :param int deploy_key_id: The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `group_id` and `user_id`. This field is read-only until Gitlab 17.5.
        :param int group_id: The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `user_id`.
        :param int user_id: The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `group_id`.
        """
        pulumi.set(__self__, "access_level", access_level)
        pulumi.set(__self__, "access_level_description", access_level_description)
        if deploy_key_id is not None:
            pulumi.set(__self__, "deploy_key_id", deploy_key_id)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> str:
        """
        Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: str):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> str:
        """
        Readable description of access level.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: str):
        pulumi.set(self, "access_level_description", value)

    @property
    @pulumi.getter(name="deployKeyId")
    def deploy_key_id(self) -> Optional[int]:
        """
        The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `group_id` and `user_id`. This field is read-only until Gitlab 17.5.
        """
        return pulumi.get(self, "deploy_key_id")

    @deploy_key_id.setter
    def deploy_key_id(self, value: Optional[int]):
        pulumi.set(self, "deploy_key_id", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[int]:
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[int]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[int]:
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[int]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class GetProjectProtectedBranchesProtectedBranchArgsDict(TypedDict):
        allow_force_push: bool
        """
        Whether force push is allowed.
        """
        code_owner_approval_required: bool
        """
        Reject code pushes that change files listed in the CODEOWNERS file.
        """
        id: int
        """
        The ID of this resource.
        """
        name: str
        """
        The name of the protected branch.
        """
        merge_access_levels: NotRequired[Sequence['GetProjectProtectedBranchesProtectedBranchMergeAccessLevelArgsDict']]
        """
        Array of access levels and user(s)/group(s) allowed to merge to protected branch.
        """
        push_access_levels: NotRequired[Sequence['GetProjectProtectedBranchesProtectedBranchPushAccessLevelArgsDict']]
        """
        Array of access levels and user(s)/group(s) allowed to push to protected branch.
        """
elif False:
    GetProjectProtectedBranchesProtectedBranchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProjectProtectedBranchesProtectedBranchArgs:
    def __init__(__self__, *,
                 allow_force_push: bool,
                 code_owner_approval_required: bool,
                 id: int,
                 name: str,
                 merge_access_levels: Optional[Sequence['GetProjectProtectedBranchesProtectedBranchMergeAccessLevelArgs']] = None,
                 push_access_levels: Optional[Sequence['GetProjectProtectedBranchesProtectedBranchPushAccessLevelArgs']] = None):
        """
        :param bool allow_force_push: Whether force push is allowed.
        :param bool code_owner_approval_required: Reject code pushes that change files listed in the CODEOWNERS file.
        :param int id: The ID of this resource.
        :param str name: The name of the protected branch.
        :param Sequence['GetProjectProtectedBranchesProtectedBranchMergeAccessLevelArgs'] merge_access_levels: Array of access levels and user(s)/group(s) allowed to merge to protected branch.
        :param Sequence['GetProjectProtectedBranchesProtectedBranchPushAccessLevelArgs'] push_access_levels: Array of access levels and user(s)/group(s) allowed to push to protected branch.
        """
        pulumi.set(__self__, "allow_force_push", allow_force_push)
        pulumi.set(__self__, "code_owner_approval_required", code_owner_approval_required)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        if merge_access_levels is not None:
            pulumi.set(__self__, "merge_access_levels", merge_access_levels)
        if push_access_levels is not None:
            pulumi.set(__self__, "push_access_levels", push_access_levels)

    @property
    @pulumi.getter(name="allowForcePush")
    def allow_force_push(self) -> bool:
        """
        Whether force push is allowed.
        """
        return pulumi.get(self, "allow_force_push")

    @allow_force_push.setter
    def allow_force_push(self, value: bool):
        pulumi.set(self, "allow_force_push", value)

    @property
    @pulumi.getter(name="codeOwnerApprovalRequired")
    def code_owner_approval_required(self) -> bool:
        """
        Reject code pushes that change files listed in the CODEOWNERS file.
        """
        return pulumi.get(self, "code_owner_approval_required")

    @code_owner_approval_required.setter
    def code_owner_approval_required(self, value: bool):
        pulumi.set(self, "code_owner_approval_required", value)

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: int):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the protected branch.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="mergeAccessLevels")
    def merge_access_levels(self) -> Optional[Sequence['GetProjectProtectedBranchesProtectedBranchMergeAccessLevelArgs']]:
        """
        Array of access levels and user(s)/group(s) allowed to merge to protected branch.
        """
        return pulumi.get(self, "merge_access_levels")

    @merge_access_levels.setter
    def merge_access_levels(self, value: Optional[Sequence['GetProjectProtectedBranchesProtectedBranchMergeAccessLevelArgs']]):
        pulumi.set(self, "merge_access_levels", value)

    @property
    @pulumi.getter(name="pushAccessLevels")
    def push_access_levels(self) -> Optional[Sequence['GetProjectProtectedBranchesProtectedBranchPushAccessLevelArgs']]:
        """
        Array of access levels and user(s)/group(s) allowed to push to protected branch.
        """
        return pulumi.get(self, "push_access_levels")

    @push_access_levels.setter
    def push_access_levels(self, value: Optional[Sequence['GetProjectProtectedBranchesProtectedBranchPushAccessLevelArgs']]):
        pulumi.set(self, "push_access_levels", value)


if not MYPY:
    class GetProjectProtectedBranchesProtectedBranchMergeAccessLevelArgsDict(TypedDict):
        access_level: str
        """
        Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`.
        """
        access_level_description: str
        """
        Readable description of access level.
        """
        group_id: NotRequired[int]
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        user_id: NotRequired[int]
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
elif False:
    GetProjectProtectedBranchesProtectedBranchMergeAccessLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProjectProtectedBranchesProtectedBranchMergeAccessLevelArgs:
    def __init__(__self__, *,
                 access_level: str,
                 access_level_description: str,
                 group_id: Optional[int] = None,
                 user_id: Optional[int] = None):
        """
        :param str access_level: Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`.
        :param str access_level_description: Readable description of access level.
        :param int group_id: The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        :param int user_id: The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        pulumi.set(__self__, "access_level", access_level)
        pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> str:
        """
        Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: str):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> str:
        """
        Readable description of access level.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: str):
        pulumi.set(self, "access_level_description", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[int]:
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[int]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[int]:
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[int]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class GetProjectProtectedBranchesProtectedBranchPushAccessLevelArgsDict(TypedDict):
        access_level: str
        """
        Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`.
        """
        access_level_description: str
        """
        Readable description of access level.
        """
        deploy_key_id: NotRequired[int]
        """
        The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `group_id` and `user_id`. This field is read-only until Gitlab 17.5.
        """
        group_id: NotRequired[int]
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `user_id`.
        """
        user_id: NotRequired[int]
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `group_id`.
        """
elif False:
    GetProjectProtectedBranchesProtectedBranchPushAccessLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProjectProtectedBranchesProtectedBranchPushAccessLevelArgs:
    def __init__(__self__, *,
                 access_level: str,
                 access_level_description: str,
                 deploy_key_id: Optional[int] = None,
                 group_id: Optional[int] = None,
                 user_id: Optional[int] = None):
        """
        :param str access_level: Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`.
        :param str access_level_description: Readable description of access level.
        :param int deploy_key_id: The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `group_id` and `user_id`. This field is read-only until Gitlab 17.5.
        :param int group_id: The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `user_id`.
        :param int user_id: The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `group_id`.
        """
        pulumi.set(__self__, "access_level", access_level)
        pulumi.set(__self__, "access_level_description", access_level_description)
        if deploy_key_id is not None:
            pulumi.set(__self__, "deploy_key_id", deploy_key_id)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> str:
        """
        Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: str):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> str:
        """
        Readable description of access level.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: str):
        pulumi.set(self, "access_level_description", value)

    @property
    @pulumi.getter(name="deployKeyId")
    def deploy_key_id(self) -> Optional[int]:
        """
        The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `group_id` and `user_id`. This field is read-only until Gitlab 17.5.
        """
        return pulumi.get(self, "deploy_key_id")

    @deploy_key_id.setter
    def deploy_key_id(self, value: Optional[int]):
        pulumi.set(self, "deploy_key_id", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[int]:
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[int]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[int]:
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[int]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class GetReleaseAssetsArgsDict(TypedDict):
        count: int
        """
        The number of assets for a release
        """
        links: NotRequired[Sequence['GetReleaseAssetsLinkArgsDict']]
        """
        The links for a release
        """
        sources: NotRequired[Sequence['GetReleaseAssetsSourceArgsDict']]
        """
        The sources for a release
        """
elif False:
    GetReleaseAssetsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetReleaseAssetsArgs:
    def __init__(__self__, *,
                 count: int,
                 links: Optional[Sequence['GetReleaseAssetsLinkArgs']] = None,
                 sources: Optional[Sequence['GetReleaseAssetsSourceArgs']] = None):
        """
        :param int count: The number of assets for a release
        :param Sequence['GetReleaseAssetsLinkArgs'] links: The links for a release
        :param Sequence['GetReleaseAssetsSourceArgs'] sources: The sources for a release
        """
        pulumi.set(__self__, "count", count)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of assets for a release
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: int):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def links(self) -> Optional[Sequence['GetReleaseAssetsLinkArgs']]:
        """
        The links for a release
        """
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[Sequence['GetReleaseAssetsLinkArgs']]):
        pulumi.set(self, "links", value)

    @property
    @pulumi.getter
    def sources(self) -> Optional[Sequence['GetReleaseAssetsSourceArgs']]:
        """
        The sources for a release
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[Sequence['GetReleaseAssetsSourceArgs']]):
        pulumi.set(self, "sources", value)


if not MYPY:
    class GetReleaseAssetsLinkArgsDict(TypedDict):
        id: int
        """
        The ID of the link
        """
        link_type: str
        """
        The type of the link
        """
        name: str
        """
        The name of the link
        """
        url: str
        """
        The URL of the link
        """
elif False:
    GetReleaseAssetsLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetReleaseAssetsLinkArgs:
    def __init__(__self__, *,
                 id: int,
                 link_type: str,
                 name: str,
                 url: str):
        """
        :param int id: The ID of the link
        :param str link_type: The type of the link
        :param str name: The name of the link
        :param str url: The URL of the link
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "link_type", link_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        The ID of the link
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: int):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="linkType")
    def link_type(self) -> str:
        """
        The type of the link
        """
        return pulumi.get(self, "link_type")

    @link_type.setter
    def link_type(self, value: str):
        pulumi.set(self, "link_type", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the link
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL of the link
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


if not MYPY:
    class GetReleaseAssetsSourceArgsDict(TypedDict):
        format: str
        """
        The format of the source
        """
        url: str
        """
        The URL of the source
        """
elif False:
    GetReleaseAssetsSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetReleaseAssetsSourceArgs:
    def __init__(__self__, *,
                 format: str,
                 url: str):
        """
        :param str format: The format of the source
        :param str url: The URL of the source
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def format(self) -> str:
        """
        The format of the source
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: str):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL of the source
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


