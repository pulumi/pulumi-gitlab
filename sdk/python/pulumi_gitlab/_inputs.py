# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'BranchCommitArgs',
    'BranchProtectionAllowedToMergeArgs',
    'BranchProtectionAllowedToPushArgs',
    'BranchProtectionAllowedToUnprotectArgs',
    'GroupEpicBoardListArgs',
    'GroupIssueBoardListArgs',
    'GroupProtectedEnvironmentApprovalRuleArgs',
    'GroupProtectedEnvironmentDeployAccessLevelArgs',
    'ProjectContainerExpirationPolicyArgs',
    'ProjectIssueBoardListArgs',
    'ProjectIssueTaskCompletionStatusArgs',
    'ProjectProtectedEnvironmentApprovalRuleArgs',
    'ProjectProtectedEnvironmentDeployAccessLevelArgs',
    'ProjectPushRulesArgs',
    'ProjectTagCommitArgs',
    'ProjectTagReleaseArgs',
    'TagProtectionAllowedToCreateArgs',
]

@pulumi.input_type
class BranchCommitArgs:
    def __init__(__self__, *,
                 author_email: Optional[pulumi.Input[str]] = None,
                 author_name: Optional[pulumi.Input[str]] = None,
                 authored_date: Optional[pulumi.Input[str]] = None,
                 committed_date: Optional[pulumi.Input[str]] = None,
                 committer_email: Optional[pulumi.Input[str]] = None,
                 committer_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 parent_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 short_id: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        BranchCommitArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            author_email=author_email,
            author_name=author_name,
            authored_date=authored_date,
            committed_date=committed_date,
            committer_email=committer_email,
            committer_name=committer_name,
            id=id,
            message=message,
            parent_ids=parent_ids,
            short_id=short_id,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             author_email: Optional[pulumi.Input[str]] = None,
             author_name: Optional[pulumi.Input[str]] = None,
             authored_date: Optional[pulumi.Input[str]] = None,
             committed_date: Optional[pulumi.Input[str]] = None,
             committer_email: Optional[pulumi.Input[str]] = None,
             committer_name: Optional[pulumi.Input[str]] = None,
             id: Optional[pulumi.Input[str]] = None,
             message: Optional[pulumi.Input[str]] = None,
             parent_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             short_id: Optional[pulumi.Input[str]] = None,
             title: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if author_email is None and 'authorEmail' in kwargs:
            author_email = kwargs['authorEmail']
        if author_name is None and 'authorName' in kwargs:
            author_name = kwargs['authorName']
        if authored_date is None and 'authoredDate' in kwargs:
            authored_date = kwargs['authoredDate']
        if committed_date is None and 'committedDate' in kwargs:
            committed_date = kwargs['committedDate']
        if committer_email is None and 'committerEmail' in kwargs:
            committer_email = kwargs['committerEmail']
        if committer_name is None and 'committerName' in kwargs:
            committer_name = kwargs['committerName']
        if parent_ids is None and 'parentIds' in kwargs:
            parent_ids = kwargs['parentIds']
        if short_id is None and 'shortId' in kwargs:
            short_id = kwargs['shortId']

        if author_email is not None:
            _setter("author_email", author_email)
        if author_name is not None:
            _setter("author_name", author_name)
        if authored_date is not None:
            _setter("authored_date", authored_date)
        if committed_date is not None:
            _setter("committed_date", committed_date)
        if committer_email is not None:
            _setter("committer_email", committer_email)
        if committer_name is not None:
            _setter("committer_name", committer_name)
        if id is not None:
            _setter("id", id)
        if message is not None:
            _setter("message", message)
        if parent_ids is not None:
            _setter("parent_ids", parent_ids)
        if short_id is not None:
            _setter("short_id", short_id)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="authorEmail")
    def author_email(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "author_email")

    @author_email.setter
    def author_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "author_email", value)

    @property
    @pulumi.getter(name="authorName")
    def author_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "author_name")

    @author_name.setter
    def author_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "author_name", value)

    @property
    @pulumi.getter(name="authoredDate")
    def authored_date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "authored_date")

    @authored_date.setter
    def authored_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authored_date", value)

    @property
    @pulumi.getter(name="committedDate")
    def committed_date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "committed_date")

    @committed_date.setter
    def committed_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "committed_date", value)

    @property
    @pulumi.getter(name="committerEmail")
    def committer_email(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "committer_email")

    @committer_email.setter
    def committer_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "committer_email", value)

    @property
    @pulumi.getter(name="committerName")
    def committer_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "committer_name")

    @committer_name.setter
    def committer_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "committer_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="parentIds")
    def parent_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "parent_ids")

    @parent_ids.setter
    def parent_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "parent_ids", value)

    @property
    @pulumi.getter(name="shortId")
    def short_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "short_id")

    @short_id.setter
    def short_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "short_id", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


@pulumi.input_type
class BranchProtectionAllowedToMergeArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[str]] = None,
                 access_level_description: Optional[pulumi.Input[str]] = None,
                 group_id: Optional[pulumi.Input[int]] = None,
                 user_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] access_level: Level of access.
        :param pulumi.Input[str] access_level_description: Readable description of level of access.
        :param pulumi.Input[int] group_id: The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        :param pulumi.Input[int] user_id: The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        BranchProtectionAllowedToMergeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_level=access_level,
            access_level_description=access_level_description,
            group_id=group_id,
            user_id=user_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_level: Optional[pulumi.Input[str]] = None,
             access_level_description: Optional[pulumi.Input[str]] = None,
             group_id: Optional[pulumi.Input[int]] = None,
             user_id: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if access_level is None and 'accessLevel' in kwargs:
            access_level = kwargs['accessLevel']
        if access_level_description is None and 'accessLevelDescription' in kwargs:
            access_level_description = kwargs['accessLevelDescription']
        if group_id is None and 'groupId' in kwargs:
            group_id = kwargs['groupId']
        if user_id is None and 'userId' in kwargs:
            user_id = kwargs['userId']

        if access_level is not None:
            _setter("access_level", access_level)
        if access_level_description is not None:
            _setter("access_level_description", access_level_description)
        if group_id is not None:
            _setter("group_id", group_id)
        if user_id is not None:
            _setter("user_id", user_id)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[str]]:
        """
        Level of access.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[pulumi.Input[str]]:
        """
        Readable description of level of access.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level_description", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "user_id", value)


@pulumi.input_type
class BranchProtectionAllowedToPushArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[str]] = None,
                 access_level_description: Optional[pulumi.Input[str]] = None,
                 group_id: Optional[pulumi.Input[int]] = None,
                 user_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] access_level: Level of access.
        :param pulumi.Input[str] access_level_description: Readable description of level of access.
        :param pulumi.Input[int] group_id: The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        :param pulumi.Input[int] user_id: The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        BranchProtectionAllowedToPushArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_level=access_level,
            access_level_description=access_level_description,
            group_id=group_id,
            user_id=user_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_level: Optional[pulumi.Input[str]] = None,
             access_level_description: Optional[pulumi.Input[str]] = None,
             group_id: Optional[pulumi.Input[int]] = None,
             user_id: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if access_level is None and 'accessLevel' in kwargs:
            access_level = kwargs['accessLevel']
        if access_level_description is None and 'accessLevelDescription' in kwargs:
            access_level_description = kwargs['accessLevelDescription']
        if group_id is None and 'groupId' in kwargs:
            group_id = kwargs['groupId']
        if user_id is None and 'userId' in kwargs:
            user_id = kwargs['userId']

        if access_level is not None:
            _setter("access_level", access_level)
        if access_level_description is not None:
            _setter("access_level_description", access_level_description)
        if group_id is not None:
            _setter("group_id", group_id)
        if user_id is not None:
            _setter("user_id", user_id)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[str]]:
        """
        Level of access.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[pulumi.Input[str]]:
        """
        Readable description of level of access.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level_description", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "user_id", value)


@pulumi.input_type
class BranchProtectionAllowedToUnprotectArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[str]] = None,
                 access_level_description: Optional[pulumi.Input[str]] = None,
                 group_id: Optional[pulumi.Input[int]] = None,
                 user_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] access_level: Level of access.
        :param pulumi.Input[str] access_level_description: Readable description of level of access.
        :param pulumi.Input[int] group_id: The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        :param pulumi.Input[int] user_id: The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        BranchProtectionAllowedToUnprotectArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_level=access_level,
            access_level_description=access_level_description,
            group_id=group_id,
            user_id=user_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_level: Optional[pulumi.Input[str]] = None,
             access_level_description: Optional[pulumi.Input[str]] = None,
             group_id: Optional[pulumi.Input[int]] = None,
             user_id: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if access_level is None and 'accessLevel' in kwargs:
            access_level = kwargs['accessLevel']
        if access_level_description is None and 'accessLevelDescription' in kwargs:
            access_level_description = kwargs['accessLevelDescription']
        if group_id is None and 'groupId' in kwargs:
            group_id = kwargs['groupId']
        if user_id is None and 'userId' in kwargs:
            user_id = kwargs['userId']

        if access_level is not None:
            _setter("access_level", access_level)
        if access_level_description is not None:
            _setter("access_level_description", access_level_description)
        if group_id is not None:
            _setter("group_id", group_id)
        if user_id is not None:
            _setter("user_id", user_id)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[str]]:
        """
        Level of access.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[pulumi.Input[str]]:
        """
        Readable description of level of access.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level_description", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "user_id", value)


@pulumi.input_type
class GroupEpicBoardListArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[int]] = None,
                 label_id: Optional[pulumi.Input[int]] = None,
                 position: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] id: The ID of the list.
        :param pulumi.Input[int] label_id: The ID of the label the list should be scoped to.
        :param pulumi.Input[int] position: The position of the list within the board. The position for the list is sed on the its position in the `lists` array.
        """
        GroupEpicBoardListArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            label_id=label_id,
            position=position,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[int]] = None,
             label_id: Optional[pulumi.Input[int]] = None,
             position: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if label_id is None and 'labelId' in kwargs:
            label_id = kwargs['labelId']

        if id is not None:
            _setter("id", id)
        if label_id is not None:
            _setter("label_id", label_id)
        if position is not None:
            _setter("position", position)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="labelId")
    def label_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the label the list should be scoped to.
        """
        return pulumi.get(self, "label_id")

    @label_id.setter
    def label_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "label_id", value)

    @property
    @pulumi.getter
    def position(self) -> Optional[pulumi.Input[int]]:
        """
        The position of the list within the board. The position for the list is sed on the its position in the `lists` array.
        """
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "position", value)


@pulumi.input_type
class GroupIssueBoardListArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[int]] = None,
                 label_id: Optional[pulumi.Input[int]] = None,
                 position: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] id: The ID of the list.
        :param pulumi.Input[int] label_id: The ID of the label the list should be scoped to.
        :param pulumi.Input[int] position: The position of the list within the board. The position for the list is based on the its position in the `lists` array.
        """
        GroupIssueBoardListArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            label_id=label_id,
            position=position,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[int]] = None,
             label_id: Optional[pulumi.Input[int]] = None,
             position: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if label_id is None and 'labelId' in kwargs:
            label_id = kwargs['labelId']

        if id is not None:
            _setter("id", id)
        if label_id is not None:
            _setter("label_id", label_id)
        if position is not None:
            _setter("position", position)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="labelId")
    def label_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the label the list should be scoped to.
        """
        return pulumi.get(self, "label_id")

    @label_id.setter
    def label_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "label_id", value)

    @property
    @pulumi.getter
    def position(self) -> Optional[pulumi.Input[int]]:
        """
        The position of the list within the board. The position for the list is based on the its position in the `lists` array.
        """
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "position", value)


@pulumi.input_type
class GroupProtectedEnvironmentApprovalRuleArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[str]] = None,
                 access_level_description: Optional[pulumi.Input[str]] = None,
                 group_id: Optional[pulumi.Input[int]] = None,
                 id: Optional[pulumi.Input[int]] = None,
                 required_approvals: Optional[pulumi.Input[int]] = None,
                 user_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] access_level: Levels of access allowed to approve a deployment to this protected environment. Valid values are `developer`, `maintainer`.
        :param pulumi.Input[str] access_level_description: Readable description of level of access.
        :param pulumi.Input[int] group_id: The ID of the group allowed to approve a deployment to this protected environment. TThe group must be a sub-group under the given group. This is mutually exclusive with user_id.
        :param pulumi.Input[int] id: The unique ID of the Approval Rules object.
        :param pulumi.Input[int] required_approvals: The number of approval required to allow deployment to this protected environment. This is mutually exclusive with user_id.
        :param pulumi.Input[int] user_id: The ID of the user allowed to approve a deployment to this protected environment. The user must be a member of the group with Maintainer role or higher. This is mutually exclusive with group*id and required*approvals.
        """
        GroupProtectedEnvironmentApprovalRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_level=access_level,
            access_level_description=access_level_description,
            group_id=group_id,
            id=id,
            required_approvals=required_approvals,
            user_id=user_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_level: Optional[pulumi.Input[str]] = None,
             access_level_description: Optional[pulumi.Input[str]] = None,
             group_id: Optional[pulumi.Input[int]] = None,
             id: Optional[pulumi.Input[int]] = None,
             required_approvals: Optional[pulumi.Input[int]] = None,
             user_id: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if access_level is None and 'accessLevel' in kwargs:
            access_level = kwargs['accessLevel']
        if access_level_description is None and 'accessLevelDescription' in kwargs:
            access_level_description = kwargs['accessLevelDescription']
        if group_id is None and 'groupId' in kwargs:
            group_id = kwargs['groupId']
        if required_approvals is None and 'requiredApprovals' in kwargs:
            required_approvals = kwargs['requiredApprovals']
        if user_id is None and 'userId' in kwargs:
            user_id = kwargs['userId']

        if access_level is not None:
            _setter("access_level", access_level)
        if access_level_description is not None:
            _setter("access_level_description", access_level_description)
        if group_id is not None:
            _setter("group_id", group_id)
        if id is not None:
            _setter("id", id)
        if required_approvals is not None:
            _setter("required_approvals", required_approvals)
        if user_id is not None:
            _setter("user_id", user_id)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[str]]:
        """
        Levels of access allowed to approve a deployment to this protected environment. Valid values are `developer`, `maintainer`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[pulumi.Input[str]]:
        """
        Readable description of level of access.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level_description", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the group allowed to approve a deployment to this protected environment. TThe group must be a sub-group under the given group. This is mutually exclusive with user_id.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        The unique ID of the Approval Rules object.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="requiredApprovals")
    def required_approvals(self) -> Optional[pulumi.Input[int]]:
        """
        The number of approval required to allow deployment to this protected environment. This is mutually exclusive with user_id.
        """
        return pulumi.get(self, "required_approvals")

    @required_approvals.setter
    def required_approvals(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "required_approvals", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the user allowed to approve a deployment to this protected environment. The user must be a member of the group with Maintainer role or higher. This is mutually exclusive with group*id and required*approvals.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "user_id", value)


@pulumi.input_type
class GroupProtectedEnvironmentDeployAccessLevelArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[str]] = None,
                 access_level_description: Optional[pulumi.Input[str]] = None,
                 group_id: Optional[pulumi.Input[int]] = None,
                 id: Optional[pulumi.Input[int]] = None,
                 user_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] access_level: Levels of access required to deploy to this protected environment. Valid values are `developer`, `maintainer`.
        :param pulumi.Input[str] access_level_description: Readable description of level of access.
        :param pulumi.Input[int] group_id: The ID of the group allowed to deploy to this protected environment. The group must be a sub-group under the given group.
        :param pulumi.Input[int] id: The unique ID of the Deploy Access Level object.
        :param pulumi.Input[int] user_id: The ID of the user allowed to deploy to this protected environment. The user must be a member of the group with Maintainer role or higher.
        """
        GroupProtectedEnvironmentDeployAccessLevelArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_level=access_level,
            access_level_description=access_level_description,
            group_id=group_id,
            id=id,
            user_id=user_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_level: Optional[pulumi.Input[str]] = None,
             access_level_description: Optional[pulumi.Input[str]] = None,
             group_id: Optional[pulumi.Input[int]] = None,
             id: Optional[pulumi.Input[int]] = None,
             user_id: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if access_level is None and 'accessLevel' in kwargs:
            access_level = kwargs['accessLevel']
        if access_level_description is None and 'accessLevelDescription' in kwargs:
            access_level_description = kwargs['accessLevelDescription']
        if group_id is None and 'groupId' in kwargs:
            group_id = kwargs['groupId']
        if user_id is None and 'userId' in kwargs:
            user_id = kwargs['userId']

        if access_level is not None:
            _setter("access_level", access_level)
        if access_level_description is not None:
            _setter("access_level_description", access_level_description)
        if group_id is not None:
            _setter("group_id", group_id)
        if id is not None:
            _setter("id", id)
        if user_id is not None:
            _setter("user_id", user_id)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[str]]:
        """
        Levels of access required to deploy to this protected environment. Valid values are `developer`, `maintainer`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[pulumi.Input[str]]:
        """
        Readable description of level of access.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level_description", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the group allowed to deploy to this protected environment. The group must be a sub-group under the given group.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        The unique ID of the Deploy Access Level object.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the user allowed to deploy to this protected environment. The user must be a member of the group with Maintainer role or higher.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "user_id", value)


@pulumi.input_type
class ProjectContainerExpirationPolicyArgs:
    def __init__(__self__, *,
                 cadence: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 keep_n: Optional[pulumi.Input[int]] = None,
                 name_regex: Optional[pulumi.Input[str]] = None,
                 name_regex_delete: Optional[pulumi.Input[str]] = None,
                 name_regex_keep: Optional[pulumi.Input[str]] = None,
                 next_run_at: Optional[pulumi.Input[str]] = None,
                 older_than: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cadence: The cadence of the policy. Valid values are: `1d`, `7d`, `14d`, `1month`, `3month`.
        :param pulumi.Input[bool] enabled: If true, the policy is enabled.
        :param pulumi.Input[int] keep_n: The number of images to keep.
        :param pulumi.Input[str] name_regex: The regular expression to match image names to delete.
        :param pulumi.Input[str] name_regex_delete: The regular expression to match image names to delete.
        :param pulumi.Input[str] name_regex_keep: The regular expression to match image names to keep.
        :param pulumi.Input[str] next_run_at: The next time the policy will run.
        :param pulumi.Input[str] older_than: The number of days to keep images.
        """
        ProjectContainerExpirationPolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cadence=cadence,
            enabled=enabled,
            keep_n=keep_n,
            name_regex=name_regex,
            name_regex_delete=name_regex_delete,
            name_regex_keep=name_regex_keep,
            next_run_at=next_run_at,
            older_than=older_than,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cadence: Optional[pulumi.Input[str]] = None,
             enabled: Optional[pulumi.Input[bool]] = None,
             keep_n: Optional[pulumi.Input[int]] = None,
             name_regex: Optional[pulumi.Input[str]] = None,
             name_regex_delete: Optional[pulumi.Input[str]] = None,
             name_regex_keep: Optional[pulumi.Input[str]] = None,
             next_run_at: Optional[pulumi.Input[str]] = None,
             older_than: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if keep_n is None and 'keepN' in kwargs:
            keep_n = kwargs['keepN']
        if name_regex is None and 'nameRegex' in kwargs:
            name_regex = kwargs['nameRegex']
        if name_regex_delete is None and 'nameRegexDelete' in kwargs:
            name_regex_delete = kwargs['nameRegexDelete']
        if name_regex_keep is None and 'nameRegexKeep' in kwargs:
            name_regex_keep = kwargs['nameRegexKeep']
        if next_run_at is None and 'nextRunAt' in kwargs:
            next_run_at = kwargs['nextRunAt']
        if older_than is None and 'olderThan' in kwargs:
            older_than = kwargs['olderThan']

        if cadence is not None:
            _setter("cadence", cadence)
        if enabled is not None:
            _setter("enabled", enabled)
        if keep_n is not None:
            _setter("keep_n", keep_n)
        if name_regex is not None:
            warnings.warn("""`name_regex` has been deprecated. Use `name_regex_delete` instead.""", DeprecationWarning)
            pulumi.log.warn("""name_regex is deprecated: `name_regex` has been deprecated. Use `name_regex_delete` instead.""")
        if name_regex is not None:
            _setter("name_regex", name_regex)
        if name_regex_delete is not None:
            _setter("name_regex_delete", name_regex_delete)
        if name_regex_keep is not None:
            _setter("name_regex_keep", name_regex_keep)
        if next_run_at is not None:
            _setter("next_run_at", next_run_at)
        if older_than is not None:
            _setter("older_than", older_than)

    @property
    @pulumi.getter
    def cadence(self) -> Optional[pulumi.Input[str]]:
        """
        The cadence of the policy. Valid values are: `1d`, `7d`, `14d`, `1month`, `3month`.
        """
        return pulumi.get(self, "cadence")

    @cadence.setter
    def cadence(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cadence", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the policy is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="keepN")
    def keep_n(self) -> Optional[pulumi.Input[int]]:
        """
        The number of images to keep.
        """
        return pulumi.get(self, "keep_n")

    @keep_n.setter
    def keep_n(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "keep_n", value)

    @property
    @pulumi.getter(name="nameRegex")
    def name_regex(self) -> Optional[pulumi.Input[str]]:
        """
        The regular expression to match image names to delete.
        """
        warnings.warn("""`name_regex` has been deprecated. Use `name_regex_delete` instead.""", DeprecationWarning)
        pulumi.log.warn("""name_regex is deprecated: `name_regex` has been deprecated. Use `name_regex_delete` instead.""")

        return pulumi.get(self, "name_regex")

    @name_regex.setter
    def name_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_regex", value)

    @property
    @pulumi.getter(name="nameRegexDelete")
    def name_regex_delete(self) -> Optional[pulumi.Input[str]]:
        """
        The regular expression to match image names to delete.
        """
        return pulumi.get(self, "name_regex_delete")

    @name_regex_delete.setter
    def name_regex_delete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_regex_delete", value)

    @property
    @pulumi.getter(name="nameRegexKeep")
    def name_regex_keep(self) -> Optional[pulumi.Input[str]]:
        """
        The regular expression to match image names to keep.
        """
        return pulumi.get(self, "name_regex_keep")

    @name_regex_keep.setter
    def name_regex_keep(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_regex_keep", value)

    @property
    @pulumi.getter(name="nextRunAt")
    def next_run_at(self) -> Optional[pulumi.Input[str]]:
        """
        The next time the policy will run.
        """
        return pulumi.get(self, "next_run_at")

    @next_run_at.setter
    def next_run_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "next_run_at", value)

    @property
    @pulumi.getter(name="olderThan")
    def older_than(self) -> Optional[pulumi.Input[str]]:
        """
        The number of days to keep images.
        """
        return pulumi.get(self, "older_than")

    @older_than.setter
    def older_than(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "older_than", value)


@pulumi.input_type
class ProjectIssueBoardListArgs:
    def __init__(__self__, *,
                 assignee_id: Optional[pulumi.Input[int]] = None,
                 id: Optional[pulumi.Input[int]] = None,
                 iteration_id: Optional[pulumi.Input[int]] = None,
                 label_id: Optional[pulumi.Input[int]] = None,
                 milestone_id: Optional[pulumi.Input[int]] = None,
                 position: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] assignee_id: The ID of the assignee the list should be scoped to. Requires a GitLab EE license.
        :param pulumi.Input[int] id: The ID of the list
        :param pulumi.Input[int] iteration_id: The ID of the iteration the list should be scoped to. Requires a GitLab EE license.
        :param pulumi.Input[int] label_id: The ID of the label the list should be scoped to. Requires a GitLab EE license.
        :param pulumi.Input[int] milestone_id: The ID of the milestone the list should be scoped to. Requires a GitLab EE license.
        :param pulumi.Input[int] position: The position of the list within the board. The position for the list is based on the its position in the `lists` array.
        """
        ProjectIssueBoardListArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            assignee_id=assignee_id,
            id=id,
            iteration_id=iteration_id,
            label_id=label_id,
            milestone_id=milestone_id,
            position=position,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             assignee_id: Optional[pulumi.Input[int]] = None,
             id: Optional[pulumi.Input[int]] = None,
             iteration_id: Optional[pulumi.Input[int]] = None,
             label_id: Optional[pulumi.Input[int]] = None,
             milestone_id: Optional[pulumi.Input[int]] = None,
             position: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if assignee_id is None and 'assigneeId' in kwargs:
            assignee_id = kwargs['assigneeId']
        if iteration_id is None and 'iterationId' in kwargs:
            iteration_id = kwargs['iterationId']
        if label_id is None and 'labelId' in kwargs:
            label_id = kwargs['labelId']
        if milestone_id is None and 'milestoneId' in kwargs:
            milestone_id = kwargs['milestoneId']

        if assignee_id is not None:
            _setter("assignee_id", assignee_id)
        if id is not None:
            _setter("id", id)
        if iteration_id is not None:
            _setter("iteration_id", iteration_id)
        if label_id is not None:
            _setter("label_id", label_id)
        if milestone_id is not None:
            _setter("milestone_id", milestone_id)
        if position is not None:
            _setter("position", position)

    @property
    @pulumi.getter(name="assigneeId")
    def assignee_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the assignee the list should be scoped to. Requires a GitLab EE license.
        """
        return pulumi.get(self, "assignee_id")

    @assignee_id.setter
    def assignee_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "assignee_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the list
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="iterationId")
    def iteration_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the iteration the list should be scoped to. Requires a GitLab EE license.
        """
        return pulumi.get(self, "iteration_id")

    @iteration_id.setter
    def iteration_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iteration_id", value)

    @property
    @pulumi.getter(name="labelId")
    def label_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the label the list should be scoped to. Requires a GitLab EE license.
        """
        return pulumi.get(self, "label_id")

    @label_id.setter
    def label_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "label_id", value)

    @property
    @pulumi.getter(name="milestoneId")
    def milestone_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the milestone the list should be scoped to. Requires a GitLab EE license.
        """
        return pulumi.get(self, "milestone_id")

    @milestone_id.setter
    def milestone_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "milestone_id", value)

    @property
    @pulumi.getter
    def position(self) -> Optional[pulumi.Input[int]]:
        """
        The position of the list within the board. The position for the list is based on the its position in the `lists` array.
        """
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "position", value)


@pulumi.input_type
class ProjectIssueTaskCompletionStatusArgs:
    def __init__(__self__, *,
                 completed_count: Optional[pulumi.Input[int]] = None,
                 count: Optional[pulumi.Input[int]] = None):
        ProjectIssueTaskCompletionStatusArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            completed_count=completed_count,
            count=count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             completed_count: Optional[pulumi.Input[int]] = None,
             count: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if completed_count is None and 'completedCount' in kwargs:
            completed_count = kwargs['completedCount']

        if completed_count is not None:
            _setter("completed_count", completed_count)
        if count is not None:
            _setter("count", count)

    @property
    @pulumi.getter(name="completedCount")
    def completed_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "completed_count")

    @completed_count.setter
    def completed_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "completed_count", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)


@pulumi.input_type
class ProjectProtectedEnvironmentApprovalRuleArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[str]] = None,
                 access_level_description: Optional[pulumi.Input[str]] = None,
                 group_id: Optional[pulumi.Input[int]] = None,
                 id: Optional[pulumi.Input[int]] = None,
                 required_approvals: Optional[pulumi.Input[int]] = None,
                 user_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] access_level: Levels of access allowed to approve a deployment to this protected environment. Valid values are `developer`, `maintainer`.
        :param pulumi.Input[str] access_level_description: Readable description of level of access.
        :param pulumi.Input[int] group_id: The ID of the group allowed to approve a deployment to this protected environment. The project must be shared with the group. This is mutually exclusive with user_id.
        :param pulumi.Input[int] id: The unique ID of the Approval Rules object.
        :param pulumi.Input[int] required_approvals: The number of approval required to allow deployment to this protected environment. This is mutually exclusive with user_id.
        :param pulumi.Input[int] user_id: The ID of the user allowed to approve a deployment to this protected environment. The user must be a member of the project. This is mutually exclusive with group*id and required*approvals.
        """
        ProjectProtectedEnvironmentApprovalRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_level=access_level,
            access_level_description=access_level_description,
            group_id=group_id,
            id=id,
            required_approvals=required_approvals,
            user_id=user_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_level: Optional[pulumi.Input[str]] = None,
             access_level_description: Optional[pulumi.Input[str]] = None,
             group_id: Optional[pulumi.Input[int]] = None,
             id: Optional[pulumi.Input[int]] = None,
             required_approvals: Optional[pulumi.Input[int]] = None,
             user_id: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if access_level is None and 'accessLevel' in kwargs:
            access_level = kwargs['accessLevel']
        if access_level_description is None and 'accessLevelDescription' in kwargs:
            access_level_description = kwargs['accessLevelDescription']
        if group_id is None and 'groupId' in kwargs:
            group_id = kwargs['groupId']
        if required_approvals is None and 'requiredApprovals' in kwargs:
            required_approvals = kwargs['requiredApprovals']
        if user_id is None and 'userId' in kwargs:
            user_id = kwargs['userId']

        if access_level is not None:
            _setter("access_level", access_level)
        if access_level_description is not None:
            _setter("access_level_description", access_level_description)
        if group_id is not None:
            _setter("group_id", group_id)
        if id is not None:
            _setter("id", id)
        if required_approvals is not None:
            _setter("required_approvals", required_approvals)
        if user_id is not None:
            _setter("user_id", user_id)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[str]]:
        """
        Levels of access allowed to approve a deployment to this protected environment. Valid values are `developer`, `maintainer`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[pulumi.Input[str]]:
        """
        Readable description of level of access.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level_description", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the group allowed to approve a deployment to this protected environment. The project must be shared with the group. This is mutually exclusive with user_id.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        The unique ID of the Approval Rules object.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="requiredApprovals")
    def required_approvals(self) -> Optional[pulumi.Input[int]]:
        """
        The number of approval required to allow deployment to this protected environment. This is mutually exclusive with user_id.
        """
        return pulumi.get(self, "required_approvals")

    @required_approvals.setter
    def required_approvals(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "required_approvals", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the user allowed to approve a deployment to this protected environment. The user must be a member of the project. This is mutually exclusive with group*id and required*approvals.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "user_id", value)


@pulumi.input_type
class ProjectProtectedEnvironmentDeployAccessLevelArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[str]] = None,
                 access_level_description: Optional[pulumi.Input[str]] = None,
                 group_id: Optional[pulumi.Input[int]] = None,
                 id: Optional[pulumi.Input[int]] = None,
                 user_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] access_level: Levels of access required to deploy to this protected environment. Valid values are `developer`, `maintainer`.
        :param pulumi.Input[str] access_level_description: Readable description of level of access.
        :param pulumi.Input[int] group_id: The ID of the group allowed to deploy to this protected environment. The project must be shared with the group.
        :param pulumi.Input[int] id: The unique ID of the Deploy Access Level object.
        :param pulumi.Input[int] user_id: The ID of the user allowed to deploy to this protected environment. The user must be a member of the project.
        """
        ProjectProtectedEnvironmentDeployAccessLevelArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_level=access_level,
            access_level_description=access_level_description,
            group_id=group_id,
            id=id,
            user_id=user_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_level: Optional[pulumi.Input[str]] = None,
             access_level_description: Optional[pulumi.Input[str]] = None,
             group_id: Optional[pulumi.Input[int]] = None,
             id: Optional[pulumi.Input[int]] = None,
             user_id: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if access_level is None and 'accessLevel' in kwargs:
            access_level = kwargs['accessLevel']
        if access_level_description is None and 'accessLevelDescription' in kwargs:
            access_level_description = kwargs['accessLevelDescription']
        if group_id is None and 'groupId' in kwargs:
            group_id = kwargs['groupId']
        if user_id is None and 'userId' in kwargs:
            user_id = kwargs['userId']

        if access_level is not None:
            _setter("access_level", access_level)
        if access_level_description is not None:
            _setter("access_level_description", access_level_description)
        if group_id is not None:
            _setter("group_id", group_id)
        if id is not None:
            _setter("id", id)
        if user_id is not None:
            _setter("user_id", user_id)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[str]]:
        """
        Levels of access required to deploy to this protected environment. Valid values are `developer`, `maintainer`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[pulumi.Input[str]]:
        """
        Readable description of level of access.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level_description", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the group allowed to deploy to this protected environment. The project must be shared with the group.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        The unique ID of the Deploy Access Level object.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the user allowed to deploy to this protected environment. The user must be a member of the project.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "user_id", value)


@pulumi.input_type
class ProjectPushRulesArgs:
    def __init__(__self__, *,
                 author_email_regex: Optional[pulumi.Input[str]] = None,
                 branch_name_regex: Optional[pulumi.Input[str]] = None,
                 commit_committer_check: Optional[pulumi.Input[bool]] = None,
                 commit_message_negative_regex: Optional[pulumi.Input[str]] = None,
                 commit_message_regex: Optional[pulumi.Input[str]] = None,
                 deny_delete_tag: Optional[pulumi.Input[bool]] = None,
                 file_name_regex: Optional[pulumi.Input[str]] = None,
                 max_file_size: Optional[pulumi.Input[int]] = None,
                 member_check: Optional[pulumi.Input[bool]] = None,
                 prevent_secrets: Optional[pulumi.Input[bool]] = None,
                 reject_unsigned_commits: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] author_email_regex: All commit author emails must match this regex, e.g. `@my-company.com$`.
        :param pulumi.Input[str] branch_name_regex: All branch names must match this regex, e.g. `(feature|hotfix)\\/*`.
        :param pulumi.Input[bool] commit_committer_check: Users can only push commits to this repository that were committed with one of their own verified emails.
        :param pulumi.Input[str] commit_message_negative_regex: No commit message is allowed to match this regex, for example `ssh\\:\\/\\/`.
        :param pulumi.Input[str] commit_message_regex: All commit messages must match this regex, e.g. `Fixed \\d+\\..*`.
        :param pulumi.Input[bool] deny_delete_tag: Deny deleting a tag.
        :param pulumi.Input[str] file_name_regex: All committed filenames must not match this regex, e.g. `(jar|exe)$`.
        :param pulumi.Input[int] max_file_size: Maximum file size (MB).
        :param pulumi.Input[bool] member_check: Restrict commits by author (email) to existing GitLab users.
        :param pulumi.Input[bool] prevent_secrets: GitLab will reject any files that are likely to contain secrets.
        :param pulumi.Input[bool] reject_unsigned_commits: Reject commit when its not signed through GPG.
        """
        ProjectPushRulesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            author_email_regex=author_email_regex,
            branch_name_regex=branch_name_regex,
            commit_committer_check=commit_committer_check,
            commit_message_negative_regex=commit_message_negative_regex,
            commit_message_regex=commit_message_regex,
            deny_delete_tag=deny_delete_tag,
            file_name_regex=file_name_regex,
            max_file_size=max_file_size,
            member_check=member_check,
            prevent_secrets=prevent_secrets,
            reject_unsigned_commits=reject_unsigned_commits,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             author_email_regex: Optional[pulumi.Input[str]] = None,
             branch_name_regex: Optional[pulumi.Input[str]] = None,
             commit_committer_check: Optional[pulumi.Input[bool]] = None,
             commit_message_negative_regex: Optional[pulumi.Input[str]] = None,
             commit_message_regex: Optional[pulumi.Input[str]] = None,
             deny_delete_tag: Optional[pulumi.Input[bool]] = None,
             file_name_regex: Optional[pulumi.Input[str]] = None,
             max_file_size: Optional[pulumi.Input[int]] = None,
             member_check: Optional[pulumi.Input[bool]] = None,
             prevent_secrets: Optional[pulumi.Input[bool]] = None,
             reject_unsigned_commits: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if author_email_regex is None and 'authorEmailRegex' in kwargs:
            author_email_regex = kwargs['authorEmailRegex']
        if branch_name_regex is None and 'branchNameRegex' in kwargs:
            branch_name_regex = kwargs['branchNameRegex']
        if commit_committer_check is None and 'commitCommitterCheck' in kwargs:
            commit_committer_check = kwargs['commitCommitterCheck']
        if commit_message_negative_regex is None and 'commitMessageNegativeRegex' in kwargs:
            commit_message_negative_regex = kwargs['commitMessageNegativeRegex']
        if commit_message_regex is None and 'commitMessageRegex' in kwargs:
            commit_message_regex = kwargs['commitMessageRegex']
        if deny_delete_tag is None and 'denyDeleteTag' in kwargs:
            deny_delete_tag = kwargs['denyDeleteTag']
        if file_name_regex is None and 'fileNameRegex' in kwargs:
            file_name_regex = kwargs['fileNameRegex']
        if max_file_size is None and 'maxFileSize' in kwargs:
            max_file_size = kwargs['maxFileSize']
        if member_check is None and 'memberCheck' in kwargs:
            member_check = kwargs['memberCheck']
        if prevent_secrets is None and 'preventSecrets' in kwargs:
            prevent_secrets = kwargs['preventSecrets']
        if reject_unsigned_commits is None and 'rejectUnsignedCommits' in kwargs:
            reject_unsigned_commits = kwargs['rejectUnsignedCommits']

        if author_email_regex is not None:
            _setter("author_email_regex", author_email_regex)
        if branch_name_regex is not None:
            _setter("branch_name_regex", branch_name_regex)
        if commit_committer_check is not None:
            _setter("commit_committer_check", commit_committer_check)
        if commit_message_negative_regex is not None:
            _setter("commit_message_negative_regex", commit_message_negative_regex)
        if commit_message_regex is not None:
            _setter("commit_message_regex", commit_message_regex)
        if deny_delete_tag is not None:
            _setter("deny_delete_tag", deny_delete_tag)
        if file_name_regex is not None:
            _setter("file_name_regex", file_name_regex)
        if max_file_size is not None:
            _setter("max_file_size", max_file_size)
        if member_check is not None:
            _setter("member_check", member_check)
        if prevent_secrets is not None:
            _setter("prevent_secrets", prevent_secrets)
        if reject_unsigned_commits is not None:
            _setter("reject_unsigned_commits", reject_unsigned_commits)

    @property
    @pulumi.getter(name="authorEmailRegex")
    def author_email_regex(self) -> Optional[pulumi.Input[str]]:
        """
        All commit author emails must match this regex, e.g. `@my-company.com$`.
        """
        return pulumi.get(self, "author_email_regex")

    @author_email_regex.setter
    def author_email_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "author_email_regex", value)

    @property
    @pulumi.getter(name="branchNameRegex")
    def branch_name_regex(self) -> Optional[pulumi.Input[str]]:
        """
        All branch names must match this regex, e.g. `(feature|hotfix)\\/*`.
        """
        return pulumi.get(self, "branch_name_regex")

    @branch_name_regex.setter
    def branch_name_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch_name_regex", value)

    @property
    @pulumi.getter(name="commitCommitterCheck")
    def commit_committer_check(self) -> Optional[pulumi.Input[bool]]:
        """
        Users can only push commits to this repository that were committed with one of their own verified emails.
        """
        return pulumi.get(self, "commit_committer_check")

    @commit_committer_check.setter
    def commit_committer_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "commit_committer_check", value)

    @property
    @pulumi.getter(name="commitMessageNegativeRegex")
    def commit_message_negative_regex(self) -> Optional[pulumi.Input[str]]:
        """
        No commit message is allowed to match this regex, for example `ssh\\:\\/\\/`.
        """
        return pulumi.get(self, "commit_message_negative_regex")

    @commit_message_negative_regex.setter
    def commit_message_negative_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "commit_message_negative_regex", value)

    @property
    @pulumi.getter(name="commitMessageRegex")
    def commit_message_regex(self) -> Optional[pulumi.Input[str]]:
        """
        All commit messages must match this regex, e.g. `Fixed \\d+\\..*`.
        """
        return pulumi.get(self, "commit_message_regex")

    @commit_message_regex.setter
    def commit_message_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "commit_message_regex", value)

    @property
    @pulumi.getter(name="denyDeleteTag")
    def deny_delete_tag(self) -> Optional[pulumi.Input[bool]]:
        """
        Deny deleting a tag.
        """
        return pulumi.get(self, "deny_delete_tag")

    @deny_delete_tag.setter
    def deny_delete_tag(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deny_delete_tag", value)

    @property
    @pulumi.getter(name="fileNameRegex")
    def file_name_regex(self) -> Optional[pulumi.Input[str]]:
        """
        All committed filenames must not match this regex, e.g. `(jar|exe)$`.
        """
        return pulumi.get(self, "file_name_regex")

    @file_name_regex.setter
    def file_name_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_name_regex", value)

    @property
    @pulumi.getter(name="maxFileSize")
    def max_file_size(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum file size (MB).
        """
        return pulumi.get(self, "max_file_size")

    @max_file_size.setter
    def max_file_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_file_size", value)

    @property
    @pulumi.getter(name="memberCheck")
    def member_check(self) -> Optional[pulumi.Input[bool]]:
        """
        Restrict commits by author (email) to existing GitLab users.
        """
        return pulumi.get(self, "member_check")

    @member_check.setter
    def member_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "member_check", value)

    @property
    @pulumi.getter(name="preventSecrets")
    def prevent_secrets(self) -> Optional[pulumi.Input[bool]]:
        """
        GitLab will reject any files that are likely to contain secrets.
        """
        return pulumi.get(self, "prevent_secrets")

    @prevent_secrets.setter
    def prevent_secrets(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "prevent_secrets", value)

    @property
    @pulumi.getter(name="rejectUnsignedCommits")
    def reject_unsigned_commits(self) -> Optional[pulumi.Input[bool]]:
        """
        Reject commit when its not signed through GPG.
        """
        return pulumi.get(self, "reject_unsigned_commits")

    @reject_unsigned_commits.setter
    def reject_unsigned_commits(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "reject_unsigned_commits", value)


@pulumi.input_type
class ProjectTagCommitArgs:
    def __init__(__self__, *,
                 author_email: Optional[pulumi.Input[str]] = None,
                 author_name: Optional[pulumi.Input[str]] = None,
                 authored_date: Optional[pulumi.Input[str]] = None,
                 committed_date: Optional[pulumi.Input[str]] = None,
                 committer_email: Optional[pulumi.Input[str]] = None,
                 committer_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 parent_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 short_id: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        ProjectTagCommitArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            author_email=author_email,
            author_name=author_name,
            authored_date=authored_date,
            committed_date=committed_date,
            committer_email=committer_email,
            committer_name=committer_name,
            id=id,
            message=message,
            parent_ids=parent_ids,
            short_id=short_id,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             author_email: Optional[pulumi.Input[str]] = None,
             author_name: Optional[pulumi.Input[str]] = None,
             authored_date: Optional[pulumi.Input[str]] = None,
             committed_date: Optional[pulumi.Input[str]] = None,
             committer_email: Optional[pulumi.Input[str]] = None,
             committer_name: Optional[pulumi.Input[str]] = None,
             id: Optional[pulumi.Input[str]] = None,
             message: Optional[pulumi.Input[str]] = None,
             parent_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             short_id: Optional[pulumi.Input[str]] = None,
             title: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if author_email is None and 'authorEmail' in kwargs:
            author_email = kwargs['authorEmail']
        if author_name is None and 'authorName' in kwargs:
            author_name = kwargs['authorName']
        if authored_date is None and 'authoredDate' in kwargs:
            authored_date = kwargs['authoredDate']
        if committed_date is None and 'committedDate' in kwargs:
            committed_date = kwargs['committedDate']
        if committer_email is None and 'committerEmail' in kwargs:
            committer_email = kwargs['committerEmail']
        if committer_name is None and 'committerName' in kwargs:
            committer_name = kwargs['committerName']
        if parent_ids is None and 'parentIds' in kwargs:
            parent_ids = kwargs['parentIds']
        if short_id is None and 'shortId' in kwargs:
            short_id = kwargs['shortId']

        if author_email is not None:
            _setter("author_email", author_email)
        if author_name is not None:
            _setter("author_name", author_name)
        if authored_date is not None:
            _setter("authored_date", authored_date)
        if committed_date is not None:
            _setter("committed_date", committed_date)
        if committer_email is not None:
            _setter("committer_email", committer_email)
        if committer_name is not None:
            _setter("committer_name", committer_name)
        if id is not None:
            _setter("id", id)
        if message is not None:
            _setter("message", message)
        if parent_ids is not None:
            _setter("parent_ids", parent_ids)
        if short_id is not None:
            _setter("short_id", short_id)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="authorEmail")
    def author_email(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "author_email")

    @author_email.setter
    def author_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "author_email", value)

    @property
    @pulumi.getter(name="authorName")
    def author_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "author_name")

    @author_name.setter
    def author_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "author_name", value)

    @property
    @pulumi.getter(name="authoredDate")
    def authored_date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "authored_date")

    @authored_date.setter
    def authored_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authored_date", value)

    @property
    @pulumi.getter(name="committedDate")
    def committed_date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "committed_date")

    @committed_date.setter
    def committed_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "committed_date", value)

    @property
    @pulumi.getter(name="committerEmail")
    def committer_email(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "committer_email")

    @committer_email.setter
    def committer_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "committer_email", value)

    @property
    @pulumi.getter(name="committerName")
    def committer_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "committer_name")

    @committer_name.setter
    def committer_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "committer_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="parentIds")
    def parent_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "parent_ids")

    @parent_ids.setter
    def parent_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "parent_ids", value)

    @property
    @pulumi.getter(name="shortId")
    def short_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "short_id")

    @short_id.setter
    def short_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "short_id", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


@pulumi.input_type
class ProjectTagReleaseArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 tag_name: Optional[pulumi.Input[str]] = None):
        ProjectTagReleaseArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            tag_name=tag_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[pulumi.Input[str]] = None,
             tag_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if tag_name is None and 'tagName' in kwargs:
            tag_name = kwargs['tagName']

        if description is not None:
            _setter("description", description)
        if tag_name is not None:
            _setter("tag_name", tag_name)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)


@pulumi.input_type
class TagProtectionAllowedToCreateArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[str]] = None,
                 access_level_description: Optional[pulumi.Input[str]] = None,
                 group_id: Optional[pulumi.Input[int]] = None,
                 user_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] access_level: Level of access.
        :param pulumi.Input[str] access_level_description: Readable description of level of access.
        :param pulumi.Input[int] group_id: The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        :param pulumi.Input[int] user_id: The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        TagProtectionAllowedToCreateArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_level=access_level,
            access_level_description=access_level_description,
            group_id=group_id,
            user_id=user_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_level: Optional[pulumi.Input[str]] = None,
             access_level_description: Optional[pulumi.Input[str]] = None,
             group_id: Optional[pulumi.Input[int]] = None,
             user_id: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if access_level is None and 'accessLevel' in kwargs:
            access_level = kwargs['accessLevel']
        if access_level_description is None and 'accessLevelDescription' in kwargs:
            access_level_description = kwargs['accessLevelDescription']
        if group_id is None and 'groupId' in kwargs:
            group_id = kwargs['groupId']
        if user_id is None and 'userId' in kwargs:
            user_id = kwargs['userId']

        if access_level is not None:
            _setter("access_level", access_level)
        if access_level_description is not None:
            _setter("access_level_description", access_level_description)
        if group_id is not None:
            _setter("group_id", group_id)
        if user_id is not None:
            _setter("user_id", user_id)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[str]]:
        """
        Level of access.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[pulumi.Input[str]]:
        """
        Readable description of level of access.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level_description", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "user_id", value)


