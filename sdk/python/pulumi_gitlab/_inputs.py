# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'ApplicationSettingsDefaultBranchProtectionDefaultsArgs',
    'ApplicationSettingsDefaultBranchProtectionDefaultsArgsDict',
    'BranchCommitArgs',
    'BranchCommitArgsDict',
    'BranchProtectionAllowedToMergeArgs',
    'BranchProtectionAllowedToMergeArgsDict',
    'BranchProtectionAllowedToPushArgs',
    'BranchProtectionAllowedToPushArgsDict',
    'BranchProtectionAllowedToUnprotectArgs',
    'BranchProtectionAllowedToUnprotectArgsDict',
    'GroupAccessTokenRotationConfigurationArgs',
    'GroupAccessTokenRotationConfigurationArgsDict',
    'GroupDefaultBranchProtectionDefaultsArgs',
    'GroupDefaultBranchProtectionDefaultsArgsDict',
    'GroupEpicBoardListArgs',
    'GroupEpicBoardListArgsDict',
    'GroupHookCustomHeaderArgs',
    'GroupHookCustomHeaderArgsDict',
    'GroupIssueBoardListArgs',
    'GroupIssueBoardListArgsDict',
    'GroupProtectedEnvironmentApprovalRuleArgs',
    'GroupProtectedEnvironmentApprovalRuleArgsDict',
    'GroupProtectedEnvironmentDeployAccessLevelArgs',
    'GroupProtectedEnvironmentDeployAccessLevelArgsDict',
    'GroupPushRulesArgs',
    'GroupPushRulesArgsDict',
    'GroupServiceAccountAccessTokenRotationConfigurationArgs',
    'GroupServiceAccountAccessTokenRotationConfigurationArgsDict',
    'GroupServiceAccountTimeoutsArgs',
    'GroupServiceAccountTimeoutsArgsDict',
    'InstanceServiceAccountTimeoutsArgs',
    'InstanceServiceAccountTimeoutsArgsDict',
    'PersonalAccessTokenRotationConfigurationArgs',
    'PersonalAccessTokenRotationConfigurationArgsDict',
    'ProjectAccessTokenRotationConfigurationArgs',
    'ProjectAccessTokenRotationConfigurationArgsDict',
    'ProjectContainerExpirationPolicyArgs',
    'ProjectContainerExpirationPolicyArgsDict',
    'ProjectHookCustomHeaderArgs',
    'ProjectHookCustomHeaderArgsDict',
    'ProjectIssueBoardListArgs',
    'ProjectIssueBoardListArgsDict',
    'ProjectIssueTaskCompletionStatusArgs',
    'ProjectIssueTaskCompletionStatusArgsDict',
    'ProjectPagesSettingsDeploymentArgs',
    'ProjectPagesSettingsDeploymentArgsDict',
    'ProjectProtectedEnvironmentApprovalRuleArgs',
    'ProjectProtectedEnvironmentApprovalRuleArgsDict',
    'ProjectProtectedEnvironmentDeployAccessLevelArgs',
    'ProjectProtectedEnvironmentDeployAccessLevelArgsDict',
    'ProjectProtectedEnvironmentDeployAccessLevelsAttributeArgs',
    'ProjectProtectedEnvironmentDeployAccessLevelsAttributeArgsDict',
    'ProjectPushRulesArgs',
    'ProjectPushRulesArgsDict',
    'ProjectTagCommitArgs',
    'ProjectTagCommitArgsDict',
    'ProjectTagReleaseArgs',
    'ProjectTagReleaseArgsDict',
    'ReleaseAssetsArgs',
    'ReleaseAssetsArgsDict',
    'ReleaseAuthorArgs',
    'ReleaseAuthorArgsDict',
    'ReleaseCommitArgs',
    'ReleaseCommitArgsDict',
    'ReleaseLinksArgs',
    'ReleaseLinksArgsDict',
    'TagProtectionAllowedToCreateArgs',
    'TagProtectionAllowedToCreateArgsDict',
    'ValueStreamAnalyticsStageArgs',
    'ValueStreamAnalyticsStageArgsDict',
    'GetGroupProvisionedUsersProvisionedUserArgs',
    'GetGroupProvisionedUsersProvisionedUserArgsDict',
    'GetProjectApprovalRulesApprovalRuleArgs',
    'GetProjectApprovalRulesApprovalRuleArgsDict',
    'GetProjectProtectedBranchMergeAccessLevelArgs',
    'GetProjectProtectedBranchMergeAccessLevelArgsDict',
    'GetProjectProtectedBranchPushAccessLevelArgs',
    'GetProjectProtectedBranchPushAccessLevelArgsDict',
    'GetProjectProtectedBranchesProtectedBranchArgs',
    'GetProjectProtectedBranchesProtectedBranchArgsDict',
    'GetProjectProtectedBranchesProtectedBranchMergeAccessLevelArgs',
    'GetProjectProtectedBranchesProtectedBranchMergeAccessLevelArgsDict',
    'GetProjectProtectedBranchesProtectedBranchPushAccessLevelArgs',
    'GetProjectProtectedBranchesProtectedBranchPushAccessLevelArgsDict',
    'GetReleaseAssetsArgs',
    'GetReleaseAssetsArgsDict',
    'GetReleaseAssetsLinkArgs',
    'GetReleaseAssetsLinkArgsDict',
    'GetReleaseAssetsSourceArgs',
    'GetReleaseAssetsSourceArgsDict',
    'GetSecurityPolicyDocumentScanExecutionPolicyArgs',
    'GetSecurityPolicyDocumentScanExecutionPolicyArgsDict',
    'GetSecurityPolicyDocumentScanExecutionPolicyActionArgs',
    'GetSecurityPolicyDocumentScanExecutionPolicyActionArgsDict',
    'GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeArgs',
    'GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeArgsDict',
    'GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeProjectsArgs',
    'GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeProjectsArgsDict',
    'GetSecurityPolicyDocumentScanExecutionPolicyRuleArgs',
    'GetSecurityPolicyDocumentScanExecutionPolicyRuleArgsDict',
    'GetSecurityPolicyDocumentScanExecutionPolicySkipCiArgs',
    'GetSecurityPolicyDocumentScanExecutionPolicySkipCiArgsDict',
]

MYPY = False

if not MYPY:
    class ApplicationSettingsDefaultBranchProtectionDefaultsArgsDict(TypedDict):
        allow_force_push: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow force push for all users with push access.
        """
        allowed_to_merges: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        An array of access levels allowed to merge. Supports Developer (30) or Maintainer (40).
        """
        allowed_to_pushes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        An array of access levels allowed to push. Supports Developer (30) or Maintainer (40).
        """
        developer_can_initial_push: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow developers to initial push.
        """
elif False:
    ApplicationSettingsDefaultBranchProtectionDefaultsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationSettingsDefaultBranchProtectionDefaultsArgs:
    def __init__(__self__, *,
                 allow_force_push: Optional[pulumi.Input[_builtins.bool]] = None,
                 allowed_to_merges: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 allowed_to_pushes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 developer_can_initial_push: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_force_push: Allow force push for all users with push access.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] allowed_to_merges: An array of access levels allowed to merge. Supports Developer (30) or Maintainer (40).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] allowed_to_pushes: An array of access levels allowed to push. Supports Developer (30) or Maintainer (40).
        :param pulumi.Input[_builtins.bool] developer_can_initial_push: Allow developers to initial push.
        """
        if allow_force_push is not None:
            pulumi.set(__self__, "allow_force_push", allow_force_push)
        if allowed_to_merges is not None:
            pulumi.set(__self__, "allowed_to_merges", allowed_to_merges)
        if allowed_to_pushes is not None:
            pulumi.set(__self__, "allowed_to_pushes", allowed_to_pushes)
        if developer_can_initial_push is not None:
            pulumi.set(__self__, "developer_can_initial_push", developer_can_initial_push)

    @_builtins.property
    @pulumi.getter(name="allowForcePush")
    def allow_force_push(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow force push for all users with push access.
        """
        return pulumi.get(self, "allow_force_push")

    @allow_force_push.setter
    def allow_force_push(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_force_push", value)

    @_builtins.property
    @pulumi.getter(name="allowedToMerges")
    def allowed_to_merges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        An array of access levels allowed to merge. Supports Developer (30) or Maintainer (40).
        """
        return pulumi.get(self, "allowed_to_merges")

    @allowed_to_merges.setter
    def allowed_to_merges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "allowed_to_merges", value)

    @_builtins.property
    @pulumi.getter(name="allowedToPushes")
    def allowed_to_pushes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        An array of access levels allowed to push. Supports Developer (30) or Maintainer (40).
        """
        return pulumi.get(self, "allowed_to_pushes")

    @allowed_to_pushes.setter
    def allowed_to_pushes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "allowed_to_pushes", value)

    @_builtins.property
    @pulumi.getter(name="developerCanInitialPush")
    def developer_can_initial_push(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow developers to initial push.
        """
        return pulumi.get(self, "developer_can_initial_push")

    @developer_can_initial_push.setter
    def developer_can_initial_push(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "developer_can_initial_push", value)


if not MYPY:
    class BranchCommitArgsDict(TypedDict):
        author_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        The email of the author.
        """
        author_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the author.
        """
        authored_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
        """
        committed_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
        """
        committer_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        The email of the user that committed.
        """
        committer_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the user that committed.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique id assigned to the commit by Gitlab.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        The commit message
        """
        parent_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The id of the parents of the commit
        """
        short_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The short id assigned to the commit by Gitlab.
        """
        title: NotRequired[pulumi.Input[_builtins.str]]
        """
        The title of the commit
        """
elif False:
    BranchCommitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchCommitArgs:
    def __init__(__self__, *,
                 author_email: Optional[pulumi.Input[_builtins.str]] = None,
                 author_name: Optional[pulumi.Input[_builtins.str]] = None,
                 authored_date: Optional[pulumi.Input[_builtins.str]] = None,
                 committed_date: Optional[pulumi.Input[_builtins.str]] = None,
                 committer_email: Optional[pulumi.Input[_builtins.str]] = None,
                 committer_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 parent_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 short_id: Optional[pulumi.Input[_builtins.str]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] author_email: The email of the author.
        :param pulumi.Input[_builtins.str] author_name: The name of the author.
        :param pulumi.Input[_builtins.str] authored_date: The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
        :param pulumi.Input[_builtins.str] committed_date: The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
        :param pulumi.Input[_builtins.str] committer_email: The email of the user that committed.
        :param pulumi.Input[_builtins.str] committer_name: The name of the user that committed.
        :param pulumi.Input[_builtins.str] id: The unique id assigned to the commit by Gitlab.
        :param pulumi.Input[_builtins.str] message: The commit message
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] parent_ids: The id of the parents of the commit
        :param pulumi.Input[_builtins.str] short_id: The short id assigned to the commit by Gitlab.
        :param pulumi.Input[_builtins.str] title: The title of the commit
        """
        if author_email is not None:
            pulumi.set(__self__, "author_email", author_email)
        if author_name is not None:
            pulumi.set(__self__, "author_name", author_name)
        if authored_date is not None:
            pulumi.set(__self__, "authored_date", authored_date)
        if committed_date is not None:
            pulumi.set(__self__, "committed_date", committed_date)
        if committer_email is not None:
            pulumi.set(__self__, "committer_email", committer_email)
        if committer_name is not None:
            pulumi.set(__self__, "committer_name", committer_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if parent_ids is not None:
            pulumi.set(__self__, "parent_ids", parent_ids)
        if short_id is not None:
            pulumi.set(__self__, "short_id", short_id)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter(name="authorEmail")
    def author_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The email of the author.
        """
        return pulumi.get(self, "author_email")

    @author_email.setter
    def author_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "author_email", value)

    @_builtins.property
    @pulumi.getter(name="authorName")
    def author_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the author.
        """
        return pulumi.get(self, "author_name")

    @author_name.setter
    def author_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "author_name", value)

    @_builtins.property
    @pulumi.getter(name="authoredDate")
    def authored_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
        """
        return pulumi.get(self, "authored_date")

    @authored_date.setter
    def authored_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authored_date", value)

    @_builtins.property
    @pulumi.getter(name="committedDate")
    def committed_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
        """
        return pulumi.get(self, "committed_date")

    @committed_date.setter
    def committed_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "committed_date", value)

    @_builtins.property
    @pulumi.getter(name="committerEmail")
    def committer_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The email of the user that committed.
        """
        return pulumi.get(self, "committer_email")

    @committer_email.setter
    def committer_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "committer_email", value)

    @_builtins.property
    @pulumi.getter(name="committerName")
    def committer_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the user that committed.
        """
        return pulumi.get(self, "committer_name")

    @committer_name.setter
    def committer_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "committer_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique id assigned to the commit by Gitlab.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The commit message
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter(name="parentIds")
    def parent_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The id of the parents of the commit
        """
        return pulumi.get(self, "parent_ids")

    @parent_ids.setter
    def parent_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "parent_ids", value)

    @_builtins.property
    @pulumi.getter(name="shortId")
    def short_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The short id assigned to the commit by Gitlab.
        """
        return pulumi.get(self, "short_id")

    @short_id.setter
    def short_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_id", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The title of the commit
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class BranchProtectionAllowedToMergeArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        """
        access_level_description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Readable description of access level.
        """
        group_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        user_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
elif False:
    BranchProtectionAllowedToMergeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchProtectionAllowedToMergeArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[_builtins.str]] = None,
                 access_level_description: Optional[pulumi.Input[_builtins.str]] = None,
                 group_id: Optional[pulumi.Input[_builtins.int]] = None,
                 user_id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] access_level: Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        :param pulumi.Input[_builtins.str] access_level_description: Readable description of access level.
        :param pulumi.Input[_builtins.int] group_id: The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        :param pulumi.Input[_builtins.int] user_id: The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_level_description is not None:
            pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_level", value)

    @_builtins.property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Readable description of access level.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_level_description", value)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "group_id", value)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class BranchProtectionAllowedToPushArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        """
        access_level_description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Readable description of access level.
        """
        deploy_key_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `group_id` and `user_id`. This field is read-only until Gitlab 17.5.
        """
        group_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `user_id`.
        """
        user_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `group_id`.
        """
elif False:
    BranchProtectionAllowedToPushArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchProtectionAllowedToPushArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[_builtins.str]] = None,
                 access_level_description: Optional[pulumi.Input[_builtins.str]] = None,
                 deploy_key_id: Optional[pulumi.Input[_builtins.int]] = None,
                 group_id: Optional[pulumi.Input[_builtins.int]] = None,
                 user_id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] access_level: Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        :param pulumi.Input[_builtins.str] access_level_description: Readable description of access level.
        :param pulumi.Input[_builtins.int] deploy_key_id: The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `group_id` and `user_id`. This field is read-only until Gitlab 17.5.
        :param pulumi.Input[_builtins.int] group_id: The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `user_id`.
        :param pulumi.Input[_builtins.int] user_id: The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `group_id`.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_level_description is not None:
            pulumi.set(__self__, "access_level_description", access_level_description)
        if deploy_key_id is not None:
            pulumi.set(__self__, "deploy_key_id", deploy_key_id)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_level", value)

    @_builtins.property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Readable description of access level.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_level_description", value)

    @_builtins.property
    @pulumi.getter(name="deployKeyId")
    def deploy_key_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `group_id` and `user_id`. This field is read-only until Gitlab 17.5.
        """
        return pulumi.get(self, "deploy_key_id")

    @deploy_key_id.setter
    def deploy_key_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "deploy_key_id", value)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "group_id", value)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class BranchProtectionAllowedToUnprotectArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access levels allowed to unprotect push to protected branch. Valid values are: `developer`, `maintainer`, `admin`.
        """
        access_level_description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Readable description of access level.
        """
        group_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        user_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
elif False:
    BranchProtectionAllowedToUnprotectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchProtectionAllowedToUnprotectArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[_builtins.str]] = None,
                 access_level_description: Optional[pulumi.Input[_builtins.str]] = None,
                 group_id: Optional[pulumi.Input[_builtins.int]] = None,
                 user_id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] access_level: Access levels allowed to unprotect push to protected branch. Valid values are: `developer`, `maintainer`, `admin`.
        :param pulumi.Input[_builtins.str] access_level_description: Readable description of access level.
        :param pulumi.Input[_builtins.int] group_id: The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        :param pulumi.Input[_builtins.int] user_id: The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_level_description is not None:
            pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access levels allowed to unprotect push to protected branch. Valid values are: `developer`, `maintainer`, `admin`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_level", value)

    @_builtins.property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Readable description of access level.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_level_description", value)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "group_id", value)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class GroupAccessTokenRotationConfigurationArgsDict(TypedDict):
        expiration_days: pulumi.Input[_builtins.int]
        """
        The duration (in days) the new token should be valid for.
        """
        rotate_before_days: pulumi.Input[_builtins.int]
        """
        The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
elif False:
    GroupAccessTokenRotationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupAccessTokenRotationConfigurationArgs:
    def __init__(__self__, *,
                 expiration_days: pulumi.Input[_builtins.int],
                 rotate_before_days: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] expiration_days: The duration (in days) the new token should be valid for.
        :param pulumi.Input[_builtins.int] rotate_before_days: The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
        pulumi.set(__self__, "expiration_days", expiration_days)
        pulumi.set(__self__, "rotate_before_days", rotate_before_days)

    @_builtins.property
    @pulumi.getter(name="expirationDays")
    def expiration_days(self) -> pulumi.Input[_builtins.int]:
        """
        The duration (in days) the new token should be valid for.
        """
        return pulumi.get(self, "expiration_days")

    @expiration_days.setter
    def expiration_days(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "expiration_days", value)

    @_builtins.property
    @pulumi.getter(name="rotateBeforeDays")
    def rotate_before_days(self) -> pulumi.Input[_builtins.int]:
        """
        The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
        return pulumi.get(self, "rotate_before_days")

    @rotate_before_days.setter
    def rotate_before_days(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "rotate_before_days", value)


if not MYPY:
    class GroupDefaultBranchProtectionDefaultsArgsDict(TypedDict):
        allow_force_push: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow force push for all users with push access.
        """
        allowed_to_merges: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An array of access levels allowed to merge. Valid values are: `developer`, `maintainer`, `no one`.
        """
        allowed_to_pushes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An array of access levels allowed to push. Valid values are: `developer`, `maintainer`, `no one`.
        """
        developer_can_initial_push: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow developers to initial push.
        """
elif False:
    GroupDefaultBranchProtectionDefaultsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupDefaultBranchProtectionDefaultsArgs:
    def __init__(__self__, *,
                 allow_force_push: Optional[pulumi.Input[_builtins.bool]] = None,
                 allowed_to_merges: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allowed_to_pushes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 developer_can_initial_push: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_force_push: Allow force push for all users with push access.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_to_merges: An array of access levels allowed to merge. Valid values are: `developer`, `maintainer`, `no one`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_to_pushes: An array of access levels allowed to push. Valid values are: `developer`, `maintainer`, `no one`.
        :param pulumi.Input[_builtins.bool] developer_can_initial_push: Allow developers to initial push.
        """
        if allow_force_push is not None:
            pulumi.set(__self__, "allow_force_push", allow_force_push)
        if allowed_to_merges is not None:
            pulumi.set(__self__, "allowed_to_merges", allowed_to_merges)
        if allowed_to_pushes is not None:
            pulumi.set(__self__, "allowed_to_pushes", allowed_to_pushes)
        if developer_can_initial_push is not None:
            pulumi.set(__self__, "developer_can_initial_push", developer_can_initial_push)

    @_builtins.property
    @pulumi.getter(name="allowForcePush")
    def allow_force_push(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow force push for all users with push access.
        """
        return pulumi.get(self, "allow_force_push")

    @allow_force_push.setter
    def allow_force_push(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_force_push", value)

    @_builtins.property
    @pulumi.getter(name="allowedToMerges")
    def allowed_to_merges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An array of access levels allowed to merge. Valid values are: `developer`, `maintainer`, `no one`.
        """
        return pulumi.get(self, "allowed_to_merges")

    @allowed_to_merges.setter
    def allowed_to_merges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_to_merges", value)

    @_builtins.property
    @pulumi.getter(name="allowedToPushes")
    def allowed_to_pushes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An array of access levels allowed to push. Valid values are: `developer`, `maintainer`, `no one`.
        """
        return pulumi.get(self, "allowed_to_pushes")

    @allowed_to_pushes.setter
    def allowed_to_pushes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_to_pushes", value)

    @_builtins.property
    @pulumi.getter(name="developerCanInitialPush")
    def developer_can_initial_push(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow developers to initial push.
        """
        return pulumi.get(self, "developer_can_initial_push")

    @developer_can_initial_push.setter
    def developer_can_initial_push(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "developer_can_initial_push", value)


if not MYPY:
    class GroupEpicBoardListArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the list.
        """
        label_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the label the list should be scoped to.
        """
        position: NotRequired[pulumi.Input[_builtins.int]]
        """
        The position of the list within the board. The position for the list is sed on the its position in the `lists` array.
        """
elif False:
    GroupEpicBoardListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupEpicBoardListArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None,
                 label_id: Optional[pulumi.Input[_builtins.int]] = None,
                 position: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] id: The ID of the list.
        :param pulumi.Input[_builtins.int] label_id: The ID of the label the list should be scoped to.
        :param pulumi.Input[_builtins.int] position: The position of the list within the board. The position for the list is sed on the its position in the `lists` array.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if label_id is not None:
            pulumi.set(__self__, "label_id", label_id)
        if position is not None:
            pulumi.set(__self__, "position", position)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="labelId")
    def label_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the label the list should be scoped to.
        """
        return pulumi.get(self, "label_id")

    @label_id.setter
    def label_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "label_id", value)

    @_builtins.property
    @pulumi.getter
    def position(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The position of the list within the board. The position for the list is sed on the its position in the `lists` array.
        """
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "position", value)


if not MYPY:
    class GroupHookCustomHeaderArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Key of the custom header.
        """
        value: pulumi.Input[_builtins.str]
        """
        Value of the custom header. This value cannot be imported.
        """
elif False:
    GroupHookCustomHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupHookCustomHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: Key of the custom header.
        :param pulumi.Input[_builtins.str] value: Value of the custom header. This value cannot be imported.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Key of the custom header.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Value of the custom header. This value cannot be imported.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GroupIssueBoardListArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the list.
        """
        label_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the label the list should be scoped to.
        """
        position: NotRequired[pulumi.Input[_builtins.int]]
        """
        The explicit position of the list within the board, zero based.
        """
elif False:
    GroupIssueBoardListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupIssueBoardListArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None,
                 label_id: Optional[pulumi.Input[_builtins.int]] = None,
                 position: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] id: The ID of the list.
        :param pulumi.Input[_builtins.int] label_id: The ID of the label the list should be scoped to.
        :param pulumi.Input[_builtins.int] position: The explicit position of the list within the board, zero based.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if label_id is not None:
            pulumi.set(__self__, "label_id", label_id)
        if position is not None:
            pulumi.set(__self__, "position", position)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="labelId")
    def label_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the label the list should be scoped to.
        """
        return pulumi.get(self, "label_id")

    @label_id.setter
    def label_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "label_id", value)

    @_builtins.property
    @pulumi.getter
    def position(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The explicit position of the list within the board, zero based.
        """
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "position", value)


if not MYPY:
    class GroupProtectedEnvironmentApprovalRuleArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        Levels of access allowed to approve a deployment to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        """
        access_level_description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Readable description of level of access.
        """
        group_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the group allowed to approve a deployment to this protected environment. TThe group must be a sub-group under the given group. Mutually exclusive with `access_level` and `user_id`.
        """
        group_inheritance_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        Group inheritance allows access rules to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        """
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The unique ID of the Approval Rules object.
        """
        required_approvals: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of approval required to allow deployment to this protected environment. This is mutually exclusive with user_id.
        """
        user_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the user allowed to approve a deployment to this protected environment. The user must be a member of the group with Maintainer role or higher. Mutually exclusive with `access_level` and `group_id`.
        """
elif False:
    GroupProtectedEnvironmentApprovalRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupProtectedEnvironmentApprovalRuleArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[_builtins.str]] = None,
                 access_level_description: Optional[pulumi.Input[_builtins.str]] = None,
                 group_id: Optional[pulumi.Input[_builtins.int]] = None,
                 group_inheritance_type: Optional[pulumi.Input[_builtins.int]] = None,
                 id: Optional[pulumi.Input[_builtins.int]] = None,
                 required_approvals: Optional[pulumi.Input[_builtins.int]] = None,
                 user_id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] access_level: Levels of access allowed to approve a deployment to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        :param pulumi.Input[_builtins.str] access_level_description: Readable description of level of access.
        :param pulumi.Input[_builtins.int] group_id: The ID of the group allowed to approve a deployment to this protected environment. TThe group must be a sub-group under the given group. Mutually exclusive with `access_level` and `user_id`.
        :param pulumi.Input[_builtins.int] group_inheritance_type: Group inheritance allows access rules to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        :param pulumi.Input[_builtins.int] id: The unique ID of the Approval Rules object.
        :param pulumi.Input[_builtins.int] required_approvals: The number of approval required to allow deployment to this protected environment. This is mutually exclusive with user_id.
        :param pulumi.Input[_builtins.int] user_id: The ID of the user allowed to approve a deployment to this protected environment. The user must be a member of the group with Maintainer role or higher. Mutually exclusive with `access_level` and `group_id`.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_level_description is not None:
            pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if group_inheritance_type is not None:
            pulumi.set(__self__, "group_inheritance_type", group_inheritance_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if required_approvals is not None:
            pulumi.set(__self__, "required_approvals", required_approvals)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Levels of access allowed to approve a deployment to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_level", value)

    @_builtins.property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Readable description of level of access.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_level_description", value)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the group allowed to approve a deployment to this protected environment. TThe group must be a sub-group under the given group. Mutually exclusive with `access_level` and `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "group_id", value)

    @_builtins.property
    @pulumi.getter(name="groupInheritanceType")
    def group_inheritance_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Group inheritance allows access rules to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        """
        return pulumi.get(self, "group_inheritance_type")

    @group_inheritance_type.setter
    def group_inheritance_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "group_inheritance_type", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The unique ID of the Approval Rules object.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="requiredApprovals")
    def required_approvals(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of approval required to allow deployment to this protected environment. This is mutually exclusive with user_id.
        """
        return pulumi.get(self, "required_approvals")

    @required_approvals.setter
    def required_approvals(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "required_approvals", value)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the user allowed to approve a deployment to this protected environment. The user must be a member of the group with Maintainer role or higher. Mutually exclusive with `access_level` and `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class GroupProtectedEnvironmentDeployAccessLevelArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        Levels of access required to deploy to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        """
        access_level_description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Readable description of level of access.
        """
        group_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the group allowed to deploy to this protected environment. The group must be a sub-group under the given group. Mutually exclusive with `access_level` and `user_id`.
        """
        group_inheritance_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        """
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The unique ID of the Deploy Access Level object.
        """
        user_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the user allowed to deploy to this protected environment. The user must be a member of the group with Maintainer role or higher. Mutually exclusive with `access_level` and `group_id`.
        """
elif False:
    GroupProtectedEnvironmentDeployAccessLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupProtectedEnvironmentDeployAccessLevelArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[_builtins.str]] = None,
                 access_level_description: Optional[pulumi.Input[_builtins.str]] = None,
                 group_id: Optional[pulumi.Input[_builtins.int]] = None,
                 group_inheritance_type: Optional[pulumi.Input[_builtins.int]] = None,
                 id: Optional[pulumi.Input[_builtins.int]] = None,
                 user_id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] access_level: Levels of access required to deploy to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        :param pulumi.Input[_builtins.str] access_level_description: Readable description of level of access.
        :param pulumi.Input[_builtins.int] group_id: The ID of the group allowed to deploy to this protected environment. The group must be a sub-group under the given group. Mutually exclusive with `access_level` and `user_id`.
        :param pulumi.Input[_builtins.int] group_inheritance_type: Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        :param pulumi.Input[_builtins.int] id: The unique ID of the Deploy Access Level object.
        :param pulumi.Input[_builtins.int] user_id: The ID of the user allowed to deploy to this protected environment. The user must be a member of the group with Maintainer role or higher. Mutually exclusive with `access_level` and `group_id`.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_level_description is not None:
            pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if group_inheritance_type is not None:
            pulumi.set(__self__, "group_inheritance_type", group_inheritance_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Levels of access required to deploy to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_level", value)

    @_builtins.property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Readable description of level of access.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_level_description", value)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the group allowed to deploy to this protected environment. The group must be a sub-group under the given group. Mutually exclusive with `access_level` and `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "group_id", value)

    @_builtins.property
    @pulumi.getter(name="groupInheritanceType")
    def group_inheritance_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        """
        return pulumi.get(self, "group_inheritance_type")

    @group_inheritance_type.setter
    def group_inheritance_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "group_inheritance_type", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The unique ID of the Deploy Access Level object.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the user allowed to deploy to this protected environment. The user must be a member of the group with Maintainer role or higher. Mutually exclusive with `access_level` and `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class GroupPushRulesArgsDict(TypedDict):
        author_email_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        All commit author emails must match this regex, e.g. `@my-company.com$`.
        """
        branch_name_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        All branch names must match this regex, e.g. `(feature|hotfix)\\/*`.
        """
        commit_committer_check: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Only commits pushed using verified emails are allowed.
        """
        commit_committer_name_check: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
        """
        commit_message_negative_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        No commit message is allowed to match this regex, for example `ssh\\:\\/\\/`.
        """
        commit_message_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        All commit messages must match this regex, e.g. `Fixed \\d+\\..*`.
        """
        deny_delete_tag: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Deny deleting a tag.
        """
        file_name_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Filenames matching the regular expression provided in this attribute are not allowed, for example, `(jar|exe)$`.
        """
        max_file_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum file size (MB) allowed.
        """
        member_check: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allows only GitLab users to author commits.
        """
        prevent_secrets: NotRequired[pulumi.Input[_builtins.bool]]
        """
        GitLab will reject any files that are likely to contain secrets.
        """
        reject_non_dco_commits: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Reject commit when its not DCO certified.
        """
        reject_unsigned_commits: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Only commits signed through GPG are allowed.
        """
elif False:
    GroupPushRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupPushRulesArgs:
    def __init__(__self__, *,
                 author_email_regex: Optional[pulumi.Input[_builtins.str]] = None,
                 branch_name_regex: Optional[pulumi.Input[_builtins.str]] = None,
                 commit_committer_check: Optional[pulumi.Input[_builtins.bool]] = None,
                 commit_committer_name_check: Optional[pulumi.Input[_builtins.bool]] = None,
                 commit_message_negative_regex: Optional[pulumi.Input[_builtins.str]] = None,
                 commit_message_regex: Optional[pulumi.Input[_builtins.str]] = None,
                 deny_delete_tag: Optional[pulumi.Input[_builtins.bool]] = None,
                 file_name_regex: Optional[pulumi.Input[_builtins.str]] = None,
                 max_file_size: Optional[pulumi.Input[_builtins.int]] = None,
                 member_check: Optional[pulumi.Input[_builtins.bool]] = None,
                 prevent_secrets: Optional[pulumi.Input[_builtins.bool]] = None,
                 reject_non_dco_commits: Optional[pulumi.Input[_builtins.bool]] = None,
                 reject_unsigned_commits: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] author_email_regex: All commit author emails must match this regex, e.g. `@my-company.com$`.
        :param pulumi.Input[_builtins.str] branch_name_regex: All branch names must match this regex, e.g. `(feature|hotfix)\\/*`.
        :param pulumi.Input[_builtins.bool] commit_committer_check: Only commits pushed using verified emails are allowed.
        :param pulumi.Input[_builtins.bool] commit_committer_name_check: Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
        :param pulumi.Input[_builtins.str] commit_message_negative_regex: No commit message is allowed to match this regex, for example `ssh\\:\\/\\/`.
        :param pulumi.Input[_builtins.str] commit_message_regex: All commit messages must match this regex, e.g. `Fixed \\d+\\..*`.
        :param pulumi.Input[_builtins.bool] deny_delete_tag: Deny deleting a tag.
        :param pulumi.Input[_builtins.str] file_name_regex: Filenames matching the regular expression provided in this attribute are not allowed, for example, `(jar|exe)$`.
        :param pulumi.Input[_builtins.int] max_file_size: Maximum file size (MB) allowed.
        :param pulumi.Input[_builtins.bool] member_check: Allows only GitLab users to author commits.
        :param pulumi.Input[_builtins.bool] prevent_secrets: GitLab will reject any files that are likely to contain secrets.
        :param pulumi.Input[_builtins.bool] reject_non_dco_commits: Reject commit when its not DCO certified.
        :param pulumi.Input[_builtins.bool] reject_unsigned_commits: Only commits signed through GPG are allowed.
        """
        if author_email_regex is not None:
            pulumi.set(__self__, "author_email_regex", author_email_regex)
        if branch_name_regex is not None:
            pulumi.set(__self__, "branch_name_regex", branch_name_regex)
        if commit_committer_check is not None:
            pulumi.set(__self__, "commit_committer_check", commit_committer_check)
        if commit_committer_name_check is not None:
            pulumi.set(__self__, "commit_committer_name_check", commit_committer_name_check)
        if commit_message_negative_regex is not None:
            pulumi.set(__self__, "commit_message_negative_regex", commit_message_negative_regex)
        if commit_message_regex is not None:
            pulumi.set(__self__, "commit_message_regex", commit_message_regex)
        if deny_delete_tag is not None:
            pulumi.set(__self__, "deny_delete_tag", deny_delete_tag)
        if file_name_regex is not None:
            pulumi.set(__self__, "file_name_regex", file_name_regex)
        if max_file_size is not None:
            pulumi.set(__self__, "max_file_size", max_file_size)
        if member_check is not None:
            pulumi.set(__self__, "member_check", member_check)
        if prevent_secrets is not None:
            pulumi.set(__self__, "prevent_secrets", prevent_secrets)
        if reject_non_dco_commits is not None:
            pulumi.set(__self__, "reject_non_dco_commits", reject_non_dco_commits)
        if reject_unsigned_commits is not None:
            pulumi.set(__self__, "reject_unsigned_commits", reject_unsigned_commits)

    @_builtins.property
    @pulumi.getter(name="authorEmailRegex")
    def author_email_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        All commit author emails must match this regex, e.g. `@my-company.com$`.
        """
        return pulumi.get(self, "author_email_regex")

    @author_email_regex.setter
    def author_email_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "author_email_regex", value)

    @_builtins.property
    @pulumi.getter(name="branchNameRegex")
    def branch_name_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        All branch names must match this regex, e.g. `(feature|hotfix)\\/*`.
        """
        return pulumi.get(self, "branch_name_regex")

    @branch_name_regex.setter
    def branch_name_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "branch_name_regex", value)

    @_builtins.property
    @pulumi.getter(name="commitCommitterCheck")
    def commit_committer_check(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Only commits pushed using verified emails are allowed.
        """
        return pulumi.get(self, "commit_committer_check")

    @commit_committer_check.setter
    def commit_committer_check(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "commit_committer_check", value)

    @_builtins.property
    @pulumi.getter(name="commitCommitterNameCheck")
    def commit_committer_name_check(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
        """
        return pulumi.get(self, "commit_committer_name_check")

    @commit_committer_name_check.setter
    def commit_committer_name_check(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "commit_committer_name_check", value)

    @_builtins.property
    @pulumi.getter(name="commitMessageNegativeRegex")
    def commit_message_negative_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        No commit message is allowed to match this regex, for example `ssh\\:\\/\\/`.
        """
        return pulumi.get(self, "commit_message_negative_regex")

    @commit_message_negative_regex.setter
    def commit_message_negative_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "commit_message_negative_regex", value)

    @_builtins.property
    @pulumi.getter(name="commitMessageRegex")
    def commit_message_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        All commit messages must match this regex, e.g. `Fixed \\d+\\..*`.
        """
        return pulumi.get(self, "commit_message_regex")

    @commit_message_regex.setter
    def commit_message_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "commit_message_regex", value)

    @_builtins.property
    @pulumi.getter(name="denyDeleteTag")
    def deny_delete_tag(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Deny deleting a tag.
        """
        return pulumi.get(self, "deny_delete_tag")

    @deny_delete_tag.setter
    def deny_delete_tag(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "deny_delete_tag", value)

    @_builtins.property
    @pulumi.getter(name="fileNameRegex")
    def file_name_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Filenames matching the regular expression provided in this attribute are not allowed, for example, `(jar|exe)$`.
        """
        return pulumi.get(self, "file_name_regex")

    @file_name_regex.setter
    def file_name_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "file_name_regex", value)

    @_builtins.property
    @pulumi.getter(name="maxFileSize")
    def max_file_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum file size (MB) allowed.
        """
        return pulumi.get(self, "max_file_size")

    @max_file_size.setter
    def max_file_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_file_size", value)

    @_builtins.property
    @pulumi.getter(name="memberCheck")
    def member_check(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allows only GitLab users to author commits.
        """
        return pulumi.get(self, "member_check")

    @member_check.setter
    def member_check(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "member_check", value)

    @_builtins.property
    @pulumi.getter(name="preventSecrets")
    def prevent_secrets(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        GitLab will reject any files that are likely to contain secrets.
        """
        return pulumi.get(self, "prevent_secrets")

    @prevent_secrets.setter
    def prevent_secrets(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "prevent_secrets", value)

    @_builtins.property
    @pulumi.getter(name="rejectNonDcoCommits")
    def reject_non_dco_commits(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Reject commit when its not DCO certified.
        """
        return pulumi.get(self, "reject_non_dco_commits")

    @reject_non_dco_commits.setter
    def reject_non_dco_commits(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "reject_non_dco_commits", value)

    @_builtins.property
    @pulumi.getter(name="rejectUnsignedCommits")
    def reject_unsigned_commits(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Only commits signed through GPG are allowed.
        """
        return pulumi.get(self, "reject_unsigned_commits")

    @reject_unsigned_commits.setter
    def reject_unsigned_commits(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "reject_unsigned_commits", value)


if not MYPY:
    class GroupServiceAccountAccessTokenRotationConfigurationArgsDict(TypedDict):
        rotate_before_days: pulumi.Input[_builtins.int]
        """
        The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
        expiration_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        The duration (in days) the new token should be valid for.
        """
elif False:
    GroupServiceAccountAccessTokenRotationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupServiceAccountAccessTokenRotationConfigurationArgs:
    def __init__(__self__, *,
                 rotate_before_days: pulumi.Input[_builtins.int],
                 expiration_days: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] rotate_before_days: The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        :param pulumi.Input[_builtins.int] expiration_days: The duration (in days) the new token should be valid for.
        """
        pulumi.set(__self__, "rotate_before_days", rotate_before_days)
        if expiration_days is not None:
            pulumi.set(__self__, "expiration_days", expiration_days)

    @_builtins.property
    @pulumi.getter(name="rotateBeforeDays")
    def rotate_before_days(self) -> pulumi.Input[_builtins.int]:
        """
        The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
        return pulumi.get(self, "rotate_before_days")

    @rotate_before_days.setter
    def rotate_before_days(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "rotate_before_days", value)

    @_builtins.property
    @pulumi.getter(name="expirationDays")
    def expiration_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The duration (in days) the new token should be valid for.
        """
        return pulumi.get(self, "expiration_days")

    @expiration_days.setter
    def expiration_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "expiration_days", value)


if not MYPY:
    class GroupServiceAccountTimeoutsArgsDict(TypedDict):
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        How long to wait for the service account to be fully deleted. Defaults to 10 minutes.
        """
elif False:
    GroupServiceAccountTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupServiceAccountTimeoutsArgs:
    def __init__(__self__, *,
                 delete: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] delete: How long to wait for the service account to be fully deleted. Defaults to 10 minutes.
        """
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How long to wait for the service account to be fully deleted. Defaults to 10 minutes.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class InstanceServiceAccountTimeoutsArgsDict(TypedDict):
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    InstanceServiceAccountTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceServiceAccountTimeoutsArgs:
    def __init__(__self__, *,
                 delete: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class PersonalAccessTokenRotationConfigurationArgsDict(TypedDict):
        expiration_days: pulumi.Input[_builtins.int]
        """
        The duration (in days) the new token should be valid for.
        """
        rotate_before_days: pulumi.Input[_builtins.int]
        """
        The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
elif False:
    PersonalAccessTokenRotationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PersonalAccessTokenRotationConfigurationArgs:
    def __init__(__self__, *,
                 expiration_days: pulumi.Input[_builtins.int],
                 rotate_before_days: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] expiration_days: The duration (in days) the new token should be valid for.
        :param pulumi.Input[_builtins.int] rotate_before_days: The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
        pulumi.set(__self__, "expiration_days", expiration_days)
        pulumi.set(__self__, "rotate_before_days", rotate_before_days)

    @_builtins.property
    @pulumi.getter(name="expirationDays")
    def expiration_days(self) -> pulumi.Input[_builtins.int]:
        """
        The duration (in days) the new token should be valid for.
        """
        return pulumi.get(self, "expiration_days")

    @expiration_days.setter
    def expiration_days(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "expiration_days", value)

    @_builtins.property
    @pulumi.getter(name="rotateBeforeDays")
    def rotate_before_days(self) -> pulumi.Input[_builtins.int]:
        """
        The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
        return pulumi.get(self, "rotate_before_days")

    @rotate_before_days.setter
    def rotate_before_days(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "rotate_before_days", value)


if not MYPY:
    class ProjectAccessTokenRotationConfigurationArgsDict(TypedDict):
        expiration_days: pulumi.Input[_builtins.int]
        """
        The duration (in days) the new token should be valid for.
        """
        rotate_before_days: pulumi.Input[_builtins.int]
        """
        The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
elif False:
    ProjectAccessTokenRotationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAccessTokenRotationConfigurationArgs:
    def __init__(__self__, *,
                 expiration_days: pulumi.Input[_builtins.int],
                 rotate_before_days: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] expiration_days: The duration (in days) the new token should be valid for.
        :param pulumi.Input[_builtins.int] rotate_before_days: The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
        pulumi.set(__self__, "expiration_days", expiration_days)
        pulumi.set(__self__, "rotate_before_days", rotate_before_days)

    @_builtins.property
    @pulumi.getter(name="expirationDays")
    def expiration_days(self) -> pulumi.Input[_builtins.int]:
        """
        The duration (in days) the new token should be valid for.
        """
        return pulumi.get(self, "expiration_days")

    @expiration_days.setter
    def expiration_days(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "expiration_days", value)

    @_builtins.property
    @pulumi.getter(name="rotateBeforeDays")
    def rotate_before_days(self) -> pulumi.Input[_builtins.int]:
        """
        The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
        return pulumi.get(self, "rotate_before_days")

    @rotate_before_days.setter
    def rotate_before_days(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "rotate_before_days", value)


if not MYPY:
    class ProjectContainerExpirationPolicyArgsDict(TypedDict):
        cadence: NotRequired[pulumi.Input[_builtins.str]]
        """
        The cadence of the policy. Valid values are: `1d`, `7d`, `14d`, `1month`, `3month`.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, the policy is enabled.
        """
        keep_n: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of images to keep.
        """
        name_regex_delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        The regular expression to match image names to delete.
        """
        name_regex_keep: NotRequired[pulumi.Input[_builtins.str]]
        """
        The regular expression to match image names to keep.
        """
        next_run_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The next time the policy will run.
        """
        older_than: NotRequired[pulumi.Input[_builtins.str]]
        """
        The number of days to keep images.
        """
elif False:
    ProjectContainerExpirationPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectContainerExpirationPolicyArgs:
    def __init__(__self__, *,
                 cadence: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 keep_n: Optional[pulumi.Input[_builtins.int]] = None,
                 name_regex_delete: Optional[pulumi.Input[_builtins.str]] = None,
                 name_regex_keep: Optional[pulumi.Input[_builtins.str]] = None,
                 next_run_at: Optional[pulumi.Input[_builtins.str]] = None,
                 older_than: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cadence: The cadence of the policy. Valid values are: `1d`, `7d`, `14d`, `1month`, `3month`.
        :param pulumi.Input[_builtins.bool] enabled: If true, the policy is enabled.
        :param pulumi.Input[_builtins.int] keep_n: The number of images to keep.
        :param pulumi.Input[_builtins.str] name_regex_delete: The regular expression to match image names to delete.
        :param pulumi.Input[_builtins.str] name_regex_keep: The regular expression to match image names to keep.
        :param pulumi.Input[_builtins.str] next_run_at: The next time the policy will run.
        :param pulumi.Input[_builtins.str] older_than: The number of days to keep images.
        """
        if cadence is not None:
            pulumi.set(__self__, "cadence", cadence)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if keep_n is not None:
            pulumi.set(__self__, "keep_n", keep_n)
        if name_regex_delete is not None:
            pulumi.set(__self__, "name_regex_delete", name_regex_delete)
        if name_regex_keep is not None:
            pulumi.set(__self__, "name_regex_keep", name_regex_keep)
        if next_run_at is not None:
            pulumi.set(__self__, "next_run_at", next_run_at)
        if older_than is not None:
            pulumi.set(__self__, "older_than", older_than)

    @_builtins.property
    @pulumi.getter
    def cadence(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The cadence of the policy. Valid values are: `1d`, `7d`, `14d`, `1month`, `3month`.
        """
        return pulumi.get(self, "cadence")

    @cadence.setter
    def cadence(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cadence", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, the policy is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="keepN")
    def keep_n(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of images to keep.
        """
        return pulumi.get(self, "keep_n")

    @keep_n.setter
    def keep_n(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "keep_n", value)

    @_builtins.property
    @pulumi.getter(name="nameRegexDelete")
    def name_regex_delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The regular expression to match image names to delete.
        """
        return pulumi.get(self, "name_regex_delete")

    @name_regex_delete.setter
    def name_regex_delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name_regex_delete", value)

    @_builtins.property
    @pulumi.getter(name="nameRegexKeep")
    def name_regex_keep(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The regular expression to match image names to keep.
        """
        return pulumi.get(self, "name_regex_keep")

    @name_regex_keep.setter
    def name_regex_keep(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name_regex_keep", value)

    @_builtins.property
    @pulumi.getter(name="nextRunAt")
    def next_run_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The next time the policy will run.
        """
        return pulumi.get(self, "next_run_at")

    @next_run_at.setter
    def next_run_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "next_run_at", value)

    @_builtins.property
    @pulumi.getter(name="olderThan")
    def older_than(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The number of days to keep images.
        """
        return pulumi.get(self, "older_than")

    @older_than.setter
    def older_than(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "older_than", value)


if not MYPY:
    class ProjectHookCustomHeaderArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Key of the custom header.
        """
        value: pulumi.Input[_builtins.str]
        """
        Value of the custom header. This value cannot be imported.
        """
elif False:
    ProjectHookCustomHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectHookCustomHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: Key of the custom header.
        :param pulumi.Input[_builtins.str] value: Value of the custom header. This value cannot be imported.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Key of the custom header.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Value of the custom header. This value cannot be imported.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ProjectIssueBoardListArgsDict(TypedDict):
        assignee_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the assignee the list should be scoped to. Requires a GitLab EE license.
        """
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the list
        """
        iteration_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the iteration the list should be scoped to. Requires a GitLab EE license.
        """
        label_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the label the list should be scoped to. Requires a GitLab EE license.
        """
        milestone_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the milestone the list should be scoped to. Requires a GitLab EE license.
        """
        position: NotRequired[pulumi.Input[_builtins.int]]
        """
        The position of the list within the board. The position for the list is based on the its position in the `lists` array.
        """
elif False:
    ProjectIssueBoardListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectIssueBoardListArgs:
    def __init__(__self__, *,
                 assignee_id: Optional[pulumi.Input[_builtins.int]] = None,
                 id: Optional[pulumi.Input[_builtins.int]] = None,
                 iteration_id: Optional[pulumi.Input[_builtins.int]] = None,
                 label_id: Optional[pulumi.Input[_builtins.int]] = None,
                 milestone_id: Optional[pulumi.Input[_builtins.int]] = None,
                 position: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] assignee_id: The ID of the assignee the list should be scoped to. Requires a GitLab EE license.
        :param pulumi.Input[_builtins.int] id: The ID of the list
        :param pulumi.Input[_builtins.int] iteration_id: The ID of the iteration the list should be scoped to. Requires a GitLab EE license.
        :param pulumi.Input[_builtins.int] label_id: The ID of the label the list should be scoped to. Requires a GitLab EE license.
        :param pulumi.Input[_builtins.int] milestone_id: The ID of the milestone the list should be scoped to. Requires a GitLab EE license.
        :param pulumi.Input[_builtins.int] position: The position of the list within the board. The position for the list is based on the its position in the `lists` array.
        """
        if assignee_id is not None:
            pulumi.set(__self__, "assignee_id", assignee_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if iteration_id is not None:
            pulumi.set(__self__, "iteration_id", iteration_id)
        if label_id is not None:
            pulumi.set(__self__, "label_id", label_id)
        if milestone_id is not None:
            pulumi.set(__self__, "milestone_id", milestone_id)
        if position is not None:
            pulumi.set(__self__, "position", position)

    @_builtins.property
    @pulumi.getter(name="assigneeId")
    def assignee_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the assignee the list should be scoped to. Requires a GitLab EE license.
        """
        return pulumi.get(self, "assignee_id")

    @assignee_id.setter
    def assignee_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "assignee_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the list
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="iterationId")
    def iteration_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the iteration the list should be scoped to. Requires a GitLab EE license.
        """
        return pulumi.get(self, "iteration_id")

    @iteration_id.setter
    def iteration_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iteration_id", value)

    @_builtins.property
    @pulumi.getter(name="labelId")
    def label_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the label the list should be scoped to. Requires a GitLab EE license.
        """
        return pulumi.get(self, "label_id")

    @label_id.setter
    def label_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "label_id", value)

    @_builtins.property
    @pulumi.getter(name="milestoneId")
    def milestone_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the milestone the list should be scoped to. Requires a GitLab EE license.
        """
        return pulumi.get(self, "milestone_id")

    @milestone_id.setter
    def milestone_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "milestone_id", value)

    @_builtins.property
    @pulumi.getter
    def position(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The position of the list within the board. The position for the list is based on the its position in the `lists` array.
        """
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "position", value)


if not MYPY:
    class ProjectIssueTaskCompletionStatusArgsDict(TypedDict):
        completed_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of tasks that are completed.
        """
        count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of tasks.
        """
elif False:
    ProjectIssueTaskCompletionStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectIssueTaskCompletionStatusArgs:
    def __init__(__self__, *,
                 completed_count: Optional[pulumi.Input[_builtins.int]] = None,
                 count: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] completed_count: The number of tasks that are completed.
        :param pulumi.Input[_builtins.int] count: The number of tasks.
        """
        if completed_count is not None:
            pulumi.set(__self__, "completed_count", completed_count)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @_builtins.property
    @pulumi.getter(name="completedCount")
    def completed_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of tasks that are completed.
        """
        return pulumi.get(self, "completed_count")

    @completed_count.setter
    def completed_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "completed_count", value)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of tasks.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)


if not MYPY:
    class ProjectPagesSettingsDeploymentArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Date the deployment was created.
        """
        path_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path prefix of the deployment when using parallel deployments.
        """
        root_directory: NotRequired[pulumi.Input[_builtins.str]]
        """
        The root directory of the deployment.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL of the deployment.
        """
elif False:
    ProjectPagesSettingsDeploymentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectPagesSettingsDeploymentArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 path_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 root_directory: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_at: Date the deployment was created.
        :param pulumi.Input[_builtins.str] path_prefix: The path prefix of the deployment when using parallel deployments.
        :param pulumi.Input[_builtins.str] root_directory: The root directory of the deployment.
        :param pulumi.Input[_builtins.str] url: The URL of the deployment.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if path_prefix is not None:
            pulumi.set(__self__, "path_prefix", path_prefix)
        if root_directory is not None:
            pulumi.set(__self__, "root_directory", root_directory)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Date the deployment was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="pathPrefix")
    def path_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path prefix of the deployment when using parallel deployments.
        """
        return pulumi.get(self, "path_prefix")

    @path_prefix.setter
    def path_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path_prefix", value)

    @_builtins.property
    @pulumi.getter(name="rootDirectory")
    def root_directory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The root directory of the deployment.
        """
        return pulumi.get(self, "root_directory")

    @root_directory.setter
    def root_directory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "root_directory", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL of the deployment.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ProjectProtectedEnvironmentApprovalRuleArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        Levels of access allowed to approve a deployment to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        """
        access_level_description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Readable description of level of access.
        """
        group_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the group allowed to approve a deployment to this protected environment. The project must be shared with the group. Mutually exclusive with `access_level` and `user_id`.
        """
        group_inheritance_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        """
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The unique ID of the Approval Rules object.
        """
        required_approvals: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of approval required to allow deployment to this protected environment. This is mutually exclusive with user_id.
        """
        user_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the user allowed to approve a deployment to this protected environment. The user must be a member of the project. Mutually exclusive with `access_level` and `group_id`.
        """
elif False:
    ProjectProtectedEnvironmentApprovalRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectProtectedEnvironmentApprovalRuleArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[_builtins.str]] = None,
                 access_level_description: Optional[pulumi.Input[_builtins.str]] = None,
                 group_id: Optional[pulumi.Input[_builtins.int]] = None,
                 group_inheritance_type: Optional[pulumi.Input[_builtins.int]] = None,
                 id: Optional[pulumi.Input[_builtins.int]] = None,
                 required_approvals: Optional[pulumi.Input[_builtins.int]] = None,
                 user_id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] access_level: Levels of access allowed to approve a deployment to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        :param pulumi.Input[_builtins.str] access_level_description: Readable description of level of access.
        :param pulumi.Input[_builtins.int] group_id: The ID of the group allowed to approve a deployment to this protected environment. The project must be shared with the group. Mutually exclusive with `access_level` and `user_id`.
        :param pulumi.Input[_builtins.int] group_inheritance_type: Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        :param pulumi.Input[_builtins.int] id: The unique ID of the Approval Rules object.
        :param pulumi.Input[_builtins.int] required_approvals: The number of approval required to allow deployment to this protected environment. This is mutually exclusive with user_id.
        :param pulumi.Input[_builtins.int] user_id: The ID of the user allowed to approve a deployment to this protected environment. The user must be a member of the project. Mutually exclusive with `access_level` and `group_id`.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_level_description is not None:
            pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if group_inheritance_type is not None:
            pulumi.set(__self__, "group_inheritance_type", group_inheritance_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if required_approvals is not None:
            pulumi.set(__self__, "required_approvals", required_approvals)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Levels of access allowed to approve a deployment to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_level", value)

    @_builtins.property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Readable description of level of access.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_level_description", value)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the group allowed to approve a deployment to this protected environment. The project must be shared with the group. Mutually exclusive with `access_level` and `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "group_id", value)

    @_builtins.property
    @pulumi.getter(name="groupInheritanceType")
    def group_inheritance_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        """
        return pulumi.get(self, "group_inheritance_type")

    @group_inheritance_type.setter
    def group_inheritance_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "group_inheritance_type", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The unique ID of the Approval Rules object.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="requiredApprovals")
    def required_approvals(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of approval required to allow deployment to this protected environment. This is mutually exclusive with user_id.
        """
        return pulumi.get(self, "required_approvals")

    @required_approvals.setter
    def required_approvals(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "required_approvals", value)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the user allowed to approve a deployment to this protected environment. The user must be a member of the project. Mutually exclusive with `access_level` and `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class ProjectProtectedEnvironmentDeployAccessLevelArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        Levels of access required to deploy to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        """
        access_level_description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Readable description of level of access.
        """
        group_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the group allowed to deploy to this protected environment. The project must be shared with the group. Mutually exclusive with `access_level` and `user_id`.
        """
        group_inheritance_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        """
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The unique ID of the Deploy Access Level object.
        """
        user_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the user allowed to deploy to this protected environment. The user must be a member of the project. Mutually exclusive with `access_level` and `group_id`.
        """
elif False:
    ProjectProtectedEnvironmentDeployAccessLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectProtectedEnvironmentDeployAccessLevelArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[_builtins.str]] = None,
                 access_level_description: Optional[pulumi.Input[_builtins.str]] = None,
                 group_id: Optional[pulumi.Input[_builtins.int]] = None,
                 group_inheritance_type: Optional[pulumi.Input[_builtins.int]] = None,
                 id: Optional[pulumi.Input[_builtins.int]] = None,
                 user_id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] access_level: Levels of access required to deploy to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        :param pulumi.Input[_builtins.str] access_level_description: Readable description of level of access.
        :param pulumi.Input[_builtins.int] group_id: The ID of the group allowed to deploy to this protected environment. The project must be shared with the group. Mutually exclusive with `access_level` and `user_id`.
        :param pulumi.Input[_builtins.int] group_inheritance_type: Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        :param pulumi.Input[_builtins.int] id: The unique ID of the Deploy Access Level object.
        :param pulumi.Input[_builtins.int] user_id: The ID of the user allowed to deploy to this protected environment. The user must be a member of the project. Mutually exclusive with `access_level` and `group_id`.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_level_description is not None:
            pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if group_inheritance_type is not None:
            pulumi.set(__self__, "group_inheritance_type", group_inheritance_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Levels of access required to deploy to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_level", value)

    @_builtins.property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Readable description of level of access.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_level_description", value)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the group allowed to deploy to this protected environment. The project must be shared with the group. Mutually exclusive with `access_level` and `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "group_id", value)

    @_builtins.property
    @pulumi.getter(name="groupInheritanceType")
    def group_inheritance_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        """
        return pulumi.get(self, "group_inheritance_type")

    @group_inheritance_type.setter
    def group_inheritance_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "group_inheritance_type", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The unique ID of the Deploy Access Level object.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the user allowed to deploy to this protected environment. The user must be a member of the project. Mutually exclusive with `access_level` and `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class ProjectProtectedEnvironmentDeployAccessLevelsAttributeArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        Levels of access required to deploy to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        """
        access_level_description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Readable description of level of access.
        """
        group_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the group allowed to deploy to this protected environment. The project must be shared with the group. Mutually exclusive with `access_level` and `user_id`.
        """
        group_inheritance_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        """
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The unique ID of the Deploy Access Level object.
        """
        user_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the user allowed to deploy to this protected environment. The user must be a member of the project. Mutually exclusive with `access_level` and `group_id`.
        """
elif False:
    ProjectProtectedEnvironmentDeployAccessLevelsAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectProtectedEnvironmentDeployAccessLevelsAttributeArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[_builtins.str]] = None,
                 access_level_description: Optional[pulumi.Input[_builtins.str]] = None,
                 group_id: Optional[pulumi.Input[_builtins.int]] = None,
                 group_inheritance_type: Optional[pulumi.Input[_builtins.int]] = None,
                 id: Optional[pulumi.Input[_builtins.int]] = None,
                 user_id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] access_level: Levels of access required to deploy to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        :param pulumi.Input[_builtins.str] access_level_description: Readable description of level of access.
        :param pulumi.Input[_builtins.int] group_id: The ID of the group allowed to deploy to this protected environment. The project must be shared with the group. Mutually exclusive with `access_level` and `user_id`.
        :param pulumi.Input[_builtins.int] group_inheritance_type: Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        :param pulumi.Input[_builtins.int] id: The unique ID of the Deploy Access Level object.
        :param pulumi.Input[_builtins.int] user_id: The ID of the user allowed to deploy to this protected environment. The user must be a member of the project. Mutually exclusive with `access_level` and `group_id`.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_level_description is not None:
            pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if group_inheritance_type is not None:
            pulumi.set(__self__, "group_inheritance_type", group_inheritance_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Levels of access required to deploy to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_level", value)

    @_builtins.property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Readable description of level of access.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_level_description", value)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the group allowed to deploy to this protected environment. The project must be shared with the group. Mutually exclusive with `access_level` and `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "group_id", value)

    @_builtins.property
    @pulumi.getter(name="groupInheritanceType")
    def group_inheritance_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        """
        return pulumi.get(self, "group_inheritance_type")

    @group_inheritance_type.setter
    def group_inheritance_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "group_inheritance_type", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The unique ID of the Deploy Access Level object.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the user allowed to deploy to this protected environment. The user must be a member of the project. Mutually exclusive with `access_level` and `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class ProjectPushRulesArgsDict(TypedDict):
        author_email_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        All commit author emails must match this regex, e.g. `@my-company.com$`.
        """
        branch_name_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        All branch names must match this regex, e.g. `(feature|hotfix)\\/*`.
        """
        commit_committer_check: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Users can only push commits to this repository that were committed with one of their own verified emails.
        """
        commit_committer_name_check: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
        """
        commit_message_negative_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        No commit message is allowed to match this regex, e.g. `ssh\\:\\/\\/`.
        """
        commit_message_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        All commit messages must match this regex, e.g. `Fixed \\d+\\..*`.
        """
        deny_delete_tag: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Deny deleting a tag.
        """
        file_name_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        All committed filenames must not match this regex, e.g. `(jar|exe)$`.
        """
        max_file_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum file size (MB).
        """
        member_check: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Restrict commits by author (email) to existing GitLab users.
        """
        prevent_secrets: NotRequired[pulumi.Input[_builtins.bool]]
        """
        GitLab will reject any files that are likely to contain secrets.
        """
        reject_non_dco_commits: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Reject commit when its not DCO certified.
        """
        reject_unsigned_commits: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Reject commit when its not signed through GPG.
        """
elif False:
    ProjectPushRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectPushRulesArgs:
    def __init__(__self__, *,
                 author_email_regex: Optional[pulumi.Input[_builtins.str]] = None,
                 branch_name_regex: Optional[pulumi.Input[_builtins.str]] = None,
                 commit_committer_check: Optional[pulumi.Input[_builtins.bool]] = None,
                 commit_committer_name_check: Optional[pulumi.Input[_builtins.bool]] = None,
                 commit_message_negative_regex: Optional[pulumi.Input[_builtins.str]] = None,
                 commit_message_regex: Optional[pulumi.Input[_builtins.str]] = None,
                 deny_delete_tag: Optional[pulumi.Input[_builtins.bool]] = None,
                 file_name_regex: Optional[pulumi.Input[_builtins.str]] = None,
                 max_file_size: Optional[pulumi.Input[_builtins.int]] = None,
                 member_check: Optional[pulumi.Input[_builtins.bool]] = None,
                 prevent_secrets: Optional[pulumi.Input[_builtins.bool]] = None,
                 reject_non_dco_commits: Optional[pulumi.Input[_builtins.bool]] = None,
                 reject_unsigned_commits: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] author_email_regex: All commit author emails must match this regex, e.g. `@my-company.com$`.
        :param pulumi.Input[_builtins.str] branch_name_regex: All branch names must match this regex, e.g. `(feature|hotfix)\\/*`.
        :param pulumi.Input[_builtins.bool] commit_committer_check: Users can only push commits to this repository that were committed with one of their own verified emails.
        :param pulumi.Input[_builtins.bool] commit_committer_name_check: Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
        :param pulumi.Input[_builtins.str] commit_message_negative_regex: No commit message is allowed to match this regex, e.g. `ssh\\:\\/\\/`.
        :param pulumi.Input[_builtins.str] commit_message_regex: All commit messages must match this regex, e.g. `Fixed \\d+\\..*`.
        :param pulumi.Input[_builtins.bool] deny_delete_tag: Deny deleting a tag.
        :param pulumi.Input[_builtins.str] file_name_regex: All committed filenames must not match this regex, e.g. `(jar|exe)$`.
        :param pulumi.Input[_builtins.int] max_file_size: Maximum file size (MB).
        :param pulumi.Input[_builtins.bool] member_check: Restrict commits by author (email) to existing GitLab users.
        :param pulumi.Input[_builtins.bool] prevent_secrets: GitLab will reject any files that are likely to contain secrets.
        :param pulumi.Input[_builtins.bool] reject_non_dco_commits: Reject commit when its not DCO certified.
        :param pulumi.Input[_builtins.bool] reject_unsigned_commits: Reject commit when its not signed through GPG.
        """
        if author_email_regex is not None:
            pulumi.set(__self__, "author_email_regex", author_email_regex)
        if branch_name_regex is not None:
            pulumi.set(__self__, "branch_name_regex", branch_name_regex)
        if commit_committer_check is not None:
            pulumi.set(__self__, "commit_committer_check", commit_committer_check)
        if commit_committer_name_check is not None:
            pulumi.set(__self__, "commit_committer_name_check", commit_committer_name_check)
        if commit_message_negative_regex is not None:
            pulumi.set(__self__, "commit_message_negative_regex", commit_message_negative_regex)
        if commit_message_regex is not None:
            pulumi.set(__self__, "commit_message_regex", commit_message_regex)
        if deny_delete_tag is not None:
            pulumi.set(__self__, "deny_delete_tag", deny_delete_tag)
        if file_name_regex is not None:
            pulumi.set(__self__, "file_name_regex", file_name_regex)
        if max_file_size is not None:
            pulumi.set(__self__, "max_file_size", max_file_size)
        if member_check is not None:
            pulumi.set(__self__, "member_check", member_check)
        if prevent_secrets is not None:
            pulumi.set(__self__, "prevent_secrets", prevent_secrets)
        if reject_non_dco_commits is not None:
            pulumi.set(__self__, "reject_non_dco_commits", reject_non_dco_commits)
        if reject_unsigned_commits is not None:
            pulumi.set(__self__, "reject_unsigned_commits", reject_unsigned_commits)

    @_builtins.property
    @pulumi.getter(name="authorEmailRegex")
    def author_email_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        All commit author emails must match this regex, e.g. `@my-company.com$`.
        """
        return pulumi.get(self, "author_email_regex")

    @author_email_regex.setter
    def author_email_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "author_email_regex", value)

    @_builtins.property
    @pulumi.getter(name="branchNameRegex")
    def branch_name_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        All branch names must match this regex, e.g. `(feature|hotfix)\\/*`.
        """
        return pulumi.get(self, "branch_name_regex")

    @branch_name_regex.setter
    def branch_name_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "branch_name_regex", value)

    @_builtins.property
    @pulumi.getter(name="commitCommitterCheck")
    def commit_committer_check(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Users can only push commits to this repository that were committed with one of their own verified emails.
        """
        return pulumi.get(self, "commit_committer_check")

    @commit_committer_check.setter
    def commit_committer_check(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "commit_committer_check", value)

    @_builtins.property
    @pulumi.getter(name="commitCommitterNameCheck")
    def commit_committer_name_check(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
        """
        return pulumi.get(self, "commit_committer_name_check")

    @commit_committer_name_check.setter
    def commit_committer_name_check(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "commit_committer_name_check", value)

    @_builtins.property
    @pulumi.getter(name="commitMessageNegativeRegex")
    def commit_message_negative_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        No commit message is allowed to match this regex, e.g. `ssh\\:\\/\\/`.
        """
        return pulumi.get(self, "commit_message_negative_regex")

    @commit_message_negative_regex.setter
    def commit_message_negative_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "commit_message_negative_regex", value)

    @_builtins.property
    @pulumi.getter(name="commitMessageRegex")
    def commit_message_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        All commit messages must match this regex, e.g. `Fixed \\d+\\..*`.
        """
        return pulumi.get(self, "commit_message_regex")

    @commit_message_regex.setter
    def commit_message_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "commit_message_regex", value)

    @_builtins.property
    @pulumi.getter(name="denyDeleteTag")
    def deny_delete_tag(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Deny deleting a tag.
        """
        return pulumi.get(self, "deny_delete_tag")

    @deny_delete_tag.setter
    def deny_delete_tag(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "deny_delete_tag", value)

    @_builtins.property
    @pulumi.getter(name="fileNameRegex")
    def file_name_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        All committed filenames must not match this regex, e.g. `(jar|exe)$`.
        """
        return pulumi.get(self, "file_name_regex")

    @file_name_regex.setter
    def file_name_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "file_name_regex", value)

    @_builtins.property
    @pulumi.getter(name="maxFileSize")
    def max_file_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum file size (MB).
        """
        return pulumi.get(self, "max_file_size")

    @max_file_size.setter
    def max_file_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_file_size", value)

    @_builtins.property
    @pulumi.getter(name="memberCheck")
    def member_check(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Restrict commits by author (email) to existing GitLab users.
        """
        return pulumi.get(self, "member_check")

    @member_check.setter
    def member_check(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "member_check", value)

    @_builtins.property
    @pulumi.getter(name="preventSecrets")
    def prevent_secrets(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        GitLab will reject any files that are likely to contain secrets.
        """
        return pulumi.get(self, "prevent_secrets")

    @prevent_secrets.setter
    def prevent_secrets(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "prevent_secrets", value)

    @_builtins.property
    @pulumi.getter(name="rejectNonDcoCommits")
    def reject_non_dco_commits(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Reject commit when its not DCO certified.
        """
        return pulumi.get(self, "reject_non_dco_commits")

    @reject_non_dco_commits.setter
    def reject_non_dco_commits(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "reject_non_dco_commits", value)

    @_builtins.property
    @pulumi.getter(name="rejectUnsignedCommits")
    def reject_unsigned_commits(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Reject commit when its not signed through GPG.
        """
        return pulumi.get(self, "reject_unsigned_commits")

    @reject_unsigned_commits.setter
    def reject_unsigned_commits(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "reject_unsigned_commits", value)


if not MYPY:
    class ProjectTagCommitArgsDict(TypedDict):
        author_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        The email of the author.
        """
        author_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the author.
        """
        authored_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
        """
        committed_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
        """
        committer_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        The email of the user that committed.
        """
        committer_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the user that committed.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique id assigned to the commit by Gitlab.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        The commit message
        """
        parent_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The id of the parents of the commit
        """
        short_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The short id assigned to the commit by Gitlab.
        """
        title: NotRequired[pulumi.Input[_builtins.str]]
        """
        The title of the commit
        """
elif False:
    ProjectTagCommitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectTagCommitArgs:
    def __init__(__self__, *,
                 author_email: Optional[pulumi.Input[_builtins.str]] = None,
                 author_name: Optional[pulumi.Input[_builtins.str]] = None,
                 authored_date: Optional[pulumi.Input[_builtins.str]] = None,
                 committed_date: Optional[pulumi.Input[_builtins.str]] = None,
                 committer_email: Optional[pulumi.Input[_builtins.str]] = None,
                 committer_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 parent_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 short_id: Optional[pulumi.Input[_builtins.str]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] author_email: The email of the author.
        :param pulumi.Input[_builtins.str] author_name: The name of the author.
        :param pulumi.Input[_builtins.str] authored_date: The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
        :param pulumi.Input[_builtins.str] committed_date: The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
        :param pulumi.Input[_builtins.str] committer_email: The email of the user that committed.
        :param pulumi.Input[_builtins.str] committer_name: The name of the user that committed.
        :param pulumi.Input[_builtins.str] id: The unique id assigned to the commit by Gitlab.
        :param pulumi.Input[_builtins.str] message: The commit message
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] parent_ids: The id of the parents of the commit
        :param pulumi.Input[_builtins.str] short_id: The short id assigned to the commit by Gitlab.
        :param pulumi.Input[_builtins.str] title: The title of the commit
        """
        if author_email is not None:
            pulumi.set(__self__, "author_email", author_email)
        if author_name is not None:
            pulumi.set(__self__, "author_name", author_name)
        if authored_date is not None:
            pulumi.set(__self__, "authored_date", authored_date)
        if committed_date is not None:
            pulumi.set(__self__, "committed_date", committed_date)
        if committer_email is not None:
            pulumi.set(__self__, "committer_email", committer_email)
        if committer_name is not None:
            pulumi.set(__self__, "committer_name", committer_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if parent_ids is not None:
            pulumi.set(__self__, "parent_ids", parent_ids)
        if short_id is not None:
            pulumi.set(__self__, "short_id", short_id)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter(name="authorEmail")
    def author_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The email of the author.
        """
        return pulumi.get(self, "author_email")

    @author_email.setter
    def author_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "author_email", value)

    @_builtins.property
    @pulumi.getter(name="authorName")
    def author_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the author.
        """
        return pulumi.get(self, "author_name")

    @author_name.setter
    def author_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "author_name", value)

    @_builtins.property
    @pulumi.getter(name="authoredDate")
    def authored_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
        """
        return pulumi.get(self, "authored_date")

    @authored_date.setter
    def authored_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authored_date", value)

    @_builtins.property
    @pulumi.getter(name="committedDate")
    def committed_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
        """
        return pulumi.get(self, "committed_date")

    @committed_date.setter
    def committed_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "committed_date", value)

    @_builtins.property
    @pulumi.getter(name="committerEmail")
    def committer_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The email of the user that committed.
        """
        return pulumi.get(self, "committer_email")

    @committer_email.setter
    def committer_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "committer_email", value)

    @_builtins.property
    @pulumi.getter(name="committerName")
    def committer_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the user that committed.
        """
        return pulumi.get(self, "committer_name")

    @committer_name.setter
    def committer_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "committer_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique id assigned to the commit by Gitlab.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The commit message
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter(name="parentIds")
    def parent_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The id of the parents of the commit
        """
        return pulumi.get(self, "parent_ids")

    @parent_ids.setter
    def parent_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "parent_ids", value)

    @_builtins.property
    @pulumi.getter(name="shortId")
    def short_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The short id assigned to the commit by Gitlab.
        """
        return pulumi.get(self, "short_id")

    @short_id.setter
    def short_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_id", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The title of the commit
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class ProjectTagReleaseArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of release.
        """
        tag_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the tag.
        """
elif False:
    ProjectTagReleaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectTagReleaseArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 tag_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: The description of release.
        :param pulumi.Input[_builtins.str] tag_name: The name of the tag.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of release.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the tag.
        """
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag_name", value)


if not MYPY:
    class ReleaseAssetsArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The total count of assets in this release.
        """
elif False:
    ReleaseAssetsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseAssetsArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] count: The total count of assets in this release.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The total count of assets in this release.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)


if not MYPY:
    class ReleaseAuthorArgsDict(TypedDict):
        avatar_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The url of the author's' user avatar.
        """
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of the author's user.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the author.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The state of the author's user.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username of the author.
        """
        web_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The url to the author's user profile.
        """
elif False:
    ReleaseAuthorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseAuthorArgs:
    def __init__(__self__, *,
                 avatar_url: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None,
                 web_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] avatar_url: The url of the author's' user avatar.
        :param pulumi.Input[_builtins.int] id: The ID of the author's user.
        :param pulumi.Input[_builtins.str] name: The name of the author.
        :param pulumi.Input[_builtins.str] state: The state of the author's user.
        :param pulumi.Input[_builtins.str] username: The username of the author.
        :param pulumi.Input[_builtins.str] web_url: The url to the author's user profile.
        """
        if avatar_url is not None:
            pulumi.set(__self__, "avatar_url", avatar_url)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if web_url is not None:
            pulumi.set(__self__, "web_url", web_url)

    @_builtins.property
    @pulumi.getter(name="avatarUrl")
    def avatar_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The url of the author's' user avatar.
        """
        return pulumi.get(self, "avatar_url")

    @avatar_url.setter
    def avatar_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "avatar_url", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of the author's user.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the author.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The state of the author's user.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username of the author.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)

    @_builtins.property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The url to the author's user profile.
        """
        return pulumi.get(self, "web_url")

    @web_url.setter
    def web_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "web_url", value)


if not MYPY:
    class ReleaseCommitArgsDict(TypedDict):
        author_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        The email address of the commit author.
        """
        author_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the commit author.
        """
        authored_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time the commit was authored. In ISO 8601 format (2019-03-15T08:00:00Z).
        """
        committed_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time the commit was made. In ISO 8601 format (2019-03-15T08:00:00Z).
        """
        committer_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        The email address of the committer.
        """
        committer_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the committer.
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time the commit was created. In ISO 8601 format (2019-03-15T08:00:00Z).
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The git commit full SHA
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        The commit message.
        """
        parent_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The full SHA of any parent commits.
        """
        short_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The git commit short SHA.
        """
        title: NotRequired[pulumi.Input[_builtins.str]]
        """
        The title of the commit.
        """
elif False:
    ReleaseCommitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseCommitArgs:
    def __init__(__self__, *,
                 author_email: Optional[pulumi.Input[_builtins.str]] = None,
                 author_name: Optional[pulumi.Input[_builtins.str]] = None,
                 authored_date: Optional[pulumi.Input[_builtins.str]] = None,
                 committed_date: Optional[pulumi.Input[_builtins.str]] = None,
                 committer_email: Optional[pulumi.Input[_builtins.str]] = None,
                 committer_name: Optional[pulumi.Input[_builtins.str]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 parent_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 short_id: Optional[pulumi.Input[_builtins.str]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] author_email: The email address of the commit author.
        :param pulumi.Input[_builtins.str] author_name: The name of the commit author.
        :param pulumi.Input[_builtins.str] authored_date: The date and time the commit was authored. In ISO 8601 format (2019-03-15T08:00:00Z).
        :param pulumi.Input[_builtins.str] committed_date: The date and time the commit was made. In ISO 8601 format (2019-03-15T08:00:00Z).
        :param pulumi.Input[_builtins.str] committer_email: The email address of the committer.
        :param pulumi.Input[_builtins.str] committer_name: The name of the committer.
        :param pulumi.Input[_builtins.str] created_at: The date and time the commit was created. In ISO 8601 format (2019-03-15T08:00:00Z).
        :param pulumi.Input[_builtins.str] id: The git commit full SHA
        :param pulumi.Input[_builtins.str] message: The commit message.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] parent_ids: The full SHA of any parent commits.
        :param pulumi.Input[_builtins.str] short_id: The git commit short SHA.
        :param pulumi.Input[_builtins.str] title: The title of the commit.
        """
        if author_email is not None:
            pulumi.set(__self__, "author_email", author_email)
        if author_name is not None:
            pulumi.set(__self__, "author_name", author_name)
        if authored_date is not None:
            pulumi.set(__self__, "authored_date", authored_date)
        if committed_date is not None:
            pulumi.set(__self__, "committed_date", committed_date)
        if committer_email is not None:
            pulumi.set(__self__, "committer_email", committer_email)
        if committer_name is not None:
            pulumi.set(__self__, "committer_name", committer_name)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if parent_ids is not None:
            pulumi.set(__self__, "parent_ids", parent_ids)
        if short_id is not None:
            pulumi.set(__self__, "short_id", short_id)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter(name="authorEmail")
    def author_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The email address of the commit author.
        """
        return pulumi.get(self, "author_email")

    @author_email.setter
    def author_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "author_email", value)

    @_builtins.property
    @pulumi.getter(name="authorName")
    def author_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the commit author.
        """
        return pulumi.get(self, "author_name")

    @author_name.setter
    def author_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "author_name", value)

    @_builtins.property
    @pulumi.getter(name="authoredDate")
    def authored_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time the commit was authored. In ISO 8601 format (2019-03-15T08:00:00Z).
        """
        return pulumi.get(self, "authored_date")

    @authored_date.setter
    def authored_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authored_date", value)

    @_builtins.property
    @pulumi.getter(name="committedDate")
    def committed_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time the commit was made. In ISO 8601 format (2019-03-15T08:00:00Z).
        """
        return pulumi.get(self, "committed_date")

    @committed_date.setter
    def committed_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "committed_date", value)

    @_builtins.property
    @pulumi.getter(name="committerEmail")
    def committer_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The email address of the committer.
        """
        return pulumi.get(self, "committer_email")

    @committer_email.setter
    def committer_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "committer_email", value)

    @_builtins.property
    @pulumi.getter(name="committerName")
    def committer_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the committer.
        """
        return pulumi.get(self, "committer_name")

    @committer_name.setter
    def committer_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "committer_name", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time the commit was created. In ISO 8601 format (2019-03-15T08:00:00Z).
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The git commit full SHA
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The commit message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter(name="parentIds")
    def parent_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The full SHA of any parent commits.
        """
        return pulumi.get(self, "parent_ids")

    @parent_ids.setter
    def parent_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "parent_ids", value)

    @_builtins.property
    @pulumi.getter(name="shortId")
    def short_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The git commit short SHA.
        """
        return pulumi.get(self, "short_id")

    @short_id.setter
    def short_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_id", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The title of the commit.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class ReleaseLinksArgsDict(TypedDict):
        closed_issues_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        URL of the release's closed issues.
        """
        closed_merge_requests_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        URL of the release's closed merge requests.
        """
        edit_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        URL of the release's edit page.
        """
        merged_merge_requests_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        URL of the release's merged merge requests.
        """
        opened_issues_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        URL of the release's open issues.
        """
        opened_merge_requests_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        URL of the release's open merge requests.
        """
        self: NotRequired[pulumi.Input[_builtins.str]]
        """
        URL of the release.
        """
elif False:
    ReleaseLinksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseLinksArgs:
    def __init__(__self__, *,
                 closed_issues_url: Optional[pulumi.Input[_builtins.str]] = None,
                 closed_merge_requests_url: Optional[pulumi.Input[_builtins.str]] = None,
                 edit_url: Optional[pulumi.Input[_builtins.str]] = None,
                 merged_merge_requests_url: Optional[pulumi.Input[_builtins.str]] = None,
                 opened_issues_url: Optional[pulumi.Input[_builtins.str]] = None,
                 opened_merge_requests_url: Optional[pulumi.Input[_builtins.str]] = None,
                 self: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] closed_issues_url: URL of the release's closed issues.
        :param pulumi.Input[_builtins.str] closed_merge_requests_url: URL of the release's closed merge requests.
        :param pulumi.Input[_builtins.str] edit_url: URL of the release's edit page.
        :param pulumi.Input[_builtins.str] merged_merge_requests_url: URL of the release's merged merge requests.
        :param pulumi.Input[_builtins.str] opened_issues_url: URL of the release's open issues.
        :param pulumi.Input[_builtins.str] opened_merge_requests_url: URL of the release's open merge requests.
        :param pulumi.Input[_builtins.str] self: URL of the release.
        """
        if closed_issues_url is not None:
            pulumi.set(__self__, "closed_issues_url", closed_issues_url)
        if closed_merge_requests_url is not None:
            pulumi.set(__self__, "closed_merge_requests_url", closed_merge_requests_url)
        if edit_url is not None:
            pulumi.set(__self__, "edit_url", edit_url)
        if merged_merge_requests_url is not None:
            pulumi.set(__self__, "merged_merge_requests_url", merged_merge_requests_url)
        if opened_issues_url is not None:
            pulumi.set(__self__, "opened_issues_url", opened_issues_url)
        if opened_merge_requests_url is not None:
            pulumi.set(__self__, "opened_merge_requests_url", opened_merge_requests_url)
        if self is not None:
            pulumi.set(__self__, "self", self)

    @_builtins.property
    @pulumi.getter(name="closedIssuesUrl")
    def closed_issues_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URL of the release's closed issues.
        """
        return pulumi.get(self, "closed_issues_url")

    @closed_issues_url.setter
    def closed_issues_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "closed_issues_url", value)

    @_builtins.property
    @pulumi.getter(name="closedMergeRequestsUrl")
    def closed_merge_requests_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URL of the release's closed merge requests.
        """
        return pulumi.get(self, "closed_merge_requests_url")

    @closed_merge_requests_url.setter
    def closed_merge_requests_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "closed_merge_requests_url", value)

    @_builtins.property
    @pulumi.getter(name="editUrl")
    def edit_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URL of the release's edit page.
        """
        return pulumi.get(self, "edit_url")

    @edit_url.setter
    def edit_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "edit_url", value)

    @_builtins.property
    @pulumi.getter(name="mergedMergeRequestsUrl")
    def merged_merge_requests_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URL of the release's merged merge requests.
        """
        return pulumi.get(self, "merged_merge_requests_url")

    @merged_merge_requests_url.setter
    def merged_merge_requests_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "merged_merge_requests_url", value)

    @_builtins.property
    @pulumi.getter(name="openedIssuesUrl")
    def opened_issues_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URL of the release's open issues.
        """
        return pulumi.get(self, "opened_issues_url")

    @opened_issues_url.setter
    def opened_issues_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "opened_issues_url", value)

    @_builtins.property
    @pulumi.getter(name="openedMergeRequestsUrl")
    def opened_merge_requests_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URL of the release's open merge requests.
        """
        return pulumi.get(self, "opened_merge_requests_url")

    @opened_merge_requests_url.setter
    def opened_merge_requests_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "opened_merge_requests_url", value)

    @_builtins.property
    @pulumi.getter
    def self(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URL of the release.
        """
        return pulumi.get(self, "self")

    @self.setter
    def self(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "self", value)


if not MYPY:
    class TagProtectionAllowedToCreateArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access levels allowed to create protected tags. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        """
        access_level_description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Readable description of access level.
        """
        group_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        user_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
elif False:
    TagProtectionAllowedToCreateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TagProtectionAllowedToCreateArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[_builtins.str]] = None,
                 access_level_description: Optional[pulumi.Input[_builtins.str]] = None,
                 group_id: Optional[pulumi.Input[_builtins.int]] = None,
                 user_id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] access_level: Access levels allowed to create protected tags. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        :param pulumi.Input[_builtins.str] access_level_description: Readable description of access level.
        :param pulumi.Input[_builtins.int] group_id: The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        :param pulumi.Input[_builtins.int] user_id: The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_level_description is not None:
            pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access levels allowed to create protected tags. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_level", value)

    @_builtins.property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Readable description of access level.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_level_description", value)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "group_id", value)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class ValueStreamAnalyticsStageArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the value stream stage.
        """
        custom: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Boolean whether the stage is customized. If false, it assigns a built-in default stage by name.
        """
        end_event_identifier: NotRequired[pulumi.Input[_builtins.str]]
        """
        End event identifier. Valid values are: `CODE_STAGE_START`, `ISSUE_CLOSED`, `ISSUE_CREATED`, `ISSUE_DEPLOYED_TO_PRODUCTION`, `ISSUE_FIRST_ADDED_TO_BOARD`, `ISSUE_FIRST_ADDED_TO_ITERATION`, `ISSUE_FIRST_ASSIGNED_AT`, `ISSUE_FIRST_ASSOCIATED_WITH_MILESTONE`, `ISSUE_FIRST_MENTIONED_IN_COMMIT`, `ISSUE_LABEL_ADDED`, `ISSUE_LABEL_REMOVED`, `ISSUE_LAST_EDITED`, `ISSUE_STAGE_END`, `MERGE_REQUEST_CLOSED`, `MERGE_REQUEST_CREATED`, `MERGE_REQUEST_FIRST_ASSIGNED_AT`, `MERGE_REQUEST_FIRST_COMMIT_AT`, `MERGE_REQUEST_FIRST_DEPLOYED_TO_PRODUCTION`, `MERGE_REQUEST_LABEL_ADDED`, `MERGE_REQUEST_LABEL_REMOVED`, `MERGE_REQUEST_LAST_BUILD_FINISHED`, `MERGE_REQUEST_LAST_BUILD_STARTED`, `MERGE_REQUEST_LAST_EDITED`, `MERGE_REQUEST_MERGED`, `MERGE_REQUEST_REVIEWER_FIRST_ASSIGNED`, `MERGE_REQUEST_PLAN_STAGE_START`
        """
        end_event_label_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Label ID associated with the end event identifier. In the format of `gid://gitlab/GroupLabel/<id>` or `gid://gitlab/ProjectLabel/<id>`
        """
        hidden: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Boolean whether the stage is hidden, GitLab provided default stages are hidden by default.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the value stream stage.
        """
        start_event_identifier: NotRequired[pulumi.Input[_builtins.str]]
        """
        Start event identifier. Valid values are: `CODE_STAGE_START`, `ISSUE_CLOSED`, `ISSUE_CREATED`, `ISSUE_DEPLOYED_TO_PRODUCTION`, `ISSUE_FIRST_ADDED_TO_BOARD`, `ISSUE_FIRST_ADDED_TO_ITERATION`, `ISSUE_FIRST_ASSIGNED_AT`, `ISSUE_FIRST_ASSOCIATED_WITH_MILESTONE`, `ISSUE_FIRST_MENTIONED_IN_COMMIT`, `ISSUE_LABEL_ADDED`, `ISSUE_LABEL_REMOVED`, `ISSUE_LAST_EDITED`, `ISSUE_STAGE_END`, `MERGE_REQUEST_CLOSED`, `MERGE_REQUEST_CREATED`, `MERGE_REQUEST_FIRST_ASSIGNED_AT`, `MERGE_REQUEST_FIRST_COMMIT_AT`, `MERGE_REQUEST_FIRST_DEPLOYED_TO_PRODUCTION`, `MERGE_REQUEST_LABEL_ADDED`, `MERGE_REQUEST_LABEL_REMOVED`, `MERGE_REQUEST_LAST_BUILD_FINISHED`, `MERGE_REQUEST_LAST_BUILD_STARTED`, `MERGE_REQUEST_LAST_EDITED`, `MERGE_REQUEST_MERGED`, `MERGE_REQUEST_REVIEWER_FIRST_ASSIGNED`, `MERGE_REQUEST_PLAN_STAGE_START`
        """
        start_event_label_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Label ID associated with the start event identifier. In the format of `gid://gitlab/GroupLabel/<id>` or `gid://gitlab/ProjectLabel/<id>`
        """
elif False:
    ValueStreamAnalyticsStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ValueStreamAnalyticsStageArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 custom: Optional[pulumi.Input[_builtins.bool]] = None,
                 end_event_identifier: Optional[pulumi.Input[_builtins.str]] = None,
                 end_event_label_id: Optional[pulumi.Input[_builtins.str]] = None,
                 hidden: Optional[pulumi.Input[_builtins.bool]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 start_event_identifier: Optional[pulumi.Input[_builtins.str]] = None,
                 start_event_label_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the value stream stage.
        :param pulumi.Input[_builtins.bool] custom: Boolean whether the stage is customized. If false, it assigns a built-in default stage by name.
        :param pulumi.Input[_builtins.str] end_event_identifier: End event identifier. Valid values are: `CODE_STAGE_START`, `ISSUE_CLOSED`, `ISSUE_CREATED`, `ISSUE_DEPLOYED_TO_PRODUCTION`, `ISSUE_FIRST_ADDED_TO_BOARD`, `ISSUE_FIRST_ADDED_TO_ITERATION`, `ISSUE_FIRST_ASSIGNED_AT`, `ISSUE_FIRST_ASSOCIATED_WITH_MILESTONE`, `ISSUE_FIRST_MENTIONED_IN_COMMIT`, `ISSUE_LABEL_ADDED`, `ISSUE_LABEL_REMOVED`, `ISSUE_LAST_EDITED`, `ISSUE_STAGE_END`, `MERGE_REQUEST_CLOSED`, `MERGE_REQUEST_CREATED`, `MERGE_REQUEST_FIRST_ASSIGNED_AT`, `MERGE_REQUEST_FIRST_COMMIT_AT`, `MERGE_REQUEST_FIRST_DEPLOYED_TO_PRODUCTION`, `MERGE_REQUEST_LABEL_ADDED`, `MERGE_REQUEST_LABEL_REMOVED`, `MERGE_REQUEST_LAST_BUILD_FINISHED`, `MERGE_REQUEST_LAST_BUILD_STARTED`, `MERGE_REQUEST_LAST_EDITED`, `MERGE_REQUEST_MERGED`, `MERGE_REQUEST_REVIEWER_FIRST_ASSIGNED`, `MERGE_REQUEST_PLAN_STAGE_START`
        :param pulumi.Input[_builtins.str] end_event_label_id: Label ID associated with the end event identifier. In the format of `gid://gitlab/GroupLabel/<id>` or `gid://gitlab/ProjectLabel/<id>`
        :param pulumi.Input[_builtins.bool] hidden: Boolean whether the stage is hidden, GitLab provided default stages are hidden by default.
        :param pulumi.Input[_builtins.str] id: The ID of the value stream stage.
        :param pulumi.Input[_builtins.str] start_event_identifier: Start event identifier. Valid values are: `CODE_STAGE_START`, `ISSUE_CLOSED`, `ISSUE_CREATED`, `ISSUE_DEPLOYED_TO_PRODUCTION`, `ISSUE_FIRST_ADDED_TO_BOARD`, `ISSUE_FIRST_ADDED_TO_ITERATION`, `ISSUE_FIRST_ASSIGNED_AT`, `ISSUE_FIRST_ASSOCIATED_WITH_MILESTONE`, `ISSUE_FIRST_MENTIONED_IN_COMMIT`, `ISSUE_LABEL_ADDED`, `ISSUE_LABEL_REMOVED`, `ISSUE_LAST_EDITED`, `ISSUE_STAGE_END`, `MERGE_REQUEST_CLOSED`, `MERGE_REQUEST_CREATED`, `MERGE_REQUEST_FIRST_ASSIGNED_AT`, `MERGE_REQUEST_FIRST_COMMIT_AT`, `MERGE_REQUEST_FIRST_DEPLOYED_TO_PRODUCTION`, `MERGE_REQUEST_LABEL_ADDED`, `MERGE_REQUEST_LABEL_REMOVED`, `MERGE_REQUEST_LAST_BUILD_FINISHED`, `MERGE_REQUEST_LAST_BUILD_STARTED`, `MERGE_REQUEST_LAST_EDITED`, `MERGE_REQUEST_MERGED`, `MERGE_REQUEST_REVIEWER_FIRST_ASSIGNED`, `MERGE_REQUEST_PLAN_STAGE_START`
        :param pulumi.Input[_builtins.str] start_event_label_id: Label ID associated with the start event identifier. In the format of `gid://gitlab/GroupLabel/<id>` or `gid://gitlab/ProjectLabel/<id>`
        """
        pulumi.set(__self__, "name", name)
        if custom is not None:
            pulumi.set(__self__, "custom", custom)
        if end_event_identifier is not None:
            pulumi.set(__self__, "end_event_identifier", end_event_identifier)
        if end_event_label_id is not None:
            pulumi.set(__self__, "end_event_label_id", end_event_label_id)
        if hidden is not None:
            pulumi.set(__self__, "hidden", hidden)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if start_event_identifier is not None:
            pulumi.set(__self__, "start_event_identifier", start_event_identifier)
        if start_event_label_id is not None:
            pulumi.set(__self__, "start_event_label_id", start_event_label_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the value stream stage.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def custom(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Boolean whether the stage is customized. If false, it assigns a built-in default stage by name.
        """
        return pulumi.get(self, "custom")

    @custom.setter
    def custom(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "custom", value)

    @_builtins.property
    @pulumi.getter(name="endEventIdentifier")
    def end_event_identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        End event identifier. Valid values are: `CODE_STAGE_START`, `ISSUE_CLOSED`, `ISSUE_CREATED`, `ISSUE_DEPLOYED_TO_PRODUCTION`, `ISSUE_FIRST_ADDED_TO_BOARD`, `ISSUE_FIRST_ADDED_TO_ITERATION`, `ISSUE_FIRST_ASSIGNED_AT`, `ISSUE_FIRST_ASSOCIATED_WITH_MILESTONE`, `ISSUE_FIRST_MENTIONED_IN_COMMIT`, `ISSUE_LABEL_ADDED`, `ISSUE_LABEL_REMOVED`, `ISSUE_LAST_EDITED`, `ISSUE_STAGE_END`, `MERGE_REQUEST_CLOSED`, `MERGE_REQUEST_CREATED`, `MERGE_REQUEST_FIRST_ASSIGNED_AT`, `MERGE_REQUEST_FIRST_COMMIT_AT`, `MERGE_REQUEST_FIRST_DEPLOYED_TO_PRODUCTION`, `MERGE_REQUEST_LABEL_ADDED`, `MERGE_REQUEST_LABEL_REMOVED`, `MERGE_REQUEST_LAST_BUILD_FINISHED`, `MERGE_REQUEST_LAST_BUILD_STARTED`, `MERGE_REQUEST_LAST_EDITED`, `MERGE_REQUEST_MERGED`, `MERGE_REQUEST_REVIEWER_FIRST_ASSIGNED`, `MERGE_REQUEST_PLAN_STAGE_START`
        """
        return pulumi.get(self, "end_event_identifier")

    @end_event_identifier.setter
    def end_event_identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_event_identifier", value)

    @_builtins.property
    @pulumi.getter(name="endEventLabelId")
    def end_event_label_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Label ID associated with the end event identifier. In the format of `gid://gitlab/GroupLabel/<id>` or `gid://gitlab/ProjectLabel/<id>`
        """
        return pulumi.get(self, "end_event_label_id")

    @end_event_label_id.setter
    def end_event_label_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_event_label_id", value)

    @_builtins.property
    @pulumi.getter
    def hidden(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Boolean whether the stage is hidden, GitLab provided default stages are hidden by default.
        """
        return pulumi.get(self, "hidden")

    @hidden.setter
    def hidden(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "hidden", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the value stream stage.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="startEventIdentifier")
    def start_event_identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Start event identifier. Valid values are: `CODE_STAGE_START`, `ISSUE_CLOSED`, `ISSUE_CREATED`, `ISSUE_DEPLOYED_TO_PRODUCTION`, `ISSUE_FIRST_ADDED_TO_BOARD`, `ISSUE_FIRST_ADDED_TO_ITERATION`, `ISSUE_FIRST_ASSIGNED_AT`, `ISSUE_FIRST_ASSOCIATED_WITH_MILESTONE`, `ISSUE_FIRST_MENTIONED_IN_COMMIT`, `ISSUE_LABEL_ADDED`, `ISSUE_LABEL_REMOVED`, `ISSUE_LAST_EDITED`, `ISSUE_STAGE_END`, `MERGE_REQUEST_CLOSED`, `MERGE_REQUEST_CREATED`, `MERGE_REQUEST_FIRST_ASSIGNED_AT`, `MERGE_REQUEST_FIRST_COMMIT_AT`, `MERGE_REQUEST_FIRST_DEPLOYED_TO_PRODUCTION`, `MERGE_REQUEST_LABEL_ADDED`, `MERGE_REQUEST_LABEL_REMOVED`, `MERGE_REQUEST_LAST_BUILD_FINISHED`, `MERGE_REQUEST_LAST_BUILD_STARTED`, `MERGE_REQUEST_LAST_EDITED`, `MERGE_REQUEST_MERGED`, `MERGE_REQUEST_REVIEWER_FIRST_ASSIGNED`, `MERGE_REQUEST_PLAN_STAGE_START`
        """
        return pulumi.get(self, "start_event_identifier")

    @start_event_identifier.setter
    def start_event_identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_event_identifier", value)

    @_builtins.property
    @pulumi.getter(name="startEventLabelId")
    def start_event_label_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Label ID associated with the start event identifier. In the format of `gid://gitlab/GroupLabel/<id>` or `gid://gitlab/ProjectLabel/<id>`
        """
        return pulumi.get(self, "start_event_label_id")

    @start_event_label_id.setter
    def start_event_label_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_event_label_id", value)


if not MYPY:
    class GetGroupProvisionedUsersProvisionedUserArgsDict(TypedDict):
        avatar_url: _builtins.str
        """
        The avatar URL of the provisioned user.
        """
        bio: _builtins.str
        """
        The bio of the provisioned user.
        """
        bot: _builtins.bool
        """
        Whether the provisioned user is a bot.
        """
        confirmed_at: _builtins.str
        """
        The confirmation date of the provisioned user.
        """
        created_at: _builtins.str
        """
        The creation date of the provisioned user.
        """
        email: _builtins.str
        """
        The email of the provisioned user.
        """
        external: _builtins.bool
        """
        Whether the provisioned user is external.
        """
        id: _builtins.str
        """
        The ID of the provisioned user.
        """
        job_title: _builtins.str
        """
        The job title of the provisioned user.
        """
        last_activity_on: _builtins.str
        """
        The last activity date of the provisioned user.
        """
        last_sign_in_at: _builtins.str
        """
        The last sign-in date of the provisioned user.
        """
        linkedin: _builtins.str
        """
        The LinkedIn ID of the provisioned user.
        """
        location: _builtins.str
        """
        The location of the provisioned user.
        """
        name: _builtins.str
        """
        The name of the provisioned user.
        """
        organization: _builtins.str
        """
        The organization of the provisioned user.
        """
        private_profile: _builtins.bool
        """
        Whether the provisioned user has a private profile.
        """
        pronouns: _builtins.str
        """
        The pronouns of the provisioned user.
        """
        public_email: _builtins.str
        """
        The public email of the provisioned user.
        """
        skype: _builtins.str
        """
        The Skype ID of the provisioned user.
        """
        state: _builtins.str
        """
        The state of the provisioned user.
        """
        twitter: _builtins.str
        """
        The Twitter ID of the provisioned user.
        """
        two_factor_enabled: _builtins.bool
        """
        Whether two-factor authentication is enabled for the provisioned user.
        """
        username: _builtins.str
        """
        The username of the provisioned user.
        """
        web_url: _builtins.str
        """
        The web URL of the provisioned user.
        """
        website_url: _builtins.str
        """
        The website URL of the provisioned user.
        """
elif False:
    GetGroupProvisionedUsersProvisionedUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGroupProvisionedUsersProvisionedUserArgs:
    def __init__(__self__, *,
                 avatar_url: _builtins.str,
                 bio: _builtins.str,
                 bot: _builtins.bool,
                 confirmed_at: _builtins.str,
                 created_at: _builtins.str,
                 email: _builtins.str,
                 external: _builtins.bool,
                 id: _builtins.str,
                 job_title: _builtins.str,
                 last_activity_on: _builtins.str,
                 last_sign_in_at: _builtins.str,
                 linkedin: _builtins.str,
                 location: _builtins.str,
                 name: _builtins.str,
                 organization: _builtins.str,
                 private_profile: _builtins.bool,
                 pronouns: _builtins.str,
                 public_email: _builtins.str,
                 skype: _builtins.str,
                 state: _builtins.str,
                 twitter: _builtins.str,
                 two_factor_enabled: _builtins.bool,
                 username: _builtins.str,
                 web_url: _builtins.str,
                 website_url: _builtins.str):
        """
        :param _builtins.str avatar_url: The avatar URL of the provisioned user.
        :param _builtins.str bio: The bio of the provisioned user.
        :param _builtins.bool bot: Whether the provisioned user is a bot.
        :param _builtins.str confirmed_at: The confirmation date of the provisioned user.
        :param _builtins.str created_at: The creation date of the provisioned user.
        :param _builtins.str email: The email of the provisioned user.
        :param _builtins.bool external: Whether the provisioned user is external.
        :param _builtins.str id: The ID of the provisioned user.
        :param _builtins.str job_title: The job title of the provisioned user.
        :param _builtins.str last_activity_on: The last activity date of the provisioned user.
        :param _builtins.str last_sign_in_at: The last sign-in date of the provisioned user.
        :param _builtins.str linkedin: The LinkedIn ID of the provisioned user.
        :param _builtins.str location: The location of the provisioned user.
        :param _builtins.str name: The name of the provisioned user.
        :param _builtins.str organization: The organization of the provisioned user.
        :param _builtins.bool private_profile: Whether the provisioned user has a private profile.
        :param _builtins.str pronouns: The pronouns of the provisioned user.
        :param _builtins.str public_email: The public email of the provisioned user.
        :param _builtins.str skype: The Skype ID of the provisioned user.
        :param _builtins.str state: The state of the provisioned user.
        :param _builtins.str twitter: The Twitter ID of the provisioned user.
        :param _builtins.bool two_factor_enabled: Whether two-factor authentication is enabled for the provisioned user.
        :param _builtins.str username: The username of the provisioned user.
        :param _builtins.str web_url: The web URL of the provisioned user.
        :param _builtins.str website_url: The website URL of the provisioned user.
        """
        pulumi.set(__self__, "avatar_url", avatar_url)
        pulumi.set(__self__, "bio", bio)
        pulumi.set(__self__, "bot", bot)
        pulumi.set(__self__, "confirmed_at", confirmed_at)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "external", external)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "job_title", job_title)
        pulumi.set(__self__, "last_activity_on", last_activity_on)
        pulumi.set(__self__, "last_sign_in_at", last_sign_in_at)
        pulumi.set(__self__, "linkedin", linkedin)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "organization", organization)
        pulumi.set(__self__, "private_profile", private_profile)
        pulumi.set(__self__, "pronouns", pronouns)
        pulumi.set(__self__, "public_email", public_email)
        pulumi.set(__self__, "skype", skype)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "twitter", twitter)
        pulumi.set(__self__, "two_factor_enabled", two_factor_enabled)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "web_url", web_url)
        pulumi.set(__self__, "website_url", website_url)

    @_builtins.property
    @pulumi.getter(name="avatarUrl")
    def avatar_url(self) -> _builtins.str:
        """
        The avatar URL of the provisioned user.
        """
        return pulumi.get(self, "avatar_url")

    @avatar_url.setter
    def avatar_url(self, value: _builtins.str):
        pulumi.set(self, "avatar_url", value)

    @_builtins.property
    @pulumi.getter
    def bio(self) -> _builtins.str:
        """
        The bio of the provisioned user.
        """
        return pulumi.get(self, "bio")

    @bio.setter
    def bio(self, value: _builtins.str):
        pulumi.set(self, "bio", value)

    @_builtins.property
    @pulumi.getter
    def bot(self) -> _builtins.bool:
        """
        Whether the provisioned user is a bot.
        """
        return pulumi.get(self, "bot")

    @bot.setter
    def bot(self, value: _builtins.bool):
        pulumi.set(self, "bot", value)

    @_builtins.property
    @pulumi.getter(name="confirmedAt")
    def confirmed_at(self) -> _builtins.str:
        """
        The confirmation date of the provisioned user.
        """
        return pulumi.get(self, "confirmed_at")

    @confirmed_at.setter
    def confirmed_at(self, value: _builtins.str):
        pulumi.set(self, "confirmed_at", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation date of the provisioned user.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: _builtins.str):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The email of the provisioned user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: _builtins.str):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter
    def external(self) -> _builtins.bool:
        """
        Whether the provisioned user is external.
        """
        return pulumi.get(self, "external")

    @external.setter
    def external(self, value: _builtins.bool):
        pulumi.set(self, "external", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the provisioned user.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="jobTitle")
    def job_title(self) -> _builtins.str:
        """
        The job title of the provisioned user.
        """
        return pulumi.get(self, "job_title")

    @job_title.setter
    def job_title(self, value: _builtins.str):
        pulumi.set(self, "job_title", value)

    @_builtins.property
    @pulumi.getter(name="lastActivityOn")
    def last_activity_on(self) -> _builtins.str:
        """
        The last activity date of the provisioned user.
        """
        return pulumi.get(self, "last_activity_on")

    @last_activity_on.setter
    def last_activity_on(self, value: _builtins.str):
        pulumi.set(self, "last_activity_on", value)

    @_builtins.property
    @pulumi.getter(name="lastSignInAt")
    def last_sign_in_at(self) -> _builtins.str:
        """
        The last sign-in date of the provisioned user.
        """
        return pulumi.get(self, "last_sign_in_at")

    @last_sign_in_at.setter
    def last_sign_in_at(self, value: _builtins.str):
        pulumi.set(self, "last_sign_in_at", value)

    @_builtins.property
    @pulumi.getter
    def linkedin(self) -> _builtins.str:
        """
        The LinkedIn ID of the provisioned user.
        """
        return pulumi.get(self, "linkedin")

    @linkedin.setter
    def linkedin(self, value: _builtins.str):
        pulumi.set(self, "linkedin", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        """
        The location of the provisioned user.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: _builtins.str):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the provisioned user.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def organization(self) -> _builtins.str:
        """
        The organization of the provisioned user.
        """
        return pulumi.get(self, "organization")

    @organization.setter
    def organization(self, value: _builtins.str):
        pulumi.set(self, "organization", value)

    @_builtins.property
    @pulumi.getter(name="privateProfile")
    def private_profile(self) -> _builtins.bool:
        """
        Whether the provisioned user has a private profile.
        """
        return pulumi.get(self, "private_profile")

    @private_profile.setter
    def private_profile(self, value: _builtins.bool):
        pulumi.set(self, "private_profile", value)

    @_builtins.property
    @pulumi.getter
    def pronouns(self) -> _builtins.str:
        """
        The pronouns of the provisioned user.
        """
        return pulumi.get(self, "pronouns")

    @pronouns.setter
    def pronouns(self, value: _builtins.str):
        pulumi.set(self, "pronouns", value)

    @_builtins.property
    @pulumi.getter(name="publicEmail")
    def public_email(self) -> _builtins.str:
        """
        The public email of the provisioned user.
        """
        return pulumi.get(self, "public_email")

    @public_email.setter
    def public_email(self, value: _builtins.str):
        pulumi.set(self, "public_email", value)

    @_builtins.property
    @pulumi.getter
    def skype(self) -> _builtins.str:
        """
        The Skype ID of the provisioned user.
        """
        return pulumi.get(self, "skype")

    @skype.setter
    def skype(self, value: _builtins.str):
        pulumi.set(self, "skype", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of the provisioned user.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: _builtins.str):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter
    def twitter(self) -> _builtins.str:
        """
        The Twitter ID of the provisioned user.
        """
        return pulumi.get(self, "twitter")

    @twitter.setter
    def twitter(self, value: _builtins.str):
        pulumi.set(self, "twitter", value)

    @_builtins.property
    @pulumi.getter(name="twoFactorEnabled")
    def two_factor_enabled(self) -> _builtins.bool:
        """
        Whether two-factor authentication is enabled for the provisioned user.
        """
        return pulumi.get(self, "two_factor_enabled")

    @two_factor_enabled.setter
    def two_factor_enabled(self, value: _builtins.bool):
        pulumi.set(self, "two_factor_enabled", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The username of the provisioned user.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: _builtins.str):
        pulumi.set(self, "username", value)

    @_builtins.property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> _builtins.str:
        """
        The web URL of the provisioned user.
        """
        return pulumi.get(self, "web_url")

    @web_url.setter
    def web_url(self, value: _builtins.str):
        pulumi.set(self, "web_url", value)

    @_builtins.property
    @pulumi.getter(name="websiteUrl")
    def website_url(self) -> _builtins.str:
        """
        The website URL of the provisioned user.
        """
        return pulumi.get(self, "website_url")

    @website_url.setter
    def website_url(self, value: _builtins.str):
        pulumi.set(self, "website_url", value)


if not MYPY:
    class GetProjectApprovalRulesApprovalRuleArgsDict(TypedDict):
        applies_to_all_protected_branches: _builtins.bool
        """
        If true, applies the rule to all protected branches, ignoring the protected branches attribute.
        """
        approvals_required: _builtins.int
        """
        The number of approvals required for this rule.
        """
        eligible_approver_ids: Sequence[_builtins.int]
        """
        List of all approver IDs that are eligible to approve this rule.
        """
        group_ids: Sequence[_builtins.int]
        """
        List of group IDs that are eligible to approve this rule.
        """
        id: _builtins.int
        """
        The ID of the approval rule.
        """
        name: _builtins.str
        """
        The name of the approval rule.
        """
        protected_branch_ids: Sequence[_builtins.int]
        """
        List of protected branch IDs that this rule applies to.
        """
        report_type: _builtins.str
        """
        The report type. Required when the rule type is `report_approver`. The supported report types are `license_scanning` and `code_coverage`.
        """
        rule_type: _builtins.str
        """
        The type of the approval rule. Can be `any_approver`, `regular` or `report_approver`.
        """
        user_ids: Sequence[_builtins.int]
        """
        List of user IDs that are eligible to approve this rule.
        """
elif False:
    GetProjectApprovalRulesApprovalRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProjectApprovalRulesApprovalRuleArgs:
    def __init__(__self__, *,
                 applies_to_all_protected_branches: _builtins.bool,
                 approvals_required: _builtins.int,
                 eligible_approver_ids: Sequence[_builtins.int],
                 group_ids: Sequence[_builtins.int],
                 id: _builtins.int,
                 name: _builtins.str,
                 protected_branch_ids: Sequence[_builtins.int],
                 report_type: _builtins.str,
                 rule_type: _builtins.str,
                 user_ids: Sequence[_builtins.int]):
        """
        :param _builtins.bool applies_to_all_protected_branches: If true, applies the rule to all protected branches, ignoring the protected branches attribute.
        :param _builtins.int approvals_required: The number of approvals required for this rule.
        :param Sequence[_builtins.int] eligible_approver_ids: List of all approver IDs that are eligible to approve this rule.
        :param Sequence[_builtins.int] group_ids: List of group IDs that are eligible to approve this rule.
        :param _builtins.int id: The ID of the approval rule.
        :param _builtins.str name: The name of the approval rule.
        :param Sequence[_builtins.int] protected_branch_ids: List of protected branch IDs that this rule applies to.
        :param _builtins.str report_type: The report type. Required when the rule type is `report_approver`. The supported report types are `license_scanning` and `code_coverage`.
        :param _builtins.str rule_type: The type of the approval rule. Can be `any_approver`, `regular` or `report_approver`.
        :param Sequence[_builtins.int] user_ids: List of user IDs that are eligible to approve this rule.
        """
        pulumi.set(__self__, "applies_to_all_protected_branches", applies_to_all_protected_branches)
        pulumi.set(__self__, "approvals_required", approvals_required)
        pulumi.set(__self__, "eligible_approver_ids", eligible_approver_ids)
        pulumi.set(__self__, "group_ids", group_ids)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protected_branch_ids", protected_branch_ids)
        pulumi.set(__self__, "report_type", report_type)
        pulumi.set(__self__, "rule_type", rule_type)
        pulumi.set(__self__, "user_ids", user_ids)

    @_builtins.property
    @pulumi.getter(name="appliesToAllProtectedBranches")
    def applies_to_all_protected_branches(self) -> _builtins.bool:
        """
        If true, applies the rule to all protected branches, ignoring the protected branches attribute.
        """
        return pulumi.get(self, "applies_to_all_protected_branches")

    @applies_to_all_protected_branches.setter
    def applies_to_all_protected_branches(self, value: _builtins.bool):
        pulumi.set(self, "applies_to_all_protected_branches", value)

    @_builtins.property
    @pulumi.getter(name="approvalsRequired")
    def approvals_required(self) -> _builtins.int:
        """
        The number of approvals required for this rule.
        """
        return pulumi.get(self, "approvals_required")

    @approvals_required.setter
    def approvals_required(self, value: _builtins.int):
        pulumi.set(self, "approvals_required", value)

    @_builtins.property
    @pulumi.getter(name="eligibleApproverIds")
    def eligible_approver_ids(self) -> Sequence[_builtins.int]:
        """
        List of all approver IDs that are eligible to approve this rule.
        """
        return pulumi.get(self, "eligible_approver_ids")

    @eligible_approver_ids.setter
    def eligible_approver_ids(self, value: Sequence[_builtins.int]):
        pulumi.set(self, "eligible_approver_ids", value)

    @_builtins.property
    @pulumi.getter(name="groupIds")
    def group_ids(self) -> Sequence[_builtins.int]:
        """
        List of group IDs that are eligible to approve this rule.
        """
        return pulumi.get(self, "group_ids")

    @group_ids.setter
    def group_ids(self, value: Sequence[_builtins.int]):
        pulumi.set(self, "group_ids", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The ID of the approval rule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.int):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the approval rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="protectedBranchIds")
    def protected_branch_ids(self) -> Sequence[_builtins.int]:
        """
        List of protected branch IDs that this rule applies to.
        """
        return pulumi.get(self, "protected_branch_ids")

    @protected_branch_ids.setter
    def protected_branch_ids(self, value: Sequence[_builtins.int]):
        pulumi.set(self, "protected_branch_ids", value)

    @_builtins.property
    @pulumi.getter(name="reportType")
    def report_type(self) -> _builtins.str:
        """
        The report type. Required when the rule type is `report_approver`. The supported report types are `license_scanning` and `code_coverage`.
        """
        return pulumi.get(self, "report_type")

    @report_type.setter
    def report_type(self, value: _builtins.str):
        pulumi.set(self, "report_type", value)

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> _builtins.str:
        """
        The type of the approval rule. Can be `any_approver`, `regular` or `report_approver`.
        """
        return pulumi.get(self, "rule_type")

    @rule_type.setter
    def rule_type(self, value: _builtins.str):
        pulumi.set(self, "rule_type", value)

    @_builtins.property
    @pulumi.getter(name="userIds")
    def user_ids(self) -> Sequence[_builtins.int]:
        """
        List of user IDs that are eligible to approve this rule.
        """
        return pulumi.get(self, "user_ids")

    @user_ids.setter
    def user_ids(self, value: Sequence[_builtins.int]):
        pulumi.set(self, "user_ids", value)


if not MYPY:
    class GetProjectProtectedBranchMergeAccessLevelArgsDict(TypedDict):
        access_level: _builtins.str
        """
        Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        """
        access_level_description: _builtins.str
        """
        Readable description of access level.
        """
        group_id: NotRequired[_builtins.int]
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        user_id: NotRequired[_builtins.int]
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
elif False:
    GetProjectProtectedBranchMergeAccessLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProjectProtectedBranchMergeAccessLevelArgs:
    def __init__(__self__, *,
                 access_level: _builtins.str,
                 access_level_description: _builtins.str,
                 group_id: Optional[_builtins.int] = None,
                 user_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str access_level: Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        :param _builtins.str access_level_description: Readable description of access level.
        :param _builtins.int group_id: The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        :param _builtins.int user_id: The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        pulumi.set(__self__, "access_level", access_level)
        pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> _builtins.str:
        """
        Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: _builtins.str):
        pulumi.set(self, "access_level", value)

    @_builtins.property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> _builtins.str:
        """
        Readable description of access level.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: _builtins.str):
        pulumi.set(self, "access_level_description", value)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[_builtins.int]):
        pulumi.set(self, "group_id", value)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[_builtins.int]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class GetProjectProtectedBranchPushAccessLevelArgsDict(TypedDict):
        access_level: _builtins.str
        """
        Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        """
        access_level_description: _builtins.str
        """
        Readable description of access level.
        """
        deploy_key_id: NotRequired[_builtins.int]
        """
        The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `group_id` and `user_id`. This field is read-only until Gitlab 17.5.
        """
        group_id: NotRequired[_builtins.int]
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `user_id`.
        """
        user_id: NotRequired[_builtins.int]
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `group_id`.
        """
elif False:
    GetProjectProtectedBranchPushAccessLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProjectProtectedBranchPushAccessLevelArgs:
    def __init__(__self__, *,
                 access_level: _builtins.str,
                 access_level_description: _builtins.str,
                 deploy_key_id: Optional[_builtins.int] = None,
                 group_id: Optional[_builtins.int] = None,
                 user_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str access_level: Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        :param _builtins.str access_level_description: Readable description of access level.
        :param _builtins.int deploy_key_id: The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `group_id` and `user_id`. This field is read-only until Gitlab 17.5.
        :param _builtins.int group_id: The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `user_id`.
        :param _builtins.int user_id: The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `group_id`.
        """
        pulumi.set(__self__, "access_level", access_level)
        pulumi.set(__self__, "access_level_description", access_level_description)
        if deploy_key_id is not None:
            pulumi.set(__self__, "deploy_key_id", deploy_key_id)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> _builtins.str:
        """
        Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: _builtins.str):
        pulumi.set(self, "access_level", value)

    @_builtins.property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> _builtins.str:
        """
        Readable description of access level.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: _builtins.str):
        pulumi.set(self, "access_level_description", value)

    @_builtins.property
    @pulumi.getter(name="deployKeyId")
    def deploy_key_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `group_id` and `user_id`. This field is read-only until Gitlab 17.5.
        """
        return pulumi.get(self, "deploy_key_id")

    @deploy_key_id.setter
    def deploy_key_id(self, value: Optional[_builtins.int]):
        pulumi.set(self, "deploy_key_id", value)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[_builtins.int]):
        pulumi.set(self, "group_id", value)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[_builtins.int]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class GetProjectProtectedBranchesProtectedBranchArgsDict(TypedDict):
        allow_force_push: _builtins.bool
        """
        Whether force push is allowed.
        """
        code_owner_approval_required: _builtins.bool
        """
        Reject code pushes that change files listed in the CODEOWNERS file.
        """
        id: _builtins.int
        """
        The ID of this resource.
        """
        name: _builtins.str
        """
        The name of the protected branch.
        """
        merge_access_levels: NotRequired[Sequence['GetProjectProtectedBranchesProtectedBranchMergeAccessLevelArgsDict']]
        """
        Array of access levels and user(s)/group(s) allowed to merge to protected branch.
        """
        push_access_levels: NotRequired[Sequence['GetProjectProtectedBranchesProtectedBranchPushAccessLevelArgsDict']]
        """
        Array of access levels and user(s)/group(s) allowed to push to protected branch.
        """
elif False:
    GetProjectProtectedBranchesProtectedBranchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProjectProtectedBranchesProtectedBranchArgs:
    def __init__(__self__, *,
                 allow_force_push: _builtins.bool,
                 code_owner_approval_required: _builtins.bool,
                 id: _builtins.int,
                 name: _builtins.str,
                 merge_access_levels: Optional[Sequence['GetProjectProtectedBranchesProtectedBranchMergeAccessLevelArgs']] = None,
                 push_access_levels: Optional[Sequence['GetProjectProtectedBranchesProtectedBranchPushAccessLevelArgs']] = None):
        """
        :param _builtins.bool allow_force_push: Whether force push is allowed.
        :param _builtins.bool code_owner_approval_required: Reject code pushes that change files listed in the CODEOWNERS file.
        :param _builtins.int id: The ID of this resource.
        :param _builtins.str name: The name of the protected branch.
        :param Sequence['GetProjectProtectedBranchesProtectedBranchMergeAccessLevelArgs'] merge_access_levels: Array of access levels and user(s)/group(s) allowed to merge to protected branch.
        :param Sequence['GetProjectProtectedBranchesProtectedBranchPushAccessLevelArgs'] push_access_levels: Array of access levels and user(s)/group(s) allowed to push to protected branch.
        """
        pulumi.set(__self__, "allow_force_push", allow_force_push)
        pulumi.set(__self__, "code_owner_approval_required", code_owner_approval_required)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        if merge_access_levels is not None:
            pulumi.set(__self__, "merge_access_levels", merge_access_levels)
        if push_access_levels is not None:
            pulumi.set(__self__, "push_access_levels", push_access_levels)

    @_builtins.property
    @pulumi.getter(name="allowForcePush")
    def allow_force_push(self) -> _builtins.bool:
        """
        Whether force push is allowed.
        """
        return pulumi.get(self, "allow_force_push")

    @allow_force_push.setter
    def allow_force_push(self, value: _builtins.bool):
        pulumi.set(self, "allow_force_push", value)

    @_builtins.property
    @pulumi.getter(name="codeOwnerApprovalRequired")
    def code_owner_approval_required(self) -> _builtins.bool:
        """
        Reject code pushes that change files listed in the CODEOWNERS file.
        """
        return pulumi.get(self, "code_owner_approval_required")

    @code_owner_approval_required.setter
    def code_owner_approval_required(self, value: _builtins.bool):
        pulumi.set(self, "code_owner_approval_required", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.int):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the protected branch.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="mergeAccessLevels")
    def merge_access_levels(self) -> Optional[Sequence['GetProjectProtectedBranchesProtectedBranchMergeAccessLevelArgs']]:
        """
        Array of access levels and user(s)/group(s) allowed to merge to protected branch.
        """
        return pulumi.get(self, "merge_access_levels")

    @merge_access_levels.setter
    def merge_access_levels(self, value: Optional[Sequence['GetProjectProtectedBranchesProtectedBranchMergeAccessLevelArgs']]):
        pulumi.set(self, "merge_access_levels", value)

    @_builtins.property
    @pulumi.getter(name="pushAccessLevels")
    def push_access_levels(self) -> Optional[Sequence['GetProjectProtectedBranchesProtectedBranchPushAccessLevelArgs']]:
        """
        Array of access levels and user(s)/group(s) allowed to push to protected branch.
        """
        return pulumi.get(self, "push_access_levels")

    @push_access_levels.setter
    def push_access_levels(self, value: Optional[Sequence['GetProjectProtectedBranchesProtectedBranchPushAccessLevelArgs']]):
        pulumi.set(self, "push_access_levels", value)


if not MYPY:
    class GetProjectProtectedBranchesProtectedBranchMergeAccessLevelArgsDict(TypedDict):
        access_level: _builtins.str
        """
        Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        """
        access_level_description: _builtins.str
        """
        Readable description of access level.
        """
        group_id: NotRequired[_builtins.int]
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        user_id: NotRequired[_builtins.int]
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
elif False:
    GetProjectProtectedBranchesProtectedBranchMergeAccessLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProjectProtectedBranchesProtectedBranchMergeAccessLevelArgs:
    def __init__(__self__, *,
                 access_level: _builtins.str,
                 access_level_description: _builtins.str,
                 group_id: Optional[_builtins.int] = None,
                 user_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str access_level: Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        :param _builtins.str access_level_description: Readable description of access level.
        :param _builtins.int group_id: The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        :param _builtins.int user_id: The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        pulumi.set(__self__, "access_level", access_level)
        pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> _builtins.str:
        """
        Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: _builtins.str):
        pulumi.set(self, "access_level", value)

    @_builtins.property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> _builtins.str:
        """
        Readable description of access level.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: _builtins.str):
        pulumi.set(self, "access_level_description", value)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[_builtins.int]):
        pulumi.set(self, "group_id", value)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[_builtins.int]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class GetProjectProtectedBranchesProtectedBranchPushAccessLevelArgsDict(TypedDict):
        access_level: _builtins.str
        """
        Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        """
        access_level_description: _builtins.str
        """
        Readable description of access level.
        """
        deploy_key_id: NotRequired[_builtins.int]
        """
        The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `group_id` and `user_id`. This field is read-only until Gitlab 17.5.
        """
        group_id: NotRequired[_builtins.int]
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `user_id`.
        """
        user_id: NotRequired[_builtins.int]
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `group_id`.
        """
elif False:
    GetProjectProtectedBranchesProtectedBranchPushAccessLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProjectProtectedBranchesProtectedBranchPushAccessLevelArgs:
    def __init__(__self__, *,
                 access_level: _builtins.str,
                 access_level_description: _builtins.str,
                 deploy_key_id: Optional[_builtins.int] = None,
                 group_id: Optional[_builtins.int] = None,
                 user_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str access_level: Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        :param _builtins.str access_level_description: Readable description of access level.
        :param _builtins.int deploy_key_id: The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `group_id` and `user_id`. This field is read-only until Gitlab 17.5.
        :param _builtins.int group_id: The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `user_id`.
        :param _builtins.int user_id: The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `group_id`.
        """
        pulumi.set(__self__, "access_level", access_level)
        pulumi.set(__self__, "access_level_description", access_level_description)
        if deploy_key_id is not None:
            pulumi.set(__self__, "deploy_key_id", deploy_key_id)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> _builtins.str:
        """
        Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: _builtins.str):
        pulumi.set(self, "access_level", value)

    @_builtins.property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> _builtins.str:
        """
        Readable description of access level.
        """
        return pulumi.get(self, "access_level_description")

    @access_level_description.setter
    def access_level_description(self, value: _builtins.str):
        pulumi.set(self, "access_level_description", value)

    @_builtins.property
    @pulumi.getter(name="deployKeyId")
    def deploy_key_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `group_id` and `user_id`. This field is read-only until Gitlab 17.5.
        """
        return pulumi.get(self, "deploy_key_id")

    @deploy_key_id.setter
    def deploy_key_id(self, value: Optional[_builtins.int]):
        pulumi.set(self, "deploy_key_id", value)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `user_id`.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[_builtins.int]):
        pulumi.set(self, "group_id", value)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `group_id`.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[_builtins.int]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class GetReleaseAssetsArgsDict(TypedDict):
        count: _builtins.int
        """
        The number of assets for a release
        """
        links: NotRequired[Sequence['GetReleaseAssetsLinkArgsDict']]
        """
        The links for a release
        """
        sources: NotRequired[Sequence['GetReleaseAssetsSourceArgsDict']]
        """
        The sources for a release
        """
elif False:
    GetReleaseAssetsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetReleaseAssetsArgs:
    def __init__(__self__, *,
                 count: _builtins.int,
                 links: Optional[Sequence['GetReleaseAssetsLinkArgs']] = None,
                 sources: Optional[Sequence['GetReleaseAssetsSourceArgs']] = None):
        """
        :param _builtins.int count: The number of assets for a release
        :param Sequence['GetReleaseAssetsLinkArgs'] links: The links for a release
        :param Sequence['GetReleaseAssetsSourceArgs'] sources: The sources for a release
        """
        pulumi.set(__self__, "count", count)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        The number of assets for a release
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: _builtins.int):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter
    def links(self) -> Optional[Sequence['GetReleaseAssetsLinkArgs']]:
        """
        The links for a release
        """
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[Sequence['GetReleaseAssetsLinkArgs']]):
        pulumi.set(self, "links", value)

    @_builtins.property
    @pulumi.getter
    def sources(self) -> Optional[Sequence['GetReleaseAssetsSourceArgs']]:
        """
        The sources for a release
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[Sequence['GetReleaseAssetsSourceArgs']]):
        pulumi.set(self, "sources", value)


if not MYPY:
    class GetReleaseAssetsLinkArgsDict(TypedDict):
        id: _builtins.int
        """
        The ID of the link
        """
        link_type: _builtins.str
        """
        The type of the link
        """
        name: _builtins.str
        """
        The name of the link
        """
        url: _builtins.str
        """
        The URL of the link
        """
elif False:
    GetReleaseAssetsLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetReleaseAssetsLinkArgs:
    def __init__(__self__, *,
                 id: _builtins.int,
                 link_type: _builtins.str,
                 name: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.int id: The ID of the link
        :param _builtins.str link_type: The type of the link
        :param _builtins.str name: The name of the link
        :param _builtins.str url: The URL of the link
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "link_type", link_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The ID of the link
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.int):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="linkType")
    def link_type(self) -> _builtins.str:
        """
        The type of the link
        """
        return pulumi.get(self, "link_type")

    @link_type.setter
    def link_type(self, value: _builtins.str):
        pulumi.set(self, "link_type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the link
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The URL of the link
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)


if not MYPY:
    class GetReleaseAssetsSourceArgsDict(TypedDict):
        format: _builtins.str
        """
        The format of the source
        """
        url: _builtins.str
        """
        The URL of the source
        """
elif False:
    GetReleaseAssetsSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetReleaseAssetsSourceArgs:
    def __init__(__self__, *,
                 format: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str format: The format of the source
        :param _builtins.str url: The URL of the source
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def format(self) -> _builtins.str:
        """
        The format of the source
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: _builtins.str):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The URL of the source
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)


if not MYPY:
    class GetSecurityPolicyDocumentScanExecutionPolicyArgsDict(TypedDict):
        actions: Sequence['GetSecurityPolicyDocumentScanExecutionPolicyActionArgsDict']
        """
        Actions to execute when rules match. At least one action is required.
        """
        enabled: _builtins.bool
        """
        Whether the policy is enabled.
        """
        name: _builtins.str
        """
        Name of the scan execution policy.
        """
        rules: Sequence['GetSecurityPolicyDocumentScanExecutionPolicyRuleArgsDict']
        """
        Rules that trigger the policy. At least one rule is required.
        """
        description: NotRequired[_builtins.str]
        """
        Description of the scan execution policy.
        """
        policy_scope: NotRequired['GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeArgsDict']
        """
        Scope configuration to limit which projects the policy applies to.
        """
        skip_ci: NotRequired['GetSecurityPolicyDocumentScanExecutionPolicySkipCiArgsDict']
        """
        Control whether users can use the skip-ci directive.
        """
elif False:
    GetSecurityPolicyDocumentScanExecutionPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecurityPolicyDocumentScanExecutionPolicyArgs:
    def __init__(__self__, *,
                 actions: Sequence['GetSecurityPolicyDocumentScanExecutionPolicyActionArgs'],
                 enabled: _builtins.bool,
                 name: _builtins.str,
                 rules: Sequence['GetSecurityPolicyDocumentScanExecutionPolicyRuleArgs'],
                 description: Optional[_builtins.str] = None,
                 policy_scope: Optional['GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeArgs'] = None,
                 skip_ci: Optional['GetSecurityPolicyDocumentScanExecutionPolicySkipCiArgs'] = None):
        """
        :param Sequence['GetSecurityPolicyDocumentScanExecutionPolicyActionArgs'] actions: Actions to execute when rules match. At least one action is required.
        :param _builtins.bool enabled: Whether the policy is enabled.
        :param _builtins.str name: Name of the scan execution policy.
        :param Sequence['GetSecurityPolicyDocumentScanExecutionPolicyRuleArgs'] rules: Rules that trigger the policy. At least one rule is required.
        :param _builtins.str description: Description of the scan execution policy.
        :param 'GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeArgs' policy_scope: Scope configuration to limit which projects the policy applies to.
        :param 'GetSecurityPolicyDocumentScanExecutionPolicySkipCiArgs' skip_ci: Control whether users can use the skip-ci directive.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rules", rules)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if policy_scope is not None:
            pulumi.set(__self__, "policy_scope", policy_scope)
        if skip_ci is not None:
            pulumi.set(__self__, "skip_ci", skip_ci)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Sequence['GetSecurityPolicyDocumentScanExecutionPolicyActionArgs']:
        """
        Actions to execute when rules match. At least one action is required.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Sequence['GetSecurityPolicyDocumentScanExecutionPolicyActionArgs']):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether the policy is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the scan execution policy.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['GetSecurityPolicyDocumentScanExecutionPolicyRuleArgs']:
        """
        Rules that trigger the policy. At least one rule is required.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Sequence['GetSecurityPolicyDocumentScanExecutionPolicyRuleArgs']):
        pulumi.set(self, "rules", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the scan execution policy.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[_builtins.str]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="policyScope")
    def policy_scope(self) -> Optional['GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeArgs']:
        """
        Scope configuration to limit which projects the policy applies to.
        """
        return pulumi.get(self, "policy_scope")

    @policy_scope.setter
    def policy_scope(self, value: Optional['GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeArgs']):
        pulumi.set(self, "policy_scope", value)

    @_builtins.property
    @pulumi.getter(name="skipCi")
    def skip_ci(self) -> Optional['GetSecurityPolicyDocumentScanExecutionPolicySkipCiArgs']:
        """
        Control whether users can use the skip-ci directive.
        """
        return pulumi.get(self, "skip_ci")

    @skip_ci.setter
    def skip_ci(self, value: Optional['GetSecurityPolicyDocumentScanExecutionPolicySkipCiArgs']):
        pulumi.set(self, "skip_ci", value)


if not MYPY:
    class GetSecurityPolicyDocumentScanExecutionPolicyActionArgsDict(TypedDict):
        scan: _builtins.str
        """
        Type of scan to run. Valid values: `sast`, `secret_detection`, `container_scanning`, `dependency_scanning`, `dast`, `sast_iac`, `cluster_image_scanning`, `api_fuzzing`, `coverage_fuzzing`.
        """
        scanner_profile: NotRequired[_builtins.str]
        """
        Scanner profile to use for DAST scans.
        """
        site_profile: NotRequired[_builtins.str]
        """
        Site profile to use for DAST scans.
        """
        tags_to_excludes: NotRequired[Sequence[_builtins.str]]
        """
        Tags to exclude from the scan.
        """
        template: NotRequired[_builtins.str]
        """
        The template to use for the scan. Valid values: `default`, `latest`.
        """
        variables: NotRequired[Mapping[str, _builtins.str]]
        """
        Environment variables to pass to the scan job.
        """
elif False:
    GetSecurityPolicyDocumentScanExecutionPolicyActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecurityPolicyDocumentScanExecutionPolicyActionArgs:
    def __init__(__self__, *,
                 scan: _builtins.str,
                 scanner_profile: Optional[_builtins.str] = None,
                 site_profile: Optional[_builtins.str] = None,
                 tags_to_excludes: Optional[Sequence[_builtins.str]] = None,
                 template: Optional[_builtins.str] = None,
                 variables: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str scan: Type of scan to run. Valid values: `sast`, `secret_detection`, `container_scanning`, `dependency_scanning`, `dast`, `sast_iac`, `cluster_image_scanning`, `api_fuzzing`, `coverage_fuzzing`.
        :param _builtins.str scanner_profile: Scanner profile to use for DAST scans.
        :param _builtins.str site_profile: Site profile to use for DAST scans.
        :param Sequence[_builtins.str] tags_to_excludes: Tags to exclude from the scan.
        :param _builtins.str template: The template to use for the scan. Valid values: `default`, `latest`.
        :param Mapping[str, _builtins.str] variables: Environment variables to pass to the scan job.
        """
        pulumi.set(__self__, "scan", scan)
        if scanner_profile is not None:
            pulumi.set(__self__, "scanner_profile", scanner_profile)
        if site_profile is not None:
            pulumi.set(__self__, "site_profile", site_profile)
        if tags_to_excludes is not None:
            pulumi.set(__self__, "tags_to_excludes", tags_to_excludes)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @_builtins.property
    @pulumi.getter
    def scan(self) -> _builtins.str:
        """
        Type of scan to run. Valid values: `sast`, `secret_detection`, `container_scanning`, `dependency_scanning`, `dast`, `sast_iac`, `cluster_image_scanning`, `api_fuzzing`, `coverage_fuzzing`.
        """
        return pulumi.get(self, "scan")

    @scan.setter
    def scan(self, value: _builtins.str):
        pulumi.set(self, "scan", value)

    @_builtins.property
    @pulumi.getter(name="scannerProfile")
    def scanner_profile(self) -> Optional[_builtins.str]:
        """
        Scanner profile to use for DAST scans.
        """
        return pulumi.get(self, "scanner_profile")

    @scanner_profile.setter
    def scanner_profile(self, value: Optional[_builtins.str]):
        pulumi.set(self, "scanner_profile", value)

    @_builtins.property
    @pulumi.getter(name="siteProfile")
    def site_profile(self) -> Optional[_builtins.str]:
        """
        Site profile to use for DAST scans.
        """
        return pulumi.get(self, "site_profile")

    @site_profile.setter
    def site_profile(self, value: Optional[_builtins.str]):
        pulumi.set(self, "site_profile", value)

    @_builtins.property
    @pulumi.getter(name="tagsToExcludes")
    def tags_to_excludes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Tags to exclude from the scan.
        """
        return pulumi.get(self, "tags_to_excludes")

    @tags_to_excludes.setter
    def tags_to_excludes(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "tags_to_excludes", value)

    @_builtins.property
    @pulumi.getter
    def template(self) -> Optional[_builtins.str]:
        """
        The template to use for the scan. Valid values: `default`, `latest`.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[_builtins.str]):
        pulumi.set(self, "template", value)

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Environment variables to pass to the scan job.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[Mapping[str, _builtins.str]]):
        pulumi.set(self, "variables", value)


if not MYPY:
    class GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeArgsDict(TypedDict):
        compliance_frameworks: NotRequired[Sequence[_builtins.str]]
        """
        Compliance framework names to scope the policy to.
        """
        projects: NotRequired['GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeProjectsArgsDict']
        """
        Project scope configuration.
        """
elif False:
    GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeArgs:
    def __init__(__self__, *,
                 compliance_frameworks: Optional[Sequence[_builtins.str]] = None,
                 projects: Optional['GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeProjectsArgs'] = None):
        """
        :param Sequence[_builtins.str] compliance_frameworks: Compliance framework names to scope the policy to.
        :param 'GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeProjectsArgs' projects: Project scope configuration.
        """
        if compliance_frameworks is not None:
            pulumi.set(__self__, "compliance_frameworks", compliance_frameworks)
        if projects is not None:
            pulumi.set(__self__, "projects", projects)

    @_builtins.property
    @pulumi.getter(name="complianceFrameworks")
    def compliance_frameworks(self) -> Optional[Sequence[_builtins.str]]:
        """
        Compliance framework names to scope the policy to.
        """
        return pulumi.get(self, "compliance_frameworks")

    @compliance_frameworks.setter
    def compliance_frameworks(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "compliance_frameworks", value)

    @_builtins.property
    @pulumi.getter
    def projects(self) -> Optional['GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeProjectsArgs']:
        """
        Project scope configuration.
        """
        return pulumi.get(self, "projects")

    @projects.setter
    def projects(self, value: Optional['GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeProjectsArgs']):
        pulumi.set(self, "projects", value)


if not MYPY:
    class GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeProjectsArgsDict(TypedDict):
        excludings: NotRequired[Sequence[_builtins.int]]
        """
        List of project IDs to exclude from this policy.
        """
        includings: NotRequired[Sequence[_builtins.int]]
        """
        List of project IDs to explicitly include in this policy.
        """
elif False:
    GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeProjectsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeProjectsArgs:
    def __init__(__self__, *,
                 excludings: Optional[Sequence[_builtins.int]] = None,
                 includings: Optional[Sequence[_builtins.int]] = None):
        """
        :param Sequence[_builtins.int] excludings: List of project IDs to exclude from this policy.
        :param Sequence[_builtins.int] includings: List of project IDs to explicitly include in this policy.
        """
        if excludings is not None:
            pulumi.set(__self__, "excludings", excludings)
        if includings is not None:
            pulumi.set(__self__, "includings", includings)

    @_builtins.property
    @pulumi.getter
    def excludings(self) -> Optional[Sequence[_builtins.int]]:
        """
        List of project IDs to exclude from this policy.
        """
        return pulumi.get(self, "excludings")

    @excludings.setter
    def excludings(self, value: Optional[Sequence[_builtins.int]]):
        pulumi.set(self, "excludings", value)

    @_builtins.property
    @pulumi.getter
    def includings(self) -> Optional[Sequence[_builtins.int]]:
        """
        List of project IDs to explicitly include in this policy.
        """
        return pulumi.get(self, "includings")

    @includings.setter
    def includings(self, value: Optional[Sequence[_builtins.int]]):
        pulumi.set(self, "includings", value)


if not MYPY:
    class GetSecurityPolicyDocumentScanExecutionPolicyRuleArgsDict(TypedDict):
        type: _builtins.str
        """
        Type of rule. Valid values: `pipeline`, `schedule`, `agent`.
        """
        agents: NotRequired[Mapping[str, _builtins.str]]
        """
        Kubernetes agents configuration for agent-based policies.
        """
        branch_exceptions: NotRequired[Sequence[_builtins.str]]
        """
        Branches to exclude from the policy.
        """
        branch_type: NotRequired[_builtins.str]
        """
        Type of branches to match. Valid values: `all`, `protected`, `default`.
        """
        branches: NotRequired[Sequence[_builtins.str]]
        """
        Branch names or patterns to match.
        """
        cadence: NotRequired[_builtins.str]
        """
        Cron expression for schedule type rules (e.g., `*/15 * * * *` for every 15 minutes).
        """
elif False:
    GetSecurityPolicyDocumentScanExecutionPolicyRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecurityPolicyDocumentScanExecutionPolicyRuleArgs:
    def __init__(__self__, *,
                 type: _builtins.str,
                 agents: Optional[Mapping[str, _builtins.str]] = None,
                 branch_exceptions: Optional[Sequence[_builtins.str]] = None,
                 branch_type: Optional[_builtins.str] = None,
                 branches: Optional[Sequence[_builtins.str]] = None,
                 cadence: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Type of rule. Valid values: `pipeline`, `schedule`, `agent`.
        :param Mapping[str, _builtins.str] agents: Kubernetes agents configuration for agent-based policies.
        :param Sequence[_builtins.str] branch_exceptions: Branches to exclude from the policy.
        :param _builtins.str branch_type: Type of branches to match. Valid values: `all`, `protected`, `default`.
        :param Sequence[_builtins.str] branches: Branch names or patterns to match.
        :param _builtins.str cadence: Cron expression for schedule type rules (e.g., `*/15 * * * *` for every 15 minutes).
        """
        pulumi.set(__self__, "type", type)
        if agents is not None:
            pulumi.set(__self__, "agents", agents)
        if branch_exceptions is not None:
            pulumi.set(__self__, "branch_exceptions", branch_exceptions)
        if branch_type is not None:
            pulumi.set(__self__, "branch_type", branch_type)
        if branches is not None:
            pulumi.set(__self__, "branches", branches)
        if cadence is not None:
            pulumi.set(__self__, "cadence", cadence)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of rule. Valid values: `pipeline`, `schedule`, `agent`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def agents(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Kubernetes agents configuration for agent-based policies.
        """
        return pulumi.get(self, "agents")

    @agents.setter
    def agents(self, value: Optional[Mapping[str, _builtins.str]]):
        pulumi.set(self, "agents", value)

    @_builtins.property
    @pulumi.getter(name="branchExceptions")
    def branch_exceptions(self) -> Optional[Sequence[_builtins.str]]:
        """
        Branches to exclude from the policy.
        """
        return pulumi.get(self, "branch_exceptions")

    @branch_exceptions.setter
    def branch_exceptions(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "branch_exceptions", value)

    @_builtins.property
    @pulumi.getter(name="branchType")
    def branch_type(self) -> Optional[_builtins.str]:
        """
        Type of branches to match. Valid values: `all`, `protected`, `default`.
        """
        return pulumi.get(self, "branch_type")

    @branch_type.setter
    def branch_type(self, value: Optional[_builtins.str]):
        pulumi.set(self, "branch_type", value)

    @_builtins.property
    @pulumi.getter
    def branches(self) -> Optional[Sequence[_builtins.str]]:
        """
        Branch names or patterns to match.
        """
        return pulumi.get(self, "branches")

    @branches.setter
    def branches(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "branches", value)

    @_builtins.property
    @pulumi.getter
    def cadence(self) -> Optional[_builtins.str]:
        """
        Cron expression for schedule type rules (e.g., `*/15 * * * *` for every 15 minutes).
        """
        return pulumi.get(self, "cadence")

    @cadence.setter
    def cadence(self, value: Optional[_builtins.str]):
        pulumi.set(self, "cadence", value)


if not MYPY:
    class GetSecurityPolicyDocumentScanExecutionPolicySkipCiArgsDict(TypedDict):
        allowed: _builtins.bool
        """
        Allow (true) or prevent (false) the use of skip-ci directive.
        """
elif False:
    GetSecurityPolicyDocumentScanExecutionPolicySkipCiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecurityPolicyDocumentScanExecutionPolicySkipCiArgs:
    def __init__(__self__, *,
                 allowed: _builtins.bool):
        """
        :param _builtins.bool allowed: Allow (true) or prevent (false) the use of skip-ci directive.
        """
        pulumi.set(__self__, "allowed", allowed)

    @_builtins.property
    @pulumi.getter
    def allowed(self) -> _builtins.bool:
        """
        Allow (true) or prevent (false) the use of skip-ci directive.
        """
        return pulumi.get(self, "allowed")

    @allowed.setter
    def allowed(self, value: _builtins.bool):
        pulumi.set(self, "allowed", value)


