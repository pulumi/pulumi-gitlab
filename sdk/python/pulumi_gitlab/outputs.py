# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'ApplicationSettingsDefaultBranchProtectionDefaults',
    'BranchCommit',
    'BranchProtectionAllowedToMerge',
    'BranchProtectionAllowedToPush',
    'BranchProtectionAllowedToUnprotect',
    'GroupAccessTokenRotationConfiguration',
    'GroupDefaultBranchProtectionDefaults',
    'GroupEpicBoardList',
    'GroupHookCustomHeader',
    'GroupIssueBoardList',
    'GroupProtectedEnvironmentApprovalRule',
    'GroupProtectedEnvironmentDeployAccessLevel',
    'GroupPushRules',
    'GroupServiceAccountAccessTokenRotationConfiguration',
    'GroupServiceAccountTimeouts',
    'InstanceServiceAccountTimeouts',
    'PersonalAccessTokenRotationConfiguration',
    'ProjectAccessTokenRotationConfiguration',
    'ProjectContainerExpirationPolicy',
    'ProjectHookCustomHeader',
    'ProjectIssueBoardList',
    'ProjectIssueTaskCompletionStatus',
    'ProjectPagesSettingsDeployment',
    'ProjectProtectedEnvironmentApprovalRule',
    'ProjectProtectedEnvironmentDeployAccessLevel',
    'ProjectProtectedEnvironmentDeployAccessLevelsAttribute',
    'ProjectPushRules',
    'ProjectTagCommit',
    'ProjectTagRelease',
    'ReleaseAssets',
    'ReleaseAuthor',
    'ReleaseCommit',
    'ReleaseLinks',
    'TagProtectionAllowedToCreate',
    'ValueStreamAnalyticsStage',
    'GetBranchCommitResult',
    'GetClusterAgentsClusterAgentResult',
    'GetGroupAccessTokensAccessTokenResult',
    'GetGroupBillableMemberMembershipsMembershipResult',
    'GetGroupHooksHookResult',
    'GetGroupMembershipMemberResult',
    'GetGroupProvisionedUsersProvisionedUserResult',
    'GetGroupSamlLinksSamlLinkResult',
    'GetGroupServiceAccountAccessTokensAccessTokenResult',
    'GetGroupSharedWithGroupResult',
    'GetGroupSubgroupsSubgroupResult',
    'GetGroupVariablesVariableResult',
    'GetGroupsGroupResult',
    'GetInstanceDeployKeysDeployKeyResult',
    'GetInstanceDeployKeysDeployKeyProjectsWithWriteAccessResult',
    'GetInstanceVariablesVariableResult',
    'GetMetadataKasResult',
    'GetPipelineScheduleLastPipelineResult',
    'GetPipelineScheduleOwnerResult',
    'GetPipelineScheduleVariableResult',
    'GetPipelineSchedulesPipelineScheduleResult',
    'GetPipelineSchedulesPipelineScheduleOwnerResult',
    'GetProjectAccessTokensAccessTokenResult',
    'GetProjectApprovalRulesApprovalRuleResult',
    'GetProjectBranchesBranchResult',
    'GetProjectBranchesBranchCommitResult',
    'GetProjectContainerExpirationPolicyResult',
    'GetProjectEnvironmentsEnvironmentResult',
    'GetProjectHooksHookResult',
    'GetProjectIssueLabelEventsEventResult',
    'GetProjectIssueLabelEventsEventLabelResult',
    'GetProjectIssueLabelEventsEventUserResult',
    'GetProjectIssueTaskCompletionStatusResult',
    'GetProjectIssuesIssueResult',
    'GetProjectIssuesIssueTaskCompletionStatusResult',
    'GetProjectMembershipMemberResult',
    'GetProjectMergeRequestAssigneeResult',
    'GetProjectMergeRequestAuthorResult',
    'GetProjectMergeRequestClosedByResult',
    'GetProjectMergeRequestsMergeRequestResult',
    'GetProjectMergeRequestsMergeRequestAssigneeResult',
    'GetProjectMergeRequestsMergeRequestAuthorResult',
    'GetProjectMergeRequestsMergeRequestClosedByResult',
    'GetProjectMilestonesMilestoneResult',
    'GetProjectProtectedBranchMergeAccessLevelResult',
    'GetProjectProtectedBranchPushAccessLevelResult',
    'GetProjectProtectedBranchesProtectedBranchResult',
    'GetProjectProtectedBranchesProtectedBranchMergeAccessLevelResult',
    'GetProjectProtectedBranchesProtectedBranchPushAccessLevelResult',
    'GetProjectProtectedTagCreateAccessLevelResult',
    'GetProjectProtectedTagsProtectedTagResult',
    'GetProjectProtectedTagsProtectedTagCreateAccessLevelResult',
    'GetProjectPushRuleResult',
    'GetProjectSecureFileMetadataResult',
    'GetProjectSecureFileMetadataIssuerResult',
    'GetProjectSecureFileMetadataSubjectResult',
    'GetProjectSharedWithGroupResult',
    'GetProjectTagCommitResult',
    'GetProjectTagReleaseResult',
    'GetProjectTagsTagResult',
    'GetProjectTagsTagCommitResult',
    'GetProjectTagsTagReleaseResult',
    'GetProjectVariablesVariableResult',
    'GetProjectsProjectResult',
    'GetProjectsProjectContainerExpirationPolicyResult',
    'GetProjectsProjectForkedFromProjectResult',
    'GetProjectsProjectNamespaceResult',
    'GetProjectsProjectOwnerResult',
    'GetProjectsProjectPermissionResult',
    'GetProjectsProjectSharedWithGroupResult',
    'GetReleaseAssetsResult',
    'GetReleaseAssetsLinkResult',
    'GetReleaseAssetsSourceResult',
    'GetReleaseLinksReleaseLinkResult',
    'GetRepositoryTreeTreeResult',
    'GetRunnersRunnerResult',
    'GetSecurityPolicyDocumentScanExecutionPolicyResult',
    'GetSecurityPolicyDocumentScanExecutionPolicyActionResult',
    'GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeResult',
    'GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeProjectsResult',
    'GetSecurityPolicyDocumentScanExecutionPolicyRuleResult',
    'GetSecurityPolicyDocumentScanExecutionPolicySkipCiResult',
    'GetUserSshkeysKeyResult',
    'GetUsersUserResult',
]

@pulumi.output_type
class ApplicationSettingsDefaultBranchProtectionDefaults(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowForcePush":
            suggest = "allow_force_push"
        elif key == "allowedToMerges":
            suggest = "allowed_to_merges"
        elif key == "allowedToPushes":
            suggest = "allowed_to_pushes"
        elif key == "developerCanInitialPush":
            suggest = "developer_can_initial_push"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationSettingsDefaultBranchProtectionDefaults. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationSettingsDefaultBranchProtectionDefaults.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationSettingsDefaultBranchProtectionDefaults.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_force_push: Optional[_builtins.bool] = None,
                 allowed_to_merges: Optional[Sequence[_builtins.int]] = None,
                 allowed_to_pushes: Optional[Sequence[_builtins.int]] = None,
                 developer_can_initial_push: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool allow_force_push: Allow force push for all users with push access.
        :param Sequence[_builtins.int] allowed_to_merges: An array of access levels allowed to merge. Supports Developer (30) or Maintainer (40).
        :param Sequence[_builtins.int] allowed_to_pushes: An array of access levels allowed to push. Supports Developer (30) or Maintainer (40).
        :param _builtins.bool developer_can_initial_push: Allow developers to initial push.
        """
        if allow_force_push is not None:
            pulumi.set(__self__, "allow_force_push", allow_force_push)
        if allowed_to_merges is not None:
            pulumi.set(__self__, "allowed_to_merges", allowed_to_merges)
        if allowed_to_pushes is not None:
            pulumi.set(__self__, "allowed_to_pushes", allowed_to_pushes)
        if developer_can_initial_push is not None:
            pulumi.set(__self__, "developer_can_initial_push", developer_can_initial_push)

    @_builtins.property
    @pulumi.getter(name="allowForcePush")
    def allow_force_push(self) -> Optional[_builtins.bool]:
        """
        Allow force push for all users with push access.
        """
        return pulumi.get(self, "allow_force_push")

    @_builtins.property
    @pulumi.getter(name="allowedToMerges")
    def allowed_to_merges(self) -> Optional[Sequence[_builtins.int]]:
        """
        An array of access levels allowed to merge. Supports Developer (30) or Maintainer (40).
        """
        return pulumi.get(self, "allowed_to_merges")

    @_builtins.property
    @pulumi.getter(name="allowedToPushes")
    def allowed_to_pushes(self) -> Optional[Sequence[_builtins.int]]:
        """
        An array of access levels allowed to push. Supports Developer (30) or Maintainer (40).
        """
        return pulumi.get(self, "allowed_to_pushes")

    @_builtins.property
    @pulumi.getter(name="developerCanInitialPush")
    def developer_can_initial_push(self) -> Optional[_builtins.bool]:
        """
        Allow developers to initial push.
        """
        return pulumi.get(self, "developer_can_initial_push")


@pulumi.output_type
class BranchCommit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorEmail":
            suggest = "author_email"
        elif key == "authorName":
            suggest = "author_name"
        elif key == "authoredDate":
            suggest = "authored_date"
        elif key == "committedDate":
            suggest = "committed_date"
        elif key == "committerEmail":
            suggest = "committer_email"
        elif key == "committerName":
            suggest = "committer_name"
        elif key == "parentIds":
            suggest = "parent_ids"
        elif key == "shortId":
            suggest = "short_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BranchCommit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BranchCommit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BranchCommit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 author_email: Optional[_builtins.str] = None,
                 author_name: Optional[_builtins.str] = None,
                 authored_date: Optional[_builtins.str] = None,
                 committed_date: Optional[_builtins.str] = None,
                 committer_email: Optional[_builtins.str] = None,
                 committer_name: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 message: Optional[_builtins.str] = None,
                 parent_ids: Optional[Sequence[_builtins.str]] = None,
                 short_id: Optional[_builtins.str] = None,
                 title: Optional[_builtins.str] = None):
        """
        :param _builtins.str author_email: The email of the author.
        :param _builtins.str author_name: The name of the author.
        :param _builtins.str authored_date: The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
        :param _builtins.str committed_date: The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
        :param _builtins.str committer_email: The email of the user that committed.
        :param _builtins.str committer_name: The name of the user that committed.
        :param _builtins.str id: The unique id assigned to the commit by Gitlab.
        :param _builtins.str message: The commit message
        :param Sequence[_builtins.str] parent_ids: The id of the parents of the commit
        :param _builtins.str short_id: The short id assigned to the commit by Gitlab.
        :param _builtins.str title: The title of the commit
        """
        if author_email is not None:
            pulumi.set(__self__, "author_email", author_email)
        if author_name is not None:
            pulumi.set(__self__, "author_name", author_name)
        if authored_date is not None:
            pulumi.set(__self__, "authored_date", authored_date)
        if committed_date is not None:
            pulumi.set(__self__, "committed_date", committed_date)
        if committer_email is not None:
            pulumi.set(__self__, "committer_email", committer_email)
        if committer_name is not None:
            pulumi.set(__self__, "committer_name", committer_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if parent_ids is not None:
            pulumi.set(__self__, "parent_ids", parent_ids)
        if short_id is not None:
            pulumi.set(__self__, "short_id", short_id)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter(name="authorEmail")
    def author_email(self) -> Optional[_builtins.str]:
        """
        The email of the author.
        """
        return pulumi.get(self, "author_email")

    @_builtins.property
    @pulumi.getter(name="authorName")
    def author_name(self) -> Optional[_builtins.str]:
        """
        The name of the author.
        """
        return pulumi.get(self, "author_name")

    @_builtins.property
    @pulumi.getter(name="authoredDate")
    def authored_date(self) -> Optional[_builtins.str]:
        """
        The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
        """
        return pulumi.get(self, "authored_date")

    @_builtins.property
    @pulumi.getter(name="committedDate")
    def committed_date(self) -> Optional[_builtins.str]:
        """
        The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
        """
        return pulumi.get(self, "committed_date")

    @_builtins.property
    @pulumi.getter(name="committerEmail")
    def committer_email(self) -> Optional[_builtins.str]:
        """
        The email of the user that committed.
        """
        return pulumi.get(self, "committer_email")

    @_builtins.property
    @pulumi.getter(name="committerName")
    def committer_name(self) -> Optional[_builtins.str]:
        """
        The name of the user that committed.
        """
        return pulumi.get(self, "committer_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The unique id assigned to the commit by Gitlab.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        The commit message
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="parentIds")
    def parent_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The id of the parents of the commit
        """
        return pulumi.get(self, "parent_ids")

    @_builtins.property
    @pulumi.getter(name="shortId")
    def short_id(self) -> Optional[_builtins.str]:
        """
        The short id assigned to the commit by Gitlab.
        """
        return pulumi.get(self, "short_id")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        The title of the commit
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class BranchProtectionAllowedToMerge(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessLevel":
            suggest = "access_level"
        elif key == "accessLevelDescription":
            suggest = "access_level_description"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BranchProtectionAllowedToMerge. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BranchProtectionAllowedToMerge.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BranchProtectionAllowedToMerge.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_level: Optional[_builtins.str] = None,
                 access_level_description: Optional[_builtins.str] = None,
                 group_id: Optional[_builtins.int] = None,
                 user_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str access_level: Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        :param _builtins.str access_level_description: Readable description of access level.
        :param _builtins.int group_id: The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        :param _builtins.int user_id: The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_level_description is not None:
            pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[_builtins.str]:
        """
        Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        """
        return pulumi.get(self, "access_level")

    @_builtins.property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[_builtins.str]:
        """
        Readable description of access level.
        """
        return pulumi.get(self, "access_level_description")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class BranchProtectionAllowedToPush(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessLevel":
            suggest = "access_level"
        elif key == "accessLevelDescription":
            suggest = "access_level_description"
        elif key == "deployKeyId":
            suggest = "deploy_key_id"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BranchProtectionAllowedToPush. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BranchProtectionAllowedToPush.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BranchProtectionAllowedToPush.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_level: Optional[_builtins.str] = None,
                 access_level_description: Optional[_builtins.str] = None,
                 deploy_key_id: Optional[_builtins.int] = None,
                 group_id: Optional[_builtins.int] = None,
                 user_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str access_level: Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        :param _builtins.str access_level_description: Readable description of access level.
        :param _builtins.int deploy_key_id: The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `group_id` and `user_id`. This field is read-only until Gitlab 17.5.
        :param _builtins.int group_id: The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `user_id`.
        :param _builtins.int user_id: The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `group_id`.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_level_description is not None:
            pulumi.set(__self__, "access_level_description", access_level_description)
        if deploy_key_id is not None:
            pulumi.set(__self__, "deploy_key_id", deploy_key_id)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[_builtins.str]:
        """
        Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        """
        return pulumi.get(self, "access_level")

    @_builtins.property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[_builtins.str]:
        """
        Readable description of access level.
        """
        return pulumi.get(self, "access_level_description")

    @_builtins.property
    @pulumi.getter(name="deployKeyId")
    def deploy_key_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `group_id` and `user_id`. This field is read-only until Gitlab 17.5.
        """
        return pulumi.get(self, "deploy_key_id")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `user_id`.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `group_id`.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class BranchProtectionAllowedToUnprotect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessLevel":
            suggest = "access_level"
        elif key == "accessLevelDescription":
            suggest = "access_level_description"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BranchProtectionAllowedToUnprotect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BranchProtectionAllowedToUnprotect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BranchProtectionAllowedToUnprotect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_level: Optional[_builtins.str] = None,
                 access_level_description: Optional[_builtins.str] = None,
                 group_id: Optional[_builtins.int] = None,
                 user_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str access_level: Access levels allowed to unprotect push to protected branch. Valid values are: `developer`, `maintainer`, `admin`.
        :param _builtins.str access_level_description: Readable description of access level.
        :param _builtins.int group_id: The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        :param _builtins.int user_id: The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_level_description is not None:
            pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[_builtins.str]:
        """
        Access levels allowed to unprotect push to protected branch. Valid values are: `developer`, `maintainer`, `admin`.
        """
        return pulumi.get(self, "access_level")

    @_builtins.property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[_builtins.str]:
        """
        Readable description of access level.
        """
        return pulumi.get(self, "access_level_description")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GroupAccessTokenRotationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expirationDays":
            suggest = "expiration_days"
        elif key == "rotateBeforeDays":
            suggest = "rotate_before_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupAccessTokenRotationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupAccessTokenRotationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupAccessTokenRotationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expiration_days: _builtins.int,
                 rotate_before_days: _builtins.int):
        """
        :param _builtins.int expiration_days: The duration (in days) the new token should be valid for.
        :param _builtins.int rotate_before_days: The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
        pulumi.set(__self__, "expiration_days", expiration_days)
        pulumi.set(__self__, "rotate_before_days", rotate_before_days)

    @_builtins.property
    @pulumi.getter(name="expirationDays")
    def expiration_days(self) -> _builtins.int:
        """
        The duration (in days) the new token should be valid for.
        """
        return pulumi.get(self, "expiration_days")

    @_builtins.property
    @pulumi.getter(name="rotateBeforeDays")
    def rotate_before_days(self) -> _builtins.int:
        """
        The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
        return pulumi.get(self, "rotate_before_days")


@pulumi.output_type
class GroupDefaultBranchProtectionDefaults(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowForcePush":
            suggest = "allow_force_push"
        elif key == "allowedToMerges":
            suggest = "allowed_to_merges"
        elif key == "allowedToPushes":
            suggest = "allowed_to_pushes"
        elif key == "developerCanInitialPush":
            suggest = "developer_can_initial_push"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupDefaultBranchProtectionDefaults. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupDefaultBranchProtectionDefaults.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupDefaultBranchProtectionDefaults.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_force_push: Optional[_builtins.bool] = None,
                 allowed_to_merges: Optional[Sequence[_builtins.str]] = None,
                 allowed_to_pushes: Optional[Sequence[_builtins.str]] = None,
                 developer_can_initial_push: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool allow_force_push: Allow force push for all users with push access.
        :param Sequence[_builtins.str] allowed_to_merges: An array of access levels allowed to merge. Valid values are: `developer`, `maintainer`, `no one`.
        :param Sequence[_builtins.str] allowed_to_pushes: An array of access levels allowed to push. Valid values are: `developer`, `maintainer`, `no one`.
        :param _builtins.bool developer_can_initial_push: Allow developers to initial push.
        """
        if allow_force_push is not None:
            pulumi.set(__self__, "allow_force_push", allow_force_push)
        if allowed_to_merges is not None:
            pulumi.set(__self__, "allowed_to_merges", allowed_to_merges)
        if allowed_to_pushes is not None:
            pulumi.set(__self__, "allowed_to_pushes", allowed_to_pushes)
        if developer_can_initial_push is not None:
            pulumi.set(__self__, "developer_can_initial_push", developer_can_initial_push)

    @_builtins.property
    @pulumi.getter(name="allowForcePush")
    def allow_force_push(self) -> Optional[_builtins.bool]:
        """
        Allow force push for all users with push access.
        """
        return pulumi.get(self, "allow_force_push")

    @_builtins.property
    @pulumi.getter(name="allowedToMerges")
    def allowed_to_merges(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of access levels allowed to merge. Valid values are: `developer`, `maintainer`, `no one`.
        """
        return pulumi.get(self, "allowed_to_merges")

    @_builtins.property
    @pulumi.getter(name="allowedToPushes")
    def allowed_to_pushes(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of access levels allowed to push. Valid values are: `developer`, `maintainer`, `no one`.
        """
        return pulumi.get(self, "allowed_to_pushes")

    @_builtins.property
    @pulumi.getter(name="developerCanInitialPush")
    def developer_can_initial_push(self) -> Optional[_builtins.bool]:
        """
        Allow developers to initial push.
        """
        return pulumi.get(self, "developer_can_initial_push")


@pulumi.output_type
class GroupEpicBoardList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelId":
            suggest = "label_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupEpicBoardList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupEpicBoardList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupEpicBoardList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[_builtins.int] = None,
                 label_id: Optional[_builtins.int] = None,
                 position: Optional[_builtins.int] = None):
        """
        :param _builtins.int id: The ID of the list.
        :param _builtins.int label_id: The ID of the label the list should be scoped to.
        :param _builtins.int position: The position of the list within the board. The position for the list is sed on the its position in the `lists` array.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if label_id is not None:
            pulumi.set(__self__, "label_id", label_id)
        if position is not None:
            pulumi.set(__self__, "position", position)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.int]:
        """
        The ID of the list.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="labelId")
    def label_id(self) -> Optional[_builtins.int]:
        """
        The ID of the label the list should be scoped to.
        """
        return pulumi.get(self, "label_id")

    @_builtins.property
    @pulumi.getter
    def position(self) -> Optional[_builtins.int]:
        """
        The position of the list within the board. The position for the list is sed on the its position in the `lists` array.
        """
        return pulumi.get(self, "position")


@pulumi.output_type
class GroupHookCustomHeader(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Key of the custom header.
        :param _builtins.str value: Value of the custom header. This value cannot be imported.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Key of the custom header.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of the custom header. This value cannot be imported.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GroupIssueBoardList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelId":
            suggest = "label_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupIssueBoardList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupIssueBoardList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupIssueBoardList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[_builtins.int] = None,
                 label_id: Optional[_builtins.int] = None,
                 position: Optional[_builtins.int] = None):
        """
        :param _builtins.int id: The ID of the list.
        :param _builtins.int label_id: The ID of the label the list should be scoped to.
        :param _builtins.int position: The explicit position of the list within the board, zero based.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if label_id is not None:
            pulumi.set(__self__, "label_id", label_id)
        if position is not None:
            pulumi.set(__self__, "position", position)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.int]:
        """
        The ID of the list.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="labelId")
    def label_id(self) -> Optional[_builtins.int]:
        """
        The ID of the label the list should be scoped to.
        """
        return pulumi.get(self, "label_id")

    @_builtins.property
    @pulumi.getter
    def position(self) -> Optional[_builtins.int]:
        """
        The explicit position of the list within the board, zero based.
        """
        return pulumi.get(self, "position")


@pulumi.output_type
class GroupProtectedEnvironmentApprovalRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessLevel":
            suggest = "access_level"
        elif key == "accessLevelDescription":
            suggest = "access_level_description"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "groupInheritanceType":
            suggest = "group_inheritance_type"
        elif key == "requiredApprovals":
            suggest = "required_approvals"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupProtectedEnvironmentApprovalRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupProtectedEnvironmentApprovalRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupProtectedEnvironmentApprovalRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_level: Optional[_builtins.str] = None,
                 access_level_description: Optional[_builtins.str] = None,
                 group_id: Optional[_builtins.int] = None,
                 group_inheritance_type: Optional[_builtins.int] = None,
                 id: Optional[_builtins.int] = None,
                 required_approvals: Optional[_builtins.int] = None,
                 user_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str access_level: Levels of access allowed to approve a deployment to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        :param _builtins.str access_level_description: Readable description of level of access.
        :param _builtins.int group_id: The ID of the group allowed to approve a deployment to this protected environment. TThe group must be a sub-group under the given group. Mutually exclusive with `access_level` and `user_id`.
        :param _builtins.int group_inheritance_type: Group inheritance allows access rules to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        :param _builtins.int id: The unique ID of the Approval Rules object.
        :param _builtins.int required_approvals: The number of approval required to allow deployment to this protected environment. This is mutually exclusive with user_id.
        :param _builtins.int user_id: The ID of the user allowed to approve a deployment to this protected environment. The user must be a member of the group with Maintainer role or higher. Mutually exclusive with `access_level` and `group_id`.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_level_description is not None:
            pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if group_inheritance_type is not None:
            pulumi.set(__self__, "group_inheritance_type", group_inheritance_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if required_approvals is not None:
            pulumi.set(__self__, "required_approvals", required_approvals)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[_builtins.str]:
        """
        Levels of access allowed to approve a deployment to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        """
        return pulumi.get(self, "access_level")

    @_builtins.property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[_builtins.str]:
        """
        Readable description of level of access.
        """
        return pulumi.get(self, "access_level_description")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.int]:
        """
        The ID of the group allowed to approve a deployment to this protected environment. TThe group must be a sub-group under the given group. Mutually exclusive with `access_level` and `user_id`.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="groupInheritanceType")
    def group_inheritance_type(self) -> Optional[_builtins.int]:
        """
        Group inheritance allows access rules to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        """
        return pulumi.get(self, "group_inheritance_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.int]:
        """
        The unique ID of the Approval Rules object.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="requiredApprovals")
    def required_approvals(self) -> Optional[_builtins.int]:
        """
        The number of approval required to allow deployment to this protected environment. This is mutually exclusive with user_id.
        """
        return pulumi.get(self, "required_approvals")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.int]:
        """
        The ID of the user allowed to approve a deployment to this protected environment. The user must be a member of the group with Maintainer role or higher. Mutually exclusive with `access_level` and `group_id`.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GroupProtectedEnvironmentDeployAccessLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessLevel":
            suggest = "access_level"
        elif key == "accessLevelDescription":
            suggest = "access_level_description"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "groupInheritanceType":
            suggest = "group_inheritance_type"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupProtectedEnvironmentDeployAccessLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupProtectedEnvironmentDeployAccessLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupProtectedEnvironmentDeployAccessLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_level: Optional[_builtins.str] = None,
                 access_level_description: Optional[_builtins.str] = None,
                 group_id: Optional[_builtins.int] = None,
                 group_inheritance_type: Optional[_builtins.int] = None,
                 id: Optional[_builtins.int] = None,
                 user_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str access_level: Levels of access required to deploy to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        :param _builtins.str access_level_description: Readable description of level of access.
        :param _builtins.int group_id: The ID of the group allowed to deploy to this protected environment. The group must be a sub-group under the given group. Mutually exclusive with `access_level` and `user_id`.
        :param _builtins.int group_inheritance_type: Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        :param _builtins.int id: The unique ID of the Deploy Access Level object.
        :param _builtins.int user_id: The ID of the user allowed to deploy to this protected environment. The user must be a member of the group with Maintainer role or higher. Mutually exclusive with `access_level` and `group_id`.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_level_description is not None:
            pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if group_inheritance_type is not None:
            pulumi.set(__self__, "group_inheritance_type", group_inheritance_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[_builtins.str]:
        """
        Levels of access required to deploy to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        """
        return pulumi.get(self, "access_level")

    @_builtins.property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[_builtins.str]:
        """
        Readable description of level of access.
        """
        return pulumi.get(self, "access_level_description")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.int]:
        """
        The ID of the group allowed to deploy to this protected environment. The group must be a sub-group under the given group. Mutually exclusive with `access_level` and `user_id`.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="groupInheritanceType")
    def group_inheritance_type(self) -> Optional[_builtins.int]:
        """
        Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        """
        return pulumi.get(self, "group_inheritance_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.int]:
        """
        The unique ID of the Deploy Access Level object.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.int]:
        """
        The ID of the user allowed to deploy to this protected environment. The user must be a member of the group with Maintainer role or higher. Mutually exclusive with `access_level` and `group_id`.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GroupPushRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorEmailRegex":
            suggest = "author_email_regex"
        elif key == "branchNameRegex":
            suggest = "branch_name_regex"
        elif key == "commitCommitterCheck":
            suggest = "commit_committer_check"
        elif key == "commitCommitterNameCheck":
            suggest = "commit_committer_name_check"
        elif key == "commitMessageNegativeRegex":
            suggest = "commit_message_negative_regex"
        elif key == "commitMessageRegex":
            suggest = "commit_message_regex"
        elif key == "denyDeleteTag":
            suggest = "deny_delete_tag"
        elif key == "fileNameRegex":
            suggest = "file_name_regex"
        elif key == "maxFileSize":
            suggest = "max_file_size"
        elif key == "memberCheck":
            suggest = "member_check"
        elif key == "preventSecrets":
            suggest = "prevent_secrets"
        elif key == "rejectNonDcoCommits":
            suggest = "reject_non_dco_commits"
        elif key == "rejectUnsignedCommits":
            suggest = "reject_unsigned_commits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupPushRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupPushRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupPushRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 author_email_regex: Optional[_builtins.str] = None,
                 branch_name_regex: Optional[_builtins.str] = None,
                 commit_committer_check: Optional[_builtins.bool] = None,
                 commit_committer_name_check: Optional[_builtins.bool] = None,
                 commit_message_negative_regex: Optional[_builtins.str] = None,
                 commit_message_regex: Optional[_builtins.str] = None,
                 deny_delete_tag: Optional[_builtins.bool] = None,
                 file_name_regex: Optional[_builtins.str] = None,
                 max_file_size: Optional[_builtins.int] = None,
                 member_check: Optional[_builtins.bool] = None,
                 prevent_secrets: Optional[_builtins.bool] = None,
                 reject_non_dco_commits: Optional[_builtins.bool] = None,
                 reject_unsigned_commits: Optional[_builtins.bool] = None):
        """
        :param _builtins.str author_email_regex: All commit author emails must match this regex, e.g. `@my-company.com$`.
        :param _builtins.str branch_name_regex: All branch names must match this regex, e.g. `(feature|hotfix)\\/*`.
        :param _builtins.bool commit_committer_check: Only commits pushed using verified emails are allowed.
        :param _builtins.bool commit_committer_name_check: Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
        :param _builtins.str commit_message_negative_regex: No commit message is allowed to match this regex, for example `ssh\\:\\/\\/`.
        :param _builtins.str commit_message_regex: All commit messages must match this regex, e.g. `Fixed \\d+\\..*`.
        :param _builtins.bool deny_delete_tag: Deny deleting a tag.
        :param _builtins.str file_name_regex: Filenames matching the regular expression provided in this attribute are not allowed, for example, `(jar|exe)$`.
        :param _builtins.int max_file_size: Maximum file size (MB) allowed.
        :param _builtins.bool member_check: Allows only GitLab users to author commits.
        :param _builtins.bool prevent_secrets: GitLab will reject any files that are likely to contain secrets.
        :param _builtins.bool reject_non_dco_commits: Reject commit when its not DCO certified.
        :param _builtins.bool reject_unsigned_commits: Only commits signed through GPG are allowed.
        """
        if author_email_regex is not None:
            pulumi.set(__self__, "author_email_regex", author_email_regex)
        if branch_name_regex is not None:
            pulumi.set(__self__, "branch_name_regex", branch_name_regex)
        if commit_committer_check is not None:
            pulumi.set(__self__, "commit_committer_check", commit_committer_check)
        if commit_committer_name_check is not None:
            pulumi.set(__self__, "commit_committer_name_check", commit_committer_name_check)
        if commit_message_negative_regex is not None:
            pulumi.set(__self__, "commit_message_negative_regex", commit_message_negative_regex)
        if commit_message_regex is not None:
            pulumi.set(__self__, "commit_message_regex", commit_message_regex)
        if deny_delete_tag is not None:
            pulumi.set(__self__, "deny_delete_tag", deny_delete_tag)
        if file_name_regex is not None:
            pulumi.set(__self__, "file_name_regex", file_name_regex)
        if max_file_size is not None:
            pulumi.set(__self__, "max_file_size", max_file_size)
        if member_check is not None:
            pulumi.set(__self__, "member_check", member_check)
        if prevent_secrets is not None:
            pulumi.set(__self__, "prevent_secrets", prevent_secrets)
        if reject_non_dco_commits is not None:
            pulumi.set(__self__, "reject_non_dco_commits", reject_non_dco_commits)
        if reject_unsigned_commits is not None:
            pulumi.set(__self__, "reject_unsigned_commits", reject_unsigned_commits)

    @_builtins.property
    @pulumi.getter(name="authorEmailRegex")
    def author_email_regex(self) -> Optional[_builtins.str]:
        """
        All commit author emails must match this regex, e.g. `@my-company.com$`.
        """
        return pulumi.get(self, "author_email_regex")

    @_builtins.property
    @pulumi.getter(name="branchNameRegex")
    def branch_name_regex(self) -> Optional[_builtins.str]:
        """
        All branch names must match this regex, e.g. `(feature|hotfix)\\/*`.
        """
        return pulumi.get(self, "branch_name_regex")

    @_builtins.property
    @pulumi.getter(name="commitCommitterCheck")
    def commit_committer_check(self) -> Optional[_builtins.bool]:
        """
        Only commits pushed using verified emails are allowed.
        """
        return pulumi.get(self, "commit_committer_check")

    @_builtins.property
    @pulumi.getter(name="commitCommitterNameCheck")
    def commit_committer_name_check(self) -> Optional[_builtins.bool]:
        """
        Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
        """
        return pulumi.get(self, "commit_committer_name_check")

    @_builtins.property
    @pulumi.getter(name="commitMessageNegativeRegex")
    def commit_message_negative_regex(self) -> Optional[_builtins.str]:
        """
        No commit message is allowed to match this regex, for example `ssh\\:\\/\\/`.
        """
        return pulumi.get(self, "commit_message_negative_regex")

    @_builtins.property
    @pulumi.getter(name="commitMessageRegex")
    def commit_message_regex(self) -> Optional[_builtins.str]:
        """
        All commit messages must match this regex, e.g. `Fixed \\d+\\..*`.
        """
        return pulumi.get(self, "commit_message_regex")

    @_builtins.property
    @pulumi.getter(name="denyDeleteTag")
    def deny_delete_tag(self) -> Optional[_builtins.bool]:
        """
        Deny deleting a tag.
        """
        return pulumi.get(self, "deny_delete_tag")

    @_builtins.property
    @pulumi.getter(name="fileNameRegex")
    def file_name_regex(self) -> Optional[_builtins.str]:
        """
        Filenames matching the regular expression provided in this attribute are not allowed, for example, `(jar|exe)$`.
        """
        return pulumi.get(self, "file_name_regex")

    @_builtins.property
    @pulumi.getter(name="maxFileSize")
    def max_file_size(self) -> Optional[_builtins.int]:
        """
        Maximum file size (MB) allowed.
        """
        return pulumi.get(self, "max_file_size")

    @_builtins.property
    @pulumi.getter(name="memberCheck")
    def member_check(self) -> Optional[_builtins.bool]:
        """
        Allows only GitLab users to author commits.
        """
        return pulumi.get(self, "member_check")

    @_builtins.property
    @pulumi.getter(name="preventSecrets")
    def prevent_secrets(self) -> Optional[_builtins.bool]:
        """
        GitLab will reject any files that are likely to contain secrets.
        """
        return pulumi.get(self, "prevent_secrets")

    @_builtins.property
    @pulumi.getter(name="rejectNonDcoCommits")
    def reject_non_dco_commits(self) -> Optional[_builtins.bool]:
        """
        Reject commit when its not DCO certified.
        """
        return pulumi.get(self, "reject_non_dco_commits")

    @_builtins.property
    @pulumi.getter(name="rejectUnsignedCommits")
    def reject_unsigned_commits(self) -> Optional[_builtins.bool]:
        """
        Only commits signed through GPG are allowed.
        """
        return pulumi.get(self, "reject_unsigned_commits")


@pulumi.output_type
class GroupServiceAccountAccessTokenRotationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rotateBeforeDays":
            suggest = "rotate_before_days"
        elif key == "expirationDays":
            suggest = "expiration_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupServiceAccountAccessTokenRotationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupServiceAccountAccessTokenRotationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupServiceAccountAccessTokenRotationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rotate_before_days: _builtins.int,
                 expiration_days: Optional[_builtins.int] = None):
        """
        :param _builtins.int rotate_before_days: The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        :param _builtins.int expiration_days: The duration (in days) the new token should be valid for.
        """
        pulumi.set(__self__, "rotate_before_days", rotate_before_days)
        if expiration_days is not None:
            pulumi.set(__self__, "expiration_days", expiration_days)

    @_builtins.property
    @pulumi.getter(name="rotateBeforeDays")
    def rotate_before_days(self) -> _builtins.int:
        """
        The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
        return pulumi.get(self, "rotate_before_days")

    @_builtins.property
    @pulumi.getter(name="expirationDays")
    def expiration_days(self) -> Optional[_builtins.int]:
        """
        The duration (in days) the new token should be valid for.
        """
        return pulumi.get(self, "expiration_days")


@pulumi.output_type
class GroupServiceAccountTimeouts(dict):
    def __init__(__self__, *,
                 delete: Optional[_builtins.str] = None):
        """
        :param _builtins.str delete: How long to wait for the service account to be fully deleted. Defaults to 10 minutes.
        """
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        How long to wait for the service account to be fully deleted. Defaults to 10 minutes.
        """
        return pulumi.get(self, "delete")


@pulumi.output_type
class InstanceServiceAccountTimeouts(dict):
    def __init__(__self__, *,
                 delete: Optional[_builtins.str] = None):
        """
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")


@pulumi.output_type
class PersonalAccessTokenRotationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expirationDays":
            suggest = "expiration_days"
        elif key == "rotateBeforeDays":
            suggest = "rotate_before_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PersonalAccessTokenRotationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PersonalAccessTokenRotationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PersonalAccessTokenRotationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expiration_days: _builtins.int,
                 rotate_before_days: _builtins.int):
        """
        :param _builtins.int expiration_days: The duration (in days) the new token should be valid for.
        :param _builtins.int rotate_before_days: The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
        pulumi.set(__self__, "expiration_days", expiration_days)
        pulumi.set(__self__, "rotate_before_days", rotate_before_days)

    @_builtins.property
    @pulumi.getter(name="expirationDays")
    def expiration_days(self) -> _builtins.int:
        """
        The duration (in days) the new token should be valid for.
        """
        return pulumi.get(self, "expiration_days")

    @_builtins.property
    @pulumi.getter(name="rotateBeforeDays")
    def rotate_before_days(self) -> _builtins.int:
        """
        The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
        return pulumi.get(self, "rotate_before_days")


@pulumi.output_type
class ProjectAccessTokenRotationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expirationDays":
            suggest = "expiration_days"
        elif key == "rotateBeforeDays":
            suggest = "rotate_before_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAccessTokenRotationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAccessTokenRotationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAccessTokenRotationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expiration_days: _builtins.int,
                 rotate_before_days: _builtins.int):
        """
        :param _builtins.int expiration_days: The duration (in days) the new token should be valid for.
        :param _builtins.int rotate_before_days: The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
        pulumi.set(__self__, "expiration_days", expiration_days)
        pulumi.set(__self__, "rotate_before_days", rotate_before_days)

    @_builtins.property
    @pulumi.getter(name="expirationDays")
    def expiration_days(self) -> _builtins.int:
        """
        The duration (in days) the new token should be valid for.
        """
        return pulumi.get(self, "expiration_days")

    @_builtins.property
    @pulumi.getter(name="rotateBeforeDays")
    def rotate_before_days(self) -> _builtins.int:
        """
        The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.
        """
        return pulumi.get(self, "rotate_before_days")


@pulumi.output_type
class ProjectContainerExpirationPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keepN":
            suggest = "keep_n"
        elif key == "nameRegexDelete":
            suggest = "name_regex_delete"
        elif key == "nameRegexKeep":
            suggest = "name_regex_keep"
        elif key == "nextRunAt":
            suggest = "next_run_at"
        elif key == "olderThan":
            suggest = "older_than"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectContainerExpirationPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectContainerExpirationPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectContainerExpirationPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cadence: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 keep_n: Optional[_builtins.int] = None,
                 name_regex_delete: Optional[_builtins.str] = None,
                 name_regex_keep: Optional[_builtins.str] = None,
                 next_run_at: Optional[_builtins.str] = None,
                 older_than: Optional[_builtins.str] = None):
        """
        :param _builtins.str cadence: The cadence of the policy. Valid values are: `1d`, `7d`, `14d`, `1month`, `3month`.
        :param _builtins.bool enabled: If true, the policy is enabled.
        :param _builtins.int keep_n: The number of images to keep.
        :param _builtins.str name_regex_delete: The regular expression to match image names to delete.
        :param _builtins.str name_regex_keep: The regular expression to match image names to keep.
        :param _builtins.str next_run_at: The next time the policy will run.
        :param _builtins.str older_than: The number of days to keep images.
        """
        if cadence is not None:
            pulumi.set(__self__, "cadence", cadence)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if keep_n is not None:
            pulumi.set(__self__, "keep_n", keep_n)
        if name_regex_delete is not None:
            pulumi.set(__self__, "name_regex_delete", name_regex_delete)
        if name_regex_keep is not None:
            pulumi.set(__self__, "name_regex_keep", name_regex_keep)
        if next_run_at is not None:
            pulumi.set(__self__, "next_run_at", next_run_at)
        if older_than is not None:
            pulumi.set(__self__, "older_than", older_than)

    @_builtins.property
    @pulumi.getter
    def cadence(self) -> Optional[_builtins.str]:
        """
        The cadence of the policy. Valid values are: `1d`, `7d`, `14d`, `1month`, `3month`.
        """
        return pulumi.get(self, "cadence")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If true, the policy is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="keepN")
    def keep_n(self) -> Optional[_builtins.int]:
        """
        The number of images to keep.
        """
        return pulumi.get(self, "keep_n")

    @_builtins.property
    @pulumi.getter(name="nameRegexDelete")
    def name_regex_delete(self) -> Optional[_builtins.str]:
        """
        The regular expression to match image names to delete.
        """
        return pulumi.get(self, "name_regex_delete")

    @_builtins.property
    @pulumi.getter(name="nameRegexKeep")
    def name_regex_keep(self) -> Optional[_builtins.str]:
        """
        The regular expression to match image names to keep.
        """
        return pulumi.get(self, "name_regex_keep")

    @_builtins.property
    @pulumi.getter(name="nextRunAt")
    def next_run_at(self) -> Optional[_builtins.str]:
        """
        The next time the policy will run.
        """
        return pulumi.get(self, "next_run_at")

    @_builtins.property
    @pulumi.getter(name="olderThan")
    def older_than(self) -> Optional[_builtins.str]:
        """
        The number of days to keep images.
        """
        return pulumi.get(self, "older_than")


@pulumi.output_type
class ProjectHookCustomHeader(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Key of the custom header.
        :param _builtins.str value: Value of the custom header. This value cannot be imported.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Key of the custom header.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of the custom header. This value cannot be imported.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProjectIssueBoardList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assigneeId":
            suggest = "assignee_id"
        elif key == "iterationId":
            suggest = "iteration_id"
        elif key == "labelId":
            suggest = "label_id"
        elif key == "milestoneId":
            suggest = "milestone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectIssueBoardList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectIssueBoardList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectIssueBoardList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assignee_id: Optional[_builtins.int] = None,
                 id: Optional[_builtins.int] = None,
                 iteration_id: Optional[_builtins.int] = None,
                 label_id: Optional[_builtins.int] = None,
                 milestone_id: Optional[_builtins.int] = None,
                 position: Optional[_builtins.int] = None):
        """
        :param _builtins.int assignee_id: The ID of the assignee the list should be scoped to. Requires a GitLab EE license.
        :param _builtins.int id: The ID of the list
        :param _builtins.int iteration_id: The ID of the iteration the list should be scoped to. Requires a GitLab EE license.
        :param _builtins.int label_id: The ID of the label the list should be scoped to. Requires a GitLab EE license.
        :param _builtins.int milestone_id: The ID of the milestone the list should be scoped to. Requires a GitLab EE license.
        :param _builtins.int position: The position of the list within the board. The position for the list is based on the its position in the `lists` array.
        """
        if assignee_id is not None:
            pulumi.set(__self__, "assignee_id", assignee_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if iteration_id is not None:
            pulumi.set(__self__, "iteration_id", iteration_id)
        if label_id is not None:
            pulumi.set(__self__, "label_id", label_id)
        if milestone_id is not None:
            pulumi.set(__self__, "milestone_id", milestone_id)
        if position is not None:
            pulumi.set(__self__, "position", position)

    @_builtins.property
    @pulumi.getter(name="assigneeId")
    def assignee_id(self) -> Optional[_builtins.int]:
        """
        The ID of the assignee the list should be scoped to. Requires a GitLab EE license.
        """
        return pulumi.get(self, "assignee_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.int]:
        """
        The ID of the list
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="iterationId")
    def iteration_id(self) -> Optional[_builtins.int]:
        """
        The ID of the iteration the list should be scoped to. Requires a GitLab EE license.
        """
        return pulumi.get(self, "iteration_id")

    @_builtins.property
    @pulumi.getter(name="labelId")
    def label_id(self) -> Optional[_builtins.int]:
        """
        The ID of the label the list should be scoped to. Requires a GitLab EE license.
        """
        return pulumi.get(self, "label_id")

    @_builtins.property
    @pulumi.getter(name="milestoneId")
    def milestone_id(self) -> Optional[_builtins.int]:
        """
        The ID of the milestone the list should be scoped to. Requires a GitLab EE license.
        """
        return pulumi.get(self, "milestone_id")

    @_builtins.property
    @pulumi.getter
    def position(self) -> Optional[_builtins.int]:
        """
        The position of the list within the board. The position for the list is based on the its position in the `lists` array.
        """
        return pulumi.get(self, "position")


@pulumi.output_type
class ProjectIssueTaskCompletionStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "completedCount":
            suggest = "completed_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectIssueTaskCompletionStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectIssueTaskCompletionStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectIssueTaskCompletionStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 completed_count: Optional[_builtins.int] = None,
                 count: Optional[_builtins.int] = None):
        """
        :param _builtins.int completed_count: The number of tasks that are completed.
        :param _builtins.int count: The number of tasks.
        """
        if completed_count is not None:
            pulumi.set(__self__, "completed_count", completed_count)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @_builtins.property
    @pulumi.getter(name="completedCount")
    def completed_count(self) -> Optional[_builtins.int]:
        """
        The number of tasks that are completed.
        """
        return pulumi.get(self, "completed_count")

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[_builtins.int]:
        """
        The number of tasks.
        """
        return pulumi.get(self, "count")


@pulumi.output_type
class ProjectPagesSettingsDeployment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "pathPrefix":
            suggest = "path_prefix"
        elif key == "rootDirectory":
            suggest = "root_directory"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectPagesSettingsDeployment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectPagesSettingsDeployment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectPagesSettingsDeployment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 path_prefix: Optional[_builtins.str] = None,
                 root_directory: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Date the deployment was created.
        :param _builtins.str path_prefix: The path prefix of the deployment when using parallel deployments.
        :param _builtins.str root_directory: The root directory of the deployment.
        :param _builtins.str url: The URL of the deployment.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if path_prefix is not None:
            pulumi.set(__self__, "path_prefix", path_prefix)
        if root_directory is not None:
            pulumi.set(__self__, "root_directory", root_directory)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        Date the deployment was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="pathPrefix")
    def path_prefix(self) -> Optional[_builtins.str]:
        """
        The path prefix of the deployment when using parallel deployments.
        """
        return pulumi.get(self, "path_prefix")

    @_builtins.property
    @pulumi.getter(name="rootDirectory")
    def root_directory(self) -> Optional[_builtins.str]:
        """
        The root directory of the deployment.
        """
        return pulumi.get(self, "root_directory")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The URL of the deployment.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ProjectProtectedEnvironmentApprovalRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessLevel":
            suggest = "access_level"
        elif key == "accessLevelDescription":
            suggest = "access_level_description"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "groupInheritanceType":
            suggest = "group_inheritance_type"
        elif key == "requiredApprovals":
            suggest = "required_approvals"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectProtectedEnvironmentApprovalRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectProtectedEnvironmentApprovalRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectProtectedEnvironmentApprovalRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_level: Optional[_builtins.str] = None,
                 access_level_description: Optional[_builtins.str] = None,
                 group_id: Optional[_builtins.int] = None,
                 group_inheritance_type: Optional[_builtins.int] = None,
                 id: Optional[_builtins.int] = None,
                 required_approvals: Optional[_builtins.int] = None,
                 user_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str access_level: Levels of access allowed to approve a deployment to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        :param _builtins.str access_level_description: Readable description of level of access.
        :param _builtins.int group_id: The ID of the group allowed to approve a deployment to this protected environment. The project must be shared with the group. Mutually exclusive with `access_level` and `user_id`.
        :param _builtins.int group_inheritance_type: Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        :param _builtins.int id: The unique ID of the Approval Rules object.
        :param _builtins.int required_approvals: The number of approval required to allow deployment to this protected environment. This is mutually exclusive with user_id.
        :param _builtins.int user_id: The ID of the user allowed to approve a deployment to this protected environment. The user must be a member of the project. Mutually exclusive with `access_level` and `group_id`.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_level_description is not None:
            pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if group_inheritance_type is not None:
            pulumi.set(__self__, "group_inheritance_type", group_inheritance_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if required_approvals is not None:
            pulumi.set(__self__, "required_approvals", required_approvals)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[_builtins.str]:
        """
        Levels of access allowed to approve a deployment to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        """
        return pulumi.get(self, "access_level")

    @_builtins.property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[_builtins.str]:
        """
        Readable description of level of access.
        """
        return pulumi.get(self, "access_level_description")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.int]:
        """
        The ID of the group allowed to approve a deployment to this protected environment. The project must be shared with the group. Mutually exclusive with `access_level` and `user_id`.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="groupInheritanceType")
    def group_inheritance_type(self) -> Optional[_builtins.int]:
        """
        Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        """
        return pulumi.get(self, "group_inheritance_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.int]:
        """
        The unique ID of the Approval Rules object.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="requiredApprovals")
    def required_approvals(self) -> Optional[_builtins.int]:
        """
        The number of approval required to allow deployment to this protected environment. This is mutually exclusive with user_id.
        """
        return pulumi.get(self, "required_approvals")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.int]:
        """
        The ID of the user allowed to approve a deployment to this protected environment. The user must be a member of the project. Mutually exclusive with `access_level` and `group_id`.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class ProjectProtectedEnvironmentDeployAccessLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessLevel":
            suggest = "access_level"
        elif key == "accessLevelDescription":
            suggest = "access_level_description"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "groupInheritanceType":
            suggest = "group_inheritance_type"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectProtectedEnvironmentDeployAccessLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectProtectedEnvironmentDeployAccessLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectProtectedEnvironmentDeployAccessLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_level: Optional[_builtins.str] = None,
                 access_level_description: Optional[_builtins.str] = None,
                 group_id: Optional[_builtins.int] = None,
                 group_inheritance_type: Optional[_builtins.int] = None,
                 id: Optional[_builtins.int] = None,
                 user_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str access_level: Levels of access required to deploy to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        :param _builtins.str access_level_description: Readable description of level of access.
        :param _builtins.int group_id: The ID of the group allowed to deploy to this protected environment. The project must be shared with the group. Mutually exclusive with `access_level` and `user_id`.
        :param _builtins.int group_inheritance_type: Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        :param _builtins.int id: The unique ID of the Deploy Access Level object.
        :param _builtins.int user_id: The ID of the user allowed to deploy to this protected environment. The user must be a member of the project. Mutually exclusive with `access_level` and `group_id`.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_level_description is not None:
            pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if group_inheritance_type is not None:
            pulumi.set(__self__, "group_inheritance_type", group_inheritance_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[_builtins.str]:
        """
        Levels of access required to deploy to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        """
        return pulumi.get(self, "access_level")

    @_builtins.property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[_builtins.str]:
        """
        Readable description of level of access.
        """
        return pulumi.get(self, "access_level_description")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.int]:
        """
        The ID of the group allowed to deploy to this protected environment. The project must be shared with the group. Mutually exclusive with `access_level` and `user_id`.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="groupInheritanceType")
    def group_inheritance_type(self) -> Optional[_builtins.int]:
        """
        Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        """
        return pulumi.get(self, "group_inheritance_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.int]:
        """
        The unique ID of the Deploy Access Level object.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.int]:
        """
        The ID of the user allowed to deploy to this protected environment. The user must be a member of the project. Mutually exclusive with `access_level` and `group_id`.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class ProjectProtectedEnvironmentDeployAccessLevelsAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessLevel":
            suggest = "access_level"
        elif key == "accessLevelDescription":
            suggest = "access_level_description"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "groupInheritanceType":
            suggest = "group_inheritance_type"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectProtectedEnvironmentDeployAccessLevelsAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectProtectedEnvironmentDeployAccessLevelsAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectProtectedEnvironmentDeployAccessLevelsAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_level: Optional[_builtins.str] = None,
                 access_level_description: Optional[_builtins.str] = None,
                 group_id: Optional[_builtins.int] = None,
                 group_inheritance_type: Optional[_builtins.int] = None,
                 id: Optional[_builtins.int] = None,
                 user_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str access_level: Levels of access required to deploy to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        :param _builtins.str access_level_description: Readable description of level of access.
        :param _builtins.int group_id: The ID of the group allowed to deploy to this protected environment. The project must be shared with the group. Mutually exclusive with `access_level` and `user_id`.
        :param _builtins.int group_inheritance_type: Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        :param _builtins.int id: The unique ID of the Deploy Access Level object.
        :param _builtins.int user_id: The ID of the user allowed to deploy to this protected environment. The user must be a member of the project. Mutually exclusive with `access_level` and `group_id`.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_level_description is not None:
            pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if group_inheritance_type is not None:
            pulumi.set(__self__, "group_inheritance_type", group_inheritance_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[_builtins.str]:
        """
        Levels of access required to deploy to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.
        """
        return pulumi.get(self, "access_level")

    @_builtins.property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[_builtins.str]:
        """
        Readable description of level of access.
        """
        return pulumi.get(self, "access_level_description")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.int]:
        """
        The ID of the group allowed to deploy to this protected environment. The project must be shared with the group. Mutually exclusive with `access_level` and `user_id`.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="groupInheritanceType")
    def group_inheritance_type(self) -> Optional[_builtins.int]:
        """
        Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` => Direct group membership only, `1` => All inherited groups. Default: `0`
        """
        return pulumi.get(self, "group_inheritance_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.int]:
        """
        The unique ID of the Deploy Access Level object.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.int]:
        """
        The ID of the user allowed to deploy to this protected environment. The user must be a member of the project. Mutually exclusive with `access_level` and `group_id`.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class ProjectPushRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorEmailRegex":
            suggest = "author_email_regex"
        elif key == "branchNameRegex":
            suggest = "branch_name_regex"
        elif key == "commitCommitterCheck":
            suggest = "commit_committer_check"
        elif key == "commitCommitterNameCheck":
            suggest = "commit_committer_name_check"
        elif key == "commitMessageNegativeRegex":
            suggest = "commit_message_negative_regex"
        elif key == "commitMessageRegex":
            suggest = "commit_message_regex"
        elif key == "denyDeleteTag":
            suggest = "deny_delete_tag"
        elif key == "fileNameRegex":
            suggest = "file_name_regex"
        elif key == "maxFileSize":
            suggest = "max_file_size"
        elif key == "memberCheck":
            suggest = "member_check"
        elif key == "preventSecrets":
            suggest = "prevent_secrets"
        elif key == "rejectNonDcoCommits":
            suggest = "reject_non_dco_commits"
        elif key == "rejectUnsignedCommits":
            suggest = "reject_unsigned_commits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectPushRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectPushRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectPushRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 author_email_regex: Optional[_builtins.str] = None,
                 branch_name_regex: Optional[_builtins.str] = None,
                 commit_committer_check: Optional[_builtins.bool] = None,
                 commit_committer_name_check: Optional[_builtins.bool] = None,
                 commit_message_negative_regex: Optional[_builtins.str] = None,
                 commit_message_regex: Optional[_builtins.str] = None,
                 deny_delete_tag: Optional[_builtins.bool] = None,
                 file_name_regex: Optional[_builtins.str] = None,
                 max_file_size: Optional[_builtins.int] = None,
                 member_check: Optional[_builtins.bool] = None,
                 prevent_secrets: Optional[_builtins.bool] = None,
                 reject_non_dco_commits: Optional[_builtins.bool] = None,
                 reject_unsigned_commits: Optional[_builtins.bool] = None):
        """
        :param _builtins.str author_email_regex: All commit author emails must match this regex, e.g. `@my-company.com$`.
        :param _builtins.str branch_name_regex: All branch names must match this regex, e.g. `(feature|hotfix)\\/*`.
        :param _builtins.bool commit_committer_check: Users can only push commits to this repository that were committed with one of their own verified emails.
        :param _builtins.bool commit_committer_name_check: Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
        :param _builtins.str commit_message_negative_regex: No commit message is allowed to match this regex, e.g. `ssh\\:\\/\\/`.
        :param _builtins.str commit_message_regex: All commit messages must match this regex, e.g. `Fixed \\d+\\..*`.
        :param _builtins.bool deny_delete_tag: Deny deleting a tag.
        :param _builtins.str file_name_regex: All committed filenames must not match this regex, e.g. `(jar|exe)$`.
        :param _builtins.int max_file_size: Maximum file size (MB).
        :param _builtins.bool member_check: Restrict commits by author (email) to existing GitLab users.
        :param _builtins.bool prevent_secrets: GitLab will reject any files that are likely to contain secrets.
        :param _builtins.bool reject_non_dco_commits: Reject commit when its not DCO certified.
        :param _builtins.bool reject_unsigned_commits: Reject commit when its not signed through GPG.
        """
        if author_email_regex is not None:
            pulumi.set(__self__, "author_email_regex", author_email_regex)
        if branch_name_regex is not None:
            pulumi.set(__self__, "branch_name_regex", branch_name_regex)
        if commit_committer_check is not None:
            pulumi.set(__self__, "commit_committer_check", commit_committer_check)
        if commit_committer_name_check is not None:
            pulumi.set(__self__, "commit_committer_name_check", commit_committer_name_check)
        if commit_message_negative_regex is not None:
            pulumi.set(__self__, "commit_message_negative_regex", commit_message_negative_regex)
        if commit_message_regex is not None:
            pulumi.set(__self__, "commit_message_regex", commit_message_regex)
        if deny_delete_tag is not None:
            pulumi.set(__self__, "deny_delete_tag", deny_delete_tag)
        if file_name_regex is not None:
            pulumi.set(__self__, "file_name_regex", file_name_regex)
        if max_file_size is not None:
            pulumi.set(__self__, "max_file_size", max_file_size)
        if member_check is not None:
            pulumi.set(__self__, "member_check", member_check)
        if prevent_secrets is not None:
            pulumi.set(__self__, "prevent_secrets", prevent_secrets)
        if reject_non_dco_commits is not None:
            pulumi.set(__self__, "reject_non_dco_commits", reject_non_dco_commits)
        if reject_unsigned_commits is not None:
            pulumi.set(__self__, "reject_unsigned_commits", reject_unsigned_commits)

    @_builtins.property
    @pulumi.getter(name="authorEmailRegex")
    def author_email_regex(self) -> Optional[_builtins.str]:
        """
        All commit author emails must match this regex, e.g. `@my-company.com$`.
        """
        return pulumi.get(self, "author_email_regex")

    @_builtins.property
    @pulumi.getter(name="branchNameRegex")
    def branch_name_regex(self) -> Optional[_builtins.str]:
        """
        All branch names must match this regex, e.g. `(feature|hotfix)\\/*`.
        """
        return pulumi.get(self, "branch_name_regex")

    @_builtins.property
    @pulumi.getter(name="commitCommitterCheck")
    def commit_committer_check(self) -> Optional[_builtins.bool]:
        """
        Users can only push commits to this repository that were committed with one of their own verified emails.
        """
        return pulumi.get(self, "commit_committer_check")

    @_builtins.property
    @pulumi.getter(name="commitCommitterNameCheck")
    def commit_committer_name_check(self) -> Optional[_builtins.bool]:
        """
        Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
        """
        return pulumi.get(self, "commit_committer_name_check")

    @_builtins.property
    @pulumi.getter(name="commitMessageNegativeRegex")
    def commit_message_negative_regex(self) -> Optional[_builtins.str]:
        """
        No commit message is allowed to match this regex, e.g. `ssh\\:\\/\\/`.
        """
        return pulumi.get(self, "commit_message_negative_regex")

    @_builtins.property
    @pulumi.getter(name="commitMessageRegex")
    def commit_message_regex(self) -> Optional[_builtins.str]:
        """
        All commit messages must match this regex, e.g. `Fixed \\d+\\..*`.
        """
        return pulumi.get(self, "commit_message_regex")

    @_builtins.property
    @pulumi.getter(name="denyDeleteTag")
    def deny_delete_tag(self) -> Optional[_builtins.bool]:
        """
        Deny deleting a tag.
        """
        return pulumi.get(self, "deny_delete_tag")

    @_builtins.property
    @pulumi.getter(name="fileNameRegex")
    def file_name_regex(self) -> Optional[_builtins.str]:
        """
        All committed filenames must not match this regex, e.g. `(jar|exe)$`.
        """
        return pulumi.get(self, "file_name_regex")

    @_builtins.property
    @pulumi.getter(name="maxFileSize")
    def max_file_size(self) -> Optional[_builtins.int]:
        """
        Maximum file size (MB).
        """
        return pulumi.get(self, "max_file_size")

    @_builtins.property
    @pulumi.getter(name="memberCheck")
    def member_check(self) -> Optional[_builtins.bool]:
        """
        Restrict commits by author (email) to existing GitLab users.
        """
        return pulumi.get(self, "member_check")

    @_builtins.property
    @pulumi.getter(name="preventSecrets")
    def prevent_secrets(self) -> Optional[_builtins.bool]:
        """
        GitLab will reject any files that are likely to contain secrets.
        """
        return pulumi.get(self, "prevent_secrets")

    @_builtins.property
    @pulumi.getter(name="rejectNonDcoCommits")
    def reject_non_dco_commits(self) -> Optional[_builtins.bool]:
        """
        Reject commit when its not DCO certified.
        """
        return pulumi.get(self, "reject_non_dco_commits")

    @_builtins.property
    @pulumi.getter(name="rejectUnsignedCommits")
    def reject_unsigned_commits(self) -> Optional[_builtins.bool]:
        """
        Reject commit when its not signed through GPG.
        """
        return pulumi.get(self, "reject_unsigned_commits")


@pulumi.output_type
class ProjectTagCommit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorEmail":
            suggest = "author_email"
        elif key == "authorName":
            suggest = "author_name"
        elif key == "authoredDate":
            suggest = "authored_date"
        elif key == "committedDate":
            suggest = "committed_date"
        elif key == "committerEmail":
            suggest = "committer_email"
        elif key == "committerName":
            suggest = "committer_name"
        elif key == "parentIds":
            suggest = "parent_ids"
        elif key == "shortId":
            suggest = "short_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectTagCommit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectTagCommit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectTagCommit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 author_email: Optional[_builtins.str] = None,
                 author_name: Optional[_builtins.str] = None,
                 authored_date: Optional[_builtins.str] = None,
                 committed_date: Optional[_builtins.str] = None,
                 committer_email: Optional[_builtins.str] = None,
                 committer_name: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 message: Optional[_builtins.str] = None,
                 parent_ids: Optional[Sequence[_builtins.str]] = None,
                 short_id: Optional[_builtins.str] = None,
                 title: Optional[_builtins.str] = None):
        """
        :param _builtins.str author_email: The email of the author.
        :param _builtins.str author_name: The name of the author.
        :param _builtins.str authored_date: The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
        :param _builtins.str committed_date: The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
        :param _builtins.str committer_email: The email of the user that committed.
        :param _builtins.str committer_name: The name of the user that committed.
        :param _builtins.str id: The unique id assigned to the commit by Gitlab.
        :param _builtins.str message: The commit message
        :param Sequence[_builtins.str] parent_ids: The id of the parents of the commit
        :param _builtins.str short_id: The short id assigned to the commit by Gitlab.
        :param _builtins.str title: The title of the commit
        """
        if author_email is not None:
            pulumi.set(__self__, "author_email", author_email)
        if author_name is not None:
            pulumi.set(__self__, "author_name", author_name)
        if authored_date is not None:
            pulumi.set(__self__, "authored_date", authored_date)
        if committed_date is not None:
            pulumi.set(__self__, "committed_date", committed_date)
        if committer_email is not None:
            pulumi.set(__self__, "committer_email", committer_email)
        if committer_name is not None:
            pulumi.set(__self__, "committer_name", committer_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if parent_ids is not None:
            pulumi.set(__self__, "parent_ids", parent_ids)
        if short_id is not None:
            pulumi.set(__self__, "short_id", short_id)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter(name="authorEmail")
    def author_email(self) -> Optional[_builtins.str]:
        """
        The email of the author.
        """
        return pulumi.get(self, "author_email")

    @_builtins.property
    @pulumi.getter(name="authorName")
    def author_name(self) -> Optional[_builtins.str]:
        """
        The name of the author.
        """
        return pulumi.get(self, "author_name")

    @_builtins.property
    @pulumi.getter(name="authoredDate")
    def authored_date(self) -> Optional[_builtins.str]:
        """
        The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
        """
        return pulumi.get(self, "authored_date")

    @_builtins.property
    @pulumi.getter(name="committedDate")
    def committed_date(self) -> Optional[_builtins.str]:
        """
        The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
        """
        return pulumi.get(self, "committed_date")

    @_builtins.property
    @pulumi.getter(name="committerEmail")
    def committer_email(self) -> Optional[_builtins.str]:
        """
        The email of the user that committed.
        """
        return pulumi.get(self, "committer_email")

    @_builtins.property
    @pulumi.getter(name="committerName")
    def committer_name(self) -> Optional[_builtins.str]:
        """
        The name of the user that committed.
        """
        return pulumi.get(self, "committer_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The unique id assigned to the commit by Gitlab.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        The commit message
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="parentIds")
    def parent_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The id of the parents of the commit
        """
        return pulumi.get(self, "parent_ids")

    @_builtins.property
    @pulumi.getter(name="shortId")
    def short_id(self) -> Optional[_builtins.str]:
        """
        The short id assigned to the commit by Gitlab.
        """
        return pulumi.get(self, "short_id")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        The title of the commit
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class ProjectTagRelease(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagName":
            suggest = "tag_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectTagRelease. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectTagRelease.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectTagRelease.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 tag_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: The description of release.
        :param _builtins.str tag_name: The name of the tag.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of release.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[_builtins.str]:
        """
        The name of the tag.
        """
        return pulumi.get(self, "tag_name")


@pulumi.output_type
class ReleaseAssets(dict):
    def __init__(__self__, *,
                 count: Optional[_builtins.int] = None):
        """
        :param _builtins.int count: The total count of assets in this release.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[_builtins.int]:
        """
        The total count of assets in this release.
        """
        return pulumi.get(self, "count")


@pulumi.output_type
class ReleaseAuthor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "avatarUrl":
            suggest = "avatar_url"
        elif key == "webUrl":
            suggest = "web_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseAuthor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseAuthor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseAuthor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 avatar_url: Optional[_builtins.str] = None,
                 id: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None,
                 web_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str avatar_url: The url of the author's' user avatar.
        :param _builtins.int id: The ID of the author's user.
        :param _builtins.str name: The name of the author.
        :param _builtins.str state: The state of the author's user.
        :param _builtins.str username: The username of the author.
        :param _builtins.str web_url: The url to the author's user profile.
        """
        if avatar_url is not None:
            pulumi.set(__self__, "avatar_url", avatar_url)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if web_url is not None:
            pulumi.set(__self__, "web_url", web_url)

    @_builtins.property
    @pulumi.getter(name="avatarUrl")
    def avatar_url(self) -> Optional[_builtins.str]:
        """
        The url of the author's' user avatar.
        """
        return pulumi.get(self, "avatar_url")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.int]:
        """
        The ID of the author's user.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the author.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        The state of the author's user.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username of the author.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> Optional[_builtins.str]:
        """
        The url to the author's user profile.
        """
        return pulumi.get(self, "web_url")


@pulumi.output_type
class ReleaseCommit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorEmail":
            suggest = "author_email"
        elif key == "authorName":
            suggest = "author_name"
        elif key == "authoredDate":
            suggest = "authored_date"
        elif key == "committedDate":
            suggest = "committed_date"
        elif key == "committerEmail":
            suggest = "committer_email"
        elif key == "committerName":
            suggest = "committer_name"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "parentIds":
            suggest = "parent_ids"
        elif key == "shortId":
            suggest = "short_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseCommit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseCommit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseCommit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 author_email: Optional[_builtins.str] = None,
                 author_name: Optional[_builtins.str] = None,
                 authored_date: Optional[_builtins.str] = None,
                 committed_date: Optional[_builtins.str] = None,
                 committer_email: Optional[_builtins.str] = None,
                 committer_name: Optional[_builtins.str] = None,
                 created_at: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 message: Optional[_builtins.str] = None,
                 parent_ids: Optional[Sequence[_builtins.str]] = None,
                 short_id: Optional[_builtins.str] = None,
                 title: Optional[_builtins.str] = None):
        """
        :param _builtins.str author_email: The email address of the commit author.
        :param _builtins.str author_name: The name of the commit author.
        :param _builtins.str authored_date: The date and time the commit was authored. In ISO 8601 format (2019-03-15T08:00:00Z).
        :param _builtins.str committed_date: The date and time the commit was made. In ISO 8601 format (2019-03-15T08:00:00Z).
        :param _builtins.str committer_email: The email address of the committer.
        :param _builtins.str committer_name: The name of the committer.
        :param _builtins.str created_at: The date and time the commit was created. In ISO 8601 format (2019-03-15T08:00:00Z).
        :param _builtins.str id: The git commit full SHA
        :param _builtins.str message: The commit message.
        :param Sequence[_builtins.str] parent_ids: The full SHA of any parent commits.
        :param _builtins.str short_id: The git commit short SHA.
        :param _builtins.str title: The title of the commit.
        """
        if author_email is not None:
            pulumi.set(__self__, "author_email", author_email)
        if author_name is not None:
            pulumi.set(__self__, "author_name", author_name)
        if authored_date is not None:
            pulumi.set(__self__, "authored_date", authored_date)
        if committed_date is not None:
            pulumi.set(__self__, "committed_date", committed_date)
        if committer_email is not None:
            pulumi.set(__self__, "committer_email", committer_email)
        if committer_name is not None:
            pulumi.set(__self__, "committer_name", committer_name)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if parent_ids is not None:
            pulumi.set(__self__, "parent_ids", parent_ids)
        if short_id is not None:
            pulumi.set(__self__, "short_id", short_id)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter(name="authorEmail")
    def author_email(self) -> Optional[_builtins.str]:
        """
        The email address of the commit author.
        """
        return pulumi.get(self, "author_email")

    @_builtins.property
    @pulumi.getter(name="authorName")
    def author_name(self) -> Optional[_builtins.str]:
        """
        The name of the commit author.
        """
        return pulumi.get(self, "author_name")

    @_builtins.property
    @pulumi.getter(name="authoredDate")
    def authored_date(self) -> Optional[_builtins.str]:
        """
        The date and time the commit was authored. In ISO 8601 format (2019-03-15T08:00:00Z).
        """
        return pulumi.get(self, "authored_date")

    @_builtins.property
    @pulumi.getter(name="committedDate")
    def committed_date(self) -> Optional[_builtins.str]:
        """
        The date and time the commit was made. In ISO 8601 format (2019-03-15T08:00:00Z).
        """
        return pulumi.get(self, "committed_date")

    @_builtins.property
    @pulumi.getter(name="committerEmail")
    def committer_email(self) -> Optional[_builtins.str]:
        """
        The email address of the committer.
        """
        return pulumi.get(self, "committer_email")

    @_builtins.property
    @pulumi.getter(name="committerName")
    def committer_name(self) -> Optional[_builtins.str]:
        """
        The name of the committer.
        """
        return pulumi.get(self, "committer_name")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The date and time the commit was created. In ISO 8601 format (2019-03-15T08:00:00Z).
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The git commit full SHA
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        The commit message.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="parentIds")
    def parent_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The full SHA of any parent commits.
        """
        return pulumi.get(self, "parent_ids")

    @_builtins.property
    @pulumi.getter(name="shortId")
    def short_id(self) -> Optional[_builtins.str]:
        """
        The git commit short SHA.
        """
        return pulumi.get(self, "short_id")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        The title of the commit.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class ReleaseLinks(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "closedIssuesUrl":
            suggest = "closed_issues_url"
        elif key == "closedMergeRequestsUrl":
            suggest = "closed_merge_requests_url"
        elif key == "editUrl":
            suggest = "edit_url"
        elif key == "mergedMergeRequestsUrl":
            suggest = "merged_merge_requests_url"
        elif key == "openedIssuesUrl":
            suggest = "opened_issues_url"
        elif key == "openedMergeRequestsUrl":
            suggest = "opened_merge_requests_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseLinks. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseLinks.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseLinks.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 closed_issues_url: Optional[_builtins.str] = None,
                 closed_merge_requests_url: Optional[_builtins.str] = None,
                 edit_url: Optional[_builtins.str] = None,
                 merged_merge_requests_url: Optional[_builtins.str] = None,
                 opened_issues_url: Optional[_builtins.str] = None,
                 opened_merge_requests_url: Optional[_builtins.str] = None,
                 self: Optional[_builtins.str] = None):
        """
        :param _builtins.str closed_issues_url: URL of the release's closed issues.
        :param _builtins.str closed_merge_requests_url: URL of the release's closed merge requests.
        :param _builtins.str edit_url: URL of the release's edit page.
        :param _builtins.str merged_merge_requests_url: URL of the release's merged merge requests.
        :param _builtins.str opened_issues_url: URL of the release's open issues.
        :param _builtins.str opened_merge_requests_url: URL of the release's open merge requests.
        :param _builtins.str self: URL of the release.
        """
        if closed_issues_url is not None:
            pulumi.set(__self__, "closed_issues_url", closed_issues_url)
        if closed_merge_requests_url is not None:
            pulumi.set(__self__, "closed_merge_requests_url", closed_merge_requests_url)
        if edit_url is not None:
            pulumi.set(__self__, "edit_url", edit_url)
        if merged_merge_requests_url is not None:
            pulumi.set(__self__, "merged_merge_requests_url", merged_merge_requests_url)
        if opened_issues_url is not None:
            pulumi.set(__self__, "opened_issues_url", opened_issues_url)
        if opened_merge_requests_url is not None:
            pulumi.set(__self__, "opened_merge_requests_url", opened_merge_requests_url)
        if self is not None:
            pulumi.set(__self__, "self", self)

    @_builtins.property
    @pulumi.getter(name="closedIssuesUrl")
    def closed_issues_url(self) -> Optional[_builtins.str]:
        """
        URL of the release's closed issues.
        """
        return pulumi.get(self, "closed_issues_url")

    @_builtins.property
    @pulumi.getter(name="closedMergeRequestsUrl")
    def closed_merge_requests_url(self) -> Optional[_builtins.str]:
        """
        URL of the release's closed merge requests.
        """
        return pulumi.get(self, "closed_merge_requests_url")

    @_builtins.property
    @pulumi.getter(name="editUrl")
    def edit_url(self) -> Optional[_builtins.str]:
        """
        URL of the release's edit page.
        """
        return pulumi.get(self, "edit_url")

    @_builtins.property
    @pulumi.getter(name="mergedMergeRequestsUrl")
    def merged_merge_requests_url(self) -> Optional[_builtins.str]:
        """
        URL of the release's merged merge requests.
        """
        return pulumi.get(self, "merged_merge_requests_url")

    @_builtins.property
    @pulumi.getter(name="openedIssuesUrl")
    def opened_issues_url(self) -> Optional[_builtins.str]:
        """
        URL of the release's open issues.
        """
        return pulumi.get(self, "opened_issues_url")

    @_builtins.property
    @pulumi.getter(name="openedMergeRequestsUrl")
    def opened_merge_requests_url(self) -> Optional[_builtins.str]:
        """
        URL of the release's open merge requests.
        """
        return pulumi.get(self, "opened_merge_requests_url")

    @_builtins.property
    @pulumi.getter
    def self(self) -> Optional[_builtins.str]:
        """
        URL of the release.
        """
        return pulumi.get(self, "self")


@pulumi.output_type
class TagProtectionAllowedToCreate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessLevel":
            suggest = "access_level"
        elif key == "accessLevelDescription":
            suggest = "access_level_description"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TagProtectionAllowedToCreate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TagProtectionAllowedToCreate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TagProtectionAllowedToCreate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_level: Optional[_builtins.str] = None,
                 access_level_description: Optional[_builtins.str] = None,
                 group_id: Optional[_builtins.int] = None,
                 user_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str access_level: Access levels allowed to create protected tags. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        :param _builtins.str access_level_description: Readable description of access level.
        :param _builtins.int group_id: The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        :param _builtins.int user_id: The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_level_description is not None:
            pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[_builtins.str]:
        """
        Access levels allowed to create protected tags. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        """
        return pulumi.get(self, "access_level")

    @_builtins.property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> Optional[_builtins.str]:
        """
        Readable description of access level.
        """
        return pulumi.get(self, "access_level_description")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class ValueStreamAnalyticsStage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endEventIdentifier":
            suggest = "end_event_identifier"
        elif key == "endEventLabelId":
            suggest = "end_event_label_id"
        elif key == "startEventIdentifier":
            suggest = "start_event_identifier"
        elif key == "startEventLabelId":
            suggest = "start_event_label_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ValueStreamAnalyticsStage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ValueStreamAnalyticsStage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ValueStreamAnalyticsStage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 custom: Optional[_builtins.bool] = None,
                 end_event_identifier: Optional[_builtins.str] = None,
                 end_event_label_id: Optional[_builtins.str] = None,
                 hidden: Optional[_builtins.bool] = None,
                 id: Optional[_builtins.str] = None,
                 start_event_identifier: Optional[_builtins.str] = None,
                 start_event_label_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the value stream stage.
        :param _builtins.bool custom: Boolean whether the stage is customized. If false, it assigns a built-in default stage by name.
        :param _builtins.str end_event_identifier: End event identifier. Valid values are: `CODE_STAGE_START`, `ISSUE_CLOSED`, `ISSUE_CREATED`, `ISSUE_DEPLOYED_TO_PRODUCTION`, `ISSUE_FIRST_ADDED_TO_BOARD`, `ISSUE_FIRST_ADDED_TO_ITERATION`, `ISSUE_FIRST_ASSIGNED_AT`, `ISSUE_FIRST_ASSOCIATED_WITH_MILESTONE`, `ISSUE_FIRST_MENTIONED_IN_COMMIT`, `ISSUE_LABEL_ADDED`, `ISSUE_LABEL_REMOVED`, `ISSUE_LAST_EDITED`, `ISSUE_STAGE_END`, `MERGE_REQUEST_CLOSED`, `MERGE_REQUEST_CREATED`, `MERGE_REQUEST_FIRST_ASSIGNED_AT`, `MERGE_REQUEST_FIRST_COMMIT_AT`, `MERGE_REQUEST_FIRST_DEPLOYED_TO_PRODUCTION`, `MERGE_REQUEST_LABEL_ADDED`, `MERGE_REQUEST_LABEL_REMOVED`, `MERGE_REQUEST_LAST_BUILD_FINISHED`, `MERGE_REQUEST_LAST_BUILD_STARTED`, `MERGE_REQUEST_LAST_EDITED`, `MERGE_REQUEST_MERGED`, `MERGE_REQUEST_REVIEWER_FIRST_ASSIGNED`, `MERGE_REQUEST_PLAN_STAGE_START`
        :param _builtins.str end_event_label_id: Label ID associated with the end event identifier. In the format of `gid://gitlab/GroupLabel/<id>` or `gid://gitlab/ProjectLabel/<id>`
        :param _builtins.bool hidden: Boolean whether the stage is hidden, GitLab provided default stages are hidden by default.
        :param _builtins.str id: The ID of the value stream stage.
        :param _builtins.str start_event_identifier: Start event identifier. Valid values are: `CODE_STAGE_START`, `ISSUE_CLOSED`, `ISSUE_CREATED`, `ISSUE_DEPLOYED_TO_PRODUCTION`, `ISSUE_FIRST_ADDED_TO_BOARD`, `ISSUE_FIRST_ADDED_TO_ITERATION`, `ISSUE_FIRST_ASSIGNED_AT`, `ISSUE_FIRST_ASSOCIATED_WITH_MILESTONE`, `ISSUE_FIRST_MENTIONED_IN_COMMIT`, `ISSUE_LABEL_ADDED`, `ISSUE_LABEL_REMOVED`, `ISSUE_LAST_EDITED`, `ISSUE_STAGE_END`, `MERGE_REQUEST_CLOSED`, `MERGE_REQUEST_CREATED`, `MERGE_REQUEST_FIRST_ASSIGNED_AT`, `MERGE_REQUEST_FIRST_COMMIT_AT`, `MERGE_REQUEST_FIRST_DEPLOYED_TO_PRODUCTION`, `MERGE_REQUEST_LABEL_ADDED`, `MERGE_REQUEST_LABEL_REMOVED`, `MERGE_REQUEST_LAST_BUILD_FINISHED`, `MERGE_REQUEST_LAST_BUILD_STARTED`, `MERGE_REQUEST_LAST_EDITED`, `MERGE_REQUEST_MERGED`, `MERGE_REQUEST_REVIEWER_FIRST_ASSIGNED`, `MERGE_REQUEST_PLAN_STAGE_START`
        :param _builtins.str start_event_label_id: Label ID associated with the start event identifier. In the format of `gid://gitlab/GroupLabel/<id>` or `gid://gitlab/ProjectLabel/<id>`
        """
        pulumi.set(__self__, "name", name)
        if custom is not None:
            pulumi.set(__self__, "custom", custom)
        if end_event_identifier is not None:
            pulumi.set(__self__, "end_event_identifier", end_event_identifier)
        if end_event_label_id is not None:
            pulumi.set(__self__, "end_event_label_id", end_event_label_id)
        if hidden is not None:
            pulumi.set(__self__, "hidden", hidden)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if start_event_identifier is not None:
            pulumi.set(__self__, "start_event_identifier", start_event_identifier)
        if start_event_label_id is not None:
            pulumi.set(__self__, "start_event_label_id", start_event_label_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the value stream stage.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def custom(self) -> Optional[_builtins.bool]:
        """
        Boolean whether the stage is customized. If false, it assigns a built-in default stage by name.
        """
        return pulumi.get(self, "custom")

    @_builtins.property
    @pulumi.getter(name="endEventIdentifier")
    def end_event_identifier(self) -> Optional[_builtins.str]:
        """
        End event identifier. Valid values are: `CODE_STAGE_START`, `ISSUE_CLOSED`, `ISSUE_CREATED`, `ISSUE_DEPLOYED_TO_PRODUCTION`, `ISSUE_FIRST_ADDED_TO_BOARD`, `ISSUE_FIRST_ADDED_TO_ITERATION`, `ISSUE_FIRST_ASSIGNED_AT`, `ISSUE_FIRST_ASSOCIATED_WITH_MILESTONE`, `ISSUE_FIRST_MENTIONED_IN_COMMIT`, `ISSUE_LABEL_ADDED`, `ISSUE_LABEL_REMOVED`, `ISSUE_LAST_EDITED`, `ISSUE_STAGE_END`, `MERGE_REQUEST_CLOSED`, `MERGE_REQUEST_CREATED`, `MERGE_REQUEST_FIRST_ASSIGNED_AT`, `MERGE_REQUEST_FIRST_COMMIT_AT`, `MERGE_REQUEST_FIRST_DEPLOYED_TO_PRODUCTION`, `MERGE_REQUEST_LABEL_ADDED`, `MERGE_REQUEST_LABEL_REMOVED`, `MERGE_REQUEST_LAST_BUILD_FINISHED`, `MERGE_REQUEST_LAST_BUILD_STARTED`, `MERGE_REQUEST_LAST_EDITED`, `MERGE_REQUEST_MERGED`, `MERGE_REQUEST_REVIEWER_FIRST_ASSIGNED`, `MERGE_REQUEST_PLAN_STAGE_START`
        """
        return pulumi.get(self, "end_event_identifier")

    @_builtins.property
    @pulumi.getter(name="endEventLabelId")
    def end_event_label_id(self) -> Optional[_builtins.str]:
        """
        Label ID associated with the end event identifier. In the format of `gid://gitlab/GroupLabel/<id>` or `gid://gitlab/ProjectLabel/<id>`
        """
        return pulumi.get(self, "end_event_label_id")

    @_builtins.property
    @pulumi.getter
    def hidden(self) -> Optional[_builtins.bool]:
        """
        Boolean whether the stage is hidden, GitLab provided default stages are hidden by default.
        """
        return pulumi.get(self, "hidden")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the value stream stage.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="startEventIdentifier")
    def start_event_identifier(self) -> Optional[_builtins.str]:
        """
        Start event identifier. Valid values are: `CODE_STAGE_START`, `ISSUE_CLOSED`, `ISSUE_CREATED`, `ISSUE_DEPLOYED_TO_PRODUCTION`, `ISSUE_FIRST_ADDED_TO_BOARD`, `ISSUE_FIRST_ADDED_TO_ITERATION`, `ISSUE_FIRST_ASSIGNED_AT`, `ISSUE_FIRST_ASSOCIATED_WITH_MILESTONE`, `ISSUE_FIRST_MENTIONED_IN_COMMIT`, `ISSUE_LABEL_ADDED`, `ISSUE_LABEL_REMOVED`, `ISSUE_LAST_EDITED`, `ISSUE_STAGE_END`, `MERGE_REQUEST_CLOSED`, `MERGE_REQUEST_CREATED`, `MERGE_REQUEST_FIRST_ASSIGNED_AT`, `MERGE_REQUEST_FIRST_COMMIT_AT`, `MERGE_REQUEST_FIRST_DEPLOYED_TO_PRODUCTION`, `MERGE_REQUEST_LABEL_ADDED`, `MERGE_REQUEST_LABEL_REMOVED`, `MERGE_REQUEST_LAST_BUILD_FINISHED`, `MERGE_REQUEST_LAST_BUILD_STARTED`, `MERGE_REQUEST_LAST_EDITED`, `MERGE_REQUEST_MERGED`, `MERGE_REQUEST_REVIEWER_FIRST_ASSIGNED`, `MERGE_REQUEST_PLAN_STAGE_START`
        """
        return pulumi.get(self, "start_event_identifier")

    @_builtins.property
    @pulumi.getter(name="startEventLabelId")
    def start_event_label_id(self) -> Optional[_builtins.str]:
        """
        Label ID associated with the start event identifier. In the format of `gid://gitlab/GroupLabel/<id>` or `gid://gitlab/ProjectLabel/<id>`
        """
        return pulumi.get(self, "start_event_label_id")


@pulumi.output_type
class GetBranchCommitResult(dict):
    def __init__(__self__, *,
                 author_email: _builtins.str,
                 author_name: _builtins.str,
                 authored_date: _builtins.str,
                 committed_date: _builtins.str,
                 committer_email: _builtins.str,
                 committer_name: _builtins.str,
                 id: _builtins.str,
                 message: _builtins.str,
                 parent_ids: Sequence[_builtins.str],
                 short_id: _builtins.str,
                 title: _builtins.str):
        """
        :param _builtins.str author_email: The email of the author.
        :param _builtins.str author_name: The name of the author.
        :param _builtins.str authored_date: The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
        :param _builtins.str committed_date: The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
        :param _builtins.str committer_email: The email of the user that committed.
        :param _builtins.str committer_name: The name of the user that committed.
        :param _builtins.str id: The unique id assigned to the commit by Gitlab.
        :param _builtins.str message: The commit message
        :param Sequence[_builtins.str] parent_ids: The id of the parents of the commit
        :param _builtins.str short_id: The short id assigned to the commit by Gitlab.
        :param _builtins.str title: The title of the commit
        """
        pulumi.set(__self__, "author_email", author_email)
        pulumi.set(__self__, "author_name", author_name)
        pulumi.set(__self__, "authored_date", authored_date)
        pulumi.set(__self__, "committed_date", committed_date)
        pulumi.set(__self__, "committer_email", committer_email)
        pulumi.set(__self__, "committer_name", committer_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "parent_ids", parent_ids)
        pulumi.set(__self__, "short_id", short_id)
        pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter(name="authorEmail")
    def author_email(self) -> _builtins.str:
        """
        The email of the author.
        """
        return pulumi.get(self, "author_email")

    @_builtins.property
    @pulumi.getter(name="authorName")
    def author_name(self) -> _builtins.str:
        """
        The name of the author.
        """
        return pulumi.get(self, "author_name")

    @_builtins.property
    @pulumi.getter(name="authoredDate")
    def authored_date(self) -> _builtins.str:
        """
        The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
        """
        return pulumi.get(self, "authored_date")

    @_builtins.property
    @pulumi.getter(name="committedDate")
    def committed_date(self) -> _builtins.str:
        """
        The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
        """
        return pulumi.get(self, "committed_date")

    @_builtins.property
    @pulumi.getter(name="committerEmail")
    def committer_email(self) -> _builtins.str:
        """
        The email of the user that committed.
        """
        return pulumi.get(self, "committer_email")

    @_builtins.property
    @pulumi.getter(name="committerName")
    def committer_name(self) -> _builtins.str:
        """
        The name of the user that committed.
        """
        return pulumi.get(self, "committer_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The unique id assigned to the commit by Gitlab.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        The commit message
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="parentIds")
    def parent_ids(self) -> Sequence[_builtins.str]:
        """
        The id of the parents of the commit
        """
        return pulumi.get(self, "parent_ids")

    @_builtins.property
    @pulumi.getter(name="shortId")
    def short_id(self) -> _builtins.str:
        """
        The short id assigned to the commit by Gitlab.
        """
        return pulumi.get(self, "short_id")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The title of the commit
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetClusterAgentsClusterAgentResult(dict):
    def __init__(__self__, *,
                 agent_id: _builtins.int,
                 created_at: _builtins.str,
                 created_by_user_id: _builtins.int,
                 name: _builtins.str,
                 project: _builtins.str):
        """
        :param _builtins.int agent_id: The ID of the agent.
        :param _builtins.str created_at: The ISO8601 datetime when the agent was created.
        :param _builtins.int created_by_user_id: The ID of the user who created the agent.
        :param _builtins.str name: The Name of the agent.
        :param _builtins.str project: ID or full path of the project maintained by the authenticated user.
        """
        pulumi.set(__self__, "agent_id", agent_id)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "created_by_user_id", created_by_user_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project", project)

    @_builtins.property
    @pulumi.getter(name="agentId")
    def agent_id(self) -> _builtins.int:
        """
        The ID of the agent.
        """
        return pulumi.get(self, "agent_id")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The ISO8601 datetime when the agent was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdByUserId")
    def created_by_user_id(self) -> _builtins.int:
        """
        The ID of the user who created the agent.
        """
        return pulumi.get(self, "created_by_user_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The Name of the agent.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def project(self) -> _builtins.str:
        """
        ID or full path of the project maintained by the authenticated user.
        """
        return pulumi.get(self, "project")


@pulumi.output_type
class GetGroupAccessTokensAccessTokenResult(dict):
    def __init__(__self__, *,
                 access_level: _builtins.str,
                 active: _builtins.bool,
                 created_at: _builtins.str,
                 expires_at: _builtins.str,
                 group: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 revoked: _builtins.bool,
                 scopes: Sequence[_builtins.str],
                 user_id: _builtins.int):
        pulumi.set(__self__, "access_level", access_level)
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "revoked", revoked)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> _builtins.str:
        return pulumi.get(self, "access_level")

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> _builtins.str:
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter
    def group(self) -> _builtins.str:
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def revoked(self) -> _builtins.bool:
        return pulumi.get(self, "revoked")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> _builtins.int:
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetGroupBillableMemberMembershipsMembershipResult(dict):
    def __init__(__self__, *,
                 access_level: _builtins.str,
                 created_at: _builtins.str,
                 expires_at: _builtins.str,
                 id: _builtins.int,
                 source_full_name: _builtins.str,
                 source_id: _builtins.int,
                 source_members_url: _builtins.str):
        """
        :param _builtins.str access_level: Access-level of the member. For details see: https://docs.gitlab.com/user/permissions/#default-roles
        :param _builtins.str created_at: Datetime when the membership was first added.
        :param _builtins.str expires_at: Date when the membership will end.
        :param _builtins.int id: The id of the membership.
        :param _builtins.str source_full_name: Breadcrumb-style, full display-name of the group or project.
        :param _builtins.int source_id: The id of the group or project, the user is a (direct) member of.
        :param _builtins.str source_members_url: URL to the members-page of the group or project.
        """
        pulumi.set(__self__, "access_level", access_level)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "source_full_name", source_full_name)
        pulumi.set(__self__, "source_id", source_id)
        pulumi.set(__self__, "source_members_url", source_members_url)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> _builtins.str:
        """
        Access-level of the member. For details see: https://docs.gitlab.com/user/permissions/#default-roles
        """
        return pulumi.get(self, "access_level")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Datetime when the membership was first added.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> _builtins.str:
        """
        Date when the membership will end.
        """
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The id of the membership.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="sourceFullName")
    def source_full_name(self) -> _builtins.str:
        """
        Breadcrumb-style, full display-name of the group or project.
        """
        return pulumi.get(self, "source_full_name")

    @_builtins.property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> _builtins.int:
        """
        The id of the group or project, the user is a (direct) member of.
        """
        return pulumi.get(self, "source_id")

    @_builtins.property
    @pulumi.getter(name="sourceMembersUrl")
    def source_members_url(self) -> _builtins.str:
        """
        URL to the members-page of the group or project.
        """
        return pulumi.get(self, "source_members_url")


@pulumi.output_type
class GetGroupHooksHookResult(dict):
    def __init__(__self__, *,
                 confidential_issues_events: _builtins.bool,
                 confidential_note_events: _builtins.bool,
                 custom_webhook_template: _builtins.str,
                 deployment_events: _builtins.bool,
                 emoji_events: _builtins.bool,
                 enable_ssl_verification: _builtins.bool,
                 group: _builtins.str,
                 group_id: _builtins.int,
                 hook_id: _builtins.int,
                 issues_events: _builtins.bool,
                 job_events: _builtins.bool,
                 merge_requests_events: _builtins.bool,
                 note_events: _builtins.bool,
                 pipeline_events: _builtins.bool,
                 push_events: _builtins.bool,
                 push_events_branch_filter: _builtins.str,
                 releases_events: _builtins.bool,
                 subgroup_events: _builtins.bool,
                 tag_push_events: _builtins.bool,
                 token: _builtins.str,
                 url: _builtins.str,
                 wiki_page_events: _builtins.bool):
        """
        :param _builtins.bool confidential_issues_events: Invoke the hook for confidential issues events.
        :param _builtins.bool confidential_note_events: Invoke the hook for confidential notes events.
        :param _builtins.str custom_webhook_template: Set a custom webhook template.
        :param _builtins.bool deployment_events: Invoke the hook for deployment events.
        :param _builtins.bool emoji_events: Invoke the hook for emoji events.
        :param _builtins.bool enable_ssl_verification: Enable ssl verification when invoking the hook.
        :param _builtins.str group: The ID or full path of the group.
        :param _builtins.int group_id: The id of the group for the hook.
        :param _builtins.int hook_id: The id of the group hook.
        :param _builtins.bool issues_events: Invoke the hook for issues events.
        :param _builtins.bool job_events: Invoke the hook for job events.
        :param _builtins.bool merge_requests_events: Invoke the hook for merge requests.
        :param _builtins.bool note_events: Invoke the hook for notes events.
        :param _builtins.bool pipeline_events: Invoke the hook for pipeline events.
        :param _builtins.bool push_events: Invoke the hook for push events.
        :param _builtins.str push_events_branch_filter: Invoke the hook for push events on matching branches only.
        :param _builtins.bool releases_events: Invoke the hook for releases events.
        :param _builtins.bool subgroup_events: Invoke the hook for subgroup events.
        :param _builtins.bool tag_push_events: Invoke the hook for tag push events.
        :param _builtins.str token: A token to present when invoking the hook. The token is only available on resource creation, not in this datasource. It will always be blank. To be removed in 19.0.
        :param _builtins.str url: The url of the hook to invoke.
        :param _builtins.bool wiki_page_events: Invoke the hook for wiki page events.
        """
        pulumi.set(__self__, "confidential_issues_events", confidential_issues_events)
        pulumi.set(__self__, "confidential_note_events", confidential_note_events)
        pulumi.set(__self__, "custom_webhook_template", custom_webhook_template)
        pulumi.set(__self__, "deployment_events", deployment_events)
        pulumi.set(__self__, "emoji_events", emoji_events)
        pulumi.set(__self__, "enable_ssl_verification", enable_ssl_verification)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "hook_id", hook_id)
        pulumi.set(__self__, "issues_events", issues_events)
        pulumi.set(__self__, "job_events", job_events)
        pulumi.set(__self__, "merge_requests_events", merge_requests_events)
        pulumi.set(__self__, "note_events", note_events)
        pulumi.set(__self__, "pipeline_events", pipeline_events)
        pulumi.set(__self__, "push_events", push_events)
        pulumi.set(__self__, "push_events_branch_filter", push_events_branch_filter)
        pulumi.set(__self__, "releases_events", releases_events)
        pulumi.set(__self__, "subgroup_events", subgroup_events)
        pulumi.set(__self__, "tag_push_events", tag_push_events)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "wiki_page_events", wiki_page_events)

    @_builtins.property
    @pulumi.getter(name="confidentialIssuesEvents")
    def confidential_issues_events(self) -> _builtins.bool:
        """
        Invoke the hook for confidential issues events.
        """
        return pulumi.get(self, "confidential_issues_events")

    @_builtins.property
    @pulumi.getter(name="confidentialNoteEvents")
    def confidential_note_events(self) -> _builtins.bool:
        """
        Invoke the hook for confidential notes events.
        """
        return pulumi.get(self, "confidential_note_events")

    @_builtins.property
    @pulumi.getter(name="customWebhookTemplate")
    def custom_webhook_template(self) -> _builtins.str:
        """
        Set a custom webhook template.
        """
        return pulumi.get(self, "custom_webhook_template")

    @_builtins.property
    @pulumi.getter(name="deploymentEvents")
    def deployment_events(self) -> _builtins.bool:
        """
        Invoke the hook for deployment events.
        """
        return pulumi.get(self, "deployment_events")

    @_builtins.property
    @pulumi.getter(name="emojiEvents")
    def emoji_events(self) -> _builtins.bool:
        """
        Invoke the hook for emoji events.
        """
        return pulumi.get(self, "emoji_events")

    @_builtins.property
    @pulumi.getter(name="enableSslVerification")
    def enable_ssl_verification(self) -> _builtins.bool:
        """
        Enable ssl verification when invoking the hook.
        """
        return pulumi.get(self, "enable_ssl_verification")

    @_builtins.property
    @pulumi.getter
    def group(self) -> _builtins.str:
        """
        The ID or full path of the group.
        """
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.int:
        """
        The id of the group for the hook.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="hookId")
    def hook_id(self) -> _builtins.int:
        """
        The id of the group hook.
        """
        return pulumi.get(self, "hook_id")

    @_builtins.property
    @pulumi.getter(name="issuesEvents")
    def issues_events(self) -> _builtins.bool:
        """
        Invoke the hook for issues events.
        """
        return pulumi.get(self, "issues_events")

    @_builtins.property
    @pulumi.getter(name="jobEvents")
    def job_events(self) -> _builtins.bool:
        """
        Invoke the hook for job events.
        """
        return pulumi.get(self, "job_events")

    @_builtins.property
    @pulumi.getter(name="mergeRequestsEvents")
    def merge_requests_events(self) -> _builtins.bool:
        """
        Invoke the hook for merge requests.
        """
        return pulumi.get(self, "merge_requests_events")

    @_builtins.property
    @pulumi.getter(name="noteEvents")
    def note_events(self) -> _builtins.bool:
        """
        Invoke the hook for notes events.
        """
        return pulumi.get(self, "note_events")

    @_builtins.property
    @pulumi.getter(name="pipelineEvents")
    def pipeline_events(self) -> _builtins.bool:
        """
        Invoke the hook for pipeline events.
        """
        return pulumi.get(self, "pipeline_events")

    @_builtins.property
    @pulumi.getter(name="pushEvents")
    def push_events(self) -> _builtins.bool:
        """
        Invoke the hook for push events.
        """
        return pulumi.get(self, "push_events")

    @_builtins.property
    @pulumi.getter(name="pushEventsBranchFilter")
    def push_events_branch_filter(self) -> _builtins.str:
        """
        Invoke the hook for push events on matching branches only.
        """
        return pulumi.get(self, "push_events_branch_filter")

    @_builtins.property
    @pulumi.getter(name="releasesEvents")
    def releases_events(self) -> _builtins.bool:
        """
        Invoke the hook for releases events.
        """
        return pulumi.get(self, "releases_events")

    @_builtins.property
    @pulumi.getter(name="subgroupEvents")
    def subgroup_events(self) -> _builtins.bool:
        """
        Invoke the hook for subgroup events.
        """
        return pulumi.get(self, "subgroup_events")

    @_builtins.property
    @pulumi.getter(name="tagPushEvents")
    def tag_push_events(self) -> _builtins.bool:
        """
        Invoke the hook for tag push events.
        """
        return pulumi.get(self, "tag_push_events")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""The token is only available on resource creation, not in this datasource. It will always be blank. To be removed in 19.0.""")
    def token(self) -> _builtins.str:
        """
        A token to present when invoking the hook. The token is only available on resource creation, not in this datasource. It will always be blank. To be removed in 19.0.
        """
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The url of the hook to invoke.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="wikiPageEvents")
    def wiki_page_events(self) -> _builtins.bool:
        """
        Invoke the hook for wiki page events.
        """
        return pulumi.get(self, "wiki_page_events")


@pulumi.output_type
class GetGroupMembershipMemberResult(dict):
    def __init__(__self__, *,
                 access_level: _builtins.str,
                 avatar_url: _builtins.str,
                 expires_at: _builtins.str,
                 id: _builtins.int,
                 name: _builtins.str,
                 state: _builtins.str,
                 username: _builtins.str,
                 web_url: _builtins.str):
        """
        :param _builtins.str access_level: The level of access to the group.
        :param _builtins.str avatar_url: The avatar URL of the user.
        :param _builtins.str expires_at: Expiration date for the group membership.
        :param _builtins.int id: The unique id assigned to the user by the gitlab server.
        :param _builtins.str name: The name of the user.
        :param _builtins.str state: Whether the user is active or blocked.
        :param _builtins.str username: The username of the user.
        :param _builtins.str web_url: User's website URL.
        """
        pulumi.set(__self__, "access_level", access_level)
        pulumi.set(__self__, "avatar_url", avatar_url)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "web_url", web_url)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> _builtins.str:
        """
        The level of access to the group.
        """
        return pulumi.get(self, "access_level")

    @_builtins.property
    @pulumi.getter(name="avatarUrl")
    def avatar_url(self) -> _builtins.str:
        """
        The avatar URL of the user.
        """
        return pulumi.get(self, "avatar_url")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> _builtins.str:
        """
        Expiration date for the group membership.
        """
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The unique id assigned to the user by the gitlab server.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        Whether the user is active or blocked.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The username of the user.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> _builtins.str:
        """
        User's website URL.
        """
        return pulumi.get(self, "web_url")


@pulumi.output_type
class GetGroupProvisionedUsersProvisionedUserResult(dict):
    def __init__(__self__, *,
                 avatar_url: _builtins.str,
                 bio: _builtins.str,
                 bot: _builtins.bool,
                 confirmed_at: _builtins.str,
                 created_at: _builtins.str,
                 email: _builtins.str,
                 external: _builtins.bool,
                 id: _builtins.str,
                 job_title: _builtins.str,
                 last_activity_on: _builtins.str,
                 last_sign_in_at: _builtins.str,
                 linkedin: _builtins.str,
                 location: _builtins.str,
                 name: _builtins.str,
                 organization: _builtins.str,
                 private_profile: _builtins.bool,
                 pronouns: _builtins.str,
                 public_email: _builtins.str,
                 skype: _builtins.str,
                 state: _builtins.str,
                 twitter: _builtins.str,
                 two_factor_enabled: _builtins.bool,
                 username: _builtins.str,
                 web_url: _builtins.str,
                 website_url: _builtins.str):
        """
        :param _builtins.str avatar_url: The avatar URL of the provisioned user.
        :param _builtins.str bio: The bio of the provisioned user.
        :param _builtins.bool bot: Whether the provisioned user is a bot.
        :param _builtins.str confirmed_at: The confirmation date of the provisioned user.
        :param _builtins.str created_at: The creation date of the provisioned user.
        :param _builtins.str email: The email of the provisioned user.
        :param _builtins.bool external: Whether the provisioned user is external.
        :param _builtins.str id: The ID of the provisioned user.
        :param _builtins.str job_title: The job title of the provisioned user.
        :param _builtins.str last_activity_on: The last activity date of the provisioned user.
        :param _builtins.str last_sign_in_at: The last sign-in date of the provisioned user.
        :param _builtins.str linkedin: The LinkedIn ID of the provisioned user.
        :param _builtins.str location: The location of the provisioned user.
        :param _builtins.str name: The name of the provisioned user.
        :param _builtins.str organization: The organization of the provisioned user.
        :param _builtins.bool private_profile: Whether the provisioned user has a private profile.
        :param _builtins.str pronouns: The pronouns of the provisioned user.
        :param _builtins.str public_email: The public email of the provisioned user.
        :param _builtins.str skype: The Skype ID of the provisioned user.
        :param _builtins.str state: The state of the provisioned user.
        :param _builtins.str twitter: The Twitter ID of the provisioned user.
        :param _builtins.bool two_factor_enabled: Whether two-factor authentication is enabled for the provisioned user.
        :param _builtins.str username: The username of the provisioned user.
        :param _builtins.str web_url: The web URL of the provisioned user.
        :param _builtins.str website_url: The website URL of the provisioned user.
        """
        pulumi.set(__self__, "avatar_url", avatar_url)
        pulumi.set(__self__, "bio", bio)
        pulumi.set(__self__, "bot", bot)
        pulumi.set(__self__, "confirmed_at", confirmed_at)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "external", external)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "job_title", job_title)
        pulumi.set(__self__, "last_activity_on", last_activity_on)
        pulumi.set(__self__, "last_sign_in_at", last_sign_in_at)
        pulumi.set(__self__, "linkedin", linkedin)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "organization", organization)
        pulumi.set(__self__, "private_profile", private_profile)
        pulumi.set(__self__, "pronouns", pronouns)
        pulumi.set(__self__, "public_email", public_email)
        pulumi.set(__self__, "skype", skype)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "twitter", twitter)
        pulumi.set(__self__, "two_factor_enabled", two_factor_enabled)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "web_url", web_url)
        pulumi.set(__self__, "website_url", website_url)

    @_builtins.property
    @pulumi.getter(name="avatarUrl")
    def avatar_url(self) -> _builtins.str:
        """
        The avatar URL of the provisioned user.
        """
        return pulumi.get(self, "avatar_url")

    @_builtins.property
    @pulumi.getter
    def bio(self) -> _builtins.str:
        """
        The bio of the provisioned user.
        """
        return pulumi.get(self, "bio")

    @_builtins.property
    @pulumi.getter
    def bot(self) -> _builtins.bool:
        """
        Whether the provisioned user is a bot.
        """
        return pulumi.get(self, "bot")

    @_builtins.property
    @pulumi.getter(name="confirmedAt")
    def confirmed_at(self) -> _builtins.str:
        """
        The confirmation date of the provisioned user.
        """
        return pulumi.get(self, "confirmed_at")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation date of the provisioned user.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The email of the provisioned user.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter
    def external(self) -> _builtins.bool:
        """
        Whether the provisioned user is external.
        """
        return pulumi.get(self, "external")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the provisioned user.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="jobTitle")
    def job_title(self) -> _builtins.str:
        """
        The job title of the provisioned user.
        """
        return pulumi.get(self, "job_title")

    @_builtins.property
    @pulumi.getter(name="lastActivityOn")
    def last_activity_on(self) -> _builtins.str:
        """
        The last activity date of the provisioned user.
        """
        return pulumi.get(self, "last_activity_on")

    @_builtins.property
    @pulumi.getter(name="lastSignInAt")
    def last_sign_in_at(self) -> _builtins.str:
        """
        The last sign-in date of the provisioned user.
        """
        return pulumi.get(self, "last_sign_in_at")

    @_builtins.property
    @pulumi.getter
    def linkedin(self) -> _builtins.str:
        """
        The LinkedIn ID of the provisioned user.
        """
        return pulumi.get(self, "linkedin")

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        """
        The location of the provisioned user.
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the provisioned user.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def organization(self) -> _builtins.str:
        """
        The organization of the provisioned user.
        """
        return pulumi.get(self, "organization")

    @_builtins.property
    @pulumi.getter(name="privateProfile")
    def private_profile(self) -> _builtins.bool:
        """
        Whether the provisioned user has a private profile.
        """
        return pulumi.get(self, "private_profile")

    @_builtins.property
    @pulumi.getter
    def pronouns(self) -> _builtins.str:
        """
        The pronouns of the provisioned user.
        """
        return pulumi.get(self, "pronouns")

    @_builtins.property
    @pulumi.getter(name="publicEmail")
    def public_email(self) -> _builtins.str:
        """
        The public email of the provisioned user.
        """
        return pulumi.get(self, "public_email")

    @_builtins.property
    @pulumi.getter
    def skype(self) -> _builtins.str:
        """
        The Skype ID of the provisioned user.
        """
        return pulumi.get(self, "skype")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of the provisioned user.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def twitter(self) -> _builtins.str:
        """
        The Twitter ID of the provisioned user.
        """
        return pulumi.get(self, "twitter")

    @_builtins.property
    @pulumi.getter(name="twoFactorEnabled")
    def two_factor_enabled(self) -> _builtins.bool:
        """
        Whether two-factor authentication is enabled for the provisioned user.
        """
        return pulumi.get(self, "two_factor_enabled")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The username of the provisioned user.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> _builtins.str:
        """
        The web URL of the provisioned user.
        """
        return pulumi.get(self, "web_url")

    @_builtins.property
    @pulumi.getter(name="websiteUrl")
    def website_url(self) -> _builtins.str:
        """
        The website URL of the provisioned user.
        """
        return pulumi.get(self, "website_url")


@pulumi.output_type
class GetGroupSamlLinksSamlLinkResult(dict):
    def __init__(__self__, *,
                 access_level: _builtins.str,
                 member_role_id: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.str access_level: The base access level for members of the SAML group.
        :param _builtins.int member_role_id: Member Role ID (custom role for members of the SAML group.
        :param _builtins.str name: Name of the SAML group.
        """
        pulumi.set(__self__, "access_level", access_level)
        pulumi.set(__self__, "member_role_id", member_role_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> _builtins.str:
        """
        The base access level for members of the SAML group.
        """
        return pulumi.get(self, "access_level")

    @_builtins.property
    @pulumi.getter(name="memberRoleId")
    def member_role_id(self) -> _builtins.int:
        """
        Member Role ID (custom role for members of the SAML group.
        """
        return pulumi.get(self, "member_role_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the SAML group.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetGroupServiceAccountAccessTokensAccessTokenResult(dict):
    def __init__(__self__, *,
                 active: _builtins.bool,
                 created_at: _builtins.str,
                 expires_at: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 revoked: _builtins.bool,
                 scopes: Sequence[_builtins.str]):
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "revoked", revoked)
        pulumi.set(__self__, "scopes", scopes)

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> _builtins.str:
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def revoked(self) -> _builtins.bool:
        return pulumi.get(self, "revoked")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "scopes")


@pulumi.output_type
class GetGroupSharedWithGroupResult(dict):
    def __init__(__self__, *,
                 expires_at: _builtins.str,
                 group_access_level: _builtins.int,
                 group_full_path: _builtins.str,
                 group_id: _builtins.int,
                 group_name: _builtins.str):
        """
        :param _builtins.str expires_at: Share with group expiration date.
        :param _builtins.int group_access_level: The access_level permission level of the shared group.
        :param _builtins.str group_full_path: The full path of the group shared with.
        :param _builtins.int group_id: The ID of the group shared with.
        :param _builtins.str group_name: The name of the group shared with.
        """
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "group_access_level", group_access_level)
        pulumi.set(__self__, "group_full_path", group_full_path)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "group_name", group_name)

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> _builtins.str:
        """
        Share with group expiration date.
        """
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter(name="groupAccessLevel")
    def group_access_level(self) -> _builtins.int:
        """
        The access_level permission level of the shared group.
        """
        return pulumi.get(self, "group_access_level")

    @_builtins.property
    @pulumi.getter(name="groupFullPath")
    def group_full_path(self) -> _builtins.str:
        """
        The full path of the group shared with.
        """
        return pulumi.get(self, "group_full_path")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.int:
        """
        The ID of the group shared with.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> _builtins.str:
        """
        The name of the group shared with.
        """
        return pulumi.get(self, "group_name")


@pulumi.output_type
class GetGroupSubgroupsSubgroupResult(dict):
    def __init__(__self__, *,
                 allowed_email_domains_list: _builtins.str,
                 auto_devops_enabled: _builtins.bool,
                 avatar_url: _builtins.str,
                 created_at: _builtins.str,
                 default_branch_protection: _builtins.int,
                 description: _builtins.str,
                 emails_enabled: _builtins.bool,
                 file_template_project_id: _builtins.int,
                 full_name: _builtins.str,
                 full_path: _builtins.str,
                 group_id: _builtins.int,
                 ip_restriction_ranges: _builtins.str,
                 lfs_enabled: _builtins.bool,
                 mentions_disabled: _builtins.bool,
                 name: _builtins.str,
                 parent_id: _builtins.int,
                 path: _builtins.str,
                 project_creation_level: _builtins.str,
                 request_access_enabled: _builtins.bool,
                 require_two_factor_authentication: _builtins.bool,
                 share_with_group_lock: _builtins.bool,
                 shared_runners_setting: _builtins.str,
                 statistics: Mapping[str, _builtins.str],
                 subgroup_creation_level: _builtins.str,
                 two_factor_grace_period: _builtins.int,
                 visibility: _builtins.str,
                 web_url: _builtins.str,
                 wiki_access_level: _builtins.str):
        """
        :param _builtins.str allowed_email_domains_list: A list of email address domains to allow group access.
        :param _builtins.bool auto_devops_enabled: Default to Auto DevOps pipeline for all projects within this group.
        :param _builtins.str avatar_url: The URL of the avatar image.
        :param _builtins.str created_at: Group created at date.
        :param _builtins.int default_branch_protection: Whether developers and maintainers can push to the applicable default branch.
        :param _builtins.str description: The description of the group.
        :param _builtins.bool emails_enabled: Enable email notifications.
        :param _builtins.int file_template_project_id: The ID of the project that will be used for file templates.
        :param _builtins.str full_name: The full name of the group.
        :param _builtins.str full_path: The full path of the group.
        :param _builtins.int group_id: The ID of the group.
        :param _builtins.str ip_restriction_ranges: A list of IP addresses or subnet masks to restrict group access.
        :param _builtins.bool lfs_enabled: Is LFS enabled for projects in this group.
        :param _builtins.bool mentions_disabled: Disable the capability of a group from getting mentioned.
        :param _builtins.str name: The name of this group.
        :param _builtins.int parent_id: ID of the parent group.
        :param _builtins.str path: The path of the group.
        :param _builtins.str project_creation_level: Determine if developers can create projects in the group. Valid values are: `noone`, `owner`, `maintainer`, `developer`, `administrator`
        :param _builtins.bool request_access_enabled: Is request for access enabled to the group.
        :param _builtins.bool require_two_factor_authentication: Require all users in this group to setup Two-factor authentication.
        :param _builtins.bool share_with_group_lock: Prevent sharing a project with another group within this group.
        :param _builtins.str shared_runners_setting: Enable or disable shared runners for a group's subgroups and projects. Valid values are: `enabled`, `disabled_and_overridable`, `disabled_and_unoverridable`, `disabled_with_override`.
        :param Mapping[str, _builtins.str] statistics: Group statistics.
        :param _builtins.str subgroup_creation_level: Allowed to create subgroups. Valid values are: `owner`, `maintainer`.
        :param _builtins.int two_factor_grace_period: Time before Two-factor authentication is enforced (in hours).
        :param _builtins.str visibility: Limited by visibility `public`, `internal`, or `private`.
        :param _builtins.str web_url: Web URL of the group.
        :param _builtins.str wiki_access_level: The group's wiki access level. Only available on Premium and Ultimate plans. Valid values are `disabled`, `private`, `enabled`.
        """
        pulumi.set(__self__, "allowed_email_domains_list", allowed_email_domains_list)
        pulumi.set(__self__, "auto_devops_enabled", auto_devops_enabled)
        pulumi.set(__self__, "avatar_url", avatar_url)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "default_branch_protection", default_branch_protection)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "emails_enabled", emails_enabled)
        pulumi.set(__self__, "file_template_project_id", file_template_project_id)
        pulumi.set(__self__, "full_name", full_name)
        pulumi.set(__self__, "full_path", full_path)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "ip_restriction_ranges", ip_restriction_ranges)
        pulumi.set(__self__, "lfs_enabled", lfs_enabled)
        pulumi.set(__self__, "mentions_disabled", mentions_disabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "parent_id", parent_id)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "project_creation_level", project_creation_level)
        pulumi.set(__self__, "request_access_enabled", request_access_enabled)
        pulumi.set(__self__, "require_two_factor_authentication", require_two_factor_authentication)
        pulumi.set(__self__, "share_with_group_lock", share_with_group_lock)
        pulumi.set(__self__, "shared_runners_setting", shared_runners_setting)
        pulumi.set(__self__, "statistics", statistics)
        pulumi.set(__self__, "subgroup_creation_level", subgroup_creation_level)
        pulumi.set(__self__, "two_factor_grace_period", two_factor_grace_period)
        pulumi.set(__self__, "visibility", visibility)
        pulumi.set(__self__, "web_url", web_url)
        pulumi.set(__self__, "wiki_access_level", wiki_access_level)

    @_builtins.property
    @pulumi.getter(name="allowedEmailDomainsList")
    def allowed_email_domains_list(self) -> _builtins.str:
        """
        A list of email address domains to allow group access.
        """
        return pulumi.get(self, "allowed_email_domains_list")

    @_builtins.property
    @pulumi.getter(name="autoDevopsEnabled")
    def auto_devops_enabled(self) -> _builtins.bool:
        """
        Default to Auto DevOps pipeline for all projects within this group.
        """
        return pulumi.get(self, "auto_devops_enabled")

    @_builtins.property
    @pulumi.getter(name="avatarUrl")
    def avatar_url(self) -> _builtins.str:
        """
        The URL of the avatar image.
        """
        return pulumi.get(self, "avatar_url")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Group created at date.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="defaultBranchProtection")
    def default_branch_protection(self) -> _builtins.int:
        """
        Whether developers and maintainers can push to the applicable default branch.
        """
        return pulumi.get(self, "default_branch_protection")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the group.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="emailsEnabled")
    def emails_enabled(self) -> _builtins.bool:
        """
        Enable email notifications.
        """
        return pulumi.get(self, "emails_enabled")

    @_builtins.property
    @pulumi.getter(name="fileTemplateProjectId")
    def file_template_project_id(self) -> _builtins.int:
        """
        The ID of the project that will be used for file templates.
        """
        return pulumi.get(self, "file_template_project_id")

    @_builtins.property
    @pulumi.getter(name="fullName")
    def full_name(self) -> _builtins.str:
        """
        The full name of the group.
        """
        return pulumi.get(self, "full_name")

    @_builtins.property
    @pulumi.getter(name="fullPath")
    def full_path(self) -> _builtins.str:
        """
        The full path of the group.
        """
        return pulumi.get(self, "full_path")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.int:
        """
        The ID of the group.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="ipRestrictionRanges")
    def ip_restriction_ranges(self) -> _builtins.str:
        """
        A list of IP addresses or subnet masks to restrict group access.
        """
        return pulumi.get(self, "ip_restriction_ranges")

    @_builtins.property
    @pulumi.getter(name="lfsEnabled")
    def lfs_enabled(self) -> _builtins.bool:
        """
        Is LFS enabled for projects in this group.
        """
        return pulumi.get(self, "lfs_enabled")

    @_builtins.property
    @pulumi.getter(name="mentionsDisabled")
    def mentions_disabled(self) -> _builtins.bool:
        """
        Disable the capability of a group from getting mentioned.
        """
        return pulumi.get(self, "mentions_disabled")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of this group.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="parentId")
    def parent_id(self) -> _builtins.int:
        """
        ID of the parent group.
        """
        return pulumi.get(self, "parent_id")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The path of the group.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="projectCreationLevel")
    def project_creation_level(self) -> _builtins.str:
        """
        Determine if developers can create projects in the group. Valid values are: `noone`, `owner`, `maintainer`, `developer`, `administrator`
        """
        return pulumi.get(self, "project_creation_level")

    @_builtins.property
    @pulumi.getter(name="requestAccessEnabled")
    def request_access_enabled(self) -> _builtins.bool:
        """
        Is request for access enabled to the group.
        """
        return pulumi.get(self, "request_access_enabled")

    @_builtins.property
    @pulumi.getter(name="requireTwoFactorAuthentication")
    def require_two_factor_authentication(self) -> _builtins.bool:
        """
        Require all users in this group to setup Two-factor authentication.
        """
        return pulumi.get(self, "require_two_factor_authentication")

    @_builtins.property
    @pulumi.getter(name="shareWithGroupLock")
    def share_with_group_lock(self) -> _builtins.bool:
        """
        Prevent sharing a project with another group within this group.
        """
        return pulumi.get(self, "share_with_group_lock")

    @_builtins.property
    @pulumi.getter(name="sharedRunnersSetting")
    def shared_runners_setting(self) -> _builtins.str:
        """
        Enable or disable shared runners for a group's subgroups and projects. Valid values are: `enabled`, `disabled_and_overridable`, `disabled_and_unoverridable`, `disabled_with_override`.
        """
        return pulumi.get(self, "shared_runners_setting")

    @_builtins.property
    @pulumi.getter
    def statistics(self) -> Mapping[str, _builtins.str]:
        """
        Group statistics.
        """
        return pulumi.get(self, "statistics")

    @_builtins.property
    @pulumi.getter(name="subgroupCreationLevel")
    def subgroup_creation_level(self) -> _builtins.str:
        """
        Allowed to create subgroups. Valid values are: `owner`, `maintainer`.
        """
        return pulumi.get(self, "subgroup_creation_level")

    @_builtins.property
    @pulumi.getter(name="twoFactorGracePeriod")
    def two_factor_grace_period(self) -> _builtins.int:
        """
        Time before Two-factor authentication is enforced (in hours).
        """
        return pulumi.get(self, "two_factor_grace_period")

    @_builtins.property
    @pulumi.getter
    def visibility(self) -> _builtins.str:
        """
        Limited by visibility `public`, `internal`, or `private`.
        """
        return pulumi.get(self, "visibility")

    @_builtins.property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> _builtins.str:
        """
        Web URL of the group.
        """
        return pulumi.get(self, "web_url")

    @_builtins.property
    @pulumi.getter(name="wikiAccessLevel")
    def wiki_access_level(self) -> _builtins.str:
        """
        The group's wiki access level. Only available on Premium and Ultimate plans. Valid values are `disabled`, `private`, `enabled`.
        """
        return pulumi.get(self, "wiki_access_level")


@pulumi.output_type
class GetGroupVariablesVariableResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 environment_scope: _builtins.str,
                 group: _builtins.str,
                 key: _builtins.str,
                 masked: _builtins.bool,
                 protected: _builtins.bool,
                 raw: _builtins.bool,
                 value: _builtins.str,
                 variable_type: _builtins.str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "environment_scope", environment_scope)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "masked", masked)
        pulumi.set(__self__, "protected", protected)
        pulumi.set(__self__, "raw", raw)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "variable_type", variable_type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="environmentScope")
    def environment_scope(self) -> _builtins.str:
        return pulumi.get(self, "environment_scope")

    @_builtins.property
    @pulumi.getter
    def group(self) -> _builtins.str:
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def masked(self) -> _builtins.bool:
        return pulumi.get(self, "masked")

    @_builtins.property
    @pulumi.getter
    def protected(self) -> _builtins.bool:
        return pulumi.get(self, "protected")

    @_builtins.property
    @pulumi.getter
    def raw(self) -> _builtins.bool:
        return pulumi.get(self, "raw")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="variableType")
    def variable_type(self) -> _builtins.str:
        return pulumi.get(self, "variable_type")


@pulumi.output_type
class GetGroupsGroupResult(dict):
    def __init__(__self__, *,
                 default_branch_protection: _builtins.int,
                 description: _builtins.str,
                 full_name: _builtins.str,
                 full_path: _builtins.str,
                 group_id: _builtins.int,
                 lfs_enabled: _builtins.bool,
                 name: _builtins.str,
                 parent_id: _builtins.int,
                 path: _builtins.str,
                 prevent_forking_outside_group: _builtins.bool,
                 request_access_enabled: _builtins.bool,
                 runners_token: _builtins.str,
                 shared_runners_setting: _builtins.str,
                 visibility_level: _builtins.str,
                 web_url: _builtins.str,
                 wiki_access_level: _builtins.str):
        """
        :param _builtins.int default_branch_protection: Whether developers and maintainers can push to the applicable default branch. Will be removed in 19.0.
        :param _builtins.str description: The description of the group.
        :param _builtins.str full_name: The full name of the group.
        :param _builtins.str full_path: The full path of the group.
        :param _builtins.int group_id: The ID of the group.
        :param _builtins.bool lfs_enabled: Is LFS enabled for projects in this group.
        :param _builtins.str name: The name of this group.
        :param _builtins.int parent_id: ID of the parent group.
        :param _builtins.str path: The path of the group.
        :param _builtins.bool prevent_forking_outside_group: When enabled, users can not fork projects from this group to external namespaces.
        :param _builtins.bool request_access_enabled: Is request for access enabled to the group.
        :param _builtins.str runners_token: The group level registration token to use during runner setup.
        :param _builtins.str shared_runners_setting: Enable or disable shared runners for a group's subgroups and projects. Valid values are: `enabled`, `disabled_and_overridable`, `disabled_and_unoverridable`, `disabled_with_override`.
        :param _builtins.str visibility_level: Visibility level of the group. Possible values are `private`, `internal`, `public`.
        :param _builtins.str web_url: Web URL of the group.
        :param _builtins.str wiki_access_level: The group's wiki access level. Only available on Premium and Ultimate plans. Valid values are `disabled`, `private`, `enabled`.
        """
        pulumi.set(__self__, "default_branch_protection", default_branch_protection)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "full_name", full_name)
        pulumi.set(__self__, "full_path", full_path)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "lfs_enabled", lfs_enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "parent_id", parent_id)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "prevent_forking_outside_group", prevent_forking_outside_group)
        pulumi.set(__self__, "request_access_enabled", request_access_enabled)
        pulumi.set(__self__, "runners_token", runners_token)
        pulumi.set(__self__, "shared_runners_setting", shared_runners_setting)
        pulumi.set(__self__, "visibility_level", visibility_level)
        pulumi.set(__self__, "web_url", web_url)
        pulumi.set(__self__, "wiki_access_level", wiki_access_level)

    @_builtins.property
    @pulumi.getter(name="defaultBranchProtection")
    @_utilities.deprecated("""Will be removed in 19.0.""")
    def default_branch_protection(self) -> _builtins.int:
        """
        Whether developers and maintainers can push to the applicable default branch. Will be removed in 19.0.
        """
        return pulumi.get(self, "default_branch_protection")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the group.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="fullName")
    def full_name(self) -> _builtins.str:
        """
        The full name of the group.
        """
        return pulumi.get(self, "full_name")

    @_builtins.property
    @pulumi.getter(name="fullPath")
    def full_path(self) -> _builtins.str:
        """
        The full path of the group.
        """
        return pulumi.get(self, "full_path")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.int:
        """
        The ID of the group.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="lfsEnabled")
    def lfs_enabled(self) -> _builtins.bool:
        """
        Is LFS enabled for projects in this group.
        """
        return pulumi.get(self, "lfs_enabled")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of this group.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="parentId")
    def parent_id(self) -> _builtins.int:
        """
        ID of the parent group.
        """
        return pulumi.get(self, "parent_id")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The path of the group.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="preventForkingOutsideGroup")
    def prevent_forking_outside_group(self) -> _builtins.bool:
        """
        When enabled, users can not fork projects from this group to external namespaces.
        """
        return pulumi.get(self, "prevent_forking_outside_group")

    @_builtins.property
    @pulumi.getter(name="requestAccessEnabled")
    def request_access_enabled(self) -> _builtins.bool:
        """
        Is request for access enabled to the group.
        """
        return pulumi.get(self, "request_access_enabled")

    @_builtins.property
    @pulumi.getter(name="runnersToken")
    def runners_token(self) -> _builtins.str:
        """
        The group level registration token to use during runner setup.
        """
        return pulumi.get(self, "runners_token")

    @_builtins.property
    @pulumi.getter(name="sharedRunnersSetting")
    def shared_runners_setting(self) -> _builtins.str:
        """
        Enable or disable shared runners for a group's subgroups and projects. Valid values are: `enabled`, `disabled_and_overridable`, `disabled_and_unoverridable`, `disabled_with_override`.
        """
        return pulumi.get(self, "shared_runners_setting")

    @_builtins.property
    @pulumi.getter(name="visibilityLevel")
    def visibility_level(self) -> _builtins.str:
        """
        Visibility level of the group. Possible values are `private`, `internal`, `public`.
        """
        return pulumi.get(self, "visibility_level")

    @_builtins.property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> _builtins.str:
        """
        Web URL of the group.
        """
        return pulumi.get(self, "web_url")

    @_builtins.property
    @pulumi.getter(name="wikiAccessLevel")
    def wiki_access_level(self) -> _builtins.str:
        """
        The group's wiki access level. Only available on Premium and Ultimate plans. Valid values are `disabled`, `private`, `enabled`.
        """
        return pulumi.get(self, "wiki_access_level")


@pulumi.output_type
class GetInstanceDeployKeysDeployKeyResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 fingerprint: _builtins.str,
                 id: _builtins.int,
                 key: _builtins.str,
                 projects_with_write_accesses: Sequence['outputs.GetInstanceDeployKeysDeployKeyProjectsWithWriteAccessResult'],
                 title: _builtins.str):
        """
        :param _builtins.str created_at: The creation date of the deploy key. In RFC3339 format.
        :param _builtins.str fingerprint: The fingerprint of the deploy key.
        :param _builtins.int id: The ID of the deploy key.
        :param _builtins.str key: The deploy key.
        :param Sequence['GetInstanceDeployKeysDeployKeyProjectsWithWriteAccessArgs'] projects_with_write_accesses: The list of projects that the deploy key has write access to.
        :param _builtins.str title: The title of the deploy key.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "fingerprint", fingerprint)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "projects_with_write_accesses", projects_with_write_accesses)
        pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation date of the deploy key. In RFC3339 format.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def fingerprint(self) -> _builtins.str:
        """
        The fingerprint of the deploy key.
        """
        return pulumi.get(self, "fingerprint")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The ID of the deploy key.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The deploy key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="projectsWithWriteAccesses")
    def projects_with_write_accesses(self) -> Sequence['outputs.GetInstanceDeployKeysDeployKeyProjectsWithWriteAccessResult']:
        """
        The list of projects that the deploy key has write access to.
        """
        return pulumi.get(self, "projects_with_write_accesses")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The title of the deploy key.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetInstanceDeployKeysDeployKeyProjectsWithWriteAccessResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 id: _builtins.int,
                 name: _builtins.str,
                 name_with_namespace: _builtins.str,
                 path: _builtins.str,
                 path_with_namespace: _builtins.str):
        """
        :param _builtins.str created_at: The creation date of the project. In RFC3339 format.
        :param _builtins.str description: The description of the project.
        :param _builtins.int id: The ID of the project.
        :param _builtins.str name: The name of the project.
        :param _builtins.str name_with_namespace: The name of the project with namespace.
        :param _builtins.str path: The path of the project.
        :param _builtins.str path_with_namespace: The path of the project with namespace.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "name_with_namespace", name_with_namespace)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "path_with_namespace", path_with_namespace)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation date of the project. In RFC3339 format.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the project.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The ID of the project.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the project.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nameWithNamespace")
    def name_with_namespace(self) -> _builtins.str:
        """
        The name of the project with namespace.
        """
        return pulumi.get(self, "name_with_namespace")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The path of the project.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="pathWithNamespace")
    def path_with_namespace(self) -> _builtins.str:
        """
        The path of the project with namespace.
        """
        return pulumi.get(self, "path_with_namespace")


@pulumi.output_type
class GetInstanceVariablesVariableResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 key: _builtins.str,
                 masked: _builtins.bool,
                 protected: _builtins.bool,
                 raw: _builtins.bool,
                 value: _builtins.str,
                 variable_type: _builtins.str):
        """
        :param _builtins.str description: The description of the variable. Maximum of 255 characters.
        :param _builtins.str key: The name of the variable.
        :param _builtins.bool masked: If set to `true`, the value of the variable will be hidden in job logs.
        :param _builtins.bool protected: If set to `true`, the variable will be passed only to pipelines running on protected branches and tags.
        :param _builtins.bool raw: If set to `true`, the variable will be treated as a raw string.
        :param _builtins.str value: The value of the variable.
        :param _builtins.str variable_type: The type of the variable, either `env_var` or `file`.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "masked", masked)
        pulumi.set(__self__, "protected", protected)
        pulumi.set(__self__, "raw", raw)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "variable_type", variable_type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the variable. Maximum of 255 characters.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def masked(self) -> _builtins.bool:
        """
        If set to `true`, the value of the variable will be hidden in job logs.
        """
        return pulumi.get(self, "masked")

    @_builtins.property
    @pulumi.getter
    def protected(self) -> _builtins.bool:
        """
        If set to `true`, the variable will be passed only to pipelines running on protected branches and tags.
        """
        return pulumi.get(self, "protected")

    @_builtins.property
    @pulumi.getter
    def raw(self) -> _builtins.bool:
        """
        If set to `true`, the variable will be treated as a raw string.
        """
        return pulumi.get(self, "raw")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the variable.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="variableType")
    def variable_type(self) -> _builtins.str:
        """
        The type of the variable, either `env_var` or `file`.
        """
        return pulumi.get(self, "variable_type")


@pulumi.output_type
class GetMetadataKasResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 external_k8s_proxy_url: _builtins.str,
                 external_url: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.bool enabled: Indicates whether KAS is enabled.
        :param _builtins.str external_k8s_proxy_url: URL used by the Kubernetes tooling to communicate with the KAS Kubernetes API proxy. Its null if kas.enabled is false.
        :param _builtins.str external_url: URL used by the agents to communicate with KAS. Its null if kas.enabled is false.
        :param _builtins.str version: Version of KAS. Its null if kas.enabled is false.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "external_k8s_proxy_url", external_k8s_proxy_url)
        pulumi.set(__self__, "external_url", external_url)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Indicates whether KAS is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="externalK8sProxyUrl")
    def external_k8s_proxy_url(self) -> _builtins.str:
        """
        URL used by the Kubernetes tooling to communicate with the KAS Kubernetes API proxy. Its null if kas.enabled is false.
        """
        return pulumi.get(self, "external_k8s_proxy_url")

    @_builtins.property
    @pulumi.getter(name="externalUrl")
    def external_url(self) -> _builtins.str:
        """
        URL used by the agents to communicate with KAS. Its null if kas.enabled is false.
        """
        return pulumi.get(self, "external_url")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Version of KAS. Its null if kas.enabled is false.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetPipelineScheduleLastPipelineResult(dict):
    def __init__(__self__, *,
                 id: _builtins.int,
                 ref: _builtins.str,
                 sha: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.int id: The pipeline ID.
        :param _builtins.str ref: The ref of the pipeline.
        :param _builtins.str sha: The SHA of the pipeline.
        :param _builtins.str status: The status of pipelines, one of: created, waiting*for*resource, preparing, pending, running, success, failed, canceled, skipped, manual, scheduled.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ref", ref)
        pulumi.set(__self__, "sha", sha)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The pipeline ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def ref(self) -> _builtins.str:
        """
        The ref of the pipeline.
        """
        return pulumi.get(self, "ref")

    @_builtins.property
    @pulumi.getter
    def sha(self) -> _builtins.str:
        """
        The SHA of the pipeline.
        """
        return pulumi.get(self, "sha")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of pipelines, one of: created, waiting*for*resource, preparing, pending, running, success, failed, canceled, skipped, manual, scheduled.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetPipelineScheduleOwnerResult(dict):
    def __init__(__self__, *,
                 avatar_url: _builtins.str,
                 id: _builtins.int,
                 name: _builtins.str,
                 state: _builtins.str,
                 username: _builtins.str,
                 web_url: _builtins.str):
        """
        :param _builtins.str avatar_url: Image URL for the user's avatar.
        :param _builtins.int id: The user ID.
        :param _builtins.str name: Name.
        :param _builtins.str state: User's state, one of: active, blocked.
        :param _builtins.str username: Username.
        :param _builtins.str web_url: URL to the user's profile.
        """
        pulumi.set(__self__, "avatar_url", avatar_url)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "web_url", web_url)

    @_builtins.property
    @pulumi.getter(name="avatarUrl")
    def avatar_url(self) -> _builtins.str:
        """
        Image URL for the user's avatar.
        """
        return pulumi.get(self, "avatar_url")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The user ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        User's state, one of: active, blocked.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Username.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> _builtins.str:
        """
        URL to the user's profile.
        """
        return pulumi.get(self, "web_url")


@pulumi.output_type
class GetPipelineScheduleVariableResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str,
                 variable_type: _builtins.str):
        """
        :param _builtins.str key: The key of a variable.
        :param _builtins.str value: The value of a variable.
        :param _builtins.str variable_type: The type of a variable, one of: env_var and file.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "variable_type", variable_type)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key of a variable.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of a variable.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="variableType")
    def variable_type(self) -> _builtins.str:
        """
        The type of a variable, one of: env_var and file.
        """
        return pulumi.get(self, "variable_type")


@pulumi.output_type
class GetPipelineSchedulesPipelineScheduleResult(dict):
    def __init__(__self__, *,
                 active: _builtins.bool,
                 created_at: _builtins.str,
                 cron: _builtins.str,
                 cron_timezone: _builtins.str,
                 description: _builtins.str,
                 id: _builtins.int,
                 next_run_at: _builtins.str,
                 owner: 'outputs.GetPipelineSchedulesPipelineScheduleOwnerResult',
                 ref: _builtins.str,
                 updated_at: _builtins.str):
        """
        :param _builtins.bool active: The activation status of pipeline schedule.
        :param _builtins.str created_at: The datetime of when the schedule was created.
        :param _builtins.str cron: The cron (e.g. `0 1 * * *`).
        :param _builtins.str cron_timezone: The timezone.
        :param _builtins.str description: The description of the pipeline schedule.
        :param _builtins.int id: The pipeline schedule id.
        :param _builtins.str next_run_at: The datetime of when the schedule will next run.
        :param 'GetPipelineSchedulesPipelineScheduleOwnerArgs' owner: The details of the pipeline schedule owner.
        :param _builtins.str ref: The branch/tag name to be triggered. This will be the full branch reference, for example: `refs/heads/main`, not `main`.
        :param _builtins.str updated_at: The datetime of when the schedule was last updated.
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "cron", cron)
        pulumi.set(__self__, "cron_timezone", cron_timezone)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "next_run_at", next_run_at)
        pulumi.set(__self__, "owner", owner)
        pulumi.set(__self__, "ref", ref)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        """
        The activation status of pipeline schedule.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The datetime of when the schedule was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def cron(self) -> _builtins.str:
        """
        The cron (e.g. `0 1 * * *`).
        """
        return pulumi.get(self, "cron")

    @_builtins.property
    @pulumi.getter(name="cronTimezone")
    def cron_timezone(self) -> _builtins.str:
        """
        The timezone.
        """
        return pulumi.get(self, "cron_timezone")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the pipeline schedule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The pipeline schedule id.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="nextRunAt")
    def next_run_at(self) -> _builtins.str:
        """
        The datetime of when the schedule will next run.
        """
        return pulumi.get(self, "next_run_at")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> 'outputs.GetPipelineSchedulesPipelineScheduleOwnerResult':
        """
        The details of the pipeline schedule owner.
        """
        return pulumi.get(self, "owner")

    @_builtins.property
    @pulumi.getter
    def ref(self) -> _builtins.str:
        """
        The branch/tag name to be triggered. This will be the full branch reference, for example: `refs/heads/main`, not `main`.
        """
        return pulumi.get(self, "ref")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        The datetime of when the schedule was last updated.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetPipelineSchedulesPipelineScheduleOwnerResult(dict):
    def __init__(__self__, *,
                 avatar_url: _builtins.str,
                 id: _builtins.int,
                 name: _builtins.str,
                 state: _builtins.str,
                 username: _builtins.str,
                 web_url: _builtins.str):
        """
        :param _builtins.str avatar_url: Image URL for the user's avatar.
        :param _builtins.int id: The user ID.
        :param _builtins.str name: Name.
        :param _builtins.str state: User's state, one of: active, blocked.
        :param _builtins.str username: Username.
        :param _builtins.str web_url: URL to the user's profile.
        """
        pulumi.set(__self__, "avatar_url", avatar_url)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "web_url", web_url)

    @_builtins.property
    @pulumi.getter(name="avatarUrl")
    def avatar_url(self) -> _builtins.str:
        """
        Image URL for the user's avatar.
        """
        return pulumi.get(self, "avatar_url")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The user ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        User's state, one of: active, blocked.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Username.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> _builtins.str:
        """
        URL to the user's profile.
        """
        return pulumi.get(self, "web_url")


@pulumi.output_type
class GetProjectAccessTokensAccessTokenResult(dict):
    def __init__(__self__, *,
                 access_level: _builtins.str,
                 active: _builtins.bool,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 expires_at: _builtins.str,
                 id: _builtins.str,
                 last_used_at: _builtins.str,
                 name: _builtins.str,
                 project: _builtins.str,
                 revoked: _builtins.bool,
                 scopes: Sequence[_builtins.str],
                 user_id: _builtins.int):
        pulumi.set(__self__, "access_level", access_level)
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_used_at", last_used_at)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project", project)
        pulumi.set(__self__, "revoked", revoked)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> _builtins.str:
        return pulumi.get(self, "access_level")

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> _builtins.str:
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lastUsedAt")
    def last_used_at(self) -> _builtins.str:
        return pulumi.get(self, "last_used_at")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def project(self) -> _builtins.str:
        return pulumi.get(self, "project")

    @_builtins.property
    @pulumi.getter
    def revoked(self) -> _builtins.bool:
        return pulumi.get(self, "revoked")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> _builtins.int:
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetProjectApprovalRulesApprovalRuleResult(dict):
    def __init__(__self__, *,
                 applies_to_all_protected_branches: _builtins.bool,
                 approvals_required: _builtins.int,
                 eligible_approver_ids: Sequence[_builtins.int],
                 group_ids: Sequence[_builtins.int],
                 id: _builtins.int,
                 name: _builtins.str,
                 protected_branch_ids: Sequence[_builtins.int],
                 report_type: _builtins.str,
                 rule_type: _builtins.str,
                 user_ids: Sequence[_builtins.int]):
        """
        :param _builtins.bool applies_to_all_protected_branches: If true, applies the rule to all protected branches, ignoring the protected branches attribute.
        :param _builtins.int approvals_required: The number of approvals required for this rule.
        :param Sequence[_builtins.int] eligible_approver_ids: List of all approver IDs that are eligible to approve this rule.
        :param Sequence[_builtins.int] group_ids: List of group IDs that are eligible to approve this rule.
        :param _builtins.int id: The ID of the approval rule.
        :param _builtins.str name: The name of the approval rule.
        :param Sequence[_builtins.int] protected_branch_ids: List of protected branch IDs that this rule applies to.
        :param _builtins.str report_type: The report type. Required when the rule type is `report_approver`. The supported report types are `license_scanning` and `code_coverage`.
        :param _builtins.str rule_type: The type of the approval rule. Can be `any_approver`, `regular` or `report_approver`.
        :param Sequence[_builtins.int] user_ids: List of user IDs that are eligible to approve this rule.
        """
        pulumi.set(__self__, "applies_to_all_protected_branches", applies_to_all_protected_branches)
        pulumi.set(__self__, "approvals_required", approvals_required)
        pulumi.set(__self__, "eligible_approver_ids", eligible_approver_ids)
        pulumi.set(__self__, "group_ids", group_ids)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protected_branch_ids", protected_branch_ids)
        pulumi.set(__self__, "report_type", report_type)
        pulumi.set(__self__, "rule_type", rule_type)
        pulumi.set(__self__, "user_ids", user_ids)

    @_builtins.property
    @pulumi.getter(name="appliesToAllProtectedBranches")
    def applies_to_all_protected_branches(self) -> _builtins.bool:
        """
        If true, applies the rule to all protected branches, ignoring the protected branches attribute.
        """
        return pulumi.get(self, "applies_to_all_protected_branches")

    @_builtins.property
    @pulumi.getter(name="approvalsRequired")
    def approvals_required(self) -> _builtins.int:
        """
        The number of approvals required for this rule.
        """
        return pulumi.get(self, "approvals_required")

    @_builtins.property
    @pulumi.getter(name="eligibleApproverIds")
    def eligible_approver_ids(self) -> Sequence[_builtins.int]:
        """
        List of all approver IDs that are eligible to approve this rule.
        """
        return pulumi.get(self, "eligible_approver_ids")

    @_builtins.property
    @pulumi.getter(name="groupIds")
    def group_ids(self) -> Sequence[_builtins.int]:
        """
        List of group IDs that are eligible to approve this rule.
        """
        return pulumi.get(self, "group_ids")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The ID of the approval rule.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the approval rule.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="protectedBranchIds")
    def protected_branch_ids(self) -> Sequence[_builtins.int]:
        """
        List of protected branch IDs that this rule applies to.
        """
        return pulumi.get(self, "protected_branch_ids")

    @_builtins.property
    @pulumi.getter(name="reportType")
    def report_type(self) -> _builtins.str:
        """
        The report type. Required when the rule type is `report_approver`. The supported report types are `license_scanning` and `code_coverage`.
        """
        return pulumi.get(self, "report_type")

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> _builtins.str:
        """
        The type of the approval rule. Can be `any_approver`, `regular` or `report_approver`.
        """
        return pulumi.get(self, "rule_type")

    @_builtins.property
    @pulumi.getter(name="userIds")
    def user_ids(self) -> Sequence[_builtins.int]:
        """
        List of user IDs that are eligible to approve this rule.
        """
        return pulumi.get(self, "user_ids")


@pulumi.output_type
class GetProjectBranchesBranchResult(dict):
    def __init__(__self__, *,
                 can_push: _builtins.bool,
                 commits: Sequence['outputs.GetProjectBranchesBranchCommitResult'],
                 default: _builtins.bool,
                 developers_can_merge: _builtins.bool,
                 developers_can_push: _builtins.bool,
                 merged: _builtins.bool,
                 name: _builtins.str,
                 protected: _builtins.bool,
                 web_url: _builtins.str):
        """
        :param _builtins.bool can_push: Bool, true if you can push to the branch.
        :param Sequence['GetProjectBranchesBranchCommitArgs'] commits: The commit associated with the branch ref.
        :param _builtins.bool default: Bool, true if branch is the default branch for the project.
        :param _builtins.bool developers_can_merge: Bool, true if developer level access allows to merge branch.
        :param _builtins.bool developers_can_push: Bool, true if developer level access allows git push.
        :param _builtins.bool merged: Bool, true if the branch has been merged into its parent.
        :param _builtins.str name: The name of the branch.
        :param _builtins.bool protected: Bool, true if branch has branch protection.
        :param _builtins.str web_url: URL that can be used to find the branch in a browser.
        """
        pulumi.set(__self__, "can_push", can_push)
        pulumi.set(__self__, "commits", commits)
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "developers_can_merge", developers_can_merge)
        pulumi.set(__self__, "developers_can_push", developers_can_push)
        pulumi.set(__self__, "merged", merged)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protected", protected)
        pulumi.set(__self__, "web_url", web_url)

    @_builtins.property
    @pulumi.getter(name="canPush")
    def can_push(self) -> _builtins.bool:
        """
        Bool, true if you can push to the branch.
        """
        return pulumi.get(self, "can_push")

    @_builtins.property
    @pulumi.getter
    def commits(self) -> Sequence['outputs.GetProjectBranchesBranchCommitResult']:
        """
        The commit associated with the branch ref.
        """
        return pulumi.get(self, "commits")

    @_builtins.property
    @pulumi.getter
    def default(self) -> _builtins.bool:
        """
        Bool, true if branch is the default branch for the project.
        """
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter(name="developersCanMerge")
    def developers_can_merge(self) -> _builtins.bool:
        """
        Bool, true if developer level access allows to merge branch.
        """
        return pulumi.get(self, "developers_can_merge")

    @_builtins.property
    @pulumi.getter(name="developersCanPush")
    def developers_can_push(self) -> _builtins.bool:
        """
        Bool, true if developer level access allows git push.
        """
        return pulumi.get(self, "developers_can_push")

    @_builtins.property
    @pulumi.getter
    def merged(self) -> _builtins.bool:
        """
        Bool, true if the branch has been merged into its parent.
        """
        return pulumi.get(self, "merged")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the branch.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def protected(self) -> _builtins.bool:
        """
        Bool, true if branch has branch protection.
        """
        return pulumi.get(self, "protected")

    @_builtins.property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> _builtins.str:
        """
        URL that can be used to find the branch in a browser.
        """
        return pulumi.get(self, "web_url")


@pulumi.output_type
class GetProjectBranchesBranchCommitResult(dict):
    def __init__(__self__, *,
                 author_email: _builtins.str,
                 author_name: _builtins.str,
                 authored_date: _builtins.str,
                 committed_date: _builtins.str,
                 committer_email: _builtins.str,
                 committer_name: _builtins.str,
                 id: _builtins.str,
                 message: _builtins.str,
                 parent_ids: Sequence[_builtins.str],
                 short_id: _builtins.str,
                 title: _builtins.str):
        """
        :param _builtins.str author_email: The email of the author.
        :param _builtins.str author_name: The name of the author.
        :param _builtins.str authored_date: The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
        :param _builtins.str committed_date: The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
        :param _builtins.str committer_email: The email of the user that committed.
        :param _builtins.str committer_name: The name of the user that committed.
        :param _builtins.str id: The unique id assigned to the commit by Gitlab.
        :param _builtins.str message: The commit message
        :param Sequence[_builtins.str] parent_ids: The id of the parents of the commit
        :param _builtins.str short_id: The short id assigned to the commit by Gitlab.
        :param _builtins.str title: The title of the commit
        """
        pulumi.set(__self__, "author_email", author_email)
        pulumi.set(__self__, "author_name", author_name)
        pulumi.set(__self__, "authored_date", authored_date)
        pulumi.set(__self__, "committed_date", committed_date)
        pulumi.set(__self__, "committer_email", committer_email)
        pulumi.set(__self__, "committer_name", committer_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "parent_ids", parent_ids)
        pulumi.set(__self__, "short_id", short_id)
        pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter(name="authorEmail")
    def author_email(self) -> _builtins.str:
        """
        The email of the author.
        """
        return pulumi.get(self, "author_email")

    @_builtins.property
    @pulumi.getter(name="authorName")
    def author_name(self) -> _builtins.str:
        """
        The name of the author.
        """
        return pulumi.get(self, "author_name")

    @_builtins.property
    @pulumi.getter(name="authoredDate")
    def authored_date(self) -> _builtins.str:
        """
        The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
        """
        return pulumi.get(self, "authored_date")

    @_builtins.property
    @pulumi.getter(name="committedDate")
    def committed_date(self) -> _builtins.str:
        """
        The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
        """
        return pulumi.get(self, "committed_date")

    @_builtins.property
    @pulumi.getter(name="committerEmail")
    def committer_email(self) -> _builtins.str:
        """
        The email of the user that committed.
        """
        return pulumi.get(self, "committer_email")

    @_builtins.property
    @pulumi.getter(name="committerName")
    def committer_name(self) -> _builtins.str:
        """
        The name of the user that committed.
        """
        return pulumi.get(self, "committer_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The unique id assigned to the commit by Gitlab.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        The commit message
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="parentIds")
    def parent_ids(self) -> Sequence[_builtins.str]:
        """
        The id of the parents of the commit
        """
        return pulumi.get(self, "parent_ids")

    @_builtins.property
    @pulumi.getter(name="shortId")
    def short_id(self) -> _builtins.str:
        """
        The short id assigned to the commit by Gitlab.
        """
        return pulumi.get(self, "short_id")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The title of the commit
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetProjectContainerExpirationPolicyResult(dict):
    def __init__(__self__, *,
                 cadence: _builtins.str,
                 enabled: _builtins.bool,
                 keep_n: _builtins.int,
                 name_regex_delete: _builtins.str,
                 name_regex_keep: _builtins.str,
                 next_run_at: _builtins.str,
                 older_than: _builtins.str):
        """
        :param _builtins.str cadence: The cadence of the policy. Valid values are: `1d`, `7d`, `14d`, `1month`, `3month`.
        :param _builtins.bool enabled: If true, the policy is enabled.
        :param _builtins.int keep_n: The number of images to keep.
        :param _builtins.str name_regex_delete: The regular expression to match image names to delete.
        :param _builtins.str name_regex_keep: The regular expression to match image names to keep.
        :param _builtins.str next_run_at: The next time the policy will run.
        :param _builtins.str older_than: The number of days to keep images.
        """
        pulumi.set(__self__, "cadence", cadence)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "keep_n", keep_n)
        pulumi.set(__self__, "name_regex_delete", name_regex_delete)
        pulumi.set(__self__, "name_regex_keep", name_regex_keep)
        pulumi.set(__self__, "next_run_at", next_run_at)
        pulumi.set(__self__, "older_than", older_than)

    @_builtins.property
    @pulumi.getter
    def cadence(self) -> _builtins.str:
        """
        The cadence of the policy. Valid values are: `1d`, `7d`, `14d`, `1month`, `3month`.
        """
        return pulumi.get(self, "cadence")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        If true, the policy is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="keepN")
    def keep_n(self) -> _builtins.int:
        """
        The number of images to keep.
        """
        return pulumi.get(self, "keep_n")

    @_builtins.property
    @pulumi.getter(name="nameRegexDelete")
    def name_regex_delete(self) -> _builtins.str:
        """
        The regular expression to match image names to delete.
        """
        return pulumi.get(self, "name_regex_delete")

    @_builtins.property
    @pulumi.getter(name="nameRegexKeep")
    def name_regex_keep(self) -> _builtins.str:
        """
        The regular expression to match image names to keep.
        """
        return pulumi.get(self, "name_regex_keep")

    @_builtins.property
    @pulumi.getter(name="nextRunAt")
    def next_run_at(self) -> _builtins.str:
        """
        The next time the policy will run.
        """
        return pulumi.get(self, "next_run_at")

    @_builtins.property
    @pulumi.getter(name="olderThan")
    def older_than(self) -> _builtins.str:
        """
        The number of days to keep images.
        """
        return pulumi.get(self, "older_than")


@pulumi.output_type
class GetProjectEnvironmentsEnvironmentResult(dict):
    def __init__(__self__, *,
                 auto_stop_at: _builtins.str,
                 auto_stop_setting: _builtins.str,
                 cluster_agent_id: _builtins.int,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 external_url: _builtins.str,
                 flux_resource_path: _builtins.str,
                 id: _builtins.int,
                 kubernetes_namespace: _builtins.str,
                 name: _builtins.str,
                 slug: _builtins.str,
                 state: _builtins.str,
                 tier: _builtins.str,
                 updated_at: _builtins.str):
        """
        :param _builtins.str auto_stop_at: Timestamp of when the environment is scheduled to stop, RFC3339 format.
        :param _builtins.str auto_stop_setting: The auto stop setting for the environment.
        :param _builtins.int cluster_agent_id: The ID of the environments cluster agent or `null` if none is assigned.
        :param _builtins.str created_at: Timestamp of the environment creation, RFC3339 format.
        :param _builtins.str description: The description of the environment.
        :param _builtins.str external_url: Place to link to for this environment.
        :param _builtins.str flux_resource_path: The Flux resource path to associate with this environment.
        :param _builtins.int id: The ID of the environment.
        :param _builtins.str kubernetes_namespace: The Kubernetes namespace to associate with this environment.
        :param _builtins.str name: The name of the environment.
        :param _builtins.str slug: The simplified version of the environment name, suitable for inclusion in DNS, URLs, Kubernetes labels, and so on. The slug is truncated to 24 characters. A random suffix is automatically added to uppercase environment names.
        :param _builtins.str state: The state of the environment. Value can be one of `available`, `stopping`, `stopped`. Returns all environments if not set.
        :param _builtins.str tier: The tier of the environment. Value can be one of `production`, `staging`, `testing`, `development`, `other`. Returns all environments if not set.
        :param _builtins.str updated_at: Timestamp of the last environment update, RFC3339 format.
        """
        pulumi.set(__self__, "auto_stop_at", auto_stop_at)
        pulumi.set(__self__, "auto_stop_setting", auto_stop_setting)
        pulumi.set(__self__, "cluster_agent_id", cluster_agent_id)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "external_url", external_url)
        pulumi.set(__self__, "flux_resource_path", flux_resource_path)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "kubernetes_namespace", kubernetes_namespace)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "slug", slug)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "tier", tier)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="autoStopAt")
    def auto_stop_at(self) -> _builtins.str:
        """
        Timestamp of when the environment is scheduled to stop, RFC3339 format.
        """
        return pulumi.get(self, "auto_stop_at")

    @_builtins.property
    @pulumi.getter(name="autoStopSetting")
    def auto_stop_setting(self) -> _builtins.str:
        """
        The auto stop setting for the environment.
        """
        return pulumi.get(self, "auto_stop_setting")

    @_builtins.property
    @pulumi.getter(name="clusterAgentId")
    def cluster_agent_id(self) -> _builtins.int:
        """
        The ID of the environments cluster agent or `null` if none is assigned.
        """
        return pulumi.get(self, "cluster_agent_id")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Timestamp of the environment creation, RFC3339 format.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the environment.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="externalUrl")
    def external_url(self) -> _builtins.str:
        """
        Place to link to for this environment.
        """
        return pulumi.get(self, "external_url")

    @_builtins.property
    @pulumi.getter(name="fluxResourcePath")
    def flux_resource_path(self) -> _builtins.str:
        """
        The Flux resource path to associate with this environment.
        """
        return pulumi.get(self, "flux_resource_path")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The ID of the environment.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="kubernetesNamespace")
    def kubernetes_namespace(self) -> _builtins.str:
        """
        The Kubernetes namespace to associate with this environment.
        """
        return pulumi.get(self, "kubernetes_namespace")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the environment.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def slug(self) -> _builtins.str:
        """
        The simplified version of the environment name, suitable for inclusion in DNS, URLs, Kubernetes labels, and so on. The slug is truncated to 24 characters. A random suffix is automatically added to uppercase environment names.
        """
        return pulumi.get(self, "slug")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of the environment. Value can be one of `available`, `stopping`, `stopped`. Returns all environments if not set.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def tier(self) -> _builtins.str:
        """
        The tier of the environment. Value can be one of `production`, `staging`, `testing`, `development`, `other`. Returns all environments if not set.
        """
        return pulumi.get(self, "tier")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp of the last environment update, RFC3339 format.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetProjectHooksHookResult(dict):
    def __init__(__self__, *,
                 confidential_issues_events: _builtins.bool,
                 confidential_note_events: _builtins.bool,
                 custom_webhook_template: _builtins.str,
                 deployment_events: _builtins.bool,
                 enable_ssl_verification: _builtins.bool,
                 hook_id: _builtins.int,
                 issues_events: _builtins.bool,
                 job_events: _builtins.bool,
                 merge_requests_events: _builtins.bool,
                 note_events: _builtins.bool,
                 pipeline_events: _builtins.bool,
                 project: _builtins.str,
                 project_id: _builtins.int,
                 push_events: _builtins.bool,
                 push_events_branch_filter: _builtins.str,
                 releases_events: _builtins.bool,
                 tag_push_events: _builtins.bool,
                 token: _builtins.str,
                 url: _builtins.str,
                 wiki_page_events: _builtins.bool):
        """
        :param _builtins.bool confidential_issues_events: Invoke the hook for confidential issues events.
        :param _builtins.bool confidential_note_events: Invoke the hook for confidential notes events.
        :param _builtins.str custom_webhook_template: Set a custom webhook template.
        :param _builtins.bool deployment_events: Invoke the hook for deployment events.
        :param _builtins.bool enable_ssl_verification: Enable ssl verification when invoking the hook.
        :param _builtins.int hook_id: The id of the project hook.
        :param _builtins.bool issues_events: Invoke the hook for issues events.
        :param _builtins.bool job_events: Invoke the hook for job events.
        :param _builtins.bool merge_requests_events: Invoke the hook for merge requests.
        :param _builtins.bool note_events: Invoke the hook for notes events.
        :param _builtins.bool pipeline_events: Invoke the hook for pipeline events.
        :param _builtins.str project: The name or id of the project to add the hook to.
        :param _builtins.int project_id: The id of the project for the hook.
        :param _builtins.bool push_events: Invoke the hook for push events.
        :param _builtins.str push_events_branch_filter: Invoke the hook for push events on matching branches only.
        :param _builtins.bool releases_events: Invoke the hook for releases events.
        :param _builtins.bool tag_push_events: Invoke the hook for tag push events.
        :param _builtins.str token: A token to present when invoking the hook. The token is only available on resource creation, not in this datasource. It will always be blank. Will be removed in 19.0.
        :param _builtins.str url: The url of the hook to invoke.
        :param _builtins.bool wiki_page_events: Invoke the hook for wiki page events.
        """
        pulumi.set(__self__, "confidential_issues_events", confidential_issues_events)
        pulumi.set(__self__, "confidential_note_events", confidential_note_events)
        pulumi.set(__self__, "custom_webhook_template", custom_webhook_template)
        pulumi.set(__self__, "deployment_events", deployment_events)
        pulumi.set(__self__, "enable_ssl_verification", enable_ssl_verification)
        pulumi.set(__self__, "hook_id", hook_id)
        pulumi.set(__self__, "issues_events", issues_events)
        pulumi.set(__self__, "job_events", job_events)
        pulumi.set(__self__, "merge_requests_events", merge_requests_events)
        pulumi.set(__self__, "note_events", note_events)
        pulumi.set(__self__, "pipeline_events", pipeline_events)
        pulumi.set(__self__, "project", project)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "push_events", push_events)
        pulumi.set(__self__, "push_events_branch_filter", push_events_branch_filter)
        pulumi.set(__self__, "releases_events", releases_events)
        pulumi.set(__self__, "tag_push_events", tag_push_events)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "wiki_page_events", wiki_page_events)

    @_builtins.property
    @pulumi.getter(name="confidentialIssuesEvents")
    def confidential_issues_events(self) -> _builtins.bool:
        """
        Invoke the hook for confidential issues events.
        """
        return pulumi.get(self, "confidential_issues_events")

    @_builtins.property
    @pulumi.getter(name="confidentialNoteEvents")
    def confidential_note_events(self) -> _builtins.bool:
        """
        Invoke the hook for confidential notes events.
        """
        return pulumi.get(self, "confidential_note_events")

    @_builtins.property
    @pulumi.getter(name="customWebhookTemplate")
    def custom_webhook_template(self) -> _builtins.str:
        """
        Set a custom webhook template.
        """
        return pulumi.get(self, "custom_webhook_template")

    @_builtins.property
    @pulumi.getter(name="deploymentEvents")
    def deployment_events(self) -> _builtins.bool:
        """
        Invoke the hook for deployment events.
        """
        return pulumi.get(self, "deployment_events")

    @_builtins.property
    @pulumi.getter(name="enableSslVerification")
    def enable_ssl_verification(self) -> _builtins.bool:
        """
        Enable ssl verification when invoking the hook.
        """
        return pulumi.get(self, "enable_ssl_verification")

    @_builtins.property
    @pulumi.getter(name="hookId")
    def hook_id(self) -> _builtins.int:
        """
        The id of the project hook.
        """
        return pulumi.get(self, "hook_id")

    @_builtins.property
    @pulumi.getter(name="issuesEvents")
    def issues_events(self) -> _builtins.bool:
        """
        Invoke the hook for issues events.
        """
        return pulumi.get(self, "issues_events")

    @_builtins.property
    @pulumi.getter(name="jobEvents")
    def job_events(self) -> _builtins.bool:
        """
        Invoke the hook for job events.
        """
        return pulumi.get(self, "job_events")

    @_builtins.property
    @pulumi.getter(name="mergeRequestsEvents")
    def merge_requests_events(self) -> _builtins.bool:
        """
        Invoke the hook for merge requests.
        """
        return pulumi.get(self, "merge_requests_events")

    @_builtins.property
    @pulumi.getter(name="noteEvents")
    def note_events(self) -> _builtins.bool:
        """
        Invoke the hook for notes events.
        """
        return pulumi.get(self, "note_events")

    @_builtins.property
    @pulumi.getter(name="pipelineEvents")
    def pipeline_events(self) -> _builtins.bool:
        """
        Invoke the hook for pipeline events.
        """
        return pulumi.get(self, "pipeline_events")

    @_builtins.property
    @pulumi.getter
    def project(self) -> _builtins.str:
        """
        The name or id of the project to add the hook to.
        """
        return pulumi.get(self, "project")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.int:
        """
        The id of the project for the hook.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="pushEvents")
    def push_events(self) -> _builtins.bool:
        """
        Invoke the hook for push events.
        """
        return pulumi.get(self, "push_events")

    @_builtins.property
    @pulumi.getter(name="pushEventsBranchFilter")
    def push_events_branch_filter(self) -> _builtins.str:
        """
        Invoke the hook for push events on matching branches only.
        """
        return pulumi.get(self, "push_events_branch_filter")

    @_builtins.property
    @pulumi.getter(name="releasesEvents")
    def releases_events(self) -> _builtins.bool:
        """
        Invoke the hook for releases events.
        """
        return pulumi.get(self, "releases_events")

    @_builtins.property
    @pulumi.getter(name="tagPushEvents")
    def tag_push_events(self) -> _builtins.bool:
        """
        Invoke the hook for tag push events.
        """
        return pulumi.get(self, "tag_push_events")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""The token is only available on resource creation, not in this datasource. It will always be blank.""")
    def token(self) -> _builtins.str:
        """
        A token to present when invoking the hook. The token is only available on resource creation, not in this datasource. It will always be blank. Will be removed in 19.0.
        """
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The url of the hook to invoke.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="wikiPageEvents")
    def wiki_page_events(self) -> _builtins.bool:
        """
        Invoke the hook for wiki page events.
        """
        return pulumi.get(self, "wiki_page_events")


@pulumi.output_type
class GetProjectIssueLabelEventsEventResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 created_at: _builtins.str,
                 id: _builtins.int,
                 label: 'outputs.GetProjectIssueLabelEventsEventLabelResult',
                 resource_id: _builtins.int,
                 resource_type: _builtins.str,
                 user: 'outputs.GetProjectIssueLabelEventsEventUserResult'):
        """
        :param _builtins.str action: The action performed on the label (add, remove).
        :param _builtins.str created_at: The date and time when the label event was created.
        :param _builtins.int id: The ID of the label event.
        :param 'GetProjectIssueLabelEventsEventLabelArgs' label: The label that was added or removed.
        :param _builtins.int resource_id: The ID of the resource associated with the label event.
        :param _builtins.str resource_type: The type of the resource associated with the label event.
        :param 'GetProjectIssueLabelEventsEventUserArgs' user: The user who performed the action.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        The action performed on the label (add, remove).
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The date and time when the label event was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The ID of the label event.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def label(self) -> 'outputs.GetProjectIssueLabelEventsEventLabelResult':
        """
        The label that was added or removed.
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.int:
        """
        The ID of the resource associated with the label event.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        The type of the resource associated with the label event.
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter
    def user(self) -> 'outputs.GetProjectIssueLabelEventsEventUserResult':
        """
        The user who performed the action.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetProjectIssueLabelEventsEventLabelResult(dict):
    def __init__(__self__, *,
                 color: _builtins.str,
                 description: _builtins.str,
                 id: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.str color: The color of the label.
        :param _builtins.str description: The description of the label.
        :param _builtins.int id: The ID of the label.
        :param _builtins.str name: The name of the label.
        """
        pulumi.set(__self__, "color", color)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def color(self) -> _builtins.str:
        """
        The color of the label.
        """
        return pulumi.get(self, "color")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the label.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The ID of the label.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the label.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetProjectIssueLabelEventsEventUserResult(dict):
    def __init__(__self__, *,
                 avatar_url: _builtins.str,
                 id: _builtins.int,
                 name: _builtins.str,
                 state: _builtins.str,
                 username: _builtins.str,
                 web_url: _builtins.str):
        """
        :param _builtins.str avatar_url: The avatar URL of the user.
        :param _builtins.int id: The ID of the user.
        :param _builtins.str name: The name of the user.
        :param _builtins.str state: The state of the user.
        :param _builtins.str username: The username of the user.
        :param _builtins.str web_url: The web URL of the user.
        """
        pulumi.set(__self__, "avatar_url", avatar_url)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "web_url", web_url)

    @_builtins.property
    @pulumi.getter(name="avatarUrl")
    def avatar_url(self) -> _builtins.str:
        """
        The avatar URL of the user.
        """
        return pulumi.get(self, "avatar_url")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The ID of the user.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of the user.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The username of the user.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> _builtins.str:
        """
        The web URL of the user.
        """
        return pulumi.get(self, "web_url")


@pulumi.output_type
class GetProjectIssueTaskCompletionStatusResult(dict):
    def __init__(__self__, *,
                 completed_count: _builtins.int,
                 count: _builtins.int):
        """
        :param _builtins.int completed_count: The number of tasks that are completed.
        :param _builtins.int count: The number of tasks.
        """
        pulumi.set(__self__, "completed_count", completed_count)
        pulumi.set(__self__, "count", count)

    @_builtins.property
    @pulumi.getter(name="completedCount")
    def completed_count(self) -> _builtins.int:
        """
        The number of tasks that are completed.
        """
        return pulumi.get(self, "completed_count")

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        The number of tasks.
        """
        return pulumi.get(self, "count")


@pulumi.output_type
class GetProjectIssuesIssueResult(dict):
    def __init__(__self__, *,
                 assignee_ids: Sequence[_builtins.int],
                 author_id: _builtins.int,
                 closed_at: _builtins.str,
                 closed_by_user_id: _builtins.int,
                 confidential: _builtins.bool,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 discussion_locked: _builtins.bool,
                 discussion_to_resolve: _builtins.str,
                 downvotes: _builtins.int,
                 due_date: _builtins.str,
                 epic_id: _builtins.int,
                 epic_issue_id: _builtins.int,
                 external_id: _builtins.str,
                 human_time_estimate: _builtins.str,
                 human_total_time_spent: _builtins.str,
                 iid: _builtins.int,
                 issue_id: _builtins.int,
                 issue_link_id: _builtins.int,
                 issue_type: _builtins.str,
                 labels: Sequence[_builtins.str],
                 links: Mapping[str, _builtins.str],
                 merge_request_to_resolve_discussions_of: _builtins.int,
                 merge_requests_count: _builtins.int,
                 milestone_id: _builtins.int,
                 moved_to_id: _builtins.int,
                 project: _builtins.str,
                 references: Mapping[str, _builtins.str],
                 state: _builtins.str,
                 subscribed: _builtins.bool,
                 task_completion_statuses: Sequence['outputs.GetProjectIssuesIssueTaskCompletionStatusResult'],
                 time_estimate: _builtins.int,
                 title: _builtins.str,
                 total_time_spent: _builtins.int,
                 updated_at: _builtins.str,
                 upvotes: _builtins.int,
                 user_notes_count: _builtins.int,
                 web_url: _builtins.str,
                 weight: _builtins.int):
        """
        :param Sequence[_builtins.int] assignee_ids: The IDs of the users to assign the issue to.
        :param _builtins.int author_id: The ID of the author of the issue. Use `User` data source to get more information about the user.
        :param _builtins.str closed_at: When the issue was closed. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.
        :param _builtins.int closed_by_user_id: The ID of the user that closed the issue. Use `User` data source to get more information about the user.
        :param _builtins.bool confidential: Set an issue to be confidential.
        :param _builtins.str created_at: When the issue was created. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z. Requires administrator or project/group owner rights.
        :param _builtins.str description: The description of an issue. Limited to 1,048,576 characters.
        :param _builtins.bool discussion_locked: Whether the issue is locked for discussions or not.
        :param _builtins.str discussion_to_resolve: The ID of a discussion to resolve. This fills out the issue with a default description and mark the discussion as resolved. Use in combination with merge_request_to_resolve_discussions_of.
        :param _builtins.int downvotes: The number of downvotes the issue has received.
        :param _builtins.str due_date: The due date. Date time string in the format YYYY-MM-DD, for example 2016-03-11.
        :param _builtins.int epic_id: ID of the epic to add the issue to. Valid values are greater than or equal to 0.
        :param _builtins.int epic_issue_id: The ID of the epic issue.
        :param _builtins.str external_id: The external ID of the issue.
        :param _builtins.str human_time_estimate: The human-readable time estimate of the issue.
        :param _builtins.str human_total_time_spent: The human-readable total time spent of the issue.
        :param _builtins.int iid: The internal ID of the project's issue.
        :param _builtins.int issue_id: The instance-wide ID of the issue.
        :param _builtins.int issue_link_id: The ID of the issue link.
        :param _builtins.str issue_type: The type of issue. Valid values are: `issue`, `incident`, `test_case`.
        :param Sequence[_builtins.str] labels: The labels of an issue.
        :param Mapping[str, _builtins.str] links: The links of the issue.
        :param _builtins.int merge_request_to_resolve_discussions_of: The IID of a merge request in which to resolve all issues. This fills out the issue with a default description and mark all discussions as resolved. When passing a description or title, these values take precedence over the default values.
        :param _builtins.int merge_requests_count: The number of merge requests associated with the issue.
        :param _builtins.int milestone_id: The global ID of a milestone to assign issue. To find the milestone_id associated with a milestone, view an issue with the milestone assigned and use the API to retrieve the issue's details.
        :param _builtins.int moved_to_id: The ID of the issue that was moved to.
        :param _builtins.str project: The name or ID of the project.
        :param Mapping[str, _builtins.str] references: The references of the issue.
        :param _builtins.str state: The state of the issue. Valid values are: `opened`, `closed`.
        :param _builtins.bool subscribed: Whether the authenticated user is subscribed to the issue or not.
        :param Sequence['GetProjectIssuesIssueTaskCompletionStatusArgs'] task_completion_statuses: The task completion status. It's always a one element list.
        :param _builtins.int time_estimate: The time estimate of the issue.
        :param _builtins.str title: The title of the issue.
        :param _builtins.int total_time_spent: The total time spent of the issue.
        :param _builtins.str updated_at: When the issue was updated. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.
        :param _builtins.int upvotes: The number of upvotes the issue has received.
        :param _builtins.int user_notes_count: The number of user notes on the issue.
        :param _builtins.str web_url: The web URL of the issue.
        :param _builtins.int weight: The weight of the issue. Valid values are greater than or equal to 0.
        """
        pulumi.set(__self__, "assignee_ids", assignee_ids)
        pulumi.set(__self__, "author_id", author_id)
        pulumi.set(__self__, "closed_at", closed_at)
        pulumi.set(__self__, "closed_by_user_id", closed_by_user_id)
        pulumi.set(__self__, "confidential", confidential)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "discussion_locked", discussion_locked)
        pulumi.set(__self__, "discussion_to_resolve", discussion_to_resolve)
        pulumi.set(__self__, "downvotes", downvotes)
        pulumi.set(__self__, "due_date", due_date)
        pulumi.set(__self__, "epic_id", epic_id)
        pulumi.set(__self__, "epic_issue_id", epic_issue_id)
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "human_time_estimate", human_time_estimate)
        pulumi.set(__self__, "human_total_time_spent", human_total_time_spent)
        pulumi.set(__self__, "iid", iid)
        pulumi.set(__self__, "issue_id", issue_id)
        pulumi.set(__self__, "issue_link_id", issue_link_id)
        pulumi.set(__self__, "issue_type", issue_type)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "links", links)
        pulumi.set(__self__, "merge_request_to_resolve_discussions_of", merge_request_to_resolve_discussions_of)
        pulumi.set(__self__, "merge_requests_count", merge_requests_count)
        pulumi.set(__self__, "milestone_id", milestone_id)
        pulumi.set(__self__, "moved_to_id", moved_to_id)
        pulumi.set(__self__, "project", project)
        pulumi.set(__self__, "references", references)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "subscribed", subscribed)
        pulumi.set(__self__, "task_completion_statuses", task_completion_statuses)
        pulumi.set(__self__, "time_estimate", time_estimate)
        pulumi.set(__self__, "title", title)
        pulumi.set(__self__, "total_time_spent", total_time_spent)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "upvotes", upvotes)
        pulumi.set(__self__, "user_notes_count", user_notes_count)
        pulumi.set(__self__, "web_url", web_url)
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="assigneeIds")
    def assignee_ids(self) -> Sequence[_builtins.int]:
        """
        The IDs of the users to assign the issue to.
        """
        return pulumi.get(self, "assignee_ids")

    @_builtins.property
    @pulumi.getter(name="authorId")
    def author_id(self) -> _builtins.int:
        """
        The ID of the author of the issue. Use `User` data source to get more information about the user.
        """
        return pulumi.get(self, "author_id")

    @_builtins.property
    @pulumi.getter(name="closedAt")
    def closed_at(self) -> _builtins.str:
        """
        When the issue was closed. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.
        """
        return pulumi.get(self, "closed_at")

    @_builtins.property
    @pulumi.getter(name="closedByUserId")
    def closed_by_user_id(self) -> _builtins.int:
        """
        The ID of the user that closed the issue. Use `User` data source to get more information about the user.
        """
        return pulumi.get(self, "closed_by_user_id")

    @_builtins.property
    @pulumi.getter
    def confidential(self) -> _builtins.bool:
        """
        Set an issue to be confidential.
        """
        return pulumi.get(self, "confidential")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        When the issue was created. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z. Requires administrator or project/group owner rights.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of an issue. Limited to 1,048,576 characters.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="discussionLocked")
    def discussion_locked(self) -> _builtins.bool:
        """
        Whether the issue is locked for discussions or not.
        """
        return pulumi.get(self, "discussion_locked")

    @_builtins.property
    @pulumi.getter(name="discussionToResolve")
    def discussion_to_resolve(self) -> _builtins.str:
        """
        The ID of a discussion to resolve. This fills out the issue with a default description and mark the discussion as resolved. Use in combination with merge_request_to_resolve_discussions_of.
        """
        return pulumi.get(self, "discussion_to_resolve")

    @_builtins.property
    @pulumi.getter
    def downvotes(self) -> _builtins.int:
        """
        The number of downvotes the issue has received.
        """
        return pulumi.get(self, "downvotes")

    @_builtins.property
    @pulumi.getter(name="dueDate")
    def due_date(self) -> _builtins.str:
        """
        The due date. Date time string in the format YYYY-MM-DD, for example 2016-03-11.
        """
        return pulumi.get(self, "due_date")

    @_builtins.property
    @pulumi.getter(name="epicId")
    def epic_id(self) -> _builtins.int:
        """
        ID of the epic to add the issue to. Valid values are greater than or equal to 0.
        """
        return pulumi.get(self, "epic_id")

    @_builtins.property
    @pulumi.getter(name="epicIssueId")
    def epic_issue_id(self) -> _builtins.int:
        """
        The ID of the epic issue.
        """
        return pulumi.get(self, "epic_issue_id")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> _builtins.str:
        """
        The external ID of the issue.
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="humanTimeEstimate")
    def human_time_estimate(self) -> _builtins.str:
        """
        The human-readable time estimate of the issue.
        """
        return pulumi.get(self, "human_time_estimate")

    @_builtins.property
    @pulumi.getter(name="humanTotalTimeSpent")
    def human_total_time_spent(self) -> _builtins.str:
        """
        The human-readable total time spent of the issue.
        """
        return pulumi.get(self, "human_total_time_spent")

    @_builtins.property
    @pulumi.getter
    def iid(self) -> _builtins.int:
        """
        The internal ID of the project's issue.
        """
        return pulumi.get(self, "iid")

    @_builtins.property
    @pulumi.getter(name="issueId")
    def issue_id(self) -> _builtins.int:
        """
        The instance-wide ID of the issue.
        """
        return pulumi.get(self, "issue_id")

    @_builtins.property
    @pulumi.getter(name="issueLinkId")
    def issue_link_id(self) -> _builtins.int:
        """
        The ID of the issue link.
        """
        return pulumi.get(self, "issue_link_id")

    @_builtins.property
    @pulumi.getter(name="issueType")
    def issue_type(self) -> _builtins.str:
        """
        The type of issue. Valid values are: `issue`, `incident`, `test_case`.
        """
        return pulumi.get(self, "issue_type")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Sequence[_builtins.str]:
        """
        The labels of an issue.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def links(self) -> Mapping[str, _builtins.str]:
        """
        The links of the issue.
        """
        return pulumi.get(self, "links")

    @_builtins.property
    @pulumi.getter(name="mergeRequestToResolveDiscussionsOf")
    def merge_request_to_resolve_discussions_of(self) -> _builtins.int:
        """
        The IID of a merge request in which to resolve all issues. This fills out the issue with a default description and mark all discussions as resolved. When passing a description or title, these values take precedence over the default values.
        """
        return pulumi.get(self, "merge_request_to_resolve_discussions_of")

    @_builtins.property
    @pulumi.getter(name="mergeRequestsCount")
    def merge_requests_count(self) -> _builtins.int:
        """
        The number of merge requests associated with the issue.
        """
        return pulumi.get(self, "merge_requests_count")

    @_builtins.property
    @pulumi.getter(name="milestoneId")
    def milestone_id(self) -> _builtins.int:
        """
        The global ID of a milestone to assign issue. To find the milestone_id associated with a milestone, view an issue with the milestone assigned and use the API to retrieve the issue's details.
        """
        return pulumi.get(self, "milestone_id")

    @_builtins.property
    @pulumi.getter(name="movedToId")
    def moved_to_id(self) -> _builtins.int:
        """
        The ID of the issue that was moved to.
        """
        return pulumi.get(self, "moved_to_id")

    @_builtins.property
    @pulumi.getter
    def project(self) -> _builtins.str:
        """
        The name or ID of the project.
        """
        return pulumi.get(self, "project")

    @_builtins.property
    @pulumi.getter
    def references(self) -> Mapping[str, _builtins.str]:
        """
        The references of the issue.
        """
        return pulumi.get(self, "references")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of the issue. Valid values are: `opened`, `closed`.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def subscribed(self) -> _builtins.bool:
        """
        Whether the authenticated user is subscribed to the issue or not.
        """
        return pulumi.get(self, "subscribed")

    @_builtins.property
    @pulumi.getter(name="taskCompletionStatuses")
    def task_completion_statuses(self) -> Sequence['outputs.GetProjectIssuesIssueTaskCompletionStatusResult']:
        """
        The task completion status. It's always a one element list.
        """
        return pulumi.get(self, "task_completion_statuses")

    @_builtins.property
    @pulumi.getter(name="timeEstimate")
    def time_estimate(self) -> _builtins.int:
        """
        The time estimate of the issue.
        """
        return pulumi.get(self, "time_estimate")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The title of the issue.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter(name="totalTimeSpent")
    def total_time_spent(self) -> _builtins.int:
        """
        The total time spent of the issue.
        """
        return pulumi.get(self, "total_time_spent")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        When the issue was updated. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def upvotes(self) -> _builtins.int:
        """
        The number of upvotes the issue has received.
        """
        return pulumi.get(self, "upvotes")

    @_builtins.property
    @pulumi.getter(name="userNotesCount")
    def user_notes_count(self) -> _builtins.int:
        """
        The number of user notes on the issue.
        """
        return pulumi.get(self, "user_notes_count")

    @_builtins.property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> _builtins.str:
        """
        The web URL of the issue.
        """
        return pulumi.get(self, "web_url")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> _builtins.int:
        """
        The weight of the issue. Valid values are greater than or equal to 0.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetProjectIssuesIssueTaskCompletionStatusResult(dict):
    def __init__(__self__, *,
                 completed_count: _builtins.int,
                 count: _builtins.int):
        """
        :param _builtins.int completed_count: The number of tasks that are completed.
        :param _builtins.int count: The number of tasks.
        """
        pulumi.set(__self__, "completed_count", completed_count)
        pulumi.set(__self__, "count", count)

    @_builtins.property
    @pulumi.getter(name="completedCount")
    def completed_count(self) -> _builtins.int:
        """
        The number of tasks that are completed.
        """
        return pulumi.get(self, "completed_count")

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        The number of tasks.
        """
        return pulumi.get(self, "count")


@pulumi.output_type
class GetProjectMembershipMemberResult(dict):
    def __init__(__self__, *,
                 access_level: _builtins.str,
                 avatar_url: _builtins.str,
                 expires_at: _builtins.str,
                 id: _builtins.int,
                 name: _builtins.str,
                 state: _builtins.str,
                 username: _builtins.str,
                 web_url: _builtins.str):
        """
        :param _builtins.str access_level: The level of access to the group.
        :param _builtins.str avatar_url: The avatar URL of the user.
        :param _builtins.str expires_at: Expiration date for the group membership.
        :param _builtins.int id: The unique id assigned to the user by the gitlab server.
        :param _builtins.str name: The name of the user.
        :param _builtins.str state: Whether the user is active or blocked.
        :param _builtins.str username: The username of the user.
        :param _builtins.str web_url: User's website URL.
        """
        pulumi.set(__self__, "access_level", access_level)
        pulumi.set(__self__, "avatar_url", avatar_url)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "web_url", web_url)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> _builtins.str:
        """
        The level of access to the group.
        """
        return pulumi.get(self, "access_level")

    @_builtins.property
    @pulumi.getter(name="avatarUrl")
    def avatar_url(self) -> _builtins.str:
        """
        The avatar URL of the user.
        """
        return pulumi.get(self, "avatar_url")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> _builtins.str:
        """
        Expiration date for the group membership.
        """
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The unique id assigned to the user by the gitlab server.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        Whether the user is active or blocked.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The username of the user.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> _builtins.str:
        """
        User's website URL.
        """
        return pulumi.get(self, "web_url")


@pulumi.output_type
class GetProjectMergeRequestAssigneeResult(dict):
    def __init__(__self__, *,
                 avatar_url: _builtins.str,
                 id: _builtins.int,
                 name: _builtins.str,
                 state: _builtins.str,
                 username: _builtins.str,
                 web_url: _builtins.str):
        """
        :param _builtins.str avatar_url: A link to the user's avatar image.
        :param _builtins.int id: The internal ID number of the user.
        :param _builtins.str name: The name of the user.
        :param _builtins.str state: The state of the user account.
        :param _builtins.str username: The username of the user.
        :param _builtins.str web_url: A link to the user's profile page.
        """
        pulumi.set(__self__, "avatar_url", avatar_url)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "web_url", web_url)

    @_builtins.property
    @pulumi.getter(name="avatarUrl")
    def avatar_url(self) -> _builtins.str:
        """
        A link to the user's avatar image.
        """
        return pulumi.get(self, "avatar_url")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The internal ID number of the user.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of the user account.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The username of the user.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> _builtins.str:
        """
        A link to the user's profile page.
        """
        return pulumi.get(self, "web_url")


@pulumi.output_type
class GetProjectMergeRequestAuthorResult(dict):
    def __init__(__self__, *,
                 avatar_url: _builtins.str,
                 id: _builtins.int,
                 name: _builtins.str,
                 state: _builtins.str,
                 username: _builtins.str,
                 web_url: _builtins.str):
        """
        :param _builtins.str avatar_url: A link to the user's avatar image.
        :param _builtins.int id: The internal ID number of the user.
        :param _builtins.str name: The name of the user.
        :param _builtins.str state: The state of the user account.
        :param _builtins.str username: The username of the user.
        :param _builtins.str web_url: A link to the user's profile page.
        """
        pulumi.set(__self__, "avatar_url", avatar_url)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "web_url", web_url)

    @_builtins.property
    @pulumi.getter(name="avatarUrl")
    def avatar_url(self) -> _builtins.str:
        """
        A link to the user's avatar image.
        """
        return pulumi.get(self, "avatar_url")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The internal ID number of the user.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of the user account.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The username of the user.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> _builtins.str:
        """
        A link to the user's profile page.
        """
        return pulumi.get(self, "web_url")


@pulumi.output_type
class GetProjectMergeRequestClosedByResult(dict):
    def __init__(__self__, *,
                 avatar_url: _builtins.str,
                 id: _builtins.int,
                 name: _builtins.str,
                 state: _builtins.str,
                 username: _builtins.str,
                 web_url: _builtins.str):
        """
        :param _builtins.str avatar_url: A link to the user's avatar image.
        :param _builtins.int id: The internal ID number of the user.
        :param _builtins.str name: The name of the user.
        :param _builtins.str state: The state of the user account.
        :param _builtins.str username: The username of the user.
        :param _builtins.str web_url: A link to the user's profile page.
        """
        pulumi.set(__self__, "avatar_url", avatar_url)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "web_url", web_url)

    @_builtins.property
    @pulumi.getter(name="avatarUrl")
    def avatar_url(self) -> _builtins.str:
        """
        A link to the user's avatar image.
        """
        return pulumi.get(self, "avatar_url")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The internal ID number of the user.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of the user account.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The username of the user.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> _builtins.str:
        """
        A link to the user's profile page.
        """
        return pulumi.get(self, "web_url")


@pulumi.output_type
class GetProjectMergeRequestsMergeRequestResult(dict):
    def __init__(__self__, *,
                 assignee: 'outputs.GetProjectMergeRequestsMergeRequestAssigneeResult',
                 assignees: Sequence['outputs.GetProjectMergeRequestsMergeRequestAssigneeResult'],
                 author: 'outputs.GetProjectMergeRequestsMergeRequestAuthorResult',
                 blocking_discussions_resolved: _builtins.bool,
                 closed_at: _builtins.str,
                 closed_by: 'outputs.GetProjectMergeRequestsMergeRequestClosedByResult',
                 created_at: _builtins.str,
                 id: _builtins.int,
                 iid: _builtins.int):
        """
        :param 'GetProjectMergeRequestsMergeRequestAssigneeArgs' assignee: First assignee of the merge request.
        :param Sequence['GetProjectMergeRequestsMergeRequestAssigneeArgs'] assignees: Assignees of the merge request.
        :param 'GetProjectMergeRequestsMergeRequestAuthorArgs' author: User who created this merge request.
        :param _builtins.bool blocking_discussions_resolved: Indicates if all discussions are resolved only if all are
               required before merge request can be merged.
        :param _builtins.str closed_at: Timestamp of when the merge request was closed.
        :param 'GetProjectMergeRequestsMergeRequestClosedByArgs' closed_by: User who closed this merge request.
        :param _builtins.str created_at: Timestamp of when the merge request was created.
        :param _builtins.int id: The unique instance level ID of the merge request.
        :param _builtins.int iid: The unique project level ID of the merge request.
        """
        pulumi.set(__self__, "assignee", assignee)
        pulumi.set(__self__, "assignees", assignees)
        pulumi.set(__self__, "author", author)
        pulumi.set(__self__, "blocking_discussions_resolved", blocking_discussions_resolved)
        pulumi.set(__self__, "closed_at", closed_at)
        pulumi.set(__self__, "closed_by", closed_by)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "iid", iid)

    @_builtins.property
    @pulumi.getter
    def assignee(self) -> 'outputs.GetProjectMergeRequestsMergeRequestAssigneeResult':
        """
        First assignee of the merge request.
        """
        return pulumi.get(self, "assignee")

    @_builtins.property
    @pulumi.getter
    def assignees(self) -> Sequence['outputs.GetProjectMergeRequestsMergeRequestAssigneeResult']:
        """
        Assignees of the merge request.
        """
        return pulumi.get(self, "assignees")

    @_builtins.property
    @pulumi.getter
    def author(self) -> 'outputs.GetProjectMergeRequestsMergeRequestAuthorResult':
        """
        User who created this merge request.
        """
        return pulumi.get(self, "author")

    @_builtins.property
    @pulumi.getter(name="blockingDiscussionsResolved")
    def blocking_discussions_resolved(self) -> _builtins.bool:
        """
        Indicates if all discussions are resolved only if all are
        required before merge request can be merged.
        """
        return pulumi.get(self, "blocking_discussions_resolved")

    @_builtins.property
    @pulumi.getter(name="closedAt")
    def closed_at(self) -> _builtins.str:
        """
        Timestamp of when the merge request was closed.
        """
        return pulumi.get(self, "closed_at")

    @_builtins.property
    @pulumi.getter(name="closedBy")
    def closed_by(self) -> 'outputs.GetProjectMergeRequestsMergeRequestClosedByResult':
        """
        User who closed this merge request.
        """
        return pulumi.get(self, "closed_by")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Timestamp of when the merge request was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The unique instance level ID of the merge request.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def iid(self) -> _builtins.int:
        """
        The unique project level ID of the merge request.
        """
        return pulumi.get(self, "iid")


@pulumi.output_type
class GetProjectMergeRequestsMergeRequestAssigneeResult(dict):
    def __init__(__self__, *,
                 avatar_url: _builtins.str,
                 id: _builtins.int,
                 name: _builtins.str,
                 state: _builtins.str,
                 username: _builtins.str,
                 web_url: _builtins.str):
        """
        :param _builtins.str avatar_url: A link to the user's avatar image.
        :param _builtins.int id: The internal ID number of the user.
        :param _builtins.str name: The name of the user.
        :param _builtins.str state: The state of the user account.
        :param _builtins.str username: The username of the user.
        :param _builtins.str web_url: A link to the user's profile page.
        """
        pulumi.set(__self__, "avatar_url", avatar_url)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "web_url", web_url)

    @_builtins.property
    @pulumi.getter(name="avatarUrl")
    def avatar_url(self) -> _builtins.str:
        """
        A link to the user's avatar image.
        """
        return pulumi.get(self, "avatar_url")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The internal ID number of the user.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of the user account.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The username of the user.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> _builtins.str:
        """
        A link to the user's profile page.
        """
        return pulumi.get(self, "web_url")


@pulumi.output_type
class GetProjectMergeRequestsMergeRequestAuthorResult(dict):
    def __init__(__self__, *,
                 avatar_url: _builtins.str,
                 id: _builtins.int,
                 name: _builtins.str,
                 state: _builtins.str,
                 username: _builtins.str,
                 web_url: _builtins.str):
        """
        :param _builtins.str avatar_url: A link to the user's avatar image.
        :param _builtins.int id: The internal ID number of the user.
        :param _builtins.str name: The name of the user.
        :param _builtins.str state: The state of the user account.
        :param _builtins.str username: The username of the user.
        :param _builtins.str web_url: A link to the user's profile page.
        """
        pulumi.set(__self__, "avatar_url", avatar_url)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "web_url", web_url)

    @_builtins.property
    @pulumi.getter(name="avatarUrl")
    def avatar_url(self) -> _builtins.str:
        """
        A link to the user's avatar image.
        """
        return pulumi.get(self, "avatar_url")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The internal ID number of the user.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of the user account.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The username of the user.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> _builtins.str:
        """
        A link to the user's profile page.
        """
        return pulumi.get(self, "web_url")


@pulumi.output_type
class GetProjectMergeRequestsMergeRequestClosedByResult(dict):
    def __init__(__self__, *,
                 avatar_url: _builtins.str,
                 id: _builtins.int,
                 name: _builtins.str,
                 state: _builtins.str,
                 username: _builtins.str,
                 web_url: _builtins.str):
        """
        :param _builtins.str avatar_url: A link to the user's avatar image.
        :param _builtins.int id: The internal ID number of the user.
        :param _builtins.str name: The name of the user.
        :param _builtins.str state: The state of the user account.
        :param _builtins.str username: The username of the user.
        :param _builtins.str web_url: A link to the user's profile page.
        """
        pulumi.set(__self__, "avatar_url", avatar_url)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "web_url", web_url)

    @_builtins.property
    @pulumi.getter(name="avatarUrl")
    def avatar_url(self) -> _builtins.str:
        """
        A link to the user's avatar image.
        """
        return pulumi.get(self, "avatar_url")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The internal ID number of the user.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of the user account.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The username of the user.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> _builtins.str:
        """
        A link to the user's profile page.
        """
        return pulumi.get(self, "web_url")


@pulumi.output_type
class GetProjectMilestonesMilestoneResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 due_date: _builtins.str,
                 expired: _builtins.bool,
                 iid: _builtins.int,
                 milestone_id: _builtins.int,
                 project: _builtins.str,
                 project_id: _builtins.int,
                 start_date: _builtins.str,
                 state: _builtins.str,
                 title: _builtins.str,
                 updated_at: _builtins.str,
                 web_url: _builtins.str):
        """
        :param _builtins.str created_at: The time of creation of the milestone. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.
        :param _builtins.str description: The description of the milestone.
        :param _builtins.str due_date: The due date of the milestone. Date time string in the format YYYY-MM-DD, for example 2016-03-11.
        :param _builtins.bool expired: Bool, true if milestone expired.
        :param _builtins.int iid: The ID of the project's milestone.
        :param _builtins.int milestone_id: The instance-wide ID of the project's milestone.
        :param _builtins.str project: The ID or URL-encoded path of the project owned by the authenticated user.
        :param _builtins.int project_id: The project ID of milestone.
        :param _builtins.str start_date: The start date of the milestone. Date time string in the format YYYY-MM-DD, for example 2016-03-11.
        :param _builtins.str state: The state of the milestone. Valid values are: `active`, `closed`.
        :param _builtins.str title: The title of a milestone.
        :param _builtins.str updated_at: The last update time of the milestone. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.
        :param _builtins.str web_url: The web URL of the milestone.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "due_date", due_date)
        pulumi.set(__self__, "expired", expired)
        pulumi.set(__self__, "iid", iid)
        pulumi.set(__self__, "milestone_id", milestone_id)
        pulumi.set(__self__, "project", project)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "title", title)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "web_url", web_url)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The time of creation of the milestone. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the milestone.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="dueDate")
    def due_date(self) -> _builtins.str:
        """
        The due date of the milestone. Date time string in the format YYYY-MM-DD, for example 2016-03-11.
        """
        return pulumi.get(self, "due_date")

    @_builtins.property
    @pulumi.getter
    def expired(self) -> _builtins.bool:
        """
        Bool, true if milestone expired.
        """
        return pulumi.get(self, "expired")

    @_builtins.property
    @pulumi.getter
    def iid(self) -> _builtins.int:
        """
        The ID of the project's milestone.
        """
        return pulumi.get(self, "iid")

    @_builtins.property
    @pulumi.getter(name="milestoneId")
    def milestone_id(self) -> _builtins.int:
        """
        The instance-wide ID of the project's milestone.
        """
        return pulumi.get(self, "milestone_id")

    @_builtins.property
    @pulumi.getter
    def project(self) -> _builtins.str:
        """
        The ID or URL-encoded path of the project owned by the authenticated user.
        """
        return pulumi.get(self, "project")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.int:
        """
        The project ID of milestone.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="startDate")
    def start_date(self) -> _builtins.str:
        """
        The start date of the milestone. Date time string in the format YYYY-MM-DD, for example 2016-03-11.
        """
        return pulumi.get(self, "start_date")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of the milestone. Valid values are: `active`, `closed`.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The title of a milestone.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        The last update time of the milestone. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> _builtins.str:
        """
        The web URL of the milestone.
        """
        return pulumi.get(self, "web_url")


@pulumi.output_type
class GetProjectProtectedBranchMergeAccessLevelResult(dict):
    def __init__(__self__, *,
                 access_level: _builtins.str,
                 access_level_description: _builtins.str,
                 group_id: Optional[_builtins.int] = None,
                 user_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str access_level: Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        :param _builtins.str access_level_description: Readable description of access level.
        :param _builtins.int group_id: The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        :param _builtins.int user_id: The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        pulumi.set(__self__, "access_level", access_level)
        pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> _builtins.str:
        """
        Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        """
        return pulumi.get(self, "access_level")

    @_builtins.property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> _builtins.str:
        """
        Readable description of access level.
        """
        return pulumi.get(self, "access_level_description")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetProjectProtectedBranchPushAccessLevelResult(dict):
    def __init__(__self__, *,
                 access_level: _builtins.str,
                 access_level_description: _builtins.str,
                 deploy_key_id: Optional[_builtins.int] = None,
                 group_id: Optional[_builtins.int] = None,
                 user_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str access_level: Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        :param _builtins.str access_level_description: Readable description of access level.
        :param _builtins.int deploy_key_id: The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `group_id` and `user_id`. This field is read-only until Gitlab 17.5.
        :param _builtins.int group_id: The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `user_id`.
        :param _builtins.int user_id: The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `group_id`.
        """
        pulumi.set(__self__, "access_level", access_level)
        pulumi.set(__self__, "access_level_description", access_level_description)
        if deploy_key_id is not None:
            pulumi.set(__self__, "deploy_key_id", deploy_key_id)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> _builtins.str:
        """
        Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        """
        return pulumi.get(self, "access_level")

    @_builtins.property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> _builtins.str:
        """
        Readable description of access level.
        """
        return pulumi.get(self, "access_level_description")

    @_builtins.property
    @pulumi.getter(name="deployKeyId")
    def deploy_key_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `group_id` and `user_id`. This field is read-only until Gitlab 17.5.
        """
        return pulumi.get(self, "deploy_key_id")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `user_id`.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `group_id`.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetProjectProtectedBranchesProtectedBranchResult(dict):
    def __init__(__self__, *,
                 allow_force_push: _builtins.bool,
                 code_owner_approval_required: _builtins.bool,
                 id: _builtins.int,
                 name: _builtins.str,
                 merge_access_levels: Optional[Sequence['outputs.GetProjectProtectedBranchesProtectedBranchMergeAccessLevelResult']] = None,
                 push_access_levels: Optional[Sequence['outputs.GetProjectProtectedBranchesProtectedBranchPushAccessLevelResult']] = None):
        """
        :param _builtins.bool allow_force_push: Whether force push is allowed.
        :param _builtins.bool code_owner_approval_required: Reject code pushes that change files listed in the CODEOWNERS file.
        :param _builtins.int id: The ID of this resource.
        :param _builtins.str name: The name of the protected branch.
        :param Sequence['GetProjectProtectedBranchesProtectedBranchMergeAccessLevelArgs'] merge_access_levels: Array of access levels and user(s)/group(s) allowed to merge to protected branch.
        :param Sequence['GetProjectProtectedBranchesProtectedBranchPushAccessLevelArgs'] push_access_levels: Array of access levels and user(s)/group(s) allowed to push to protected branch.
        """
        pulumi.set(__self__, "allow_force_push", allow_force_push)
        pulumi.set(__self__, "code_owner_approval_required", code_owner_approval_required)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        if merge_access_levels is not None:
            pulumi.set(__self__, "merge_access_levels", merge_access_levels)
        if push_access_levels is not None:
            pulumi.set(__self__, "push_access_levels", push_access_levels)

    @_builtins.property
    @pulumi.getter(name="allowForcePush")
    def allow_force_push(self) -> _builtins.bool:
        """
        Whether force push is allowed.
        """
        return pulumi.get(self, "allow_force_push")

    @_builtins.property
    @pulumi.getter(name="codeOwnerApprovalRequired")
    def code_owner_approval_required(self) -> _builtins.bool:
        """
        Reject code pushes that change files listed in the CODEOWNERS file.
        """
        return pulumi.get(self, "code_owner_approval_required")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the protected branch.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="mergeAccessLevels")
    def merge_access_levels(self) -> Optional[Sequence['outputs.GetProjectProtectedBranchesProtectedBranchMergeAccessLevelResult']]:
        """
        Array of access levels and user(s)/group(s) allowed to merge to protected branch.
        """
        return pulumi.get(self, "merge_access_levels")

    @_builtins.property
    @pulumi.getter(name="pushAccessLevels")
    def push_access_levels(self) -> Optional[Sequence['outputs.GetProjectProtectedBranchesProtectedBranchPushAccessLevelResult']]:
        """
        Array of access levels and user(s)/group(s) allowed to push to protected branch.
        """
        return pulumi.get(self, "push_access_levels")


@pulumi.output_type
class GetProjectProtectedBranchesProtectedBranchMergeAccessLevelResult(dict):
    def __init__(__self__, *,
                 access_level: _builtins.str,
                 access_level_description: _builtins.str,
                 group_id: Optional[_builtins.int] = None,
                 user_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str access_level: Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        :param _builtins.str access_level_description: Readable description of access level.
        :param _builtins.int group_id: The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        :param _builtins.int user_id: The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        pulumi.set(__self__, "access_level", access_level)
        pulumi.set(__self__, "access_level_description", access_level_description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> _builtins.str:
        """
        Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        """
        return pulumi.get(self, "access_level")

    @_builtins.property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> _builtins.str:
        """
        Readable description of access level.
        """
        return pulumi.get(self, "access_level_description")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetProjectProtectedBranchesProtectedBranchPushAccessLevelResult(dict):
    def __init__(__self__, *,
                 access_level: _builtins.str,
                 access_level_description: _builtins.str,
                 deploy_key_id: Optional[_builtins.int] = None,
                 group_id: Optional[_builtins.int] = None,
                 user_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str access_level: Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        :param _builtins.str access_level_description: Readable description of access level.
        :param _builtins.int deploy_key_id: The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `group_id` and `user_id`. This field is read-only until Gitlab 17.5.
        :param _builtins.int group_id: The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `user_id`.
        :param _builtins.int user_id: The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `group_id`.
        """
        pulumi.set(__self__, "access_level", access_level)
        pulumi.set(__self__, "access_level_description", access_level_description)
        if deploy_key_id is not None:
            pulumi.set(__self__, "deploy_key_id", deploy_key_id)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> _builtins.str:
        """
        Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`, `admin`.
        """
        return pulumi.get(self, "access_level")

    @_builtins.property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> _builtins.str:
        """
        Readable description of access level.
        """
        return pulumi.get(self, "access_level_description")

    @_builtins.property
    @pulumi.getter(name="deployKeyId")
    def deploy_key_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `group_id` and `user_id`. This field is read-only until Gitlab 17.5.
        """
        return pulumi.get(self, "deploy_key_id")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `user_id`.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `group_id`.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetProjectProtectedTagCreateAccessLevelResult(dict):
    def __init__(__self__, *,
                 access_level: _builtins.str,
                 access_level_description: _builtins.str,
                 id: _builtins.int,
                 group_id: Optional[_builtins.int] = None,
                 user_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str access_level: Access level allowed to create protected tags.
        :param _builtins.str access_level_description: Readable description of access level.
        :param _builtins.int id: The ID of the create access level.
        :param _builtins.int group_id: The ID of a GitLab group allowed to perform the relevant action.
        :param _builtins.int user_id: The ID of a GitLab user allowed to perform the relevant action.
        """
        pulumi.set(__self__, "access_level", access_level)
        pulumi.set(__self__, "access_level_description", access_level_description)
        pulumi.set(__self__, "id", id)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> _builtins.str:
        """
        Access level allowed to create protected tags.
        """
        return pulumi.get(self, "access_level")

    @_builtins.property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> _builtins.str:
        """
        Readable description of access level.
        """
        return pulumi.get(self, "access_level_description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The ID of the create access level.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab group allowed to perform the relevant action.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab user allowed to perform the relevant action.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetProjectProtectedTagsProtectedTagResult(dict):
    def __init__(__self__, *,
                 create_access_levels: Sequence['outputs.GetProjectProtectedTagsProtectedTagCreateAccessLevelResult'],
                 tag: _builtins.str):
        """
        :param Sequence['GetProjectProtectedTagsProtectedTagCreateAccessLevelArgs'] create_access_levels: Array of access levels/user(s)/group(s) allowed to create protected tags.
        :param _builtins.str tag: The name of the protected tag.
        """
        pulumi.set(__self__, "create_access_levels", create_access_levels)
        pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter(name="createAccessLevels")
    def create_access_levels(self) -> Sequence['outputs.GetProjectProtectedTagsProtectedTagCreateAccessLevelResult']:
        """
        Array of access levels/user(s)/group(s) allowed to create protected tags.
        """
        return pulumi.get(self, "create_access_levels")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> _builtins.str:
        """
        The name of the protected tag.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class GetProjectProtectedTagsProtectedTagCreateAccessLevelResult(dict):
    def __init__(__self__, *,
                 access_level: _builtins.str,
                 access_level_description: _builtins.str,
                 id: _builtins.int,
                 group_id: Optional[_builtins.int] = None,
                 user_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str access_level: Access level allowed to create protected tags.
        :param _builtins.str access_level_description: Readable description of access level.
        :param _builtins.int id: The ID of the create access level.
        :param _builtins.int group_id: The ID of a GitLab group allowed to perform the relevant action.
        :param _builtins.int user_id: The ID of a GitLab user allowed to perform the relevant action.
        """
        pulumi.set(__self__, "access_level", access_level)
        pulumi.set(__self__, "access_level_description", access_level_description)
        pulumi.set(__self__, "id", id)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> _builtins.str:
        """
        Access level allowed to create protected tags.
        """
        return pulumi.get(self, "access_level")

    @_builtins.property
    @pulumi.getter(name="accessLevelDescription")
    def access_level_description(self) -> _builtins.str:
        """
        Readable description of access level.
        """
        return pulumi.get(self, "access_level_description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The ID of the create access level.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab group allowed to perform the relevant action.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.int]:
        """
        The ID of a GitLab user allowed to perform the relevant action.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetProjectPushRuleResult(dict):
    def __init__(__self__, *,
                 author_email_regex: _builtins.str,
                 branch_name_regex: _builtins.str,
                 commit_committer_check: _builtins.bool,
                 commit_committer_name_check: _builtins.bool,
                 commit_message_negative_regex: _builtins.str,
                 commit_message_regex: _builtins.str,
                 deny_delete_tag: _builtins.bool,
                 file_name_regex: _builtins.str,
                 max_file_size: _builtins.int,
                 member_check: _builtins.bool,
                 prevent_secrets: _builtins.bool,
                 reject_non_dco_commits: _builtins.bool,
                 reject_unsigned_commits: _builtins.bool):
        """
        :param _builtins.str author_email_regex: All commit author emails must match this regex, e.g. `@my-company.com$`.
        :param _builtins.str branch_name_regex: All branch names must match this regex, e.g. `(feature|hotfix)\\/*`.
        :param _builtins.bool commit_committer_check: Users can only push commits to this repository that were committed with one of their own verified emails.
        :param _builtins.bool commit_committer_name_check: Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
        :param _builtins.str commit_message_negative_regex: No commit message is allowed to match this regex, for example `ssh\\:\\/\\/`.
        :param _builtins.str commit_message_regex: All commit messages must match this regex, e.g. `Fixed \\d+\\..*`.
        :param _builtins.bool deny_delete_tag: Deny deleting a tag.
        :param _builtins.str file_name_regex: All committed filenames must not match this regex, e.g. `(jar|exe)$`.
        :param _builtins.int max_file_size: Maximum file size (MB).
        :param _builtins.bool member_check: Restrict commits by author (email) to existing GitLab users.
        :param _builtins.bool prevent_secrets: GitLab will reject any files that are likely to contain secrets.
        :param _builtins.bool reject_non_dco_commits: Reject commit when it's not DCO certified.
        :param _builtins.bool reject_unsigned_commits: Reject commit when it's not signed through GPG.
        """
        pulumi.set(__self__, "author_email_regex", author_email_regex)
        pulumi.set(__self__, "branch_name_regex", branch_name_regex)
        pulumi.set(__self__, "commit_committer_check", commit_committer_check)
        pulumi.set(__self__, "commit_committer_name_check", commit_committer_name_check)
        pulumi.set(__self__, "commit_message_negative_regex", commit_message_negative_regex)
        pulumi.set(__self__, "commit_message_regex", commit_message_regex)
        pulumi.set(__self__, "deny_delete_tag", deny_delete_tag)
        pulumi.set(__self__, "file_name_regex", file_name_regex)
        pulumi.set(__self__, "max_file_size", max_file_size)
        pulumi.set(__self__, "member_check", member_check)
        pulumi.set(__self__, "prevent_secrets", prevent_secrets)
        pulumi.set(__self__, "reject_non_dco_commits", reject_non_dco_commits)
        pulumi.set(__self__, "reject_unsigned_commits", reject_unsigned_commits)

    @_builtins.property
    @pulumi.getter(name="authorEmailRegex")
    def author_email_regex(self) -> _builtins.str:
        """
        All commit author emails must match this regex, e.g. `@my-company.com$`.
        """
        return pulumi.get(self, "author_email_regex")

    @_builtins.property
    @pulumi.getter(name="branchNameRegex")
    def branch_name_regex(self) -> _builtins.str:
        """
        All branch names must match this regex, e.g. `(feature|hotfix)\\/*`.
        """
        return pulumi.get(self, "branch_name_regex")

    @_builtins.property
    @pulumi.getter(name="commitCommitterCheck")
    def commit_committer_check(self) -> _builtins.bool:
        """
        Users can only push commits to this repository that were committed with one of their own verified emails.
        """
        return pulumi.get(self, "commit_committer_check")

    @_builtins.property
    @pulumi.getter(name="commitCommitterNameCheck")
    def commit_committer_name_check(self) -> _builtins.bool:
        """
        Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.
        """
        return pulumi.get(self, "commit_committer_name_check")

    @_builtins.property
    @pulumi.getter(name="commitMessageNegativeRegex")
    def commit_message_negative_regex(self) -> _builtins.str:
        """
        No commit message is allowed to match this regex, for example `ssh\\:\\/\\/`.
        """
        return pulumi.get(self, "commit_message_negative_regex")

    @_builtins.property
    @pulumi.getter(name="commitMessageRegex")
    def commit_message_regex(self) -> _builtins.str:
        """
        All commit messages must match this regex, e.g. `Fixed \\d+\\..*`.
        """
        return pulumi.get(self, "commit_message_regex")

    @_builtins.property
    @pulumi.getter(name="denyDeleteTag")
    def deny_delete_tag(self) -> _builtins.bool:
        """
        Deny deleting a tag.
        """
        return pulumi.get(self, "deny_delete_tag")

    @_builtins.property
    @pulumi.getter(name="fileNameRegex")
    def file_name_regex(self) -> _builtins.str:
        """
        All committed filenames must not match this regex, e.g. `(jar|exe)$`.
        """
        return pulumi.get(self, "file_name_regex")

    @_builtins.property
    @pulumi.getter(name="maxFileSize")
    def max_file_size(self) -> _builtins.int:
        """
        Maximum file size (MB).
        """
        return pulumi.get(self, "max_file_size")

    @_builtins.property
    @pulumi.getter(name="memberCheck")
    def member_check(self) -> _builtins.bool:
        """
        Restrict commits by author (email) to existing GitLab users.
        """
        return pulumi.get(self, "member_check")

    @_builtins.property
    @pulumi.getter(name="preventSecrets")
    def prevent_secrets(self) -> _builtins.bool:
        """
        GitLab will reject any files that are likely to contain secrets.
        """
        return pulumi.get(self, "prevent_secrets")

    @_builtins.property
    @pulumi.getter(name="rejectNonDcoCommits")
    def reject_non_dco_commits(self) -> _builtins.bool:
        """
        Reject commit when it's not DCO certified.
        """
        return pulumi.get(self, "reject_non_dco_commits")

    @_builtins.property
    @pulumi.getter(name="rejectUnsignedCommits")
    def reject_unsigned_commits(self) -> _builtins.bool:
        """
        Reject commit when it's not signed through GPG.
        """
        return pulumi.get(self, "reject_unsigned_commits")


@pulumi.output_type
class GetProjectSecureFileMetadataResult(dict):
    def __init__(__self__, *,
                 expires_at: _builtins.str,
                 id: _builtins.str,
                 issuer: 'outputs.GetProjectSecureFileMetadataIssuerResult',
                 subject: 'outputs.GetProjectSecureFileMetadataSubjectResult'):
        """
        :param _builtins.str expires_at: Certificate expiration date
        :param _builtins.str id: Certificate ID
        :param 'GetProjectSecureFileMetadataIssuerArgs' issuer: Certificate issuer information
        :param 'GetProjectSecureFileMetadataSubjectArgs' subject: Certificate subject information
        """
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "subject", subject)

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> _builtins.str:
        """
        Certificate expiration date
        """
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Certificate ID
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> 'outputs.GetProjectSecureFileMetadataIssuerResult':
        """
        Certificate issuer information
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> 'outputs.GetProjectSecureFileMetadataSubjectResult':
        """
        Certificate subject information
        """
        return pulumi.get(self, "subject")


@pulumi.output_type
class GetProjectSecureFileMetadataIssuerResult(dict):
    def __init__(__self__, *,
                 c: _builtins.str,
                 cn: _builtins.str,
                 o: _builtins.str,
                 ou: _builtins.str):
        """
        :param _builtins.str c: Country
        :param _builtins.str cn: Common Name
        :param _builtins.str o: Organization
        :param _builtins.str ou: Organizational Unit
        """
        pulumi.set(__self__, "c", c)
        pulumi.set(__self__, "cn", cn)
        pulumi.set(__self__, "o", o)
        pulumi.set(__self__, "ou", ou)

    @_builtins.property
    @pulumi.getter
    def c(self) -> _builtins.str:
        """
        Country
        """
        return pulumi.get(self, "c")

    @_builtins.property
    @pulumi.getter
    def cn(self) -> _builtins.str:
        """
        Common Name
        """
        return pulumi.get(self, "cn")

    @_builtins.property
    @pulumi.getter
    def o(self) -> _builtins.str:
        """
        Organization
        """
        return pulumi.get(self, "o")

    @_builtins.property
    @pulumi.getter
    def ou(self) -> _builtins.str:
        """
        Organizational Unit
        """
        return pulumi.get(self, "ou")


@pulumi.output_type
class GetProjectSecureFileMetadataSubjectResult(dict):
    def __init__(__self__, *,
                 c: _builtins.str,
                 cn: _builtins.str,
                 o: _builtins.str,
                 ou: _builtins.str,
                 uid: _builtins.str):
        """
        :param _builtins.str c: Country
        :param _builtins.str cn: Common Name
        :param _builtins.str o: Organization
        :param _builtins.str ou: Organizational Unit
        :param _builtins.str uid: User ID
        """
        pulumi.set(__self__, "c", c)
        pulumi.set(__self__, "cn", cn)
        pulumi.set(__self__, "o", o)
        pulumi.set(__self__, "ou", ou)
        pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def c(self) -> _builtins.str:
        """
        Country
        """
        return pulumi.get(self, "c")

    @_builtins.property
    @pulumi.getter
    def cn(self) -> _builtins.str:
        """
        Common Name
        """
        return pulumi.get(self, "cn")

    @_builtins.property
    @pulumi.getter
    def o(self) -> _builtins.str:
        """
        Organization
        """
        return pulumi.get(self, "o")

    @_builtins.property
    @pulumi.getter
    def ou(self) -> _builtins.str:
        """
        Organizational Unit
        """
        return pulumi.get(self, "ou")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> _builtins.str:
        """
        User ID
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class GetProjectSharedWithGroupResult(dict):
    def __init__(__self__, *,
                 group_access_level: _builtins.int,
                 group_full_path: _builtins.str,
                 group_id: _builtins.int,
                 group_name: _builtins.str):
        """
        :param _builtins.int group_access_level: The access_level permission level of the shared group.
        :param _builtins.str group_full_path: The full path of the group shared with.
        :param _builtins.int group_id: The ID of the group shared with.
        :param _builtins.str group_name: The name of the group shared with.
        """
        pulumi.set(__self__, "group_access_level", group_access_level)
        pulumi.set(__self__, "group_full_path", group_full_path)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "group_name", group_name)

    @_builtins.property
    @pulumi.getter(name="groupAccessLevel")
    def group_access_level(self) -> _builtins.int:
        """
        The access_level permission level of the shared group.
        """
        return pulumi.get(self, "group_access_level")

    @_builtins.property
    @pulumi.getter(name="groupFullPath")
    def group_full_path(self) -> _builtins.str:
        """
        The full path of the group shared with.
        """
        return pulumi.get(self, "group_full_path")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.int:
        """
        The ID of the group shared with.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> _builtins.str:
        """
        The name of the group shared with.
        """
        return pulumi.get(self, "group_name")


@pulumi.output_type
class GetProjectTagCommitResult(dict):
    def __init__(__self__, *,
                 author_email: _builtins.str,
                 author_name: _builtins.str,
                 authored_date: _builtins.str,
                 committed_date: _builtins.str,
                 committer_email: _builtins.str,
                 committer_name: _builtins.str,
                 id: _builtins.str,
                 message: _builtins.str,
                 parent_ids: Sequence[_builtins.str],
                 short_id: _builtins.str,
                 title: _builtins.str):
        """
        :param _builtins.str author_email: The email of the author.
        :param _builtins.str author_name: The name of the author.
        :param _builtins.str authored_date: The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
        :param _builtins.str committed_date: The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
        :param _builtins.str committer_email: The email of the user that committed.
        :param _builtins.str committer_name: The name of the user that committed.
        :param _builtins.str id: The unique id assigned to the commit by Gitlab.
        :param _builtins.str message: The commit message
        :param Sequence[_builtins.str] parent_ids: The id of the parents of the commit
        :param _builtins.str short_id: The short id assigned to the commit by Gitlab.
        :param _builtins.str title: The title of the commit
        """
        pulumi.set(__self__, "author_email", author_email)
        pulumi.set(__self__, "author_name", author_name)
        pulumi.set(__self__, "authored_date", authored_date)
        pulumi.set(__self__, "committed_date", committed_date)
        pulumi.set(__self__, "committer_email", committer_email)
        pulumi.set(__self__, "committer_name", committer_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "parent_ids", parent_ids)
        pulumi.set(__self__, "short_id", short_id)
        pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter(name="authorEmail")
    def author_email(self) -> _builtins.str:
        """
        The email of the author.
        """
        return pulumi.get(self, "author_email")

    @_builtins.property
    @pulumi.getter(name="authorName")
    def author_name(self) -> _builtins.str:
        """
        The name of the author.
        """
        return pulumi.get(self, "author_name")

    @_builtins.property
    @pulumi.getter(name="authoredDate")
    def authored_date(self) -> _builtins.str:
        """
        The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
        """
        return pulumi.get(self, "authored_date")

    @_builtins.property
    @pulumi.getter(name="committedDate")
    def committed_date(self) -> _builtins.str:
        """
        The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
        """
        return pulumi.get(self, "committed_date")

    @_builtins.property
    @pulumi.getter(name="committerEmail")
    def committer_email(self) -> _builtins.str:
        """
        The email of the user that committed.
        """
        return pulumi.get(self, "committer_email")

    @_builtins.property
    @pulumi.getter(name="committerName")
    def committer_name(self) -> _builtins.str:
        """
        The name of the user that committed.
        """
        return pulumi.get(self, "committer_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The unique id assigned to the commit by Gitlab.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        The commit message
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="parentIds")
    def parent_ids(self) -> Sequence[_builtins.str]:
        """
        The id of the parents of the commit
        """
        return pulumi.get(self, "parent_ids")

    @_builtins.property
    @pulumi.getter(name="shortId")
    def short_id(self) -> _builtins.str:
        """
        The short id assigned to the commit by Gitlab.
        """
        return pulumi.get(self, "short_id")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The title of the commit
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetProjectTagReleaseResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 tag_name: _builtins.str):
        """
        :param _builtins.str description: The description of the release.
        :param _builtins.str tag_name: The name of the tag.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "tag_name", tag_name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the release.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> _builtins.str:
        """
        The name of the tag.
        """
        return pulumi.get(self, "tag_name")


@pulumi.output_type
class GetProjectTagsTagResult(dict):
    def __init__(__self__, *,
                 commits: Sequence['outputs.GetProjectTagsTagCommitResult'],
                 message: _builtins.str,
                 name: _builtins.str,
                 protected: _builtins.bool,
                 releases: Sequence['outputs.GetProjectTagsTagReleaseResult'],
                 target: _builtins.str):
        """
        :param Sequence['GetProjectTagsTagCommitArgs'] commits: The commit associated with the tag.
        :param _builtins.str message: The message of the annotated tag.
        :param _builtins.str name: The name of a tag.
        :param _builtins.bool protected: True if tag has tag protection.
        :param Sequence['GetProjectTagsTagReleaseArgs'] releases: The release associated with the tag.
        :param _builtins.str target: The unique id assigned to the commit by Gitlab.
        """
        pulumi.set(__self__, "commits", commits)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protected", protected)
        pulumi.set(__self__, "releases", releases)
        pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def commits(self) -> Sequence['outputs.GetProjectTagsTagCommitResult']:
        """
        The commit associated with the tag.
        """
        return pulumi.get(self, "commits")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        The message of the annotated tag.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of a tag.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def protected(self) -> _builtins.bool:
        """
        True if tag has tag protection.
        """
        return pulumi.get(self, "protected")

    @_builtins.property
    @pulumi.getter
    def releases(self) -> Sequence['outputs.GetProjectTagsTagReleaseResult']:
        """
        The release associated with the tag.
        """
        return pulumi.get(self, "releases")

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        """
        The unique id assigned to the commit by Gitlab.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class GetProjectTagsTagCommitResult(dict):
    def __init__(__self__, *,
                 author_email: _builtins.str,
                 author_name: _builtins.str,
                 authored_date: _builtins.str,
                 committed_date: _builtins.str,
                 committer_email: _builtins.str,
                 committer_name: _builtins.str,
                 id: _builtins.str,
                 message: _builtins.str,
                 parent_ids: Sequence[_builtins.str],
                 short_id: _builtins.str,
                 title: _builtins.str):
        """
        :param _builtins.str author_email: The email of the author.
        :param _builtins.str author_name: The name of the author.
        :param _builtins.str authored_date: The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
        :param _builtins.str committed_date: The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
        :param _builtins.str committer_email: The email of the user that committed.
        :param _builtins.str committer_name: The name of the user that committed.
        :param _builtins.str id: The unique id assigned to the commit by Gitlab.
        :param _builtins.str message: The commit message
        :param Sequence[_builtins.str] parent_ids: The id of the parents of the commit
        :param _builtins.str short_id: The short id assigned to the commit by Gitlab.
        :param _builtins.str title: The title of the commit
        """
        pulumi.set(__self__, "author_email", author_email)
        pulumi.set(__self__, "author_name", author_name)
        pulumi.set(__self__, "authored_date", authored_date)
        pulumi.set(__self__, "committed_date", committed_date)
        pulumi.set(__self__, "committer_email", committer_email)
        pulumi.set(__self__, "committer_name", committer_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "parent_ids", parent_ids)
        pulumi.set(__self__, "short_id", short_id)
        pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter(name="authorEmail")
    def author_email(self) -> _builtins.str:
        """
        The email of the author.
        """
        return pulumi.get(self, "author_email")

    @_builtins.property
    @pulumi.getter(name="authorName")
    def author_name(self) -> _builtins.str:
        """
        The name of the author.
        """
        return pulumi.get(self, "author_name")

    @_builtins.property
    @pulumi.getter(name="authoredDate")
    def authored_date(self) -> _builtins.str:
        """
        The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).
        """
        return pulumi.get(self, "authored_date")

    @_builtins.property
    @pulumi.getter(name="committedDate")
    def committed_date(self) -> _builtins.str:
        """
        The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).
        """
        return pulumi.get(self, "committed_date")

    @_builtins.property
    @pulumi.getter(name="committerEmail")
    def committer_email(self) -> _builtins.str:
        """
        The email of the user that committed.
        """
        return pulumi.get(self, "committer_email")

    @_builtins.property
    @pulumi.getter(name="committerName")
    def committer_name(self) -> _builtins.str:
        """
        The name of the user that committed.
        """
        return pulumi.get(self, "committer_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The unique id assigned to the commit by Gitlab.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        The commit message
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="parentIds")
    def parent_ids(self) -> Sequence[_builtins.str]:
        """
        The id of the parents of the commit
        """
        return pulumi.get(self, "parent_ids")

    @_builtins.property
    @pulumi.getter(name="shortId")
    def short_id(self) -> _builtins.str:
        """
        The short id assigned to the commit by Gitlab.
        """
        return pulumi.get(self, "short_id")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The title of the commit
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetProjectTagsTagReleaseResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 tag_name: _builtins.str):
        """
        :param _builtins.str description: The description of the release.
        :param _builtins.str tag_name: The name of the tag.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "tag_name", tag_name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the release.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> _builtins.str:
        """
        The name of the tag.
        """
        return pulumi.get(self, "tag_name")


@pulumi.output_type
class GetProjectVariablesVariableResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 environment_scope: _builtins.str,
                 key: _builtins.str,
                 masked: _builtins.bool,
                 project: _builtins.str,
                 protected: _builtins.bool,
                 raw: _builtins.bool,
                 value: _builtins.str,
                 variable_type: _builtins.str):
        """
        :param _builtins.str description: The description of the variable. Maximum of 255 characters.
        :param _builtins.str environment_scope: The environment scope of the variable. Defaults to all environment (`*`).
        :param _builtins.str key: The name of the variable.
        :param _builtins.bool masked: If set to `true`, the value of the variable will be hidden in job logs.
        :param _builtins.str project: The name or path of the project.
        :param _builtins.bool protected: If set to `true`, the variable will be passed only to pipelines running on protected branches and tags.
        :param _builtins.bool raw: If set to `true`, the variable will be treated as a raw string.
        :param _builtins.str value: The value of the variable.
        :param _builtins.str variable_type: The type of the variable, either `env_var` or `file`.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "environment_scope", environment_scope)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "masked", masked)
        pulumi.set(__self__, "project", project)
        pulumi.set(__self__, "protected", protected)
        pulumi.set(__self__, "raw", raw)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "variable_type", variable_type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the variable. Maximum of 255 characters.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="environmentScope")
    def environment_scope(self) -> _builtins.str:
        """
        The environment scope of the variable. Defaults to all environment (`*`).
        """
        return pulumi.get(self, "environment_scope")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def masked(self) -> _builtins.bool:
        """
        If set to `true`, the value of the variable will be hidden in job logs.
        """
        return pulumi.get(self, "masked")

    @_builtins.property
    @pulumi.getter
    def project(self) -> _builtins.str:
        """
        The name or path of the project.
        """
        return pulumi.get(self, "project")

    @_builtins.property
    @pulumi.getter
    def protected(self) -> _builtins.bool:
        """
        If set to `true`, the variable will be passed only to pipelines running on protected branches and tags.
        """
        return pulumi.get(self, "protected")

    @_builtins.property
    @pulumi.getter
    def raw(self) -> _builtins.bool:
        """
        If set to `true`, the variable will be treated as a raw string.
        """
        return pulumi.get(self, "raw")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the variable.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="variableType")
    def variable_type(self) -> _builtins.str:
        """
        The type of the variable, either `env_var` or `file`.
        """
        return pulumi.get(self, "variable_type")


@pulumi.output_type
class GetProjectsProjectResult(dict):
    def __init__(__self__, *,
                 _links: Mapping[str, _builtins.str],
                 allow_merge_on_skipped_pipeline: _builtins.bool,
                 allow_pipeline_trigger_approve_deployment: _builtins.bool,
                 analytics_access_level: _builtins.str,
                 approvals_before_merge: _builtins.int,
                 archived: _builtins.bool,
                 auto_cancel_pending_pipelines: _builtins.str,
                 auto_devops_deploy_strategy: _builtins.str,
                 auto_devops_enabled: _builtins.bool,
                 autoclose_referenced_issues: _builtins.bool,
                 avatar_url: _builtins.str,
                 build_coverage_regex: _builtins.str,
                 build_git_strategy: _builtins.str,
                 build_timeout: _builtins.int,
                 builds_access_level: _builtins.str,
                 ci_config_path: _builtins.str,
                 ci_default_git_depth: _builtins.int,
                 ci_delete_pipelines_in_seconds: _builtins.int,
                 ci_forward_deployment_enabled: _builtins.bool,
                 ci_forward_deployment_rollback_allowed: _builtins.bool,
                 ci_id_token_sub_claim_components: Sequence[_builtins.str],
                 ci_pipeline_variables_minimum_override_role: _builtins.str,
                 ci_restrict_pipeline_cancellation_role: _builtins.str,
                 container_expiration_policies: Sequence['outputs.GetProjectsProjectContainerExpirationPolicyResult'],
                 container_registry_access_level: _builtins.str,
                 container_registry_enabled: _builtins.bool,
                 created_at: _builtins.str,
                 creator_id: _builtins.int,
                 custom_attributes: Sequence[Mapping[str, _builtins.str]],
                 default_branch: _builtins.str,
                 description: _builtins.str,
                 emails_enabled: _builtins.bool,
                 empty_repo: _builtins.bool,
                 environments_access_level: _builtins.str,
                 external_authorization_classification_label: _builtins.str,
                 feature_flags_access_level: _builtins.str,
                 forked_from_projects: Sequence['outputs.GetProjectsProjectForkedFromProjectResult'],
                 forking_access_level: _builtins.str,
                 forks_count: _builtins.int,
                 group_runners_enabled: _builtins.bool,
                 http_url_to_repo: _builtins.str,
                 id: _builtins.int,
                 import_error: _builtins.str,
                 import_status: _builtins.str,
                 import_url: _builtins.str,
                 infrastructure_access_level: _builtins.str,
                 issues_access_level: _builtins.str,
                 issues_enabled: _builtins.bool,
                 jobs_enabled: _builtins.bool,
                 keep_latest_artifact: _builtins.bool,
                 last_activity_at: _builtins.str,
                 lfs_enabled: _builtins.bool,
                 links: Mapping[str, _builtins.str],
                 merge_commit_template: _builtins.str,
                 merge_method: _builtins.str,
                 merge_pipelines_enabled: _builtins.bool,
                 merge_requests_access_level: _builtins.str,
                 merge_requests_enabled: _builtins.bool,
                 merge_trains_enabled: _builtins.bool,
                 mirror: _builtins.bool,
                 mirror_overwrites_diverged_branches: _builtins.bool,
                 mirror_trigger_builds: _builtins.bool,
                 mirror_user_id: _builtins.int,
                 model_experiments_access_level: _builtins.str,
                 model_registry_access_level: _builtins.str,
                 monitor_access_level: _builtins.str,
                 name: _builtins.str,
                 name_with_namespace: _builtins.str,
                 namespaces: Sequence['outputs.GetProjectsProjectNamespaceResult'],
                 only_allow_merge_if_all_discussions_are_resolved: _builtins.bool,
                 only_allow_merge_if_pipeline_succeeds: _builtins.bool,
                 only_mirror_protected_branches: _builtins.bool,
                 open_issues_count: _builtins.int,
                 owners: Sequence['outputs.GetProjectsProjectOwnerResult'],
                 packages_enabled: _builtins.bool,
                 path: _builtins.str,
                 path_with_namespace: _builtins.str,
                 permissions: Sequence['outputs.GetProjectsProjectPermissionResult'],
                 prevent_merge_without_jira_issue: _builtins.bool,
                 public_builds: _builtins.bool,
                 readme_url: _builtins.str,
                 releases_access_level: _builtins.str,
                 repository_access_level: _builtins.str,
                 repository_storage: _builtins.str,
                 request_access_enabled: _builtins.bool,
                 requirements_access_level: _builtins.str,
                 resolve_outdated_diff_discussions: _builtins.bool,
                 resource_group_default_process_mode: _builtins.str,
                 restrict_user_defined_variables: _builtins.bool,
                 runners_token: _builtins.str,
                 security_and_compliance_access_level: _builtins.str,
                 shared_runners_enabled: _builtins.bool,
                 shared_with_groups: Sequence['outputs.GetProjectsProjectSharedWithGroupResult'],
                 snippets_access_level: _builtins.str,
                 snippets_enabled: _builtins.bool,
                 squash_commit_template: _builtins.str,
                 ssh_url_to_repo: _builtins.str,
                 star_count: _builtins.int,
                 statistics: Mapping[str, _builtins.int],
                 suggestion_commit_message: _builtins.str,
                 tag_lists: Sequence[_builtins.str],
                 topics: Sequence[_builtins.str],
                 visibility: _builtins.str,
                 web_url: _builtins.str,
                 wiki_access_level: _builtins.str,
                 wiki_enabled: _builtins.bool):
        """
        :param Mapping[str, _builtins.str] _links: Links for the project. Use `links` instead. To be removed in 19.0.
        :param _builtins.bool allow_merge_on_skipped_pipeline: Whether allow_merge_on_skipped_pipeline is enabled for the project.
        :param _builtins.bool allow_pipeline_trigger_approve_deployment: Set whether or not a pipeline triggerer is allowed to approve deployments. Premium and Ultimate only.
        :param _builtins.str analytics_access_level: Set the analytics access level. Valid values are `disabled`, `private`, `enabled`.
        :param _builtins.int approvals_before_merge: The numbers of approvals needed in a merge requests.
        :param _builtins.bool archived: Whether the project is archived.
        :param _builtins.str auto_cancel_pending_pipelines: Auto-cancel pending pipelines. This isnt a boolean, but enabled/disabled.
        :param _builtins.str auto_devops_deploy_strategy: Auto Deploy strategy. Valid values are `continuous`, `manual`, `timed_incremental`.
        :param _builtins.bool auto_devops_enabled: Enable Auto DevOps for this project.
        :param _builtins.bool autoclose_referenced_issues: Set whether auto-closing referenced issues on default branch.
        :param _builtins.str avatar_url: The avatar url of the project.
        :param _builtins.str build_coverage_regex: Build coverage regex for the project.
        :param _builtins.str build_git_strategy: The Git strategy. Defaults to fetch.
        :param _builtins.int build_timeout: The maximum amount of time, in seconds, that a job can run.
        :param _builtins.str builds_access_level: Set the builds access level. Valid values are `disabled`, `private`, `enabled`.
        :param _builtins.str ci_config_path: CI config file path for the project.
        :param _builtins.int ci_default_git_depth: Default number of revisions for shallow cloning.
        :param _builtins.int ci_delete_pipelines_in_seconds: Pipelines older than the configured time are deleted.
        :param _builtins.bool ci_forward_deployment_enabled: When a new deployment job starts, skip older deployment jobs that are still pending.
        :param _builtins.bool ci_forward_deployment_rollback_allowed: Allow job retries even if the deployment job is outdated.
        :param Sequence[_builtins.str] ci_id_token_sub_claim_components: Fields included in the sub claim of the ID Token. Accepts an array starting with project_path. The array might also include ref_type and ref. Defaults to ["project_path", "ref_type", "ref"]. Introduced in GitLab 17.10.
        :param _builtins.str ci_pipeline_variables_minimum_override_role: The minimum role required to set variables when running pipelines and jobs. Introduced in GitLab 17.1. Valid values are `developer`, `maintainer`, `owner`, `no_one_allowed`
        :param _builtins.str ci_restrict_pipeline_cancellation_role: The role required to cancel a pipeline or job. Premium and Ultimate only. Valid values are `developer`, `maintainer`, `no one`
        :param Sequence['GetProjectsProjectContainerExpirationPolicyArgs'] container_expiration_policies: Set the image cleanup policy for this project. **Note**: this field is sometimes named `container_expiration_policy_attributes` in the GitLab Upstream API.
        :param _builtins.str container_registry_access_level: Set visibility of container registry, for this project. Valid values are `disabled`, `private`, `enabled`.
        :param _builtins.bool container_registry_enabled: Whether the container registry is enabled for the project.
        :param _builtins.str created_at: Creation time for the project.
        :param _builtins.int creator_id: Creator ID for the project.
        :param Sequence[Mapping[str, _builtins.str]] custom_attributes: Custom attributes for the project.
        :param _builtins.str default_branch: The default branch name of the project.
        :param _builtins.str description: The description of the project.
        :param _builtins.bool emails_enabled: Enable email notifications.
        :param _builtins.bool empty_repo: Whether the project is empty.
        :param _builtins.str environments_access_level: Set the environments access level. Valid values are `disabled`, `private`, `enabled`.
        :param _builtins.str external_authorization_classification_label: The classification label for the project.
        :param _builtins.str feature_flags_access_level: Set the feature flags access level. Valid values are `disabled`, `private`, `enabled`.
        :param Sequence['GetProjectsProjectForkedFromProjectArgs'] forked_from_projects: Present if the project is a fork. Contains information about the upstream project.
        :param _builtins.str forking_access_level: Set the forking access level. Valid values are `disabled`, `private`, `enabled`.
        :param _builtins.int forks_count: The number of forks of the project.
        :param _builtins.bool group_runners_enabled: Whether group runners are enabled for the project.
        :param _builtins.str http_url_to_repo: The HTTP clone URL of the project.
        :param _builtins.int id: The ID of the project.
        :param _builtins.str import_error: The import error, if it exists, for the project.
        :param _builtins.str import_status: The import status of the project.
        :param _builtins.str import_url: URL the project was imported from.
        :param _builtins.str infrastructure_access_level: Set the infrastructure access level. Valid values are `disabled`, `private`, `enabled`.
        :param _builtins.str issues_access_level: Set the issues access level. Valid values are `disabled`, `private`, `enabled`.
        :param _builtins.bool issues_enabled: Whether issues are enabled for the project.
        :param _builtins.bool jobs_enabled: Whether pipelines are enabled for the project.
        :param _builtins.bool keep_latest_artifact: Disable or enable the ability to keep the latest artifact for this project.
        :param _builtins.str last_activity_at: Last activirty time for the project.
        :param _builtins.bool lfs_enabled: Whether LFS (large file storage) is enabled for the project.
        :param Mapping[str, _builtins.str] links: Links for the project.
        :param _builtins.str merge_commit_template: Template used to create merge commit message in merge requests.
        :param _builtins.str merge_method: Merge method for the project.
        :param _builtins.bool merge_pipelines_enabled: Enable or disable merge pipelines.
        :param _builtins.str merge_requests_access_level: Set the merge requests access level. Valid values are `disabled`, `private`, `enabled`.
        :param _builtins.bool merge_requests_enabled: Whether merge requests are enabled for the project.
        :param _builtins.bool merge_trains_enabled: Enable or disable merge trains.
        :param _builtins.bool mirror: Whether the pull mirroring is enabled for the project.
        :param _builtins.bool mirror_overwrites_diverged_branches: Whether mirror_overwrites_diverged_branches is enabled for the project.
        :param _builtins.bool mirror_trigger_builds: Whether pull mirroring triggers builds for the project.
        :param _builtins.int mirror_user_id: The mirror user ID for the project.
        :param _builtins.str model_experiments_access_level: The visibility of machine learning model experiments.
        :param _builtins.str model_registry_access_level: The visibility of machine learning model registry.
        :param _builtins.str monitor_access_level: Set the monitor access level. Valid values are `disabled`, `private`, `enabled`.
        :param _builtins.str name: The name of the project.
        :param _builtins.str name_with_namespace: In `group / subgroup / project` or `user / project` format.
        :param Sequence['GetProjectsProjectNamespaceArgs'] namespaces: Namespace of the project (parent group/s).
        :param _builtins.bool only_allow_merge_if_all_discussions_are_resolved: Whether only_allow_merge_if_all_discussions_are_resolved is enabled for the project.
        :param _builtins.bool only_allow_merge_if_pipeline_succeeds: Whether only_allow_merge_if_pipeline_succeeds is enabled for the project.
        :param _builtins.bool only_mirror_protected_branches: Whether only_mirror_protected_branches is enabled for the project.
        :param _builtins.int open_issues_count: The number of open issies for the project.
        :param _builtins.bool packages_enabled: Whether packages are enabled for the project.
        :param _builtins.str path: The path of the project.
        :param _builtins.str path_with_namespace: In `group/subgroup/project` or `user/project` format.
        :param Sequence['GetProjectsProjectPermissionArgs'] permissions: Permissions for the project.
        :param _builtins.bool prevent_merge_without_jira_issue: Whether merge requests require an associated issue from Jira. Premium and Ultimate only.
        :param _builtins.bool public_builds: Whether public builds are enabled for the project.
        :param _builtins.str readme_url: The remote url of the project.
        :param _builtins.str releases_access_level: Set the releases access level. Valid values are `disabled`, `private`, `enabled`.
        :param _builtins.str repository_access_level: Set the repository access level. Valid values are `disabled`, `private`, `enabled`.
        :param _builtins.str repository_storage: Which storage shard the repository is on. (administrator only)
        :param _builtins.bool request_access_enabled: Whether requesting access is enabled for the project.
        :param _builtins.str requirements_access_level: Set the requirements access level. Valid values are `disabled`, `private`, `enabled`.
        :param _builtins.bool resolve_outdated_diff_discussions: Whether resolve_outdated_diff_discussions is enabled for the project
        :param _builtins.str resource_group_default_process_mode: The default resource group process mode for the project.
        :param _builtins.bool restrict_user_defined_variables: Allow only users with the Maintainer role to pass user-defined variables when triggering a pipeline.
        :param _builtins.str runners_token: The runners token for the project.
        :param _builtins.str security_and_compliance_access_level: Set the security and compliance access level. Valid values are `disabled`, `private`, `enabled`.
        :param _builtins.bool shared_runners_enabled: Whether shared runners are enabled for the project.
        :param Sequence['GetProjectsProjectSharedWithGroupArgs'] shared_with_groups: Groups the the project is shared with.
        :param _builtins.str snippets_access_level: Set the snippets access level. Valid values are `disabled`, `private`, `enabled`.
        :param _builtins.bool snippets_enabled: Whether snippets are enabled for the project.
        :param _builtins.str squash_commit_template: Template used to create squash commit message in merge requests.
        :param _builtins.str ssh_url_to_repo: The SSH clone URL of the project.
        :param _builtins.int star_count: The number of stars on the project.
        :param Mapping[str, _builtins.int] statistics: Statistics for the project.
        :param _builtins.str suggestion_commit_message: The commit message used to apply merge request suggestions.
        :param Sequence[_builtins.str] tag_lists: A set of the project topics (formerly called "project tags").
        :param Sequence[_builtins.str] topics: The list of topics for the project.
        :param _builtins.str visibility: The visibility of the project.
        :param _builtins.str web_url: The web url of the project.
        :param _builtins.str wiki_access_level: Set the wiki access level. Valid values are `disabled`, `private`, `enabled`.
        :param _builtins.bool wiki_enabled: Whether wiki is enabled for the project.
        """
        pulumi.set(__self__, "_links", _links)
        pulumi.set(__self__, "allow_merge_on_skipped_pipeline", allow_merge_on_skipped_pipeline)
        pulumi.set(__self__, "allow_pipeline_trigger_approve_deployment", allow_pipeline_trigger_approve_deployment)
        pulumi.set(__self__, "analytics_access_level", analytics_access_level)
        pulumi.set(__self__, "approvals_before_merge", approvals_before_merge)
        pulumi.set(__self__, "archived", archived)
        pulumi.set(__self__, "auto_cancel_pending_pipelines", auto_cancel_pending_pipelines)
        pulumi.set(__self__, "auto_devops_deploy_strategy", auto_devops_deploy_strategy)
        pulumi.set(__self__, "auto_devops_enabled", auto_devops_enabled)
        pulumi.set(__self__, "autoclose_referenced_issues", autoclose_referenced_issues)
        pulumi.set(__self__, "avatar_url", avatar_url)
        pulumi.set(__self__, "build_coverage_regex", build_coverage_regex)
        pulumi.set(__self__, "build_git_strategy", build_git_strategy)
        pulumi.set(__self__, "build_timeout", build_timeout)
        pulumi.set(__self__, "builds_access_level", builds_access_level)
        pulumi.set(__self__, "ci_config_path", ci_config_path)
        pulumi.set(__self__, "ci_default_git_depth", ci_default_git_depth)
        pulumi.set(__self__, "ci_delete_pipelines_in_seconds", ci_delete_pipelines_in_seconds)
        pulumi.set(__self__, "ci_forward_deployment_enabled", ci_forward_deployment_enabled)
        pulumi.set(__self__, "ci_forward_deployment_rollback_allowed", ci_forward_deployment_rollback_allowed)
        pulumi.set(__self__, "ci_id_token_sub_claim_components", ci_id_token_sub_claim_components)
        pulumi.set(__self__, "ci_pipeline_variables_minimum_override_role", ci_pipeline_variables_minimum_override_role)
        pulumi.set(__self__, "ci_restrict_pipeline_cancellation_role", ci_restrict_pipeline_cancellation_role)
        pulumi.set(__self__, "container_expiration_policies", container_expiration_policies)
        pulumi.set(__self__, "container_registry_access_level", container_registry_access_level)
        pulumi.set(__self__, "container_registry_enabled", container_registry_enabled)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "creator_id", creator_id)
        pulumi.set(__self__, "custom_attributes", custom_attributes)
        pulumi.set(__self__, "default_branch", default_branch)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "emails_enabled", emails_enabled)
        pulumi.set(__self__, "empty_repo", empty_repo)
        pulumi.set(__self__, "environments_access_level", environments_access_level)
        pulumi.set(__self__, "external_authorization_classification_label", external_authorization_classification_label)
        pulumi.set(__self__, "feature_flags_access_level", feature_flags_access_level)
        pulumi.set(__self__, "forked_from_projects", forked_from_projects)
        pulumi.set(__self__, "forking_access_level", forking_access_level)
        pulumi.set(__self__, "forks_count", forks_count)
        pulumi.set(__self__, "group_runners_enabled", group_runners_enabled)
        pulumi.set(__self__, "http_url_to_repo", http_url_to_repo)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "import_error", import_error)
        pulumi.set(__self__, "import_status", import_status)
        pulumi.set(__self__, "import_url", import_url)
        pulumi.set(__self__, "infrastructure_access_level", infrastructure_access_level)
        pulumi.set(__self__, "issues_access_level", issues_access_level)
        pulumi.set(__self__, "issues_enabled", issues_enabled)
        pulumi.set(__self__, "jobs_enabled", jobs_enabled)
        pulumi.set(__self__, "keep_latest_artifact", keep_latest_artifact)
        pulumi.set(__self__, "last_activity_at", last_activity_at)
        pulumi.set(__self__, "lfs_enabled", lfs_enabled)
        pulumi.set(__self__, "links", links)
        pulumi.set(__self__, "merge_commit_template", merge_commit_template)
        pulumi.set(__self__, "merge_method", merge_method)
        pulumi.set(__self__, "merge_pipelines_enabled", merge_pipelines_enabled)
        pulumi.set(__self__, "merge_requests_access_level", merge_requests_access_level)
        pulumi.set(__self__, "merge_requests_enabled", merge_requests_enabled)
        pulumi.set(__self__, "merge_trains_enabled", merge_trains_enabled)
        pulumi.set(__self__, "mirror", mirror)
        pulumi.set(__self__, "mirror_overwrites_diverged_branches", mirror_overwrites_diverged_branches)
        pulumi.set(__self__, "mirror_trigger_builds", mirror_trigger_builds)
        pulumi.set(__self__, "mirror_user_id", mirror_user_id)
        pulumi.set(__self__, "model_experiments_access_level", model_experiments_access_level)
        pulumi.set(__self__, "model_registry_access_level", model_registry_access_level)
        pulumi.set(__self__, "monitor_access_level", monitor_access_level)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "name_with_namespace", name_with_namespace)
        pulumi.set(__self__, "namespaces", namespaces)
        pulumi.set(__self__, "only_allow_merge_if_all_discussions_are_resolved", only_allow_merge_if_all_discussions_are_resolved)
        pulumi.set(__self__, "only_allow_merge_if_pipeline_succeeds", only_allow_merge_if_pipeline_succeeds)
        pulumi.set(__self__, "only_mirror_protected_branches", only_mirror_protected_branches)
        pulumi.set(__self__, "open_issues_count", open_issues_count)
        pulumi.set(__self__, "owners", owners)
        pulumi.set(__self__, "packages_enabled", packages_enabled)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "path_with_namespace", path_with_namespace)
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "prevent_merge_without_jira_issue", prevent_merge_without_jira_issue)
        pulumi.set(__self__, "public_builds", public_builds)
        pulumi.set(__self__, "readme_url", readme_url)
        pulumi.set(__self__, "releases_access_level", releases_access_level)
        pulumi.set(__self__, "repository_access_level", repository_access_level)
        pulumi.set(__self__, "repository_storage", repository_storage)
        pulumi.set(__self__, "request_access_enabled", request_access_enabled)
        pulumi.set(__self__, "requirements_access_level", requirements_access_level)
        pulumi.set(__self__, "resolve_outdated_diff_discussions", resolve_outdated_diff_discussions)
        pulumi.set(__self__, "resource_group_default_process_mode", resource_group_default_process_mode)
        pulumi.set(__self__, "restrict_user_defined_variables", restrict_user_defined_variables)
        pulumi.set(__self__, "runners_token", runners_token)
        pulumi.set(__self__, "security_and_compliance_access_level", security_and_compliance_access_level)
        pulumi.set(__self__, "shared_runners_enabled", shared_runners_enabled)
        pulumi.set(__self__, "shared_with_groups", shared_with_groups)
        pulumi.set(__self__, "snippets_access_level", snippets_access_level)
        pulumi.set(__self__, "snippets_enabled", snippets_enabled)
        pulumi.set(__self__, "squash_commit_template", squash_commit_template)
        pulumi.set(__self__, "ssh_url_to_repo", ssh_url_to_repo)
        pulumi.set(__self__, "star_count", star_count)
        pulumi.set(__self__, "statistics", statistics)
        pulumi.set(__self__, "suggestion_commit_message", suggestion_commit_message)
        pulumi.set(__self__, "tag_lists", tag_lists)
        pulumi.set(__self__, "topics", topics)
        pulumi.set(__self__, "visibility", visibility)
        pulumi.set(__self__, "web_url", web_url)
        pulumi.set(__self__, "wiki_access_level", wiki_access_level)
        pulumi.set(__self__, "wiki_enabled", wiki_enabled)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Use `links` instead. To be removed in 19.0.""")
    def _links(self) -> Mapping[str, _builtins.str]:
        """
        Links for the project. Use `links` instead. To be removed in 19.0.
        """
        return pulumi.get(self, "_links")

    @_builtins.property
    @pulumi.getter(name="allowMergeOnSkippedPipeline")
    def allow_merge_on_skipped_pipeline(self) -> _builtins.bool:
        """
        Whether allow_merge_on_skipped_pipeline is enabled for the project.
        """
        return pulumi.get(self, "allow_merge_on_skipped_pipeline")

    @_builtins.property
    @pulumi.getter(name="allowPipelineTriggerApproveDeployment")
    def allow_pipeline_trigger_approve_deployment(self) -> _builtins.bool:
        """
        Set whether or not a pipeline triggerer is allowed to approve deployments. Premium and Ultimate only.
        """
        return pulumi.get(self, "allow_pipeline_trigger_approve_deployment")

    @_builtins.property
    @pulumi.getter(name="analyticsAccessLevel")
    def analytics_access_level(self) -> _builtins.str:
        """
        Set the analytics access level. Valid values are `disabled`, `private`, `enabled`.
        """
        return pulumi.get(self, "analytics_access_level")

    @_builtins.property
    @pulumi.getter(name="approvalsBeforeMerge")
    def approvals_before_merge(self) -> _builtins.int:
        """
        The numbers of approvals needed in a merge requests.
        """
        return pulumi.get(self, "approvals_before_merge")

    @_builtins.property
    @pulumi.getter
    def archived(self) -> _builtins.bool:
        """
        Whether the project is archived.
        """
        return pulumi.get(self, "archived")

    @_builtins.property
    @pulumi.getter(name="autoCancelPendingPipelines")
    def auto_cancel_pending_pipelines(self) -> _builtins.str:
        """
        Auto-cancel pending pipelines. This isnt a boolean, but enabled/disabled.
        """
        return pulumi.get(self, "auto_cancel_pending_pipelines")

    @_builtins.property
    @pulumi.getter(name="autoDevopsDeployStrategy")
    def auto_devops_deploy_strategy(self) -> _builtins.str:
        """
        Auto Deploy strategy. Valid values are `continuous`, `manual`, `timed_incremental`.
        """
        return pulumi.get(self, "auto_devops_deploy_strategy")

    @_builtins.property
    @pulumi.getter(name="autoDevopsEnabled")
    def auto_devops_enabled(self) -> _builtins.bool:
        """
        Enable Auto DevOps for this project.
        """
        return pulumi.get(self, "auto_devops_enabled")

    @_builtins.property
    @pulumi.getter(name="autocloseReferencedIssues")
    def autoclose_referenced_issues(self) -> _builtins.bool:
        """
        Set whether auto-closing referenced issues on default branch.
        """
        return pulumi.get(self, "autoclose_referenced_issues")

    @_builtins.property
    @pulumi.getter(name="avatarUrl")
    def avatar_url(self) -> _builtins.str:
        """
        The avatar url of the project.
        """
        return pulumi.get(self, "avatar_url")

    @_builtins.property
    @pulumi.getter(name="buildCoverageRegex")
    def build_coverage_regex(self) -> _builtins.str:
        """
        Build coverage regex for the project.
        """
        return pulumi.get(self, "build_coverage_regex")

    @_builtins.property
    @pulumi.getter(name="buildGitStrategy")
    def build_git_strategy(self) -> _builtins.str:
        """
        The Git strategy. Defaults to fetch.
        """
        return pulumi.get(self, "build_git_strategy")

    @_builtins.property
    @pulumi.getter(name="buildTimeout")
    def build_timeout(self) -> _builtins.int:
        """
        The maximum amount of time, in seconds, that a job can run.
        """
        return pulumi.get(self, "build_timeout")

    @_builtins.property
    @pulumi.getter(name="buildsAccessLevel")
    def builds_access_level(self) -> _builtins.str:
        """
        Set the builds access level. Valid values are `disabled`, `private`, `enabled`.
        """
        return pulumi.get(self, "builds_access_level")

    @_builtins.property
    @pulumi.getter(name="ciConfigPath")
    def ci_config_path(self) -> _builtins.str:
        """
        CI config file path for the project.
        """
        return pulumi.get(self, "ci_config_path")

    @_builtins.property
    @pulumi.getter(name="ciDefaultGitDepth")
    def ci_default_git_depth(self) -> _builtins.int:
        """
        Default number of revisions for shallow cloning.
        """
        return pulumi.get(self, "ci_default_git_depth")

    @_builtins.property
    @pulumi.getter(name="ciDeletePipelinesInSeconds")
    def ci_delete_pipelines_in_seconds(self) -> _builtins.int:
        """
        Pipelines older than the configured time are deleted.
        """
        return pulumi.get(self, "ci_delete_pipelines_in_seconds")

    @_builtins.property
    @pulumi.getter(name="ciForwardDeploymentEnabled")
    def ci_forward_deployment_enabled(self) -> _builtins.bool:
        """
        When a new deployment job starts, skip older deployment jobs that are still pending.
        """
        return pulumi.get(self, "ci_forward_deployment_enabled")

    @_builtins.property
    @pulumi.getter(name="ciForwardDeploymentRollbackAllowed")
    def ci_forward_deployment_rollback_allowed(self) -> _builtins.bool:
        """
        Allow job retries even if the deployment job is outdated.
        """
        return pulumi.get(self, "ci_forward_deployment_rollback_allowed")

    @_builtins.property
    @pulumi.getter(name="ciIdTokenSubClaimComponents")
    def ci_id_token_sub_claim_components(self) -> Sequence[_builtins.str]:
        """
        Fields included in the sub claim of the ID Token. Accepts an array starting with project_path. The array might also include ref_type and ref. Defaults to ["project_path", "ref_type", "ref"]. Introduced in GitLab 17.10.
        """
        return pulumi.get(self, "ci_id_token_sub_claim_components")

    @_builtins.property
    @pulumi.getter(name="ciPipelineVariablesMinimumOverrideRole")
    def ci_pipeline_variables_minimum_override_role(self) -> _builtins.str:
        """
        The minimum role required to set variables when running pipelines and jobs. Introduced in GitLab 17.1. Valid values are `developer`, `maintainer`, `owner`, `no_one_allowed`
        """
        return pulumi.get(self, "ci_pipeline_variables_minimum_override_role")

    @_builtins.property
    @pulumi.getter(name="ciRestrictPipelineCancellationRole")
    def ci_restrict_pipeline_cancellation_role(self) -> _builtins.str:
        """
        The role required to cancel a pipeline or job. Premium and Ultimate only. Valid values are `developer`, `maintainer`, `no one`
        """
        return pulumi.get(self, "ci_restrict_pipeline_cancellation_role")

    @_builtins.property
    @pulumi.getter(name="containerExpirationPolicies")
    def container_expiration_policies(self) -> Sequence['outputs.GetProjectsProjectContainerExpirationPolicyResult']:
        """
        Set the image cleanup policy for this project. **Note**: this field is sometimes named `container_expiration_policy_attributes` in the GitLab Upstream API.
        """
        return pulumi.get(self, "container_expiration_policies")

    @_builtins.property
    @pulumi.getter(name="containerRegistryAccessLevel")
    def container_registry_access_level(self) -> _builtins.str:
        """
        Set visibility of container registry, for this project. Valid values are `disabled`, `private`, `enabled`.
        """
        return pulumi.get(self, "container_registry_access_level")

    @_builtins.property
    @pulumi.getter(name="containerRegistryEnabled")
    def container_registry_enabled(self) -> _builtins.bool:
        """
        Whether the container registry is enabled for the project.
        """
        return pulumi.get(self, "container_registry_enabled")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Creation time for the project.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="creatorId")
    def creator_id(self) -> _builtins.int:
        """
        Creator ID for the project.
        """
        return pulumi.get(self, "creator_id")

    @_builtins.property
    @pulumi.getter(name="customAttributes")
    def custom_attributes(self) -> Sequence[Mapping[str, _builtins.str]]:
        """
        Custom attributes for the project.
        """
        return pulumi.get(self, "custom_attributes")

    @_builtins.property
    @pulumi.getter(name="defaultBranch")
    def default_branch(self) -> _builtins.str:
        """
        The default branch name of the project.
        """
        return pulumi.get(self, "default_branch")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the project.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="emailsEnabled")
    def emails_enabled(self) -> _builtins.bool:
        """
        Enable email notifications.
        """
        return pulumi.get(self, "emails_enabled")

    @_builtins.property
    @pulumi.getter(name="emptyRepo")
    def empty_repo(self) -> _builtins.bool:
        """
        Whether the project is empty.
        """
        return pulumi.get(self, "empty_repo")

    @_builtins.property
    @pulumi.getter(name="environmentsAccessLevel")
    def environments_access_level(self) -> _builtins.str:
        """
        Set the environments access level. Valid values are `disabled`, `private`, `enabled`.
        """
        return pulumi.get(self, "environments_access_level")

    @_builtins.property
    @pulumi.getter(name="externalAuthorizationClassificationLabel")
    def external_authorization_classification_label(self) -> _builtins.str:
        """
        The classification label for the project.
        """
        return pulumi.get(self, "external_authorization_classification_label")

    @_builtins.property
    @pulumi.getter(name="featureFlagsAccessLevel")
    def feature_flags_access_level(self) -> _builtins.str:
        """
        Set the feature flags access level. Valid values are `disabled`, `private`, `enabled`.
        """
        return pulumi.get(self, "feature_flags_access_level")

    @_builtins.property
    @pulumi.getter(name="forkedFromProjects")
    def forked_from_projects(self) -> Sequence['outputs.GetProjectsProjectForkedFromProjectResult']:
        """
        Present if the project is a fork. Contains information about the upstream project.
        """
        return pulumi.get(self, "forked_from_projects")

    @_builtins.property
    @pulumi.getter(name="forkingAccessLevel")
    def forking_access_level(self) -> _builtins.str:
        """
        Set the forking access level. Valid values are `disabled`, `private`, `enabled`.
        """
        return pulumi.get(self, "forking_access_level")

    @_builtins.property
    @pulumi.getter(name="forksCount")
    def forks_count(self) -> _builtins.int:
        """
        The number of forks of the project.
        """
        return pulumi.get(self, "forks_count")

    @_builtins.property
    @pulumi.getter(name="groupRunnersEnabled")
    def group_runners_enabled(self) -> _builtins.bool:
        """
        Whether group runners are enabled for the project.
        """
        return pulumi.get(self, "group_runners_enabled")

    @_builtins.property
    @pulumi.getter(name="httpUrlToRepo")
    def http_url_to_repo(self) -> _builtins.str:
        """
        The HTTP clone URL of the project.
        """
        return pulumi.get(self, "http_url_to_repo")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The ID of the project.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="importError")
    def import_error(self) -> _builtins.str:
        """
        The import error, if it exists, for the project.
        """
        return pulumi.get(self, "import_error")

    @_builtins.property
    @pulumi.getter(name="importStatus")
    def import_status(self) -> _builtins.str:
        """
        The import status of the project.
        """
        return pulumi.get(self, "import_status")

    @_builtins.property
    @pulumi.getter(name="importUrl")
    def import_url(self) -> _builtins.str:
        """
        URL the project was imported from.
        """
        return pulumi.get(self, "import_url")

    @_builtins.property
    @pulumi.getter(name="infrastructureAccessLevel")
    def infrastructure_access_level(self) -> _builtins.str:
        """
        Set the infrastructure access level. Valid values are `disabled`, `private`, `enabled`.
        """
        return pulumi.get(self, "infrastructure_access_level")

    @_builtins.property
    @pulumi.getter(name="issuesAccessLevel")
    def issues_access_level(self) -> _builtins.str:
        """
        Set the issues access level. Valid values are `disabled`, `private`, `enabled`.
        """
        return pulumi.get(self, "issues_access_level")

    @_builtins.property
    @pulumi.getter(name="issuesEnabled")
    def issues_enabled(self) -> _builtins.bool:
        """
        Whether issues are enabled for the project.
        """
        return pulumi.get(self, "issues_enabled")

    @_builtins.property
    @pulumi.getter(name="jobsEnabled")
    def jobs_enabled(self) -> _builtins.bool:
        """
        Whether pipelines are enabled for the project.
        """
        return pulumi.get(self, "jobs_enabled")

    @_builtins.property
    @pulumi.getter(name="keepLatestArtifact")
    def keep_latest_artifact(self) -> _builtins.bool:
        """
        Disable or enable the ability to keep the latest artifact for this project.
        """
        return pulumi.get(self, "keep_latest_artifact")

    @_builtins.property
    @pulumi.getter(name="lastActivityAt")
    def last_activity_at(self) -> _builtins.str:
        """
        Last activirty time for the project.
        """
        return pulumi.get(self, "last_activity_at")

    @_builtins.property
    @pulumi.getter(name="lfsEnabled")
    def lfs_enabled(self) -> _builtins.bool:
        """
        Whether LFS (large file storage) is enabled for the project.
        """
        return pulumi.get(self, "lfs_enabled")

    @_builtins.property
    @pulumi.getter
    def links(self) -> Mapping[str, _builtins.str]:
        """
        Links for the project.
        """
        return pulumi.get(self, "links")

    @_builtins.property
    @pulumi.getter(name="mergeCommitTemplate")
    def merge_commit_template(self) -> _builtins.str:
        """
        Template used to create merge commit message in merge requests.
        """
        return pulumi.get(self, "merge_commit_template")

    @_builtins.property
    @pulumi.getter(name="mergeMethod")
    def merge_method(self) -> _builtins.str:
        """
        Merge method for the project.
        """
        return pulumi.get(self, "merge_method")

    @_builtins.property
    @pulumi.getter(name="mergePipelinesEnabled")
    def merge_pipelines_enabled(self) -> _builtins.bool:
        """
        Enable or disable merge pipelines.
        """
        return pulumi.get(self, "merge_pipelines_enabled")

    @_builtins.property
    @pulumi.getter(name="mergeRequestsAccessLevel")
    def merge_requests_access_level(self) -> _builtins.str:
        """
        Set the merge requests access level. Valid values are `disabled`, `private`, `enabled`.
        """
        return pulumi.get(self, "merge_requests_access_level")

    @_builtins.property
    @pulumi.getter(name="mergeRequestsEnabled")
    def merge_requests_enabled(self) -> _builtins.bool:
        """
        Whether merge requests are enabled for the project.
        """
        return pulumi.get(self, "merge_requests_enabled")

    @_builtins.property
    @pulumi.getter(name="mergeTrainsEnabled")
    def merge_trains_enabled(self) -> _builtins.bool:
        """
        Enable or disable merge trains.
        """
        return pulumi.get(self, "merge_trains_enabled")

    @_builtins.property
    @pulumi.getter
    def mirror(self) -> _builtins.bool:
        """
        Whether the pull mirroring is enabled for the project.
        """
        return pulumi.get(self, "mirror")

    @_builtins.property
    @pulumi.getter(name="mirrorOverwritesDivergedBranches")
    def mirror_overwrites_diverged_branches(self) -> _builtins.bool:
        """
        Whether mirror_overwrites_diverged_branches is enabled for the project.
        """
        return pulumi.get(self, "mirror_overwrites_diverged_branches")

    @_builtins.property
    @pulumi.getter(name="mirrorTriggerBuilds")
    def mirror_trigger_builds(self) -> _builtins.bool:
        """
        Whether pull mirroring triggers builds for the project.
        """
        return pulumi.get(self, "mirror_trigger_builds")

    @_builtins.property
    @pulumi.getter(name="mirrorUserId")
    def mirror_user_id(self) -> _builtins.int:
        """
        The mirror user ID for the project.
        """
        return pulumi.get(self, "mirror_user_id")

    @_builtins.property
    @pulumi.getter(name="modelExperimentsAccessLevel")
    def model_experiments_access_level(self) -> _builtins.str:
        """
        The visibility of machine learning model experiments.
        """
        return pulumi.get(self, "model_experiments_access_level")

    @_builtins.property
    @pulumi.getter(name="modelRegistryAccessLevel")
    def model_registry_access_level(self) -> _builtins.str:
        """
        The visibility of machine learning model registry.
        """
        return pulumi.get(self, "model_registry_access_level")

    @_builtins.property
    @pulumi.getter(name="monitorAccessLevel")
    def monitor_access_level(self) -> _builtins.str:
        """
        Set the monitor access level. Valid values are `disabled`, `private`, `enabled`.
        """
        return pulumi.get(self, "monitor_access_level")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the project.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nameWithNamespace")
    def name_with_namespace(self) -> _builtins.str:
        """
        In `group / subgroup / project` or `user / project` format.
        """
        return pulumi.get(self, "name_with_namespace")

    @_builtins.property
    @pulumi.getter
    def namespaces(self) -> Sequence['outputs.GetProjectsProjectNamespaceResult']:
        """
        Namespace of the project (parent group/s).
        """
        return pulumi.get(self, "namespaces")

    @_builtins.property
    @pulumi.getter(name="onlyAllowMergeIfAllDiscussionsAreResolved")
    def only_allow_merge_if_all_discussions_are_resolved(self) -> _builtins.bool:
        """
        Whether only_allow_merge_if_all_discussions_are_resolved is enabled for the project.
        """
        return pulumi.get(self, "only_allow_merge_if_all_discussions_are_resolved")

    @_builtins.property
    @pulumi.getter(name="onlyAllowMergeIfPipelineSucceeds")
    def only_allow_merge_if_pipeline_succeeds(self) -> _builtins.bool:
        """
        Whether only_allow_merge_if_pipeline_succeeds is enabled for the project.
        """
        return pulumi.get(self, "only_allow_merge_if_pipeline_succeeds")

    @_builtins.property
    @pulumi.getter(name="onlyMirrorProtectedBranches")
    def only_mirror_protected_branches(self) -> _builtins.bool:
        """
        Whether only_mirror_protected_branches is enabled for the project.
        """
        return pulumi.get(self, "only_mirror_protected_branches")

    @_builtins.property
    @pulumi.getter(name="openIssuesCount")
    def open_issues_count(self) -> _builtins.int:
        """
        The number of open issies for the project.
        """
        return pulumi.get(self, "open_issues_count")

    @_builtins.property
    @pulumi.getter
    def owners(self) -> Sequence['outputs.GetProjectsProjectOwnerResult']:
        return pulumi.get(self, "owners")

    @_builtins.property
    @pulumi.getter(name="packagesEnabled")
    def packages_enabled(self) -> _builtins.bool:
        """
        Whether packages are enabled for the project.
        """
        return pulumi.get(self, "packages_enabled")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The path of the project.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="pathWithNamespace")
    def path_with_namespace(self) -> _builtins.str:
        """
        In `group/subgroup/project` or `user/project` format.
        """
        return pulumi.get(self, "path_with_namespace")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Sequence['outputs.GetProjectsProjectPermissionResult']:
        """
        Permissions for the project.
        """
        return pulumi.get(self, "permissions")

    @_builtins.property
    @pulumi.getter(name="preventMergeWithoutJiraIssue")
    def prevent_merge_without_jira_issue(self) -> _builtins.bool:
        """
        Whether merge requests require an associated issue from Jira. Premium and Ultimate only.
        """
        return pulumi.get(self, "prevent_merge_without_jira_issue")

    @_builtins.property
    @pulumi.getter(name="publicBuilds")
    def public_builds(self) -> _builtins.bool:
        """
        Whether public builds are enabled for the project.
        """
        return pulumi.get(self, "public_builds")

    @_builtins.property
    @pulumi.getter(name="readmeUrl")
    def readme_url(self) -> _builtins.str:
        """
        The remote url of the project.
        """
        return pulumi.get(self, "readme_url")

    @_builtins.property
    @pulumi.getter(name="releasesAccessLevel")
    def releases_access_level(self) -> _builtins.str:
        """
        Set the releases access level. Valid values are `disabled`, `private`, `enabled`.
        """
        return pulumi.get(self, "releases_access_level")

    @_builtins.property
    @pulumi.getter(name="repositoryAccessLevel")
    def repository_access_level(self) -> _builtins.str:
        """
        Set the repository access level. Valid values are `disabled`, `private`, `enabled`.
        """
        return pulumi.get(self, "repository_access_level")

    @_builtins.property
    @pulumi.getter(name="repositoryStorage")
    def repository_storage(self) -> _builtins.str:
        """
        Which storage shard the repository is on. (administrator only)
        """
        return pulumi.get(self, "repository_storage")

    @_builtins.property
    @pulumi.getter(name="requestAccessEnabled")
    def request_access_enabled(self) -> _builtins.bool:
        """
        Whether requesting access is enabled for the project.
        """
        return pulumi.get(self, "request_access_enabled")

    @_builtins.property
    @pulumi.getter(name="requirementsAccessLevel")
    def requirements_access_level(self) -> _builtins.str:
        """
        Set the requirements access level. Valid values are `disabled`, `private`, `enabled`.
        """
        return pulumi.get(self, "requirements_access_level")

    @_builtins.property
    @pulumi.getter(name="resolveOutdatedDiffDiscussions")
    def resolve_outdated_diff_discussions(self) -> _builtins.bool:
        """
        Whether resolve_outdated_diff_discussions is enabled for the project
        """
        return pulumi.get(self, "resolve_outdated_diff_discussions")

    @_builtins.property
    @pulumi.getter(name="resourceGroupDefaultProcessMode")
    def resource_group_default_process_mode(self) -> _builtins.str:
        """
        The default resource group process mode for the project.
        """
        return pulumi.get(self, "resource_group_default_process_mode")

    @_builtins.property
    @pulumi.getter(name="restrictUserDefinedVariables")
    def restrict_user_defined_variables(self) -> _builtins.bool:
        """
        Allow only users with the Maintainer role to pass user-defined variables when triggering a pipeline.
        """
        return pulumi.get(self, "restrict_user_defined_variables")

    @_builtins.property
    @pulumi.getter(name="runnersToken")
    def runners_token(self) -> _builtins.str:
        """
        The runners token for the project.
        """
        return pulumi.get(self, "runners_token")

    @_builtins.property
    @pulumi.getter(name="securityAndComplianceAccessLevel")
    def security_and_compliance_access_level(self) -> _builtins.str:
        """
        Set the security and compliance access level. Valid values are `disabled`, `private`, `enabled`.
        """
        return pulumi.get(self, "security_and_compliance_access_level")

    @_builtins.property
    @pulumi.getter(name="sharedRunnersEnabled")
    def shared_runners_enabled(self) -> _builtins.bool:
        """
        Whether shared runners are enabled for the project.
        """
        return pulumi.get(self, "shared_runners_enabled")

    @_builtins.property
    @pulumi.getter(name="sharedWithGroups")
    def shared_with_groups(self) -> Sequence['outputs.GetProjectsProjectSharedWithGroupResult']:
        """
        Groups the the project is shared with.
        """
        return pulumi.get(self, "shared_with_groups")

    @_builtins.property
    @pulumi.getter(name="snippetsAccessLevel")
    def snippets_access_level(self) -> _builtins.str:
        """
        Set the snippets access level. Valid values are `disabled`, `private`, `enabled`.
        """
        return pulumi.get(self, "snippets_access_level")

    @_builtins.property
    @pulumi.getter(name="snippetsEnabled")
    def snippets_enabled(self) -> _builtins.bool:
        """
        Whether snippets are enabled for the project.
        """
        return pulumi.get(self, "snippets_enabled")

    @_builtins.property
    @pulumi.getter(name="squashCommitTemplate")
    def squash_commit_template(self) -> _builtins.str:
        """
        Template used to create squash commit message in merge requests.
        """
        return pulumi.get(self, "squash_commit_template")

    @_builtins.property
    @pulumi.getter(name="sshUrlToRepo")
    def ssh_url_to_repo(self) -> _builtins.str:
        """
        The SSH clone URL of the project.
        """
        return pulumi.get(self, "ssh_url_to_repo")

    @_builtins.property
    @pulumi.getter(name="starCount")
    def star_count(self) -> _builtins.int:
        """
        The number of stars on the project.
        """
        return pulumi.get(self, "star_count")

    @_builtins.property
    @pulumi.getter
    def statistics(self) -> Mapping[str, _builtins.int]:
        """
        Statistics for the project.
        """
        return pulumi.get(self, "statistics")

    @_builtins.property
    @pulumi.getter(name="suggestionCommitMessage")
    def suggestion_commit_message(self) -> _builtins.str:
        """
        The commit message used to apply merge request suggestions.
        """
        return pulumi.get(self, "suggestion_commit_message")

    @_builtins.property
    @pulumi.getter(name="tagLists")
    def tag_lists(self) -> Sequence[_builtins.str]:
        """
        A set of the project topics (formerly called "project tags").
        """
        return pulumi.get(self, "tag_lists")

    @_builtins.property
    @pulumi.getter
    def topics(self) -> Sequence[_builtins.str]:
        """
        The list of topics for the project.
        """
        return pulumi.get(self, "topics")

    @_builtins.property
    @pulumi.getter
    def visibility(self) -> _builtins.str:
        """
        The visibility of the project.
        """
        return pulumi.get(self, "visibility")

    @_builtins.property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> _builtins.str:
        """
        The web url of the project.
        """
        return pulumi.get(self, "web_url")

    @_builtins.property
    @pulumi.getter(name="wikiAccessLevel")
    def wiki_access_level(self) -> _builtins.str:
        """
        Set the wiki access level. Valid values are `disabled`, `private`, `enabled`.
        """
        return pulumi.get(self, "wiki_access_level")

    @_builtins.property
    @pulumi.getter(name="wikiEnabled")
    def wiki_enabled(self) -> _builtins.bool:
        """
        Whether wiki is enabled for the project.
        """
        return pulumi.get(self, "wiki_enabled")


@pulumi.output_type
class GetProjectsProjectContainerExpirationPolicyResult(dict):
    def __init__(__self__, *,
                 cadence: _builtins.str,
                 enabled: _builtins.bool,
                 keep_n: _builtins.int,
                 name_regex_delete: _builtins.str,
                 name_regex_keep: _builtins.str,
                 next_run_at: _builtins.str,
                 older_than: _builtins.str):
        """
        :param _builtins.str cadence: The cadence of the policy. Valid values are: `1d`, `7d`, `14d`, `1month`, `3month`.
        :param _builtins.bool enabled: If true, the policy is enabled.
        :param _builtins.int keep_n: The number of images to keep.
        :param _builtins.str name_regex_delete: The regular expression to match image names to delete.
        :param _builtins.str name_regex_keep: The regular expression to match image names to keep.
        :param _builtins.str next_run_at: The next time the policy will run.
        :param _builtins.str older_than: The number of days to keep images.
        """
        pulumi.set(__self__, "cadence", cadence)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "keep_n", keep_n)
        pulumi.set(__self__, "name_regex_delete", name_regex_delete)
        pulumi.set(__self__, "name_regex_keep", name_regex_keep)
        pulumi.set(__self__, "next_run_at", next_run_at)
        pulumi.set(__self__, "older_than", older_than)

    @_builtins.property
    @pulumi.getter
    def cadence(self) -> _builtins.str:
        """
        The cadence of the policy. Valid values are: `1d`, `7d`, `14d`, `1month`, `3month`.
        """
        return pulumi.get(self, "cadence")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        If true, the policy is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="keepN")
    def keep_n(self) -> _builtins.int:
        """
        The number of images to keep.
        """
        return pulumi.get(self, "keep_n")

    @_builtins.property
    @pulumi.getter(name="nameRegexDelete")
    def name_regex_delete(self) -> _builtins.str:
        """
        The regular expression to match image names to delete.
        """
        return pulumi.get(self, "name_regex_delete")

    @_builtins.property
    @pulumi.getter(name="nameRegexKeep")
    def name_regex_keep(self) -> _builtins.str:
        """
        The regular expression to match image names to keep.
        """
        return pulumi.get(self, "name_regex_keep")

    @_builtins.property
    @pulumi.getter(name="nextRunAt")
    def next_run_at(self) -> _builtins.str:
        """
        The next time the policy will run.
        """
        return pulumi.get(self, "next_run_at")

    @_builtins.property
    @pulumi.getter(name="olderThan")
    def older_than(self) -> _builtins.str:
        """
        The number of days to keep images.
        """
        return pulumi.get(self, "older_than")


@pulumi.output_type
class GetProjectsProjectForkedFromProjectResult(dict):
    def __init__(__self__, *,
                 http_url_to_repo: _builtins.str,
                 id: _builtins.int,
                 name: _builtins.str,
                 name_with_namespace: _builtins.str,
                 path: _builtins.str,
                 path_with_namespace: _builtins.str,
                 web_url: _builtins.str):
        """
        :param _builtins.str http_url_to_repo: The HTTP clone URL of the upstream project.
        :param _builtins.int id: The ID of the upstream project.
        :param _builtins.str name: The name of the upstream project.
        :param _builtins.str name_with_namespace: In `group / subgroup / project` or `user / project` format.
        :param _builtins.str path: The path of the upstream project.
        :param _builtins.str path_with_namespace: In `group/subgroup/project` or `user/project` format.
        :param _builtins.str web_url: The web url of the upstream project.
        """
        pulumi.set(__self__, "http_url_to_repo", http_url_to_repo)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "name_with_namespace", name_with_namespace)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "path_with_namespace", path_with_namespace)
        pulumi.set(__self__, "web_url", web_url)

    @_builtins.property
    @pulumi.getter(name="httpUrlToRepo")
    def http_url_to_repo(self) -> _builtins.str:
        """
        The HTTP clone URL of the upstream project.
        """
        return pulumi.get(self, "http_url_to_repo")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The ID of the upstream project.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the upstream project.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nameWithNamespace")
    def name_with_namespace(self) -> _builtins.str:
        """
        In `group / subgroup / project` or `user / project` format.
        """
        return pulumi.get(self, "name_with_namespace")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The path of the upstream project.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="pathWithNamespace")
    def path_with_namespace(self) -> _builtins.str:
        """
        In `group/subgroup/project` or `user/project` format.
        """
        return pulumi.get(self, "path_with_namespace")

    @_builtins.property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> _builtins.str:
        """
        The web url of the upstream project.
        """
        return pulumi.get(self, "web_url")


@pulumi.output_type
class GetProjectsProjectNamespaceResult(dict):
    def __init__(__self__, *,
                 full_path: _builtins.str,
                 id: _builtins.int,
                 kind: _builtins.str,
                 name: _builtins.str,
                 path: _builtins.str):
        """
        :param _builtins.str full_path: The full path of the namespace.
        :param _builtins.int id: The ID of the namespace.
        :param _builtins.str kind: The kind of the namespace.
        :param _builtins.str name: The name of the namespace.
        :param _builtins.str path: The path of the namespace.
        """
        pulumi.set(__self__, "full_path", full_path)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter(name="fullPath")
    def full_path(self) -> _builtins.str:
        """
        The full path of the namespace.
        """
        return pulumi.get(self, "full_path")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The ID of the namespace.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        The kind of the namespace.
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the namespace.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The path of the namespace.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetProjectsProjectOwnerResult(dict):
    def __init__(__self__, *,
                 avatar_url: _builtins.str,
                 id: _builtins.int,
                 name: _builtins.str,
                 state: _builtins.str,
                 username: _builtins.str,
                 website_url: _builtins.str):
        """
        :param _builtins.str avatar_url: The avatar url of the owner.
        :param _builtins.int id: The ID of the owner.
        :param _builtins.str name: The name of the owner.
        :param _builtins.str state: The state of the owner.
        :param _builtins.str username: The username of the owner.
        :param _builtins.str website_url: The website url of the owner.
        """
        pulumi.set(__self__, "avatar_url", avatar_url)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "website_url", website_url)

    @_builtins.property
    @pulumi.getter(name="avatarUrl")
    def avatar_url(self) -> _builtins.str:
        """
        The avatar url of the owner.
        """
        return pulumi.get(self, "avatar_url")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The ID of the owner.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the owner.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of the owner.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The username of the owner.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="websiteUrl")
    def website_url(self) -> _builtins.str:
        """
        The website url of the owner.
        """
        return pulumi.get(self, "website_url")


@pulumi.output_type
class GetProjectsProjectPermissionResult(dict):
    def __init__(__self__, *,
                 group_access: Mapping[str, _builtins.int],
                 project_access: Mapping[str, _builtins.int]):
        """
        :param Mapping[str, _builtins.int] group_access: Group access level.
        :param Mapping[str, _builtins.int] project_access: Project access level.
        """
        pulumi.set(__self__, "group_access", group_access)
        pulumi.set(__self__, "project_access", project_access)

    @_builtins.property
    @pulumi.getter(name="groupAccess")
    def group_access(self) -> Mapping[str, _builtins.int]:
        """
        Group access level.
        """
        return pulumi.get(self, "group_access")

    @_builtins.property
    @pulumi.getter(name="projectAccess")
    def project_access(self) -> Mapping[str, _builtins.int]:
        """
        Project access level.
        """
        return pulumi.get(self, "project_access")


@pulumi.output_type
class GetProjectsProjectSharedWithGroupResult(dict):
    def __init__(__self__, *,
                 group_access_level: _builtins.str,
                 group_id: _builtins.int,
                 group_name: _builtins.str):
        """
        :param _builtins.str group_access_level: The group access level.
        :param _builtins.int group_id: The group ID.
        :param _builtins.str group_name: The group name.
        """
        pulumi.set(__self__, "group_access_level", group_access_level)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "group_name", group_name)

    @_builtins.property
    @pulumi.getter(name="groupAccessLevel")
    def group_access_level(self) -> _builtins.str:
        """
        The group access level.
        """
        return pulumi.get(self, "group_access_level")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.int:
        """
        The group ID.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> _builtins.str:
        """
        The group name.
        """
        return pulumi.get(self, "group_name")


@pulumi.output_type
class GetReleaseAssetsResult(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 links: Optional[Sequence['outputs.GetReleaseAssetsLinkResult']] = None,
                 sources: Optional[Sequence['outputs.GetReleaseAssetsSourceResult']] = None):
        """
        :param _builtins.int count: The number of assets for a release
        :param Sequence['GetReleaseAssetsLinkArgs'] links: The links for a release
        :param Sequence['GetReleaseAssetsSourceArgs'] sources: The sources for a release
        """
        pulumi.set(__self__, "count", count)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        The number of assets for a release
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def links(self) -> Optional[Sequence['outputs.GetReleaseAssetsLinkResult']]:
        """
        The links for a release
        """
        return pulumi.get(self, "links")

    @_builtins.property
    @pulumi.getter
    def sources(self) -> Optional[Sequence['outputs.GetReleaseAssetsSourceResult']]:
        """
        The sources for a release
        """
        return pulumi.get(self, "sources")


@pulumi.output_type
class GetReleaseAssetsLinkResult(dict):
    def __init__(__self__, *,
                 id: _builtins.int,
                 link_type: _builtins.str,
                 name: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.int id: The ID of the link
        :param _builtins.str link_type: The type of the link
        :param _builtins.str name: The name of the link
        :param _builtins.str url: The URL of the link
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "link_type", link_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The ID of the link
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="linkType")
    def link_type(self) -> _builtins.str:
        """
        The type of the link
        """
        return pulumi.get(self, "link_type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the link
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The URL of the link
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetReleaseAssetsSourceResult(dict):
    def __init__(__self__, *,
                 format: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str format: The format of the source
        :param _builtins.str url: The URL of the source
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def format(self) -> _builtins.str:
        """
        The format of the source
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The URL of the source
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetReleaseLinksReleaseLinkResult(dict):
    def __init__(__self__, *,
                 direct_asset_url: _builtins.str,
                 external: _builtins.bool,
                 filepath: _builtins.str,
                 link_id: _builtins.int,
                 link_type: _builtins.str,
                 name: _builtins.str,
                 project: _builtins.str,
                 tag_name: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str direct_asset_url: Full path for a [Direct Asset link](https://docs.gitlab.com/user/project/releases/release_fields/#permanent-links-to-latest-release-assets).
        :param _builtins.bool external: External or internal link.
        :param _builtins.str filepath: Relative path for a [Direct Asset link](https://docs.gitlab.com/user/project/releases/release_fields/#permanent-links-to-latest-release-assets).
        :param _builtins.int link_id: The ID of the link.
        :param _builtins.str link_type: The type of the link. Valid values are `other`, `runbook`, `image`, `package`.
        :param _builtins.str name: The name of the link. Link names must be unique within the release.
        :param _builtins.str project: The ID or Namespace path of the project.
        :param _builtins.str tag_name: The tag associated with the Release.
        :param _builtins.str url: The URL of the link. Link URLs must be unique within the release.
        """
        pulumi.set(__self__, "direct_asset_url", direct_asset_url)
        pulumi.set(__self__, "external", external)
        pulumi.set(__self__, "filepath", filepath)
        pulumi.set(__self__, "link_id", link_id)
        pulumi.set(__self__, "link_type", link_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project", project)
        pulumi.set(__self__, "tag_name", tag_name)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="directAssetUrl")
    def direct_asset_url(self) -> _builtins.str:
        """
        Full path for a [Direct Asset link](https://docs.gitlab.com/user/project/releases/release_fields/#permanent-links-to-latest-release-assets).
        """
        return pulumi.get(self, "direct_asset_url")

    @_builtins.property
    @pulumi.getter
    def external(self) -> _builtins.bool:
        """
        External or internal link.
        """
        return pulumi.get(self, "external")

    @_builtins.property
    @pulumi.getter
    def filepath(self) -> _builtins.str:
        """
        Relative path for a [Direct Asset link](https://docs.gitlab.com/user/project/releases/release_fields/#permanent-links-to-latest-release-assets).
        """
        return pulumi.get(self, "filepath")

    @_builtins.property
    @pulumi.getter(name="linkId")
    def link_id(self) -> _builtins.int:
        """
        The ID of the link.
        """
        return pulumi.get(self, "link_id")

    @_builtins.property
    @pulumi.getter(name="linkType")
    def link_type(self) -> _builtins.str:
        """
        The type of the link. Valid values are `other`, `runbook`, `image`, `package`.
        """
        return pulumi.get(self, "link_type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the link. Link names must be unique within the release.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def project(self) -> _builtins.str:
        """
        The ID or Namespace path of the project.
        """
        return pulumi.get(self, "project")

    @_builtins.property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> _builtins.str:
        """
        The tag associated with the Release.
        """
        return pulumi.get(self, "tag_name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The URL of the link. Link URLs must be unique within the release.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetRepositoryTreeTreeResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 mode: _builtins.str,
                 name: _builtins.str,
                 node_id: _builtins.str,
                 path: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str id: The project ID. Use `node_id` instead. To be removed in 19.0.
        :param _builtins.str mode: Unix access mode of the file in the repository.
        :param _builtins.str name: Name of the blob or tree in the repository
        :param _builtins.str node_id: The SHA-1 hash of the tree or blob in the repository.
        :param _builtins.str path: Path of the object inside of the repository.
        :param _builtins.str type: Type of object in the repository. Can be either type tree or of type blob
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node_id", node_id)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Use `node_id` instead. To be removed in 19.0.""")
    def id(self) -> _builtins.str:
        """
        The project ID. Use `node_id` instead. To be removed in 19.0.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Unix access mode of the file in the repository.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the blob or tree in the repository
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> _builtins.str:
        """
        The SHA-1 hash of the tree or blob in the repository.
        """
        return pulumi.get(self, "node_id")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Path of the object inside of the repository.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of object in the repository. Can be either type tree or of type blob
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetRunnersRunnerResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 id: _builtins.int,
                 is_shared: _builtins.bool,
                 online: _builtins.bool,
                 paused: _builtins.bool,
                 runner_type: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str description: The description of the runner.
        :param _builtins.int id: The runner id.
        :param _builtins.bool is_shared: Indicates if this is a shared runner
        :param _builtins.bool online: The connectivity status of the runner.
        :param _builtins.bool paused: Indicates if the runner is accepting or ignoring new jobs.
        :param _builtins.str runner_type: The runner type. Values are `instance_type`, `group_type` and `project_type`.
        :param _builtins.str status: The status of the runner. Values can be `online`, `offline`, `stale`, and `never_contacted`.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_shared", is_shared)
        pulumi.set(__self__, "online", online)
        pulumi.set(__self__, "paused", paused)
        pulumi.set(__self__, "runner_type", runner_type)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the runner.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The runner id.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isShared")
    def is_shared(self) -> _builtins.bool:
        """
        Indicates if this is a shared runner
        """
        return pulumi.get(self, "is_shared")

    @_builtins.property
    @pulumi.getter
    def online(self) -> _builtins.bool:
        """
        The connectivity status of the runner.
        """
        return pulumi.get(self, "online")

    @_builtins.property
    @pulumi.getter
    def paused(self) -> _builtins.bool:
        """
        Indicates if the runner is accepting or ignoring new jobs.
        """
        return pulumi.get(self, "paused")

    @_builtins.property
    @pulumi.getter(name="runnerType")
    def runner_type(self) -> _builtins.str:
        """
        The runner type. Values are `instance_type`, `group_type` and `project_type`.
        """
        return pulumi.get(self, "runner_type")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the runner. Values can be `online`, `offline`, `stale`, and `never_contacted`.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetSecurityPolicyDocumentScanExecutionPolicyResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetSecurityPolicyDocumentScanExecutionPolicyActionResult'],
                 enabled: _builtins.bool,
                 name: _builtins.str,
                 rules: Sequence['outputs.GetSecurityPolicyDocumentScanExecutionPolicyRuleResult'],
                 description: Optional[_builtins.str] = None,
                 policy_scope: Optional['outputs.GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeResult'] = None,
                 skip_ci: Optional['outputs.GetSecurityPolicyDocumentScanExecutionPolicySkipCiResult'] = None):
        """
        :param Sequence['GetSecurityPolicyDocumentScanExecutionPolicyActionArgs'] actions: Actions to execute when rules match. At least one action is required.
        :param _builtins.bool enabled: Whether the policy is enabled.
        :param _builtins.str name: Name of the scan execution policy.
        :param Sequence['GetSecurityPolicyDocumentScanExecutionPolicyRuleArgs'] rules: Rules that trigger the policy. At least one rule is required.
        :param _builtins.str description: Description of the scan execution policy.
        :param 'GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeArgs' policy_scope: Scope configuration to limit which projects the policy applies to.
        :param 'GetSecurityPolicyDocumentScanExecutionPolicySkipCiArgs' skip_ci: Control whether users can use the skip-ci directive.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rules", rules)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if policy_scope is not None:
            pulumi.set(__self__, "policy_scope", policy_scope)
        if skip_ci is not None:
            pulumi.set(__self__, "skip_ci", skip_ci)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetSecurityPolicyDocumentScanExecutionPolicyActionResult']:
        """
        Actions to execute when rules match. At least one action is required.
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether the policy is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the scan execution policy.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetSecurityPolicyDocumentScanExecutionPolicyRuleResult']:
        """
        Rules that trigger the policy. At least one rule is required.
        """
        return pulumi.get(self, "rules")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the scan execution policy.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="policyScope")
    def policy_scope(self) -> Optional['outputs.GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeResult']:
        """
        Scope configuration to limit which projects the policy applies to.
        """
        return pulumi.get(self, "policy_scope")

    @_builtins.property
    @pulumi.getter(name="skipCi")
    def skip_ci(self) -> Optional['outputs.GetSecurityPolicyDocumentScanExecutionPolicySkipCiResult']:
        """
        Control whether users can use the skip-ci directive.
        """
        return pulumi.get(self, "skip_ci")


@pulumi.output_type
class GetSecurityPolicyDocumentScanExecutionPolicyActionResult(dict):
    def __init__(__self__, *,
                 scan: _builtins.str,
                 scanner_profile: Optional[_builtins.str] = None,
                 site_profile: Optional[_builtins.str] = None,
                 tags_to_excludes: Optional[Sequence[_builtins.str]] = None,
                 template: Optional[_builtins.str] = None,
                 variables: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str scan: Type of scan to run. Valid values: `sast`, `secret_detection`, `container_scanning`, `dependency_scanning`, `dast`, `sast_iac`, `cluster_image_scanning`, `api_fuzzing`, `coverage_fuzzing`.
        :param _builtins.str scanner_profile: Scanner profile to use for DAST scans.
        :param _builtins.str site_profile: Site profile to use for DAST scans.
        :param Sequence[_builtins.str] tags_to_excludes: Tags to exclude from the scan.
        :param _builtins.str template: The template to use for the scan. Valid values: `default`, `latest`.
        :param Mapping[str, _builtins.str] variables: Environment variables to pass to the scan job.
        """
        pulumi.set(__self__, "scan", scan)
        if scanner_profile is not None:
            pulumi.set(__self__, "scanner_profile", scanner_profile)
        if site_profile is not None:
            pulumi.set(__self__, "site_profile", site_profile)
        if tags_to_excludes is not None:
            pulumi.set(__self__, "tags_to_excludes", tags_to_excludes)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @_builtins.property
    @pulumi.getter
    def scan(self) -> _builtins.str:
        """
        Type of scan to run. Valid values: `sast`, `secret_detection`, `container_scanning`, `dependency_scanning`, `dast`, `sast_iac`, `cluster_image_scanning`, `api_fuzzing`, `coverage_fuzzing`.
        """
        return pulumi.get(self, "scan")

    @_builtins.property
    @pulumi.getter(name="scannerProfile")
    def scanner_profile(self) -> Optional[_builtins.str]:
        """
        Scanner profile to use for DAST scans.
        """
        return pulumi.get(self, "scanner_profile")

    @_builtins.property
    @pulumi.getter(name="siteProfile")
    def site_profile(self) -> Optional[_builtins.str]:
        """
        Site profile to use for DAST scans.
        """
        return pulumi.get(self, "site_profile")

    @_builtins.property
    @pulumi.getter(name="tagsToExcludes")
    def tags_to_excludes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Tags to exclude from the scan.
        """
        return pulumi.get(self, "tags_to_excludes")

    @_builtins.property
    @pulumi.getter
    def template(self) -> Optional[_builtins.str]:
        """
        The template to use for the scan. Valid values: `default`, `latest`.
        """
        return pulumi.get(self, "template")

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Environment variables to pass to the scan job.
        """
        return pulumi.get(self, "variables")


@pulumi.output_type
class GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeResult(dict):
    def __init__(__self__, *,
                 compliance_frameworks: Optional[Sequence[_builtins.str]] = None,
                 projects: Optional['outputs.GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeProjectsResult'] = None):
        """
        :param Sequence[_builtins.str] compliance_frameworks: Compliance framework names to scope the policy to.
        :param 'GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeProjectsArgs' projects: Project scope configuration.
        """
        if compliance_frameworks is not None:
            pulumi.set(__self__, "compliance_frameworks", compliance_frameworks)
        if projects is not None:
            pulumi.set(__self__, "projects", projects)

    @_builtins.property
    @pulumi.getter(name="complianceFrameworks")
    def compliance_frameworks(self) -> Optional[Sequence[_builtins.str]]:
        """
        Compliance framework names to scope the policy to.
        """
        return pulumi.get(self, "compliance_frameworks")

    @_builtins.property
    @pulumi.getter
    def projects(self) -> Optional['outputs.GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeProjectsResult']:
        """
        Project scope configuration.
        """
        return pulumi.get(self, "projects")


@pulumi.output_type
class GetSecurityPolicyDocumentScanExecutionPolicyPolicyScopeProjectsResult(dict):
    def __init__(__self__, *,
                 excludings: Optional[Sequence[_builtins.int]] = None,
                 includings: Optional[Sequence[_builtins.int]] = None):
        """
        :param Sequence[_builtins.int] excludings: List of project IDs to exclude from this policy.
        :param Sequence[_builtins.int] includings: List of project IDs to explicitly include in this policy.
        """
        if excludings is not None:
            pulumi.set(__self__, "excludings", excludings)
        if includings is not None:
            pulumi.set(__self__, "includings", includings)

    @_builtins.property
    @pulumi.getter
    def excludings(self) -> Optional[Sequence[_builtins.int]]:
        """
        List of project IDs to exclude from this policy.
        """
        return pulumi.get(self, "excludings")

    @_builtins.property
    @pulumi.getter
    def includings(self) -> Optional[Sequence[_builtins.int]]:
        """
        List of project IDs to explicitly include in this policy.
        """
        return pulumi.get(self, "includings")


@pulumi.output_type
class GetSecurityPolicyDocumentScanExecutionPolicyRuleResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 agents: Optional[Mapping[str, _builtins.str]] = None,
                 branch_exceptions: Optional[Sequence[_builtins.str]] = None,
                 branch_type: Optional[_builtins.str] = None,
                 branches: Optional[Sequence[_builtins.str]] = None,
                 cadence: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Type of rule. Valid values: `pipeline`, `schedule`, `agent`.
        :param Mapping[str, _builtins.str] agents: Kubernetes agents configuration for agent-based policies.
        :param Sequence[_builtins.str] branch_exceptions: Branches to exclude from the policy.
        :param _builtins.str branch_type: Type of branches to match. Valid values: `all`, `protected`, `default`.
        :param Sequence[_builtins.str] branches: Branch names or patterns to match.
        :param _builtins.str cadence: Cron expression for schedule type rules (e.g., `*/15 * * * *` for every 15 minutes).
        """
        pulumi.set(__self__, "type", type)
        if agents is not None:
            pulumi.set(__self__, "agents", agents)
        if branch_exceptions is not None:
            pulumi.set(__self__, "branch_exceptions", branch_exceptions)
        if branch_type is not None:
            pulumi.set(__self__, "branch_type", branch_type)
        if branches is not None:
            pulumi.set(__self__, "branches", branches)
        if cadence is not None:
            pulumi.set(__self__, "cadence", cadence)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of rule. Valid values: `pipeline`, `schedule`, `agent`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def agents(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Kubernetes agents configuration for agent-based policies.
        """
        return pulumi.get(self, "agents")

    @_builtins.property
    @pulumi.getter(name="branchExceptions")
    def branch_exceptions(self) -> Optional[Sequence[_builtins.str]]:
        """
        Branches to exclude from the policy.
        """
        return pulumi.get(self, "branch_exceptions")

    @_builtins.property
    @pulumi.getter(name="branchType")
    def branch_type(self) -> Optional[_builtins.str]:
        """
        Type of branches to match. Valid values: `all`, `protected`, `default`.
        """
        return pulumi.get(self, "branch_type")

    @_builtins.property
    @pulumi.getter
    def branches(self) -> Optional[Sequence[_builtins.str]]:
        """
        Branch names or patterns to match.
        """
        return pulumi.get(self, "branches")

    @_builtins.property
    @pulumi.getter
    def cadence(self) -> Optional[_builtins.str]:
        """
        Cron expression for schedule type rules (e.g., `*/15 * * * *` for every 15 minutes).
        """
        return pulumi.get(self, "cadence")


@pulumi.output_type
class GetSecurityPolicyDocumentScanExecutionPolicySkipCiResult(dict):
    def __init__(__self__, *,
                 allowed: _builtins.bool):
        """
        :param _builtins.bool allowed: Allow (true) or prevent (false) the use of skip-ci directive.
        """
        pulumi.set(__self__, "allowed", allowed)

    @_builtins.property
    @pulumi.getter
    def allowed(self) -> _builtins.bool:
        """
        Allow (true) or prevent (false) the use of skip-ci directive.
        """
        return pulumi.get(self, "allowed")


@pulumi.output_type
class GetUserSshkeysKeyResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 expires_at: _builtins.str,
                 key: _builtins.str,
                 key_id: _builtins.int,
                 title: _builtins.str,
                 user_id: _builtins.int):
        """
        :param _builtins.str created_at: The time when this key was created in GitLab.
        :param _builtins.str expires_at: The expiration date of the SSH key in ISO 8601 format (YYYY-MM-DDTHH:MM:SSZ)
        :param _builtins.str key: The ssh key. The SSH key `comment` (trailing part) is optional and ignored for diffing, because GitLab overrides it with the username and GitLab hostname.
        :param _builtins.int key_id: The ID of the ssh key.
        :param _builtins.str title: The title of the ssh key.
        :param _builtins.int user_id: The ID or username of the user. If this field is omitted, this resource manages a SSH key for the current user. Otherwise, this resource manages a SSH key for the specified user, and an admin token is required.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "title", title)
        pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The time when this key was created in GitLab.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> _builtins.str:
        """
        The expiration date of the SSH key in ISO 8601 format (YYYY-MM-DDTHH:MM:SSZ)
        """
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The ssh key. The SSH key `comment` (trailing part) is optional and ignored for diffing, because GitLab overrides it with the username and GitLab hostname.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> _builtins.int:
        """
        The ID of the ssh key.
        """
        return pulumi.get(self, "key_id")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The title of the ssh key.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> _builtins.int:
        """
        The ID or username of the user. If this field is omitted, this resource manages a SSH key for the current user. Otherwise, this resource manages a SSH key for the specified user, and an admin token is required.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetUsersUserResult(dict):
    def __init__(__self__, *,
                 avatar_url: _builtins.str,
                 bio: _builtins.str,
                 can_create_group: _builtins.bool,
                 can_create_project: _builtins.bool,
                 color_scheme_id: _builtins.int,
                 created_at: _builtins.str,
                 current_sign_in_at: _builtins.str,
                 email: _builtins.str,
                 extern_uid: _builtins.str,
                 external: _builtins.bool,
                 id: _builtins.int,
                 is_admin: _builtins.bool,
                 is_bot: _builtins.bool,
                 last_sign_in_at: _builtins.str,
                 linkedin: _builtins.str,
                 location: _builtins.str,
                 name: _builtins.str,
                 namespace_id: _builtins.int,
                 organization: _builtins.str,
                 projects_limit: _builtins.int,
                 provider: _builtins.str,
                 skype: _builtins.str,
                 state: _builtins.str,
                 theme_id: _builtins.int,
                 twitter: _builtins.str,
                 two_factor_enabled: _builtins.bool,
                 username: _builtins.str,
                 website_url: _builtins.str):
        """
        :param _builtins.str avatar_url: The avatar URL of the user.
        :param _builtins.str bio: The bio of the user.
        :param _builtins.bool can_create_group: Whether the user can create groups.
        :param _builtins.bool can_create_project: Whether the user can create projects.
        :param _builtins.int color_scheme_id: User's color scheme ID.
        :param _builtins.str created_at: Date the user was created at.
        :param _builtins.str current_sign_in_at: Current user's sign-in date.
        :param _builtins.str email: The public email address of the user.
        :param _builtins.str extern_uid: The external UID of the user.
        :param _builtins.bool external: Whether the user is external.
        :param _builtins.int id: The unique id assigned to the user by the gitlab server.
        :param _builtins.bool is_admin: Whether the user is an admin.
        :param _builtins.bool is_bot: Whether the user is a bot.
        :param _builtins.str last_sign_in_at: Last user's sign-in date.
        :param _builtins.str linkedin: LinkedIn profile of the user.
        :param _builtins.str location: The location of the user.
        :param _builtins.str name: The name of the user.
        :param _builtins.int namespace_id: The ID of the user's namespace. Requires admin token to access this field.
        :param _builtins.str organization: The organization of the user.
        :param _builtins.int projects_limit: Number of projects the user can create.
        :param _builtins.str provider: The UID provider of the user.
        :param _builtins.str skype: Skype username of the user.
        :param _builtins.str state: Whether the user is active or blocked.
        :param _builtins.int theme_id: User's theme ID.
        :param _builtins.str twitter: Twitter username of the user.
        :param _builtins.bool two_factor_enabled: Whether user's two-factor auth is enabled.
        :param _builtins.str username: The username of the user.
        :param _builtins.str website_url: User's website URL.
        """
        pulumi.set(__self__, "avatar_url", avatar_url)
        pulumi.set(__self__, "bio", bio)
        pulumi.set(__self__, "can_create_group", can_create_group)
        pulumi.set(__self__, "can_create_project", can_create_project)
        pulumi.set(__self__, "color_scheme_id", color_scheme_id)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "current_sign_in_at", current_sign_in_at)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "extern_uid", extern_uid)
        pulumi.set(__self__, "external", external)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_admin", is_admin)
        pulumi.set(__self__, "is_bot", is_bot)
        pulumi.set(__self__, "last_sign_in_at", last_sign_in_at)
        pulumi.set(__self__, "linkedin", linkedin)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace_id", namespace_id)
        pulumi.set(__self__, "organization", organization)
        pulumi.set(__self__, "projects_limit", projects_limit)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "skype", skype)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "theme_id", theme_id)
        pulumi.set(__self__, "twitter", twitter)
        pulumi.set(__self__, "two_factor_enabled", two_factor_enabled)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "website_url", website_url)

    @_builtins.property
    @pulumi.getter(name="avatarUrl")
    def avatar_url(self) -> _builtins.str:
        """
        The avatar URL of the user.
        """
        return pulumi.get(self, "avatar_url")

    @_builtins.property
    @pulumi.getter
    def bio(self) -> _builtins.str:
        """
        The bio of the user.
        """
        return pulumi.get(self, "bio")

    @_builtins.property
    @pulumi.getter(name="canCreateGroup")
    def can_create_group(self) -> _builtins.bool:
        """
        Whether the user can create groups.
        """
        return pulumi.get(self, "can_create_group")

    @_builtins.property
    @pulumi.getter(name="canCreateProject")
    def can_create_project(self) -> _builtins.bool:
        """
        Whether the user can create projects.
        """
        return pulumi.get(self, "can_create_project")

    @_builtins.property
    @pulumi.getter(name="colorSchemeId")
    def color_scheme_id(self) -> _builtins.int:
        """
        User's color scheme ID.
        """
        return pulumi.get(self, "color_scheme_id")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Date the user was created at.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="currentSignInAt")
    def current_sign_in_at(self) -> _builtins.str:
        """
        Current user's sign-in date.
        """
        return pulumi.get(self, "current_sign_in_at")

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The public email address of the user.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="externUid")
    def extern_uid(self) -> _builtins.str:
        """
        The external UID of the user.
        """
        return pulumi.get(self, "extern_uid")

    @_builtins.property
    @pulumi.getter
    def external(self) -> _builtins.bool:
        """
        Whether the user is external.
        """
        return pulumi.get(self, "external")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The unique id assigned to the user by the gitlab server.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isAdmin")
    def is_admin(self) -> _builtins.bool:
        """
        Whether the user is an admin.
        """
        return pulumi.get(self, "is_admin")

    @_builtins.property
    @pulumi.getter(name="isBot")
    def is_bot(self) -> _builtins.bool:
        """
        Whether the user is a bot.
        """
        return pulumi.get(self, "is_bot")

    @_builtins.property
    @pulumi.getter(name="lastSignInAt")
    def last_sign_in_at(self) -> _builtins.str:
        """
        Last user's sign-in date.
        """
        return pulumi.get(self, "last_sign_in_at")

    @_builtins.property
    @pulumi.getter
    def linkedin(self) -> _builtins.str:
        """
        LinkedIn profile of the user.
        """
        return pulumi.get(self, "linkedin")

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        """
        The location of the user.
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> _builtins.int:
        """
        The ID of the user's namespace. Requires admin token to access this field.
        """
        return pulumi.get(self, "namespace_id")

    @_builtins.property
    @pulumi.getter
    def organization(self) -> _builtins.str:
        """
        The organization of the user.
        """
        return pulumi.get(self, "organization")

    @_builtins.property
    @pulumi.getter(name="projectsLimit")
    def projects_limit(self) -> _builtins.int:
        """
        Number of projects the user can create.
        """
        return pulumi.get(self, "projects_limit")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> _builtins.str:
        """
        The UID provider of the user.
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def skype(self) -> _builtins.str:
        """
        Skype username of the user.
        """
        return pulumi.get(self, "skype")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        Whether the user is active or blocked.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="themeId")
    def theme_id(self) -> _builtins.int:
        """
        User's theme ID.
        """
        return pulumi.get(self, "theme_id")

    @_builtins.property
    @pulumi.getter
    def twitter(self) -> _builtins.str:
        """
        Twitter username of the user.
        """
        return pulumi.get(self, "twitter")

    @_builtins.property
    @pulumi.getter(name="twoFactorEnabled")
    def two_factor_enabled(self) -> _builtins.bool:
        """
        Whether user's two-factor auth is enabled.
        """
        return pulumi.get(self, "two_factor_enabled")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The username of the user.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="websiteUrl")
    def website_url(self) -> _builtins.str:
        """
        User's website URL.
        """
        return pulumi.get(self, "website_url")


