{
    "name": "gitlab",
    "description": "A Pulumi package for creating and managing GitLab resources.",
    "keywords": [
        "pulumi",
        "gitlab"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`gitlab` Terraform Provider](https://github.com/gitlabhq/terraform-provider-gitlab).",
    "repository": "https://github.com/pulumi/pulumi-gitlab",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "compatibility": "tfbridge20",
            "namespaces": {
                "gitlab": "GitLab"
            },
            "packageReferences": {
                "Pulumi": "3.*"
            }
        },
        "go": {
            "generateExtraInputTypes": true,
            "generateResourceContainerTypes": true,
            "importBasePath": "github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab"
        },
        "nodejs": {
            "compatibility": "tfbridge20",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0",
                "builtin-modules": "3.0.0",
                "read-package-tree": "^5.2.1",
                "resolve": "^1.7.1"
            },
            "devDependencies": {
                "@types/node": "^10.0.0"
            },
            "disableUnionOutputTypes": true,
            "packageDescription": "A Pulumi package for creating and managing GitLab resources.",
            "packageName": "",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/gitlabhq/terraform-provider-gitlab)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-gitlab` repo](https://github.com/pulumi/pulumi-gitlab/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-gitlab` repo](https://github.com/gitlabhq/terraform-provider-gitlab/issues).",
            "typescriptVersion": ""
        },
        "python": {
            "compatibility": "tfbridge20",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/gitlabhq/terraform-provider-gitlab)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-gitlab` repo](https://github.com/pulumi/pulumi-gitlab/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-gitlab` repo](https://github.com/gitlabhq/terraform-provider-gitlab/issues).",
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            }
        }
    },
    "config": {
        "variables": {
            "baseUrl": {
                "type": "string",
                "description": "This is the target GitLab base API endpoint. Providing a value is a requirement when working with GitLab CE or GitLab\nEnterprise e.g. `https://my.gitlab.server/api/v4/`. It is optional to provide this value and it can also be sourced from\nthe `GITLAB_BASE_URL` environment variable. The value must end with a slash.\n"
            },
            "cacertFile": {
                "type": "string",
                "description": "This is a file containing the ca cert to verify the gitlab instance. This is available for use when working with GitLab\nCE or Gitlab Enterprise with a locally-issued or self-signed certificate chain.\n"
            },
            "clientCert": {
                "type": "string",
                "description": "File path to client certificate when GitLab instance is behind company proxy. File must contain PEM encoded data.\n"
            },
            "clientKey": {
                "type": "string",
                "description": "File path to client key when GitLab instance is behind company proxy. File must contain PEM encoded data. Required when\n`client_cert` is set.\n"
            },
            "earlyAuthCheck": {
                "type": "boolean",
                "description": "(Experimental) By default the provider does a dummy request to get the current user in order to verify that the provider\nconfiguration is correct and the GitLab API is reachable. Set this to `false` to skip this check. This may be useful if\nthe GitLab instance does not yet exist and is created within the same terraform module. It may be sourced from the\n`GITLAB_EARLY_AUTH_CHECK`. This is an experimental feature and may change in the future. Please make sure to always keep\nbackups of your state.\n"
            },
            "insecure": {
                "type": "boolean",
                "description": "When set to true this disables SSL verification of the connection to the GitLab instance.\n"
            },
            "token": {
                "type": "string",
                "description": "The OAuth2 Token, Project, Group, Personal Access Token or CI Job Token used to connect to GitLab. The OAuth method is\nused in this provider for authentication (using Bearer authorization token). See\nhttps://docs.gitlab.com/ee/api/#authentication for details. It may be sourced from the `GITLAB_TOKEN` environment\nvariable.\n",
                "secret": true
            }
        }
    },
    "types": {
        "gitlab:index/BranchCommit:BranchCommit": {
            "properties": {
                "authorEmail": {
                    "type": "string"
                },
                "authorName": {
                    "type": "string"
                },
                "authoredDate": {
                    "type": "string"
                },
                "committedDate": {
                    "type": "string"
                },
                "committerEmail": {
                    "type": "string"
                },
                "committerName": {
                    "type": "string"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of this resource.\n"
                },
                "message": {
                    "type": "string"
                },
                "parentIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "shortId": {
                    "type": "string"
                },
                "title": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "authorEmail",
                        "authorName",
                        "authoredDate",
                        "committedDate",
                        "committerEmail",
                        "committerName",
                        "id",
                        "message",
                        "parentIds",
                        "shortId",
                        "title"
                    ]
                }
            }
        },
        "gitlab:index/BranchProtectionAllowedToMerge:BranchProtectionAllowedToMerge": {
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Level of access.\n"
                },
                "accessLevelDescription": {
                    "type": "string",
                    "description": "Readable description of level of access.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "accessLevel",
                        "accessLevelDescription"
                    ]
                }
            }
        },
        "gitlab:index/BranchProtectionAllowedToPush:BranchProtectionAllowedToPush": {
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Level of access.\n"
                },
                "accessLevelDescription": {
                    "type": "string",
                    "description": "Readable description of level of access.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "accessLevel",
                        "accessLevelDescription"
                    ]
                }
            }
        },
        "gitlab:index/BranchProtectionAllowedToUnprotect:BranchProtectionAllowedToUnprotect": {
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Level of access.\n"
                },
                "accessLevelDescription": {
                    "type": "string",
                    "description": "Readable description of level of access.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "accessLevel",
                        "accessLevelDescription"
                    ]
                }
            }
        },
        "gitlab:index/ProjectContainerExpirationPolicy:ProjectContainerExpirationPolicy": {
            "properties": {
                "cadence": {
                    "type": "string",
                    "description": "The cadence of the policy. Valid values are: `1d`, `7d`, `14d`, `1month`, `3month`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "If true, the policy is enabled.\n"
                },
                "keepN": {
                    "type": "integer",
                    "description": "The number of images to keep.\n"
                },
                "nameRegex": {
                    "type": "string",
                    "description": "The regular expression to match image names to delete.\n"
                },
                "nameRegexDelete": {
                    "type": "string",
                    "description": "The regular expression to match image names to delete.\n",
                    "deprecationMessage": "`name_regex_delete` has been deprecated. Use `name_regex` instead."
                },
                "nameRegexKeep": {
                    "type": "string",
                    "description": "The regular expression to match image names to keep.\n"
                },
                "nextRunAt": {
                    "type": "string",
                    "description": "The next time the policy will run.\n"
                },
                "olderThan": {
                    "type": "string",
                    "description": "The number of days to keep images.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "cadence",
                        "enabled",
                        "keepN",
                        "nameRegex",
                        "nameRegexDelete",
                        "nameRegexKeep",
                        "nextRunAt",
                        "olderThan"
                    ]
                }
            }
        },
        "gitlab:index/ProjectIssueBoardList:ProjectIssueBoardList": {
            "properties": {
                "assigneeId": {
                    "type": "integer",
                    "description": "The ID of the assignee the list should be scoped to. Requires a GitLab EE license.\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The ID of the list\n"
                },
                "iterationId": {
                    "type": "integer",
                    "description": "The ID of the iteration the list should be scoped to. Requires a GitLab EE license.\n"
                },
                "labelId": {
                    "type": "integer",
                    "description": "The ID of the label the list should be scoped to. Requires a GitLab EE license.\n"
                },
                "milestoneId": {
                    "type": "integer",
                    "description": "The ID of the milestone the list should be scoped to. Requires a GitLab EE license.\n"
                },
                "position": {
                    "type": "integer",
                    "description": "The position of the list within the board. The position for the list is based on the its position in the `lists` array.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "position"
                    ]
                }
            }
        },
        "gitlab:index/ProjectIssueTaskCompletionStatus:ProjectIssueTaskCompletionStatus": {
            "properties": {
                "completedCount": {
                    "type": "integer"
                },
                "count": {
                    "type": "integer"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "completedCount",
                        "count"
                    ]
                }
            }
        },
        "gitlab:index/ProjectProtectedEnvironmentDeployAccessLevel:ProjectProtectedEnvironmentDeployAccessLevel": {
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Levels of access required to deploy to this protected environment. Valid values are `developer`, `maintainer`.\n"
                },
                "accessLevelDescription": {
                    "type": "string",
                    "description": "Readable description of level of access.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of the group allowed to deploy to this protected environment. The project must be shared with the group.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID of the user allowed to deploy to this protected environment. The user must be a member of the project.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "accessLevelDescription"
                    ]
                }
            }
        },
        "gitlab:index/ProjectPushRules:ProjectPushRules": {
            "properties": {
                "authorEmailRegex": {
                    "type": "string",
                    "description": "All commit author emails must match this regex, e.g. `@my-company.com$`.\n"
                },
                "branchNameRegex": {
                    "type": "string",
                    "description": "All branch names must match this regex, e.g. `(feature|hotfix)\\/*`.\n"
                },
                "commitCommitterCheck": {
                    "type": "boolean",
                    "description": "Users can only push commits to this repository that were committed with one of their own verified emails.\n"
                },
                "commitMessageNegativeRegex": {
                    "type": "string",
                    "description": "No commit message is allowed to match this regex, for example `ssh\\:\\/\\/`.\n"
                },
                "commitMessageRegex": {
                    "type": "string",
                    "description": "All commit messages must match this regex, e.g. `Fixed \\d+\\..*`.\n"
                },
                "denyDeleteTag": {
                    "type": "boolean",
                    "description": "Deny deleting a tag.\n"
                },
                "fileNameRegex": {
                    "type": "string",
                    "description": "All committed filenames must not match this regex, e.g. `(jar|exe)$`.\n"
                },
                "maxFileSize": {
                    "type": "integer",
                    "description": "Maximum file size (MB).\n"
                },
                "memberCheck": {
                    "type": "boolean",
                    "description": "Restrict commits by author (email) to existing GitLab users.\n"
                },
                "preventSecrets": {
                    "type": "boolean",
                    "description": "GitLab will reject any files that are likely to contain secrets.\n"
                },
                "rejectUnsignedCommits": {
                    "type": "boolean",
                    "description": "Reject commit when it’s not signed through GPG.\n"
                }
            },
            "type": "object"
        },
        "gitlab:index/ProjectTagCommit:ProjectTagCommit": {
            "properties": {
                "authorEmail": {
                    "type": "string"
                },
                "authorName": {
                    "type": "string"
                },
                "authoredDate": {
                    "type": "string"
                },
                "committedDate": {
                    "type": "string"
                },
                "committerEmail": {
                    "type": "string"
                },
                "committerName": {
                    "type": "string"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of this resource.\n"
                },
                "message": {
                    "type": "string",
                    "description": "The message of the annotated tag.\n"
                },
                "parentIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "shortId": {
                    "type": "string"
                },
                "title": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "authorEmail",
                        "authorName",
                        "authoredDate",
                        "committedDate",
                        "committerEmail",
                        "committerName",
                        "id",
                        "message",
                        "parentIds",
                        "shortId",
                        "title"
                    ]
                }
            }
        },
        "gitlab:index/ProjectTagRelease:ProjectTagRelease": {
            "properties": {
                "description": {
                    "type": "string"
                },
                "tagName": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "description",
                        "tagName"
                    ]
                }
            }
        },
        "gitlab:index/getBranchCommit:getBranchCommit": {
            "properties": {
                "authorEmail": {
                    "type": "string"
                },
                "authorName": {
                    "type": "string"
                },
                "authoredDate": {
                    "type": "string"
                },
                "committedDate": {
                    "type": "string"
                },
                "committerEmail": {
                    "type": "string"
                },
                "committerName": {
                    "type": "string"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of this resource.\n"
                },
                "message": {
                    "type": "string"
                },
                "parentIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "shortId": {
                    "type": "string"
                },
                "title": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "authorEmail",
                "authorName",
                "authoredDate",
                "committedDate",
                "committerEmail",
                "committerName",
                "id",
                "message",
                "parentIds",
                "shortId",
                "title"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getClusterAgentsClusterAgent:getClusterAgentsClusterAgent": {
            "properties": {
                "agentId": {
                    "type": "integer"
                },
                "createdAt": {
                    "type": "string"
                },
                "createdByUserId": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project owned by the authenticated user.\n"
                }
            },
            "type": "object",
            "required": [
                "agentId",
                "createdAt",
                "createdByUserId",
                "name",
                "project"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getGroupHooksHook:getGroupHooksHook": {
            "properties": {
                "confidentialIssuesEvents": {
                    "type": "boolean"
                },
                "confidentialNoteEvents": {
                    "type": "boolean"
                },
                "deploymentEvents": {
                    "type": "boolean"
                },
                "enableSslVerification": {
                    "type": "boolean"
                },
                "group": {
                    "type": "string",
                    "description": "The ID or full path of the group.\n"
                },
                "groupId": {
                    "type": "integer"
                },
                "hookId": {
                    "type": "integer"
                },
                "issuesEvents": {
                    "type": "boolean"
                },
                "jobEvents": {
                    "type": "boolean"
                },
                "mergeRequestsEvents": {
                    "type": "boolean"
                },
                "noteEvents": {
                    "type": "boolean"
                },
                "pipelineEvents": {
                    "type": "boolean"
                },
                "pushEvents": {
                    "type": "boolean"
                },
                "pushEventsBranchFilter": {
                    "type": "string"
                },
                "releasesEvents": {
                    "type": "boolean"
                },
                "subgroupEvents": {
                    "type": "boolean"
                },
                "tagPushEvents": {
                    "type": "boolean"
                },
                "token": {
                    "type": "string"
                },
                "url": {
                    "type": "string"
                },
                "wikiPageEvents": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "required": [
                "confidentialIssuesEvents",
                "confidentialNoteEvents",
                "deploymentEvents",
                "enableSslVerification",
                "group",
                "groupId",
                "hookId",
                "issuesEvents",
                "jobEvents",
                "mergeRequestsEvents",
                "noteEvents",
                "pipelineEvents",
                "pushEvents",
                "pushEventsBranchFilter",
                "releasesEvents",
                "subgroupEvents",
                "tagPushEvents",
                "token",
                "url",
                "wikiPageEvents"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getGroupMembershipMember:getGroupMembershipMember": {
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Only return members with the desired access level. Acceptable values are: `guest`, `reporter`, `developer`, `maintainer`, `owner`.\n"
                },
                "avatarUrl": {
                    "type": "string"
                },
                "expiresAt": {
                    "type": "string"
                },
                "id": {
                    "type": "integer",
                    "description": "The ID of this resource.\n"
                },
                "name": {
                    "type": "string"
                },
                "state": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                },
                "webUrl": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "accessLevel",
                "avatarUrl",
                "expiresAt",
                "id",
                "name",
                "state",
                "username",
                "webUrl"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getGroupSubgroupsSubgroup:getGroupSubgroupsSubgroup": {
            "properties": {
                "autoDevopsEnabled": {
                    "type": "boolean"
                },
                "avatarUrl": {
                    "type": "string"
                },
                "createdAt": {
                    "type": "string"
                },
                "defaultBranchProtection": {
                    "type": "integer"
                },
                "description": {
                    "type": "string"
                },
                "emailsDisabled": {
                    "type": "boolean"
                },
                "fileTemplateProjectId": {
                    "type": "integer"
                },
                "fullName": {
                    "type": "string"
                },
                "fullPath": {
                    "type": "string"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of the group.\n"
                },
                "ipRestrictionRanges": {
                    "type": "string"
                },
                "lfsEnabled": {
                    "type": "boolean"
                },
                "mentionsDisabled": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string"
                },
                "parentId": {
                    "type": "integer"
                },
                "path": {
                    "type": "string"
                },
                "projectCreationLevel": {
                    "type": "string"
                },
                "requestAccessEnabled": {
                    "type": "boolean"
                },
                "requireTwoFactorAuthentication": {
                    "type": "boolean"
                },
                "shareWithGroupLock": {
                    "type": "boolean"
                },
                "statistics": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Include group statistics (administrators only).\n"
                },
                "subgroupCreationLevel": {
                    "type": "string"
                },
                "twoFactorGracePeriod": {
                    "type": "integer"
                },
                "visibility": {
                    "type": "string"
                },
                "webUrl": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "autoDevopsEnabled",
                "avatarUrl",
                "createdAt",
                "defaultBranchProtection",
                "description",
                "emailsDisabled",
                "fileTemplateProjectId",
                "fullName",
                "fullPath",
                "groupId",
                "ipRestrictionRanges",
                "lfsEnabled",
                "mentionsDisabled",
                "name",
                "parentId",
                "path",
                "projectCreationLevel",
                "requestAccessEnabled",
                "requireTwoFactorAuthentication",
                "shareWithGroupLock",
                "statistics",
                "subgroupCreationLevel",
                "twoFactorGracePeriod",
                "visibility",
                "webUrl"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getGroupVariablesVariable:getGroupVariablesVariable": {
            "properties": {
                "environmentScope": {
                    "type": "string",
                    "description": "The environment scope of the variable. Defaults to all environment (`*`).\n"
                },
                "group": {
                    "type": "string",
                    "description": "The name or id of the group.\n"
                },
                "key": {
                    "type": "string"
                },
                "masked": {
                    "type": "boolean"
                },
                "protected": {
                    "type": "boolean"
                },
                "value": {
                    "type": "string"
                },
                "variableType": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "environmentScope",
                "group",
                "key",
                "masked",
                "protected",
                "value",
                "variableType"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getGroupsGroup:getGroupsGroup": {
            "properties": {
                "defaultBranchProtection": {
                    "type": "integer"
                },
                "description": {
                    "type": "string"
                },
                "fullName": {
                    "type": "string"
                },
                "fullPath": {
                    "type": "string"
                },
                "groupId": {
                    "type": "integer"
                },
                "lfsEnabled": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string"
                },
                "parentId": {
                    "type": "integer"
                },
                "path": {
                    "type": "string"
                },
                "preventForkingOutsideGroup": {
                    "type": "boolean"
                },
                "requestAccessEnabled": {
                    "type": "boolean"
                },
                "runnersToken": {
                    "type": "string",
                    "secret": true
                },
                "visibilityLevel": {
                    "type": "string"
                },
                "webUrl": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "defaultBranchProtection",
                "description",
                "fullName",
                "fullPath",
                "groupId",
                "lfsEnabled",
                "name",
                "parentId",
                "path",
                "preventForkingOutsideGroup",
                "requestAccessEnabled",
                "runnersToken",
                "visibilityLevel",
                "webUrl"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getInstanceDeployKeysDeployKey:getInstanceDeployKeysDeployKey": {
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "fingerprint": {
                    "type": "string"
                },
                "id": {
                    "type": "integer",
                    "description": "The ID of this resource.\n"
                },
                "key": {
                    "type": "string"
                },
                "projectsWithWriteAccesses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getInstanceDeployKeysDeployKeyProjectsWithWriteAccess:getInstanceDeployKeysDeployKeyProjectsWithWriteAccess"
                    }
                },
                "title": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "createdAt",
                "fingerprint",
                "id",
                "key",
                "projectsWithWriteAccesses",
                "title"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getInstanceDeployKeysDeployKeyProjectsWithWriteAccess:getInstanceDeployKeysDeployKeyProjectsWithWriteAccess": {
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "id": {
                    "type": "integer",
                    "description": "The ID of this resource.\n"
                },
                "name": {
                    "type": "string"
                },
                "nameWithNamespace": {
                    "type": "string"
                },
                "path": {
                    "type": "string"
                },
                "pathWithNamespace": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "createdAt",
                "description",
                "id",
                "name",
                "nameWithNamespace",
                "path",
                "pathWithNamespace"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getInstanceVariablesVariable:getInstanceVariablesVariable": {
            "properties": {
                "key": {
                    "type": "string"
                },
                "masked": {
                    "type": "boolean"
                },
                "protected": {
                    "type": "boolean"
                },
                "value": {
                    "type": "string"
                },
                "variableType": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "key",
                "masked",
                "protected",
                "value",
                "variableType"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getMetadataKas:getMetadataKas": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Indicates whether KAS is enabled.\n"
                },
                "externalUrl": {
                    "type": "string",
                    "description": "URL used by the agents to communicate with KAS. It’s null if kas.enabled is false.\n"
                },
                "version": {
                    "type": "string",
                    "description": "Version of KAS. It’s null if kas.enabled is false.\n"
                }
            },
            "type": "object",
            "required": [
                "enabled",
                "externalUrl",
                "version"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectBranchesBranch:getProjectBranchesBranch": {
            "properties": {
                "canPush": {
                    "type": "boolean"
                },
                "commits": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getProjectBranchesBranchCommit:getProjectBranchesBranchCommit"
                    }
                },
                "default": {
                    "type": "boolean"
                },
                "developersCanMerge": {
                    "type": "boolean"
                },
                "developersCanPush": {
                    "type": "boolean"
                },
                "merged": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string"
                },
                "protected": {
                    "type": "boolean"
                },
                "webUrl": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "canPush",
                "commits",
                "default",
                "developersCanMerge",
                "developersCanPush",
                "merged",
                "name",
                "protected",
                "webUrl"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectBranchesBranchCommit:getProjectBranchesBranchCommit": {
            "properties": {
                "authorEmail": {
                    "type": "string"
                },
                "authorName": {
                    "type": "string"
                },
                "authoredDate": {
                    "type": "string"
                },
                "committedDate": {
                    "type": "string"
                },
                "committerEmail": {
                    "type": "string"
                },
                "committerName": {
                    "type": "string"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of this resource.\n"
                },
                "message": {
                    "type": "string"
                },
                "parentIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "shortId": {
                    "type": "string"
                },
                "title": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "authorEmail",
                "authorName",
                "authoredDate",
                "committedDate",
                "committerEmail",
                "committerName",
                "id",
                "message",
                "parentIds",
                "shortId",
                "title"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectContainerExpirationPolicy:getProjectContainerExpirationPolicy": {
            "properties": {
                "cadence": {
                    "type": "string"
                },
                "enabled": {
                    "type": "boolean"
                },
                "keepN": {
                    "type": "integer"
                },
                "nameRegex": {
                    "type": "string"
                },
                "nameRegexDelete": {
                    "type": "string",
                    "deprecationMessage": "`name_regex_delete` has been deprecated. Use `name_regex` instead."
                },
                "nameRegexKeep": {
                    "type": "string"
                },
                "nextRunAt": {
                    "type": "string"
                },
                "olderThan": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "cadence",
                "enabled",
                "keepN",
                "nameRegex",
                "nameRegexDelete",
                "nameRegexKeep",
                "nextRunAt",
                "olderThan"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectHooksHook:getProjectHooksHook": {
            "properties": {
                "confidentialIssuesEvents": {
                    "type": "boolean"
                },
                "confidentialNoteEvents": {
                    "type": "boolean"
                },
                "deploymentEvents": {
                    "type": "boolean"
                },
                "enableSslVerification": {
                    "type": "boolean"
                },
                "hookId": {
                    "type": "integer"
                },
                "issuesEvents": {
                    "type": "boolean"
                },
                "jobEvents": {
                    "type": "boolean"
                },
                "mergeRequestsEvents": {
                    "type": "boolean"
                },
                "noteEvents": {
                    "type": "boolean"
                },
                "pipelineEvents": {
                    "type": "boolean"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project.\n"
                },
                "projectId": {
                    "type": "integer"
                },
                "pushEvents": {
                    "type": "boolean"
                },
                "pushEventsBranchFilter": {
                    "type": "string"
                },
                "releasesEvents": {
                    "type": "boolean"
                },
                "tagPushEvents": {
                    "type": "boolean"
                },
                "token": {
                    "type": "string"
                },
                "url": {
                    "type": "string"
                },
                "wikiPageEvents": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "required": [
                "confidentialIssuesEvents",
                "confidentialNoteEvents",
                "deploymentEvents",
                "enableSslVerification",
                "hookId",
                "issuesEvents",
                "jobEvents",
                "mergeRequestsEvents",
                "noteEvents",
                "pipelineEvents",
                "project",
                "projectId",
                "pushEvents",
                "pushEventsBranchFilter",
                "releasesEvents",
                "tagPushEvents",
                "token",
                "url",
                "wikiPageEvents"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectIssueTaskCompletionStatus:getProjectIssueTaskCompletionStatus": {
            "properties": {
                "completedCount": {
                    "type": "integer"
                },
                "count": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "completedCount",
                "count"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectIssuesIssue:getProjectIssuesIssue": {
            "properties": {
                "assigneeIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "authorId": {
                    "type": "integer",
                    "description": "Return issues created by the given user id. Combine with scope=all or scope=assigned*to*me.\n"
                },
                "closedAt": {
                    "type": "string"
                },
                "closedByUserId": {
                    "type": "integer"
                },
                "confidential": {
                    "type": "boolean",
                    "description": "Filter confidential or public issues.\n"
                },
                "createdAt": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "discussionLocked": {
                    "type": "boolean"
                },
                "discussionToResolve": {
                    "type": "string"
                },
                "downvotes": {
                    "type": "integer"
                },
                "dueDate": {
                    "type": "string",
                    "description": "Return issues that have no due date, are overdue, or whose due date is this week, this month, or between two weeks ago and next month. Accepts: 0 (no due date), any, today, tomorrow, overdue, week, month, next*month*and*previous*two_weeks.\n"
                },
                "epicId": {
                    "type": "integer"
                },
                "epicIssueId": {
                    "type": "integer"
                },
                "externalId": {
                    "type": "string"
                },
                "humanTimeEstimate": {
                    "type": "string"
                },
                "humanTotalTimeSpent": {
                    "type": "string"
                },
                "iid": {
                    "type": "integer"
                },
                "issueId": {
                    "type": "integer"
                },
                "issueLinkId": {
                    "type": "integer"
                },
                "issueType": {
                    "type": "string",
                    "description": "Filter to a given type of issue. Valid values are [issue incident test_case]. (Introduced in GitLab 13.12)\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Return issues with labels. Issues must have all labels to be returned. None lists all issues with no labels. Any lists all issues with at least one label. No+Label (Deprecated) lists all issues with no labels. Predefined names are case-insensitive.\n"
                },
                "links": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "mergeRequestToResolveDiscussionsOf": {
                    "type": "integer"
                },
                "mergeRequestsCount": {
                    "type": "integer"
                },
                "milestoneId": {
                    "type": "integer"
                },
                "movedToId": {
                    "type": "integer"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project.\n"
                },
                "references": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "state": {
                    "type": "string"
                },
                "subscribed": {
                    "type": "boolean"
                },
                "taskCompletionStatuses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getProjectIssuesIssueTaskCompletionStatus:getProjectIssuesIssueTaskCompletionStatus"
                    }
                },
                "timeEstimate": {
                    "type": "integer"
                },
                "title": {
                    "type": "string"
                },
                "totalTimeSpent": {
                    "type": "integer"
                },
                "updatedAt": {
                    "type": "string"
                },
                "upvotes": {
                    "type": "integer"
                },
                "userNotesCount": {
                    "type": "integer"
                },
                "webUrl": {
                    "type": "string"
                },
                "weight": {
                    "type": "integer",
                    "description": "Return issues with the specified weight. None returns issues with no weight assigned. Any returns issues with a weight assigned.\n"
                }
            },
            "type": "object",
            "required": [
                "assigneeIds",
                "authorId",
                "closedAt",
                "closedByUserId",
                "confidential",
                "createdAt",
                "description",
                "discussionLocked",
                "discussionToResolve",
                "downvotes",
                "dueDate",
                "epicId",
                "epicIssueId",
                "externalId",
                "humanTimeEstimate",
                "humanTotalTimeSpent",
                "iid",
                "issueId",
                "issueLinkId",
                "issueType",
                "labels",
                "links",
                "mergeRequestToResolveDiscussionsOf",
                "mergeRequestsCount",
                "milestoneId",
                "movedToId",
                "project",
                "references",
                "state",
                "subscribed",
                "taskCompletionStatuses",
                "timeEstimate",
                "title",
                "totalTimeSpent",
                "updatedAt",
                "upvotes",
                "userNotesCount",
                "webUrl",
                "weight"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectIssuesIssueTaskCompletionStatus:getProjectIssuesIssueTaskCompletionStatus": {
            "properties": {
                "completedCount": {
                    "type": "integer"
                },
                "count": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "completedCount",
                "count"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectMembershipMember:getProjectMembershipMember": {
            "properties": {
                "accessLevel": {
                    "type": "string"
                },
                "avatarUrl": {
                    "type": "string"
                },
                "expiresAt": {
                    "type": "string"
                },
                "id": {
                    "type": "integer",
                    "description": "The ID of this resource.\n"
                },
                "name": {
                    "type": "string"
                },
                "state": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                },
                "webUrl": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "accessLevel",
                "avatarUrl",
                "expiresAt",
                "id",
                "name",
                "state",
                "username",
                "webUrl"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectMilestonesMilestone:getProjectMilestonesMilestone": {
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "dueDate": {
                    "type": "string"
                },
                "expired": {
                    "type": "boolean"
                },
                "iid": {
                    "type": "integer"
                },
                "milestoneId": {
                    "type": "integer"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n"
                },
                "projectId": {
                    "type": "integer"
                },
                "startDate": {
                    "type": "string"
                },
                "state": {
                    "type": "string",
                    "description": "Return only `active` or `closed` milestones.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Return only the milestones having the given `title`.\n"
                },
                "updatedAt": {
                    "type": "string"
                },
                "webUrl": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "createdAt",
                "description",
                "dueDate",
                "expired",
                "iid",
                "milestoneId",
                "project",
                "projectId",
                "startDate",
                "state",
                "title",
                "updatedAt",
                "webUrl"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectProtectedBranchMergeAccessLevel:getProjectProtectedBranchMergeAccessLevel": {
            "properties": {
                "accessLevel": {
                    "type": "string"
                },
                "accessLevelDescription": {
                    "type": "string"
                },
                "groupId": {
                    "type": "integer"
                },
                "userId": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "accessLevel",
                "accessLevelDescription",
                "groupId",
                "userId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectProtectedBranchPushAccessLevel:getProjectProtectedBranchPushAccessLevel": {
            "properties": {
                "accessLevel": {
                    "type": "string"
                },
                "accessLevelDescription": {
                    "type": "string"
                },
                "groupId": {
                    "type": "integer"
                },
                "userId": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "accessLevel",
                "accessLevelDescription",
                "groupId",
                "userId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectProtectedBranchesProtectedBranch:getProjectProtectedBranchesProtectedBranch": {
            "properties": {
                "allowForcePush": {
                    "type": "boolean"
                },
                "codeOwnerApprovalRequired": {
                    "type": "boolean"
                },
                "id": {
                    "type": "integer",
                    "description": "The ID of this resource.\n"
                },
                "mergeAccessLevels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getProjectProtectedBranchesProtectedBranchMergeAccessLevel:getProjectProtectedBranchesProtectedBranchMergeAccessLevel"
                    }
                },
                "name": {
                    "type": "string"
                },
                "pushAccessLevels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getProjectProtectedBranchesProtectedBranchPushAccessLevel:getProjectProtectedBranchesProtectedBranchPushAccessLevel"
                    }
                }
            },
            "type": "object",
            "required": [
                "allowForcePush",
                "codeOwnerApprovalRequired",
                "id",
                "mergeAccessLevels",
                "name",
                "pushAccessLevels"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectProtectedBranchesProtectedBranchMergeAccessLevel:getProjectProtectedBranchesProtectedBranchMergeAccessLevel": {
            "properties": {
                "accessLevel": {
                    "type": "string"
                },
                "accessLevelDescription": {
                    "type": "string"
                },
                "groupId": {
                    "type": "integer"
                },
                "userId": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "accessLevel",
                "accessLevelDescription",
                "groupId",
                "userId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectProtectedBranchesProtectedBranchPushAccessLevel:getProjectProtectedBranchesProtectedBranchPushAccessLevel": {
            "properties": {
                "accessLevel": {
                    "type": "string"
                },
                "accessLevelDescription": {
                    "type": "string"
                },
                "groupId": {
                    "type": "integer"
                },
                "userId": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "accessLevel",
                "accessLevelDescription",
                "groupId",
                "userId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectPushRule:getProjectPushRule": {
            "properties": {
                "authorEmailRegex": {
                    "type": "string"
                },
                "branchNameRegex": {
                    "type": "string"
                },
                "commitCommitterCheck": {
                    "type": "boolean"
                },
                "commitMessageNegativeRegex": {
                    "type": "string"
                },
                "commitMessageRegex": {
                    "type": "string"
                },
                "denyDeleteTag": {
                    "type": "boolean"
                },
                "fileNameRegex": {
                    "type": "string"
                },
                "maxFileSize": {
                    "type": "integer"
                },
                "memberCheck": {
                    "type": "boolean"
                },
                "preventSecrets": {
                    "type": "boolean"
                },
                "rejectUnsignedCommits": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "required": [
                "authorEmailRegex",
                "branchNameRegex",
                "commitCommitterCheck",
                "commitMessageNegativeRegex",
                "commitMessageRegex",
                "denyDeleteTag",
                "fileNameRegex",
                "maxFileSize",
                "memberCheck",
                "preventSecrets",
                "rejectUnsignedCommits"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectTagCommit:getProjectTagCommit": {
            "properties": {
                "authorEmail": {
                    "type": "string"
                },
                "authorName": {
                    "type": "string"
                },
                "authoredDate": {
                    "type": "string"
                },
                "committedDate": {
                    "type": "string"
                },
                "committerEmail": {
                    "type": "string"
                },
                "committerName": {
                    "type": "string"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of this resource.\n"
                },
                "message": {
                    "type": "string",
                    "description": "The message of the annotated tag.\n"
                },
                "parentIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "shortId": {
                    "type": "string"
                },
                "title": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "authorEmail",
                "authorName",
                "authoredDate",
                "committedDate",
                "committerEmail",
                "committerName",
                "id",
                "message",
                "parentIds",
                "shortId",
                "title"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectTagRelease:getProjectTagRelease": {
            "properties": {
                "description": {
                    "type": "string"
                },
                "tagName": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "description",
                "tagName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectTagsTag:getProjectTagsTag": {
            "properties": {
                "commits": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getProjectTagsTagCommit:getProjectTagsTagCommit"
                    }
                },
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "protected": {
                    "type": "boolean"
                },
                "releases": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getProjectTagsTagRelease:getProjectTagsTagRelease"
                    }
                },
                "target": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "commits",
                "message",
                "name",
                "protected",
                "releases",
                "target"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectTagsTagCommit:getProjectTagsTagCommit": {
            "properties": {
                "authorEmail": {
                    "type": "string"
                },
                "authorName": {
                    "type": "string"
                },
                "authoredDate": {
                    "type": "string"
                },
                "committedDate": {
                    "type": "string"
                },
                "committerEmail": {
                    "type": "string"
                },
                "committerName": {
                    "type": "string"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of this resource.\n"
                },
                "message": {
                    "type": "string"
                },
                "parentIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "shortId": {
                    "type": "string"
                },
                "title": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "authorEmail",
                "authorName",
                "authoredDate",
                "committedDate",
                "committerEmail",
                "committerName",
                "id",
                "message",
                "parentIds",
                "shortId",
                "title"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectTagsTagRelease:getProjectTagsTagRelease": {
            "properties": {
                "description": {
                    "type": "string"
                },
                "tagName": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "description",
                "tagName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectVariablesVariable:getProjectVariablesVariable": {
            "properties": {
                "environmentScope": {
                    "type": "string",
                    "description": "The environment scope of the variable. Defaults to all environment (`*`).\n"
                },
                "key": {
                    "type": "string"
                },
                "masked": {
                    "type": "boolean"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project.\n"
                },
                "protected": {
                    "type": "boolean"
                },
                "value": {
                    "type": "string"
                },
                "variableType": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "environmentScope",
                "key",
                "masked",
                "project",
                "protected",
                "value",
                "variableType"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectsProject:getProjectsProject": {
            "properties": {
                "_links": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "allowMergeOnSkippedPipeline": {
                    "type": "boolean"
                },
                "analyticsAccessLevel": {
                    "type": "string"
                },
                "approvalsBeforeMerge": {
                    "type": "integer"
                },
                "archived": {
                    "type": "boolean",
                    "description": "Limit by archived status.\n"
                },
                "autoCancelPendingPipelines": {
                    "type": "string"
                },
                "autoDevopsDeployStrategy": {
                    "type": "string"
                },
                "autoDevopsEnabled": {
                    "type": "boolean"
                },
                "autocloseReferencedIssues": {
                    "type": "boolean"
                },
                "avatarUrl": {
                    "type": "string"
                },
                "buildCoverageRegex": {
                    "type": "string"
                },
                "buildGitStrategy": {
                    "type": "string"
                },
                "buildTimeout": {
                    "type": "integer"
                },
                "buildsAccessLevel": {
                    "type": "string"
                },
                "ciConfigPath": {
                    "type": "string"
                },
                "ciDefaultGitDepth": {
                    "type": "integer"
                },
                "ciForwardDeploymentEnabled": {
                    "type": "boolean"
                },
                "containerExpirationPolicies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getProjectsProjectContainerExpirationPolicy:getProjectsProjectContainerExpirationPolicy"
                    }
                },
                "containerRegistryAccessLevel": {
                    "type": "string"
                },
                "containerRegistryEnabled": {
                    "type": "boolean"
                },
                "createdAt": {
                    "type": "string"
                },
                "creatorId": {
                    "type": "integer"
                },
                "customAttributes": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    }
                },
                "defaultBranch": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "emailsDisabled": {
                    "type": "boolean"
                },
                "environmentsAccessLevel": {
                    "type": "string"
                },
                "externalAuthorizationClassificationLabel": {
                    "type": "string"
                },
                "featureFlagsAccessLevel": {
                    "type": "string"
                },
                "forkedFromProjects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getProjectsProjectForkedFromProject:getProjectsProjectForkedFromProject"
                    }
                },
                "forkingAccessLevel": {
                    "type": "string"
                },
                "forksCount": {
                    "type": "integer"
                },
                "httpUrlToRepo": {
                    "type": "string"
                },
                "id": {
                    "type": "integer",
                    "description": "The ID of this resource.\n"
                },
                "importError": {
                    "type": "string"
                },
                "importStatus": {
                    "type": "string"
                },
                "importUrl": {
                    "type": "string"
                },
                "infrastructureAccessLevel": {
                    "type": "string"
                },
                "issuesAccessLevel": {
                    "type": "string"
                },
                "issuesEnabled": {
                    "type": "boolean"
                },
                "jobsEnabled": {
                    "type": "boolean"
                },
                "keepLatestArtifact": {
                    "type": "boolean"
                },
                "lastActivityAt": {
                    "type": "string"
                },
                "lfsEnabled": {
                    "type": "boolean"
                },
                "mergeCommitTemplate": {
                    "type": "string"
                },
                "mergeMethod": {
                    "type": "string"
                },
                "mergePipelinesEnabled": {
                    "type": "boolean"
                },
                "mergeRequestsAccessLevel": {
                    "type": "string"
                },
                "mergeRequestsEnabled": {
                    "type": "boolean"
                },
                "mergeTrainsEnabled": {
                    "type": "boolean"
                },
                "mirror": {
                    "type": "boolean"
                },
                "mirrorOverwritesDivergedBranches": {
                    "type": "boolean"
                },
                "mirrorTriggerBuilds": {
                    "type": "boolean"
                },
                "mirrorUserId": {
                    "type": "integer"
                },
                "monitorAccessLevel": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "nameWithNamespace": {
                    "type": "string"
                },
                "namespaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getProjectsProjectNamespace:getProjectsProjectNamespace"
                    }
                },
                "onlyAllowMergeIfAllDiscussionsAreResolved": {
                    "type": "boolean"
                },
                "onlyAllowMergeIfPipelineSucceeds": {
                    "type": "boolean"
                },
                "onlyMirrorProtectedBranches": {
                    "type": "boolean"
                },
                "openIssuesCount": {
                    "type": "integer"
                },
                "operationsAccessLevel": {
                    "type": "string"
                },
                "owners": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getProjectsProjectOwner:getProjectsProjectOwner"
                    }
                },
                "packagesEnabled": {
                    "type": "boolean"
                },
                "path": {
                    "type": "string"
                },
                "pathWithNamespace": {
                    "type": "string"
                },
                "permissions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getProjectsProjectPermission:getProjectsProjectPermission"
                    }
                },
                "public": {
                    "type": "boolean"
                },
                "publicBuilds": {
                    "type": "boolean"
                },
                "readmeUrl": {
                    "type": "string"
                },
                "releasesAccessLevel": {
                    "type": "string"
                },
                "repositoryAccessLevel": {
                    "type": "string"
                },
                "repositoryStorage": {
                    "type": "string"
                },
                "requestAccessEnabled": {
                    "type": "boolean"
                },
                "requirementsAccessLevel": {
                    "type": "string"
                },
                "resolveOutdatedDiffDiscussions": {
                    "type": "boolean"
                },
                "restrictUserDefinedVariables": {
                    "type": "boolean"
                },
                "runnersToken": {
                    "type": "string",
                    "secret": true
                },
                "securityAndComplianceAccessLevel": {
                    "type": "string"
                },
                "sharedRunnersEnabled": {
                    "type": "boolean"
                },
                "sharedWithGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getProjectsProjectSharedWithGroup:getProjectsProjectSharedWithGroup"
                    }
                },
                "snippetsAccessLevel": {
                    "type": "string"
                },
                "snippetsEnabled": {
                    "type": "boolean"
                },
                "squashCommitTemplate": {
                    "type": "string"
                },
                "sshUrlToRepo": {
                    "type": "string"
                },
                "starCount": {
                    "type": "integer"
                },
                "statistics": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "integer"
                    },
                    "description": "Include project statistics. Cannot be used with `group_id`.\n"
                },
                "suggestionCommitMessage": {
                    "type": "string"
                },
                "tagLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "topics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "visibility": {
                    "type": "string",
                    "description": "Limit by visibility `public`, `internal`, or `private`.\n"
                },
                "webUrl": {
                    "type": "string"
                },
                "wikiAccessLevel": {
                    "type": "string"
                },
                "wikiEnabled": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "required": [
                "_links",
                "allowMergeOnSkippedPipeline",
                "analyticsAccessLevel",
                "approvalsBeforeMerge",
                "archived",
                "autoCancelPendingPipelines",
                "autoDevopsDeployStrategy",
                "autoDevopsEnabled",
                "autocloseReferencedIssues",
                "avatarUrl",
                "buildCoverageRegex",
                "buildGitStrategy",
                "buildTimeout",
                "buildsAccessLevel",
                "ciConfigPath",
                "ciDefaultGitDepth",
                "ciForwardDeploymentEnabled",
                "containerExpirationPolicies",
                "containerRegistryAccessLevel",
                "containerRegistryEnabled",
                "createdAt",
                "creatorId",
                "customAttributes",
                "defaultBranch",
                "description",
                "emailsDisabled",
                "environmentsAccessLevel",
                "externalAuthorizationClassificationLabel",
                "featureFlagsAccessLevel",
                "forkedFromProjects",
                "forkingAccessLevel",
                "forksCount",
                "httpUrlToRepo",
                "id",
                "importError",
                "importStatus",
                "importUrl",
                "infrastructureAccessLevel",
                "issuesAccessLevel",
                "issuesEnabled",
                "jobsEnabled",
                "keepLatestArtifact",
                "lastActivityAt",
                "lfsEnabled",
                "mergeCommitTemplate",
                "mergeMethod",
                "mergePipelinesEnabled",
                "mergeRequestsAccessLevel",
                "mergeRequestsEnabled",
                "mergeTrainsEnabled",
                "mirror",
                "mirrorOverwritesDivergedBranches",
                "mirrorTriggerBuilds",
                "mirrorUserId",
                "monitorAccessLevel",
                "name",
                "nameWithNamespace",
                "namespaces",
                "onlyAllowMergeIfAllDiscussionsAreResolved",
                "onlyAllowMergeIfPipelineSucceeds",
                "onlyMirrorProtectedBranches",
                "openIssuesCount",
                "operationsAccessLevel",
                "owners",
                "packagesEnabled",
                "path",
                "pathWithNamespace",
                "permissions",
                "public",
                "publicBuilds",
                "readmeUrl",
                "releasesAccessLevel",
                "repositoryAccessLevel",
                "repositoryStorage",
                "requestAccessEnabled",
                "requirementsAccessLevel",
                "resolveOutdatedDiffDiscussions",
                "restrictUserDefinedVariables",
                "runnersToken",
                "securityAndComplianceAccessLevel",
                "sharedRunnersEnabled",
                "sharedWithGroups",
                "snippetsAccessLevel",
                "snippetsEnabled",
                "squashCommitTemplate",
                "sshUrlToRepo",
                "starCount",
                "statistics",
                "suggestionCommitMessage",
                "tagLists",
                "topics",
                "visibility",
                "webUrl",
                "wikiAccessLevel",
                "wikiEnabled"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectsProjectContainerExpirationPolicy:getProjectsProjectContainerExpirationPolicy": {
            "properties": {
                "cadence": {
                    "type": "string"
                },
                "enabled": {
                    "type": "boolean"
                },
                "keepN": {
                    "type": "integer"
                },
                "nameRegex": {
                    "type": "string"
                },
                "nameRegexDelete": {
                    "type": "string",
                    "deprecationMessage": "`name_regex_delete` has been deprecated. Use `name_regex` instead."
                },
                "nameRegexKeep": {
                    "type": "string"
                },
                "nextRunAt": {
                    "type": "string"
                },
                "olderThan": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "cadence",
                "enabled",
                "keepN",
                "nameRegex",
                "nameRegexDelete",
                "nameRegexKeep",
                "nextRunAt",
                "olderThan"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectsProjectForkedFromProject:getProjectsProjectForkedFromProject": {
            "properties": {
                "httpUrlToRepo": {
                    "type": "string"
                },
                "id": {
                    "type": "integer",
                    "description": "The ID of this resource.\n"
                },
                "name": {
                    "type": "string"
                },
                "nameWithNamespace": {
                    "type": "string"
                },
                "path": {
                    "type": "string"
                },
                "pathWithNamespace": {
                    "type": "string"
                },
                "webUrl": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "httpUrlToRepo",
                "id",
                "name",
                "nameWithNamespace",
                "path",
                "pathWithNamespace",
                "webUrl"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectsProjectNamespace:getProjectsProjectNamespace": {
            "properties": {
                "fullPath": {
                    "type": "string"
                },
                "id": {
                    "type": "integer",
                    "description": "The ID of this resource.\n"
                },
                "kind": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "path": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "fullPath",
                "id",
                "kind",
                "name",
                "path"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectsProjectOwner:getProjectsProjectOwner": {
            "properties": {
                "avatarUrl": {
                    "type": "string"
                },
                "id": {
                    "type": "integer",
                    "description": "The ID of this resource.\n"
                },
                "name": {
                    "type": "string"
                },
                "state": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                },
                "websiteUrl": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "avatarUrl",
                "id",
                "name",
                "state",
                "username",
                "websiteUrl"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectsProjectPermission:getProjectsProjectPermission": {
            "properties": {
                "groupAccess": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "integer"
                    }
                },
                "projectAccess": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "integer"
                    }
                }
            },
            "type": "object",
            "required": [
                "groupAccess",
                "projectAccess"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectsProjectSharedWithGroup:getProjectsProjectSharedWithGroup": {
            "properties": {
                "groupAccessLevel": {
                    "type": "string"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of the group owned by the authenticated user to look projects for within. Cannot be used with `min_access_level`, `with_programming_language` or `statistics`.\n"
                },
                "groupName": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "groupAccessLevel",
                "groupId",
                "groupName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getReleaseLinksReleaseLink:getReleaseLinksReleaseLink": {
            "properties": {
                "directAssetUrl": {
                    "type": "string"
                },
                "external": {
                    "type": "boolean"
                },
                "filepath": {
                    "type": "string"
                },
                "linkId": {
                    "type": "integer"
                },
                "linkType": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path to the project.\n"
                },
                "tagName": {
                    "type": "string",
                    "description": "The tag associated with the Release.\n"
                },
                "url": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "directAssetUrl",
                "external",
                "filepath",
                "linkId",
                "linkType",
                "name",
                "project",
                "tagName",
                "url"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getRepositoryTreeTree:getRepositoryTreeTree": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "The ID of this resource.\n"
                },
                "mode": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "path": {
                    "type": "string",
                    "description": "The path inside repository. Used to get content of subdirectories.\n"
                },
                "type": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "id",
                "mode",
                "name",
                "path",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getUserSshkeysKey:getUserSshkeysKey": {
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "expiresAt": {
                    "type": "string"
                },
                "key": {
                    "type": "string"
                },
                "keyId": {
                    "type": "integer"
                },
                "title": {
                    "type": "string"
                },
                "userId": {
                    "type": "integer",
                    "description": "ID of the user to get the SSH keys for.\n"
                }
            },
            "type": "object",
            "required": [
                "createdAt",
                "expiresAt",
                "key",
                "keyId",
                "title",
                "userId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getUsersUser:getUsersUser": {
            "properties": {
                "avatarUrl": {
                    "type": "string"
                },
                "bio": {
                    "type": "string"
                },
                "canCreateGroup": {
                    "type": "boolean"
                },
                "canCreateProject": {
                    "type": "boolean"
                },
                "colorSchemeId": {
                    "type": "integer"
                },
                "createdAt": {
                    "type": "string"
                },
                "currentSignInAt": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "externUid": {
                    "type": "string",
                    "description": "Lookup users by external UID. (Requires administrator privileges)\n"
                },
                "external": {
                    "type": "boolean"
                },
                "id": {
                    "type": "integer",
                    "description": "The ID of this resource.\n"
                },
                "isAdmin": {
                    "type": "boolean"
                },
                "lastSignInAt": {
                    "type": "string"
                },
                "linkedin": {
                    "type": "string"
                },
                "location": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "namespaceId": {
                    "type": "integer"
                },
                "organization": {
                    "type": "string"
                },
                "projectsLimit": {
                    "type": "integer"
                },
                "provider": {
                    "type": "string"
                },
                "skype": {
                    "type": "string"
                },
                "state": {
                    "type": "string"
                },
                "themeId": {
                    "type": "integer"
                },
                "twitter": {
                    "type": "string"
                },
                "twoFactorEnabled": {
                    "type": "boolean"
                },
                "username": {
                    "type": "string"
                },
                "websiteUrl": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "avatarUrl",
                "bio",
                "canCreateGroup",
                "canCreateProject",
                "colorSchemeId",
                "createdAt",
                "currentSignInAt",
                "email",
                "externUid",
                "external",
                "id",
                "isAdmin",
                "lastSignInAt",
                "linkedin",
                "location",
                "name",
                "namespaceId",
                "organization",
                "projectsLimit",
                "provider",
                "skype",
                "state",
                "themeId",
                "twitter",
                "twoFactorEnabled",
                "username",
                "websiteUrl"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        }
    },
    "provider": {
        "description": "The provider type for the gitlab package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "baseUrl": {
                "type": "string",
                "description": "This is the target GitLab base API endpoint. Providing a value is a requirement when working with GitLab CE or GitLab\nEnterprise e.g. `https://my.gitlab.server/api/v4/`. It is optional to provide this value and it can also be sourced from\nthe `GITLAB_BASE_URL` environment variable. The value must end with a slash.\n"
            },
            "cacertFile": {
                "type": "string",
                "description": "This is a file containing the ca cert to verify the gitlab instance. This is available for use when working with GitLab\nCE or Gitlab Enterprise with a locally-issued or self-signed certificate chain.\n"
            },
            "clientCert": {
                "type": "string",
                "description": "File path to client certificate when GitLab instance is behind company proxy. File must contain PEM encoded data.\n"
            },
            "clientKey": {
                "type": "string",
                "description": "File path to client key when GitLab instance is behind company proxy. File must contain PEM encoded data. Required when\n`client_cert` is set.\n"
            },
            "earlyAuthCheck": {
                "type": "boolean",
                "description": "(Experimental) By default the provider does a dummy request to get the current user in order to verify that the provider\nconfiguration is correct and the GitLab API is reachable. Set this to `false` to skip this check. This may be useful if\nthe GitLab instance does not yet exist and is created within the same terraform module. It may be sourced from the\n`GITLAB_EARLY_AUTH_CHECK`. This is an experimental feature and may change in the future. Please make sure to always keep\nbackups of your state.\n"
            },
            "insecure": {
                "type": "boolean",
                "description": "When set to true this disables SSL verification of the connection to the GitLab instance.\n"
            },
            "token": {
                "type": "string",
                "description": "The OAuth2 Token, Project, Group, Personal Access Token or CI Job Token used to connect to GitLab. The OAuth method is\nused in this provider for authentication (using Bearer authorization token). See\nhttps://docs.gitlab.com/ee/api/#authentication for details. It may be sourced from the `GITLAB_TOKEN` environment\nvariable.\n",
                "secret": true
            }
        },
        "inputProperties": {
            "baseUrl": {
                "type": "string",
                "description": "This is the target GitLab base API endpoint. Providing a value is a requirement when working with GitLab CE or GitLab\nEnterprise e.g. `https://my.gitlab.server/api/v4/`. It is optional to provide this value and it can also be sourced from\nthe `GITLAB_BASE_URL` environment variable. The value must end with a slash.\n"
            },
            "cacertFile": {
                "type": "string",
                "description": "This is a file containing the ca cert to verify the gitlab instance. This is available for use when working with GitLab\nCE or Gitlab Enterprise with a locally-issued or self-signed certificate chain.\n"
            },
            "clientCert": {
                "type": "string",
                "description": "File path to client certificate when GitLab instance is behind company proxy. File must contain PEM encoded data.\n"
            },
            "clientKey": {
                "type": "string",
                "description": "File path to client key when GitLab instance is behind company proxy. File must contain PEM encoded data. Required when\n`client_cert` is set.\n"
            },
            "earlyAuthCheck": {
                "type": "boolean",
                "description": "(Experimental) By default the provider does a dummy request to get the current user in order to verify that the provider\nconfiguration is correct and the GitLab API is reachable. Set this to `false` to skip this check. This may be useful if\nthe GitLab instance does not yet exist and is created within the same terraform module. It may be sourced from the\n`GITLAB_EARLY_AUTH_CHECK`. This is an experimental feature and may change in the future. Please make sure to always keep\nbackups of your state.\n"
            },
            "insecure": {
                "type": "boolean",
                "description": "When set to true this disables SSL verification of the connection to the GitLab instance.\n"
            },
            "token": {
                "type": "string",
                "description": "The OAuth2 Token, Project, Group, Personal Access Token or CI Job Token used to connect to GitLab. The OAuth method is\nused in this provider for authentication (using Bearer authorization token). See\nhttps://docs.gitlab.com/ee/api/#authentication for details. It may be sourced from the `GITLAB_TOKEN` environment\nvariable.\n",
                "secret": true
            }
        }
    },
    "resources": {
        "gitlab:index/application:Application": {
            "description": "The `gitlab.Application` resource allows to manage the lifecycle of applications in gitlab.\n\n\u003e In order to use a user for a user to create an application, they must have admin privileges at the instance level.\nTo create an OIDC application, a scope of \"openid\".\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/applications.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst oidc = new gitlab.Application(\"oidc\", {\n    confidential: true,\n    redirectUrl: \"https://mycompany.com\",\n    scopes: [\"openid\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\noidc = gitlab.Application(\"oidc\",\n    confidential=True,\n    redirect_url=\"https://mycompany.com\",\n    scopes=[\"openid\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var oidc = new GitLab.Application(\"oidc\", new()\n    {\n        Confidential = true,\n        RedirectUrl = \"https://mycompany.com\",\n        Scopes = new[]\n        {\n            \"openid\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewApplication(ctx, \"oidc\", \u0026gitlab.ApplicationArgs{\n\t\t\tConfidential: pulumi.Bool(true),\n\t\t\tRedirectUrl:  pulumi.String(\"https://mycompany.com\"),\n\t\t\tScopes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"openid\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Application;\nimport com.pulumi.gitlab.ApplicationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var oidc = new Application(\"oidc\", ApplicationArgs.builder()        \n            .confidential(true)\n            .redirectUrl(\"https://mycompany.com\")\n            .scopes(\"openid\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  oidc:\n    type: gitlab:Application\n    properties:\n      confidential: true\n      redirectUrl: https://mycompany.com\n      scopes:\n        - openid\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitlab applications can be imported with their id, e.g.\n\n```sh\n $ pulumi import gitlab:index/application:Application example \"1\"\n```\n\n NOTEthe secret and scopes cannot be imported ",
            "properties": {
                "applicationId": {
                    "type": "string",
                    "description": "Internal name of the application.\n"
                },
                "confidential": {
                    "type": "boolean",
                    "description": "The application is used where the client secret can be kept confidential. Native mobile apps and Single Page Apps are considered non-confidential. Defaults to true if not supplied\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the application.\n"
                },
                "redirectUrl": {
                    "type": "string",
                    "description": "The URL gitlab should send the user to after authentication.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Scopes of the application. Use \"openid\" if you plan to use this as an oidc authentication application. Valid options are: `api`, `read_api`, `read_user`, `read_repository`, `write_repository`, `read_registry`, `write_registry`, `sudo`, `admin_mode`, `openid`, `profile`, `email`.\nThis is only populated when creating a new application. This attribute is not available for imported resources\n"
                },
                "secret": {
                    "type": "string",
                    "description": "Application secret. Sensitive and must be kept secret. This is only populated when creating a new application. This attribute is not available for imported resources.\n",
                    "secret": true
                }
            },
            "required": [
                "applicationId",
                "confidential",
                "name",
                "redirectUrl",
                "scopes",
                "secret"
            ],
            "inputProperties": {
                "confidential": {
                    "type": "boolean",
                    "description": "The application is used where the client secret can be kept confidential. Native mobile apps and Single Page Apps are considered non-confidential. Defaults to true if not supplied\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the application.\n"
                },
                "redirectUrl": {
                    "type": "string",
                    "description": "The URL gitlab should send the user to after authentication.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Scopes of the application. Use \"openid\" if you plan to use this as an oidc authentication application. Valid options are: `api`, `read_api`, `read_user`, `read_repository`, `write_repository`, `read_registry`, `write_registry`, `sudo`, `admin_mode`, `openid`, `profile`, `email`.\nThis is only populated when creating a new application. This attribute is not available for imported resources\n"
                }
            },
            "requiredInputs": [
                "redirectUrl",
                "scopes"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Application resources.\n",
                "properties": {
                    "applicationId": {
                        "type": "string",
                        "description": "Internal name of the application.\n"
                    },
                    "confidential": {
                        "type": "boolean",
                        "description": "The application is used where the client secret can be kept confidential. Native mobile apps and Single Page Apps are considered non-confidential. Defaults to true if not supplied\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the application.\n"
                    },
                    "redirectUrl": {
                        "type": "string",
                        "description": "The URL gitlab should send the user to after authentication.\n"
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Scopes of the application. Use \"openid\" if you plan to use this as an oidc authentication application. Valid options are: `api`, `read_api`, `read_user`, `read_repository`, `write_repository`, `read_registry`, `write_registry`, `sudo`, `admin_mode`, `openid`, `profile`, `email`.\nThis is only populated when creating a new application. This attribute is not available for imported resources\n"
                    },
                    "secret": {
                        "type": "string",
                        "description": "Application secret. Sensitive and must be kept secret. This is only populated when creating a new application. This attribute is not available for imported resources.\n",
                        "secret": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/applicationSettings:ApplicationSettings": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\n// Set the 2FA settings\nconst _this = new gitlab.ApplicationSettings(\"this\", {\n    requireTwoFactorAuthentication: true,\n    twoFactorGracePeriod: 24,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\n# Set the 2FA settings\nthis = gitlab.ApplicationSettings(\"this\",\n    require_two_factor_authentication=True,\n    two_factor_grace_period=24)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Set the 2FA settings\n    var @this = new GitLab.ApplicationSettings(\"this\", new()\n    {\n        RequireTwoFactorAuthentication = true,\n        TwoFactorGracePeriod = 24,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewApplicationSettings(ctx, \"this\", \u0026gitlab.ApplicationSettingsArgs{\n\t\t\tRequireTwoFactorAuthentication: pulumi.Bool(true),\n\t\t\tTwoFactorGracePeriod:           pulumi.Int(24),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ApplicationSettings;\nimport com.pulumi.gitlab.ApplicationSettingsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var this_ = new ApplicationSettings(\"this\", ApplicationSettingsArgs.builder()        \n            .requireTwoFactorAuthentication(true)\n            .twoFactorGracePeriod(24)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Set the 2FA settings\n  this:\n    type: gitlab:ApplicationSettings\n    properties:\n      requireTwoFactorAuthentication: true\n      twoFactorGracePeriod: 24\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "abuseNotificationEmail": {
                    "type": "string",
                    "description": "If set, abuse reports are sent to this address. Abuse reports are always available in the Admin Area.\n"
                },
                "adminMode": {
                    "type": "boolean",
                    "description": "Require administrators to enable Admin Mode by re-authenticating for administrative tasks.\n"
                },
                "afterSignOutPath": {
                    "type": "string",
                    "description": "Where to redirect users after logout.\n"
                },
                "afterSignUpText": {
                    "type": "string",
                    "description": "Text shown to the user after signing up.\n"
                },
                "akismetApiKey": {
                    "type": "string",
                    "description": "API key for Akismet spam protection.\n",
                    "secret": true
                },
                "akismetEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: akismet*api*key) Enable or disable Akismet spam protection.\n"
                },
                "allowGroupOwnersToManageLdap": {
                    "type": "boolean",
                    "description": "Set to true to allow group owners to manage LDAP.\n"
                },
                "allowLocalRequestsFromSystemHooks": {
                    "type": "boolean",
                    "description": "Allow requests to the local network from system hooks.\n"
                },
                "allowLocalRequestsFromWebHooksAndServices": {
                    "type": "boolean",
                    "description": "Allow requests to the local network from web hooks and services.\n"
                },
                "archiveBuildsInHumanReadable": {
                    "type": "string",
                    "description": "Set the duration for which the jobs are considered as old and expired. After that time passes, the jobs are archived and no longer able to be retried. Make it empty to never expire jobs. It has to be no less than 1 day, for example: 15 days, 1 month, 2 years.\n"
                },
                "assetProxyAllowlists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Assets that match these domains are not proxied. Wildcards allowed. Your GitLab installation URL is automatically allowlisted. GitLab restart is required to apply changes.\n"
                },
                "assetProxyEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: asset*proxy*url) Enable proxying of assets. GitLab restart is required to apply changes.\n"
                },
                "assetProxySecretKey": {
                    "type": "string",
                    "description": "Shared secret with the asset proxy server. GitLab restart is required to apply changes.\n",
                    "secret": true
                },
                "assetProxyUrl": {
                    "type": "string",
                    "description": "URL of the asset proxy server. GitLab restart is required to apply changes.\n"
                },
                "authorizedKeysEnabled": {
                    "type": "boolean",
                    "description": "By default, we write to the authorized_keys file to support Git over SSH without additional configuration. GitLab can be optimized to authenticate SSH keys via the database file. Only disable this if you have configured your OpenSSH server to use the AuthorizedKeysCommand.\n"
                },
                "autoDevopsDomain": {
                    "type": "string",
                    "description": "Specify a domain to use by default for every project’s Auto Review Apps and Auto Deploy stages.\n"
                },
                "autoDevopsEnabled": {
                    "type": "boolean",
                    "description": "Enable Auto DevOps for projects by default. It automatically builds, tests, and deploys applications based on a predefined CI/CD configuration.\n"
                },
                "automaticPurchasedStorageAllocation": {
                    "type": "boolean",
                    "description": "Enabling this permits automatic allocation of purchased storage in a namespace.\n"
                },
                "canCreateGroup": {
                    "type": "boolean",
                    "description": "Indicates whether users can create top-level groups. Introduced in GitLab 15.5.\n"
                },
                "checkNamespacePlan": {
                    "type": "boolean",
                    "description": "Enabling this makes only licensed EE features available to projects if the project namespace’s plan includes the feature or if the project is public.\n"
                },
                "commitEmailHostname": {
                    "type": "string",
                    "description": "Custom hostname (for private commit emails).\n"
                },
                "containerExpirationPoliciesEnableHistoricEntries": {
                    "type": "boolean",
                    "description": "Enable cleanup policies for all projects.\n"
                },
                "containerRegistryCleanupTagsServiceMaxListSize": {
                    "type": "integer",
                    "description": "The maximum number of tags that can be deleted in a single execution of cleanup policies.\n"
                },
                "containerRegistryDeleteTagsServiceTimeout": {
                    "type": "integer",
                    "description": "The maximum time, in seconds, that the cleanup process can take to delete a batch of tags for cleanup policies.\n"
                },
                "containerRegistryExpirationPoliciesCaching": {
                    "type": "boolean",
                    "description": "Caching during the execution of cleanup policies.\n"
                },
                "containerRegistryExpirationPoliciesWorkerCapacity": {
                    "type": "integer",
                    "description": "Number of workers for cleanup policies.\n"
                },
                "containerRegistryTokenExpireDelay": {
                    "type": "integer",
                    "description": "Container Registry token duration in minutes.\n"
                },
                "deactivateDormantUsers": {
                    "type": "boolean",
                    "description": "Enable automatic deactivation of dormant users.\n"
                },
                "defaultArtifactsExpireIn": {
                    "type": "string",
                    "description": "Set the default expiration time for each job’s artifacts.\n"
                },
                "defaultBranchName": {
                    "type": "string",
                    "description": "Instance-level custom initial branch name (introduced in GitLab 13.2).\n"
                },
                "defaultBranchProtection": {
                    "type": "integer",
                    "description": "Determine if developers can push to the default branch. Can take: 0 (not protected, both users with the Developer role or Maintainer role can push new commits and force push), 1 (partially protected, users with the Developer role or Maintainer role can push new commits, but cannot force push) or 2 (fully protected, users with the Developer or Maintainer role cannot push new commits, but users with the Developer or Maintainer role can; no one can force push) as a parameter. Default is 2.\n"
                },
                "defaultCiConfigPath": {
                    "type": "string",
                    "description": "Default CI/CD configuration file and path for new projects (.gitlab-ci.yml if not set).\n"
                },
                "defaultGroupVisibility": {
                    "type": "string",
                    "description": "What visibility level new groups receive. Can take private, internal and public as a parameter.\n"
                },
                "defaultProjectCreation": {
                    "type": "integer",
                    "description": "Default project creation protection. Can take: 0 (No one), 1 (Maintainers) or 2 (Developers + Maintainers).\n"
                },
                "defaultProjectVisibility": {
                    "type": "string",
                    "description": "What visibility level new projects receive. Can take private, internal and public as a parameter.\n"
                },
                "defaultProjectsLimit": {
                    "type": "integer",
                    "description": "Project limit per user.\n"
                },
                "defaultSnippetVisibility": {
                    "type": "string",
                    "description": "What visibility level new snippets receive. Can take private, internal and public as a parameter.\n"
                },
                "delayedGroupDeletion": {
                    "type": "boolean",
                    "description": "Enable delayed group deletion. Introduced in GitLab 15.0. From GitLab 15.1, disables and locks the group-level setting for delayed protect deletion when set to false.\n"
                },
                "delayedProjectDeletion": {
                    "type": "boolean",
                    "description": "Enable delayed project deletion by default in new groups. From GitLab 15.1, can only be enabled when delayed*group*deletion is true.\n"
                },
                "deleteInactiveProjects": {
                    "type": "boolean",
                    "description": "Enable inactive project deletion feature. Introduced in GitLab 14.10. Became operational in GitLab 15.0 (with feature flag inactive*projects*deletion).\n"
                },
                "deletionAdjournedPeriod": {
                    "type": "integer",
                    "description": "The number of days to wait before deleting a project or group that is marked for deletion. Value must be between 1 and 90. From GitLab 15.1, a hook on deletion*adjourned*period sets the period to 1 on every update, and sets both delayed*project*deletion and delayed*group*deletion to false if the period is 0.\n"
                },
                "diffMaxFiles": {
                    "type": "integer",
                    "description": "Maximum files in a diff.\n"
                },
                "diffMaxLines": {
                    "type": "integer",
                    "description": "Maximum lines in a diff.\n"
                },
                "diffMaxPatchBytes": {
                    "type": "integer",
                    "description": "Maximum diff patch size, in bytes.\n"
                },
                "disableFeedToken": {
                    "type": "boolean",
                    "description": "Disable display of RSS/Atom and calendar feed tokens (introduced in GitLab 13.7).\n"
                },
                "disabledOauthSignInSources": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Disabled OAuth sign-in sources.\n"
                },
                "dnsRebindingProtectionEnabled": {
                    "type": "boolean",
                    "description": "Enforce DNS rebinding attack protection.\n"
                },
                "domainAllowlists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Force people to use only corporate emails for sign-up. Null means there is no restriction.\n"
                },
                "domainDenylistEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: domain_denylist) Allows blocking sign-ups from emails from specific domains.\n"
                },
                "domainDenylists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Users with email addresses that match these domains cannot sign up. Wildcards allowed. Use separate lines for multiple entries. Ex: domain.com, *.domain.com.\n"
                },
                "dsaKeyRestriction": {
                    "type": "integer",
                    "description": "The minimum allowed bit length of an uploaded DSA key. 0 means no restriction. -1 disables DSA keys.\n"
                },
                "ecdsaKeyRestriction": {
                    "type": "integer",
                    "description": "The minimum allowed curve size (in bits) of an uploaded ECDSA key. 0 means no restriction. -1 disables ECDSA keys.\n"
                },
                "ecdsaSkKeyRestriction": {
                    "type": "integer",
                    "description": "The minimum allowed curve size (in bits) of an uploaded ECDSA*SK key. 0 means no restriction. -1 disables ECDSA*SK keys.\n"
                },
                "ed25519KeyRestriction": {
                    "type": "integer",
                    "description": "The minimum allowed curve size (in bits) of an uploaded ED25519 key. 0 means no restriction. -1 disables ED25519 keys.\n"
                },
                "ed25519SkKeyRestriction": {
                    "type": "integer",
                    "description": "The minimum allowed curve size (in bits) of an uploaded ED25519*SK key. 0 means no restriction. -1 disables ED25519*SK keys.\n"
                },
                "eksAccessKeyId": {
                    "type": "string",
                    "description": "AWS IAM access key ID.\n",
                    "secret": true
                },
                "eksAccountId": {
                    "type": "string",
                    "description": "Amazon account ID.\n"
                },
                "eksIntegrationEnabled": {
                    "type": "boolean",
                    "description": "Enable integration with Amazon EKS.\n"
                },
                "eksSecretAccessKey": {
                    "type": "string",
                    "description": "AWS IAM secret access key.\n",
                    "secret": true
                },
                "elasticsearchAws": {
                    "type": "boolean",
                    "description": "Enable the use of AWS hosted Elasticsearch.\n"
                },
                "elasticsearchAwsAccessKey": {
                    "type": "string",
                    "description": "AWS IAM access key.\n",
                    "secret": true
                },
                "elasticsearchAwsRegion": {
                    "type": "string",
                    "description": "The AWS region the Elasticsearch domain is configured.\n"
                },
                "elasticsearchAwsSecretAccessKey": {
                    "type": "string",
                    "description": "AWS IAM secret access key.\n",
                    "secret": true
                },
                "elasticsearchIndexedFieldLengthLimit": {
                    "type": "integer",
                    "description": "Maximum size of text fields to index by Elasticsearch. 0 value means no limit. This does not apply to repository and wiki indexing.\n"
                },
                "elasticsearchIndexedFileSizeLimitKb": {
                    "type": "integer",
                    "description": "Maximum size of repository and wiki files that are indexed by Elasticsearch.\n"
                },
                "elasticsearchIndexing": {
                    "type": "boolean",
                    "description": "Enable Elasticsearch indexing.\n"
                },
                "elasticsearchLimitIndexing": {
                    "type": "boolean",
                    "description": "Limit Elasticsearch to index certain namespaces and projects.\n"
                },
                "elasticsearchMaxBulkConcurrency": {
                    "type": "integer",
                    "description": "Maximum concurrency of Elasticsearch bulk requests per indexing operation. This only applies to repository indexing operations.\n"
                },
                "elasticsearchMaxBulkSizeMb": {
                    "type": "integer",
                    "description": "Maximum size of Elasticsearch bulk indexing requests in MB. This only applies to repository indexing operations.\n"
                },
                "elasticsearchNamespaceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The namespaces to index via Elasticsearch if elasticsearch*limit*indexing is enabled.\n"
                },
                "elasticsearchPassword": {
                    "type": "string",
                    "description": "The password of your Elasticsearch instance.\n",
                    "secret": true
                },
                "elasticsearchProjectIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The projects to index via Elasticsearch if elasticsearch*limit*indexing is enabled.\n"
                },
                "elasticsearchSearch": {
                    "type": "boolean",
                    "description": "Enable Elasticsearch search.\n"
                },
                "elasticsearchUrls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The URL to use for connecting to Elasticsearch. Use a comma-separated list to support cluster (for example, http://localhost:9200, http://localhost:9201).\n"
                },
                "elasticsearchUsername": {
                    "type": "string",
                    "description": "The username of your Elasticsearch instance.\n"
                },
                "emailAdditionalText": {
                    "type": "string",
                    "description": "Additional text added to the bottom of every email for legal/auditing/compliance reasons.\n"
                },
                "emailAuthorInBody": {
                    "type": "boolean",
                    "description": "Some email servers do not support overriding the email sender name. Enable this option to include the name of the author of the issue, merge request or comment in the email body instead.\n"
                },
                "enabledGitAccessProtocol": {
                    "type": "string",
                    "description": "Enabled protocols for Git access. Allowed values are: ssh, http, and nil to allow both protocols.\n"
                },
                "enforceNamespaceStorageLimit": {
                    "type": "boolean",
                    "description": "Enabling this permits enforcement of namespace storage limits.\n"
                },
                "enforceTerms": {
                    "type": "boolean",
                    "description": "(If enabled, requires: terms) Enforce application ToS to all users.\n"
                },
                "externalAuthClientCert": {
                    "type": "string",
                    "description": "(If enabled, requires: external*auth*client_key) The certificate to use to authenticate with the external authorization service.\n"
                },
                "externalAuthClientKey": {
                    "type": "string",
                    "description": "Private key for the certificate when authentication is required for the external authorization service, this is encrypted when stored.\n",
                    "secret": true
                },
                "externalAuthClientKeyPass": {
                    "type": "string",
                    "description": "Passphrase to use for the private key when authenticating with the external service this is encrypted when stored.\n",
                    "secret": true
                },
                "externalAuthorizationServiceDefaultLabel": {
                    "type": "string",
                    "description": "The default classification label to use when requesting authorization and no classification label has been specified on the project.\n"
                },
                "externalAuthorizationServiceEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: external*authorization*service*default*label, external*authorization*service*timeout and external*authorization*service*url) Enable using an external authorization service for accessing projects.\n"
                },
                "externalAuthorizationServiceTimeout": {
                    "type": "number",
                    "description": "The timeout after which an authorization request is aborted, in seconds. When a request times out, access is denied to the user. (min: 0.001, max: 10, step: 0.001).\n"
                },
                "externalAuthorizationServiceUrl": {
                    "type": "string",
                    "description": "URL to which authorization requests are directed.\n"
                },
                "externalPipelineValidationServiceTimeout": {
                    "type": "integer",
                    "description": "How long to wait for a response from the pipeline validation service. Assumes OK if it times out.\n"
                },
                "externalPipelineValidationServiceToken": {
                    "type": "string",
                    "description": "Optional. Token to include as the X-Gitlab-Token header in requests to the URL in external*pipeline*validation*service*url.\n"
                },
                "externalPipelineValidationServiceUrl": {
                    "type": "string",
                    "description": "URL to use for pipeline validation requests.\n"
                },
                "fileTemplateProjectId": {
                    "type": "integer",
                    "description": "The ID of a project to load custom file templates from.\n"
                },
                "firstDayOfWeek": {
                    "type": "integer",
                    "description": "Start day of the week for calendar views and date pickers. Valid values are 0 for Sunday, 1 for Monday, and 6 for Saturday.\n"
                },
                "geoNodeAllowedIps": {
                    "type": "string",
                    "description": "Comma-separated list of IPs and CIDRs of allowed secondary nodes. For example, 1.1.1.1, 2.2.2.0/24.\n"
                },
                "geoStatusTimeout": {
                    "type": "integer",
                    "description": "The amount of seconds after which a request to get a secondary node status times out.\n"
                },
                "gitRateLimitUsersAllowlists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of usernames excluded from Git anti-abuse rate limits. Maximum: 100 usernames. Introduced in GitLab 15.2.\n"
                },
                "gitTwoFactorSessionExpiry": {
                    "type": "integer",
                    "description": "Maximum duration (in minutes) of a session for Git operations when 2FA is enabled.\n"
                },
                "gitalyTimeoutDefault": {
                    "type": "integer",
                    "description": "Default Gitaly timeout, in seconds. This timeout is not enforced for Git fetch/push operations or Sidekiq jobs. Set to 0 to disable timeouts.\n"
                },
                "gitalyTimeoutFast": {
                    "type": "integer",
                    "description": "Gitaly fast operation timeout, in seconds. Some Gitaly operations are expected to be fast. If they exceed this threshold, there may be a problem with a storage shard and ‘failing fast’ can help maintain the stability of the GitLab instance. Set to 0 to disable timeouts.\n"
                },
                "gitalyTimeoutMedium": {
                    "type": "integer",
                    "description": "Medium Gitaly timeout, in seconds. This should be a value between the Fast and the Default timeout. Set to 0 to disable timeouts.\n"
                },
                "grafanaEnabled": {
                    "type": "boolean",
                    "description": "Enable Grafana.\n"
                },
                "grafanaUrl": {
                    "type": "string",
                    "description": "Grafana URL.\n"
                },
                "gravatarEnabled": {
                    "type": "boolean",
                    "description": "Enable Gravatar.\n"
                },
                "groupOwnersCanManageDefaultBranchProtection": {
                    "type": "boolean",
                    "description": "Prevent overrides of default branch protection.\n"
                },
                "hashedStorageEnabled": {
                    "type": "boolean",
                    "description": "Create new projects using hashed storage paths: Enable immutable, hash-based paths and repository names to store repositories on disk. This prevents repositories from having to be moved or renamed when the Project URL changes and may improve disk I/O performance. (Always enabled in GitLab versions 13.0 and later, configuration is scheduled for removal in 14.0).\n"
                },
                "helpPageHideCommercialContent": {
                    "type": "boolean",
                    "description": "Hide marketing-related entries from help.\n"
                },
                "helpPageSupportUrl": {
                    "type": "string",
                    "description": "Alternate support URL for help page and help dropdown.\n"
                },
                "helpPageText": {
                    "type": "string",
                    "description": "Custom text displayed on the help page.\n"
                },
                "helpText": {
                    "type": "string",
                    "description": "GitLab server administrator information.\n"
                },
                "hideThirdPartyOffers": {
                    "type": "boolean",
                    "description": "Do not display offers from third parties in GitLab.\n"
                },
                "homePageUrl": {
                    "type": "string",
                    "description": "Redirect to this URL when not logged in.\n"
                },
                "housekeepingEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: housekeeping*bitmaps*enabled, housekeeping*full*repack*period, housekeeping*gc*period, and housekeeping*incremental*repack*period) Enable or disable Git housekeeping.\n"
                },
                "housekeepingFullRepackPeriod": {
                    "type": "integer",
                    "description": "Number of Git pushes after which an incremental git repack is run.\n"
                },
                "housekeepingGcPeriod": {
                    "type": "integer",
                    "description": "Number of Git pushes after which git gc is run.\n"
                },
                "housekeepingIncrementalRepackPeriod": {
                    "type": "integer",
                    "description": "Number of Git pushes after which an incremental git repack is run.\n"
                },
                "htmlEmailsEnabled": {
                    "type": "boolean",
                    "description": "Enable HTML emails.\n"
                },
                "importSources": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Sources to allow project import from, possible values: github, bitbucket, bitbucket*server, gitlab, fogbugz, git, gitlab*project, gitea, manifest, and phabricator.\n"
                },
                "inProductMarketingEmailsEnabled": {
                    "type": "boolean",
                    "description": "Enable in-product marketing emails.\n"
                },
                "inactiveProjectsDeleteAfterMonths": {
                    "type": "integer",
                    "description": "If delete*inactive*projects is true, the time (in months) to wait before deleting inactive projects. Introduced in GitLab 14.10. Became operational in GitLab 15.0.\n"
                },
                "inactiveProjectsMinSizeMb": {
                    "type": "integer",
                    "description": "If delete*inactive*projects is true, the minimum repository size for projects to be checked for inactivity. Introduced in GitLab 14.10. Became operational in GitLab 15.0.\n"
                },
                "inactiveProjectsSendWarningEmailAfterMonths": {
                    "type": "integer",
                    "description": "If delete*inactive*projects is true, sets the time (in months) to wait before emailing maintainers that the project is scheduled be deleted because it is inactive. Introduced in GitLab 14.10. Became operational in GitLab 15.0.\n"
                },
                "invisibleCaptchaEnabled": {
                    "type": "boolean",
                    "description": "Enable Invisible CAPTCHA spam detection during sign-up.\n"
                },
                "issuesCreateLimit": {
                    "type": "integer",
                    "description": "Max number of issue creation requests per minute per user.\n"
                },
                "keepLatestArtifact": {
                    "type": "boolean",
                    "description": "Prevent the deletion of the artifacts from the most recent successful jobs, regardless of the expiry time.\n"
                },
                "localMarkdownVersion": {
                    "type": "integer",
                    "description": "Increase this value when any cached Markdown should be invalidated.\n"
                },
                "mailgunEventsEnabled": {
                    "type": "boolean",
                    "description": "Enable Mailgun event receiver.\n"
                },
                "mailgunSigningKey": {
                    "type": "string",
                    "description": "The Mailgun HTTP webhook signing key for receiving events from webhook.\n",
                    "secret": true
                },
                "maintenanceMode": {
                    "type": "boolean",
                    "description": "When instance is in maintenance mode, non-administrative users can sign in with read-only access and make read-only API requests.\n"
                },
                "maintenanceModeMessage": {
                    "type": "string",
                    "description": "Message displayed when instance is in maintenance mode.\n"
                },
                "maxArtifactsSize": {
                    "type": "integer",
                    "description": "Maximum artifacts size in MB.\n"
                },
                "maxAttachmentSize": {
                    "type": "integer",
                    "description": "Limit attachment size in MB.\n"
                },
                "maxExportSize": {
                    "type": "integer",
                    "description": "Maximum export size in MB. 0 for unlimited.\n"
                },
                "maxImportSize": {
                    "type": "integer",
                    "description": "Maximum import size in MB. 0 for unlimited.\n"
                },
                "maxNumberOfRepositoryDownloads": {
                    "type": "integer",
                    "description": "Maximum number of unique repositories a user can download in the specified time period before they are banned. Maximum: 10,000 repositories. Introduced in GitLab 15.1.\n"
                },
                "maxNumberOfRepositoryDownloadsWithinTimePeriod": {
                    "type": "integer",
                    "description": "Reporting time period (in seconds). Maximum: 864000 seconds (10 days). Introduced in GitLab 15.1.\n"
                },
                "maxPagesSize": {
                    "type": "integer",
                    "description": "Maximum size of pages repositories in MB.\n"
                },
                "maxPersonalAccessTokenLifetime": {
                    "type": "integer",
                    "description": "Maximum allowable lifetime for access tokens in days.\n"
                },
                "maxSshKeyLifetime": {
                    "type": "integer",
                    "description": "Maximum allowable lifetime for SSH keys in days. Introduced in GitLab 14.6.\n"
                },
                "metricsMethodCallThreshold": {
                    "type": "integer",
                    "description": "A method call is only tracked when it takes longer than the given amount of milliseconds.\n"
                },
                "mirrorAvailable": {
                    "type": "boolean",
                    "description": "Allow repository mirroring to configured by project Maintainers. If disabled, only Administrators can configure repository mirroring.\n"
                },
                "mirrorCapacityThreshold": {
                    "type": "integer",
                    "description": "Minimum capacity to be available before scheduling more mirrors preemptively.\n"
                },
                "mirrorMaxCapacity": {
                    "type": "integer",
                    "description": "Maximum number of mirrors that can be synchronizing at the same time.\n"
                },
                "mirrorMaxDelay": {
                    "type": "integer",
                    "description": "Maximum time (in minutes) between updates that a mirror can have when scheduled to synchronize.\n"
                },
                "npmPackageRequestsForwarding": {
                    "type": "boolean",
                    "description": "Use npmjs.org as a default remote repository when the package is not found in the GitLab Package Registry for npm.\n"
                },
                "outboundLocalRequestsWhitelists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Define a list of trusted domains or IP addresses to which local requests are allowed when local requests for hooks and services are disabled.\n"
                },
                "packageRegistryCleanupPoliciesWorkerCapacity": {
                    "type": "integer",
                    "description": "Number of workers assigned to the packages cleanup policies.\n"
                },
                "pagesDomainVerificationEnabled": {
                    "type": "boolean",
                    "description": "Require users to prove ownership of custom domains. Domain verification is an essential security measure for public GitLab sites. Users are required to demonstrate they control a domain before it is enabled.\n"
                },
                "passwordAuthenticationEnabledForGit": {
                    "type": "boolean",
                    "description": "Enable authentication for Git over HTTP(S) via a GitLab account password.\n"
                },
                "passwordAuthenticationEnabledForWeb": {
                    "type": "boolean",
                    "description": "Enable authentication for the web interface via a GitLab account password.\n"
                },
                "passwordLowercaseRequired": {
                    "type": "boolean",
                    "description": "Indicates whether passwords require at least one lowercase letter. Introduced in GitLab 15.1.\n"
                },
                "passwordNumberRequired": {
                    "type": "boolean",
                    "description": "Indicates whether passwords require at least one number. Introduced in GitLab 15.1.\n"
                },
                "passwordSymbolRequired": {
                    "type": "boolean",
                    "description": "Indicates whether passwords require at least one symbol character. Introduced in GitLab 15.1.\n"
                },
                "passwordUppercaseRequired": {
                    "type": "boolean",
                    "description": "Indicates whether passwords require at least one uppercase letter. Introduced in GitLab 15.1.\n"
                },
                "performanceBarAllowedGroupPath": {
                    "type": "string",
                    "description": "Path of the group that is allowed to toggle the performance bar.\n"
                },
                "personalAccessTokenPrefix": {
                    "type": "string",
                    "description": "Prefix for all generated personal access tokens.\n"
                },
                "pipelineLimitPerProjectUserSha": {
                    "type": "integer",
                    "description": "Maximum number of pipeline creation requests per minute per user and commit.\n"
                },
                "plantumlEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: plantuml_url) Enable PlantUML integration.\n"
                },
                "plantumlUrl": {
                    "type": "string",
                    "description": "The PlantUML instance URL for integration.\n"
                },
                "pollingIntervalMultiplier": {
                    "type": "number",
                    "description": "Interval multiplier used by endpoints that perform polling. Set to 0 to disable polling.\n"
                },
                "projectExportEnabled": {
                    "type": "boolean",
                    "description": "Enable project export.\n"
                },
                "prometheusMetricsEnabled": {
                    "type": "boolean",
                    "description": "Enable Prometheus metrics.\n"
                },
                "protectedCiVariables": {
                    "type": "boolean",
                    "description": "CI/CD variables are protected by default.\n"
                },
                "pushEventActivitiesLimit": {
                    "type": "integer",
                    "description": "Number of changes (branches or tags) in a single push to determine whether individual push events or bulk push events are created. Bulk push events are created if it surpasses that value.\n"
                },
                "pushEventHooksLimit": {
                    "type": "integer",
                    "description": "Number of changes (branches or tags) in a single push to determine whether webhooks and services fire or not. Webhooks and services aren’t submitted if it surpasses that value.\n"
                },
                "pypiPackageRequestsForwarding": {
                    "type": "boolean",
                    "description": "Use pypi.org as a default remote repository when the package is not found in the GitLab Package Registry for PyPI.\n"
                },
                "rateLimitingResponseText": {
                    "type": "string",
                    "description": "When rate limiting is enabled via the throttle_* settings, send this plain text response when a rate limit is exceeded. ‘Retry later’ is sent if this is blank.\n"
                },
                "rawBlobRequestLimit": {
                    "type": "integer",
                    "description": "Max number of requests per minute for each raw path. To disable throttling set to 0.\n"
                },
                "recaptchaEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: recaptcha*private*key and recaptcha*site*key) Enable reCAPTCHA.\n"
                },
                "recaptchaPrivateKey": {
                    "type": "string",
                    "description": "Private key for reCAPTCHA.\n",
                    "secret": true
                },
                "recaptchaSiteKey": {
                    "type": "string",
                    "description": "Site key for reCAPTCHA.\n",
                    "secret": true
                },
                "receiveMaxInputSize": {
                    "type": "integer",
                    "description": "Maximum push size (MB).\n"
                },
                "repositoryChecksEnabled": {
                    "type": "boolean",
                    "description": "GitLab periodically runs git fsck in all project and wiki repositories to look for silent disk corruption issues.\n"
                },
                "repositorySizeLimit": {
                    "type": "integer",
                    "description": "Size limit per repository (MB).\n"
                },
                "repositoryStorages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(GitLab 13.0 and earlier) List of names of enabled storage paths, taken from gitlab.yml. New projects are created in one of these stores, chosen at random.\n"
                },
                "repositoryStoragesWeighted": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "integer"
                    },
                    "description": "(GitLab 13.1 and later) Hash of names of taken from gitlab.yml to weights. New projects are created in one of these stores, chosen by a weighted random selection.\n"
                },
                "requireAdminApprovalAfterUserSignup": {
                    "type": "boolean",
                    "description": "When enabled, any user that signs up for an account using the registration form is placed under a Pending approval state and has to be explicitly approved by an administrator.\n"
                },
                "requireTwoFactorAuthentication": {
                    "type": "boolean",
                    "description": "(If enabled, requires: two*factor*grace_period) Require all users to set up Two-factor authentication.\n"
                },
                "restrictedVisibilityLevels": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Selected levels cannot be used by non-Administrator users for groups, projects or snippets. Can take private, internal and public as a parameter. Null means there is no restriction.\n"
                },
                "rsaKeyRestriction": {
                    "type": "integer",
                    "description": "The minimum allowed bit length of an uploaded RSA key. 0 means no restriction. -1 disables RSA keys.\n"
                },
                "searchRateLimit": {
                    "type": "integer",
                    "description": "Max number of requests per minute for performing a search while authenticated. To disable throttling set to 0.\n"
                },
                "searchRateLimitUnauthenticated": {
                    "type": "integer",
                    "description": "Max number of requests per minute for performing a search while unauthenticated. To disable throttling set to 0.\n"
                },
                "sendUserConfirmationEmail": {
                    "type": "boolean",
                    "description": "Send confirmation email on sign-up.\n"
                },
                "sessionExpireDelay": {
                    "type": "integer",
                    "description": "Session duration in minutes. GitLab restart is required to apply changes.\n"
                },
                "sharedRunnersEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: shared*runners*text and shared*runners*minutes) Enable shared runners for new projects.\n"
                },
                "sharedRunnersMinutes": {
                    "type": "integer",
                    "description": "Set the maximum number of CI/CD minutes that a group can use on shared runners per month.\n"
                },
                "sharedRunnersText": {
                    "type": "string",
                    "description": "Shared runners text.\n"
                },
                "sidekiqJobLimiterCompressionThresholdBytes": {
                    "type": "integer",
                    "description": "The threshold in bytes at which Sidekiq jobs are compressed before being stored in Redis.\n"
                },
                "sidekiqJobLimiterLimitBytes": {
                    "type": "integer",
                    "description": "The threshold in bytes at which Sidekiq jobs are rejected. 0 means do not reject any job.\n"
                },
                "sidekiqJobLimiterMode": {
                    "type": "string",
                    "description": "track or compress. Sets the behavior for Sidekiq job size limits.\n"
                },
                "signInText": {
                    "type": "string",
                    "description": "Text on the login page.\n"
                },
                "signupEnabled": {
                    "type": "boolean",
                    "description": "Enable registration.\n"
                },
                "slackAppEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: slack*app*id, slack*app*secret and slack*app*secret) Enable Slack app.\n"
                },
                "slackAppId": {
                    "type": "string",
                    "description": "The app ID of the Slack-app.\n"
                },
                "slackAppSecret": {
                    "type": "string",
                    "description": "The app secret of the Slack-app.\n",
                    "secret": true
                },
                "slackAppSigningSecret": {
                    "type": "string",
                    "description": "The signing secret of the Slack-app.\n",
                    "secret": true
                },
                "slackAppVerificationToken": {
                    "type": "string",
                    "description": "The verification token of the Slack-app.\n"
                },
                "snippetSizeLimit": {
                    "type": "integer",
                    "description": "Max snippet content size in bytes.\n"
                },
                "snowplowAppId": {
                    "type": "string",
                    "description": "The Snowplow site name / application ID. (for example, gitlab)\n"
                },
                "snowplowCollectorHostname": {
                    "type": "string",
                    "description": "The Snowplow collector hostname. (for example, snowplow.trx.gitlab.net)\n"
                },
                "snowplowCookieDomain": {
                    "type": "string",
                    "description": "The Snowplow cookie domain. (for example, .gitlab.com)\n"
                },
                "snowplowEnabled": {
                    "type": "boolean",
                    "description": "Enable snowplow tracking.\n"
                },
                "sourcegraphEnabled": {
                    "type": "boolean",
                    "description": "Enables Sourcegraph integration. If enabled, requires sourcegraph_url.\n"
                },
                "sourcegraphPublicOnly": {
                    "type": "boolean",
                    "description": "Blocks Sourcegraph from being loaded on private and internal projects.\n"
                },
                "sourcegraphUrl": {
                    "type": "string",
                    "description": "The Sourcegraph instance URL for integration.\n"
                },
                "spamCheckApiKey": {
                    "type": "string",
                    "description": "API key used by GitLab for accessing the Spam Check service endpoint.\n",
                    "secret": true
                },
                "spamCheckEndpointEnabled": {
                    "type": "boolean",
                    "description": "Enables spam checking using external Spam Check API endpoint.\n"
                },
                "spamCheckEndpointUrl": {
                    "type": "string",
                    "description": "URL of the external Spamcheck service endpoint. Valid URI schemes are grpc or tls. Specifying tls forces communication to be encrypted.\n"
                },
                "suggestPipelineEnabled": {
                    "type": "boolean",
                    "description": "Enable pipeline suggestion banner.\n"
                },
                "terminalMaxSessionTime": {
                    "type": "integer",
                    "description": "Maximum time for web terminal websocket connection (in seconds). Set to 0 for unlimited time.\n"
                },
                "terms": {
                    "type": "string",
                    "description": "(Required by: enforce_terms) Markdown content for the ToS.\n"
                },
                "throttleAuthenticatedApiEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: throttle*authenticated*api*period*in*seconds and throttle*authenticated*api*requests*per*period) Enable authenticated API request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots).\n"
                },
                "throttleAuthenticatedApiPeriodInSeconds": {
                    "type": "integer",
                    "description": "Rate limit period (in seconds).\n"
                },
                "throttleAuthenticatedApiRequestsPerPeriod": {
                    "type": "integer",
                    "description": "Maximum requests per period per user.\n"
                },
                "throttleAuthenticatedPackagesApiEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: throttle*authenticated*packages*api*period*in*seconds and throttle*authenticated*packages*api*requests*per*period) Enable authenticated API request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots). View Package Registry rate limits for more details.\n"
                },
                "throttleAuthenticatedPackagesApiPeriodInSeconds": {
                    "type": "integer",
                    "description": "Rate limit period (in seconds). View Package Registry rate limits for more details.\n"
                },
                "throttleAuthenticatedPackagesApiRequestsPerPeriod": {
                    "type": "integer",
                    "description": "Maximum requests per period per user. View Package Registry rate limits for more details.\n"
                },
                "throttleAuthenticatedWebEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: throttle*authenticated*web*period*in*seconds and throttle*authenticated*web*requests*per*period) Enable authenticated web request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots).\n"
                },
                "throttleAuthenticatedWebPeriodInSeconds": {
                    "type": "integer",
                    "description": "Rate limit period (in seconds).\n"
                },
                "throttleAuthenticatedWebRequestsPerPeriod": {
                    "type": "integer",
                    "description": "Maximum requests per period per user.\n"
                },
                "throttleUnauthenticatedApiEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: throttle*unauthenticated*api*period*in*seconds and throttle*unauthenticated*api*requests*per*period) Enable unauthenticated API request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots).\n"
                },
                "throttleUnauthenticatedApiPeriodInSeconds": {
                    "type": "integer",
                    "description": "Rate limit period in seconds.\n"
                },
                "throttleUnauthenticatedApiRequestsPerPeriod": {
                    "type": "integer",
                    "description": "Max requests per period per IP.\n"
                },
                "throttleUnauthenticatedPackagesApiEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: throttle*unauthenticated*packages*api*period*in*seconds and throttle*unauthenticated*packages*api*requests*per*period) Enable authenticated API request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots). View Package Registry rate limits for more details.\n"
                },
                "throttleUnauthenticatedPackagesApiPeriodInSeconds": {
                    "type": "integer",
                    "description": "Rate limit period (in seconds). View Package Registry rate limits for more details.\n"
                },
                "throttleUnauthenticatedPackagesApiRequestsPerPeriod": {
                    "type": "integer",
                    "description": "Maximum requests per period per user. View Package Registry rate limits for more details.\n"
                },
                "throttleUnauthenticatedWebEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: throttle*unauthenticated*web*period*in*seconds and throttle*unauthenticated*web*requests*per*period) Enable unauthenticated web request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots).\n"
                },
                "throttleUnauthenticatedWebPeriodInSeconds": {
                    "type": "integer",
                    "description": "Rate limit period in seconds.\n"
                },
                "throttleUnauthenticatedWebRequestsPerPeriod": {
                    "type": "integer",
                    "description": "Max requests per period per IP.\n"
                },
                "timeTrackingLimitToHours": {
                    "type": "boolean",
                    "description": "Limit display of time tracking units to hours.\n"
                },
                "twoFactorGracePeriod": {
                    "type": "integer",
                    "description": "Amount of time (in hours) that users are allowed to skip forced configuration of two-factor authentication.\n"
                },
                "uniqueIpsLimitEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: unique*ips*limit*per*user and unique*ips*limit*time*window) Limit sign in from multiple IPs.\n"
                },
                "uniqueIpsLimitPerUser": {
                    "type": "integer",
                    "description": "Maximum number of IPs per user.\n"
                },
                "uniqueIpsLimitTimeWindow": {
                    "type": "integer",
                    "description": "How many seconds an IP is counted towards the limit.\n"
                },
                "usagePingEnabled": {
                    "type": "boolean",
                    "description": "Every week GitLab reports license usage back to GitLab, Inc.\n"
                },
                "userDeactivationEmailsEnabled": {
                    "type": "boolean",
                    "description": "Send an email to users upon account deactivation.\n"
                },
                "userDefaultExternal": {
                    "type": "boolean",
                    "description": "Newly registered users are external by default.\n"
                },
                "userDefaultInternalRegex": {
                    "type": "string",
                    "description": "Specify an email address regex pattern to identify default internal users.\n"
                },
                "userOauthApplications": {
                    "type": "boolean",
                    "description": "Allow users to register any application to use GitLab as an OAuth provider.\n"
                },
                "userShowAddSshKeyMessage": {
                    "type": "boolean",
                    "description": "When set to false disable the You won't be able to pull or push project code via SSH warning shown to users with no uploaded SSH key.\n"
                },
                "versionCheckEnabled": {
                    "type": "boolean",
                    "description": "Let GitLab inform you when an update is available.\n"
                },
                "webIdeClientsidePreviewEnabled": {
                    "type": "boolean",
                    "description": "Live Preview (allow live previews of JavaScript projects in the Web IDE using CodeSandbox Live Preview).\n"
                },
                "whatsNewVariant": {
                    "type": "string",
                    "description": "What’s new variant, possible values: all*tiers, current*tier, and disabled.\n"
                },
                "wikiPageMaxContentBytes": {
                    "type": "integer",
                    "description": "Maximum wiki page content size in bytes. The minimum value is 1024 bytes.\n"
                }
            },
            "required": [
                "abuseNotificationEmail",
                "adminMode",
                "afterSignOutPath",
                "afterSignUpText",
                "akismetApiKey",
                "akismetEnabled",
                "allowGroupOwnersToManageLdap",
                "allowLocalRequestsFromSystemHooks",
                "allowLocalRequestsFromWebHooksAndServices",
                "archiveBuildsInHumanReadable",
                "assetProxyAllowlists",
                "assetProxyEnabled",
                "assetProxySecretKey",
                "assetProxyUrl",
                "authorizedKeysEnabled",
                "autoDevopsDomain",
                "autoDevopsEnabled",
                "automaticPurchasedStorageAllocation",
                "canCreateGroup",
                "checkNamespacePlan",
                "commitEmailHostname",
                "containerExpirationPoliciesEnableHistoricEntries",
                "containerRegistryCleanupTagsServiceMaxListSize",
                "containerRegistryDeleteTagsServiceTimeout",
                "containerRegistryExpirationPoliciesCaching",
                "containerRegistryExpirationPoliciesWorkerCapacity",
                "containerRegistryTokenExpireDelay",
                "deactivateDormantUsers",
                "defaultArtifactsExpireIn",
                "defaultBranchName",
                "defaultBranchProtection",
                "defaultCiConfigPath",
                "defaultGroupVisibility",
                "defaultProjectCreation",
                "defaultProjectVisibility",
                "defaultProjectsLimit",
                "defaultSnippetVisibility",
                "delayedGroupDeletion",
                "delayedProjectDeletion",
                "deleteInactiveProjects",
                "deletionAdjournedPeriod",
                "diffMaxFiles",
                "diffMaxLines",
                "diffMaxPatchBytes",
                "disableFeedToken",
                "disabledOauthSignInSources",
                "dnsRebindingProtectionEnabled",
                "domainAllowlists",
                "domainDenylists",
                "domainDenylistEnabled",
                "dsaKeyRestriction",
                "ecdsaKeyRestriction",
                "ecdsaSkKeyRestriction",
                "ed25519KeyRestriction",
                "ed25519SkKeyRestriction",
                "eksAccessKeyId",
                "eksAccountId",
                "eksIntegrationEnabled",
                "eksSecretAccessKey",
                "elasticsearchAws",
                "elasticsearchAwsAccessKey",
                "elasticsearchAwsRegion",
                "elasticsearchAwsSecretAccessKey",
                "elasticsearchIndexedFieldLengthLimit",
                "elasticsearchIndexedFileSizeLimitKb",
                "elasticsearchIndexing",
                "elasticsearchLimitIndexing",
                "elasticsearchMaxBulkConcurrency",
                "elasticsearchMaxBulkSizeMb",
                "elasticsearchNamespaceIds",
                "elasticsearchPassword",
                "elasticsearchProjectIds",
                "elasticsearchSearch",
                "elasticsearchUrls",
                "elasticsearchUsername",
                "emailAdditionalText",
                "emailAuthorInBody",
                "enabledGitAccessProtocol",
                "enforceNamespaceStorageLimit",
                "enforceTerms",
                "externalAuthClientCert",
                "externalAuthClientKey",
                "externalAuthClientKeyPass",
                "externalAuthorizationServiceDefaultLabel",
                "externalAuthorizationServiceEnabled",
                "externalAuthorizationServiceTimeout",
                "externalAuthorizationServiceUrl",
                "externalPipelineValidationServiceTimeout",
                "externalPipelineValidationServiceToken",
                "externalPipelineValidationServiceUrl",
                "fileTemplateProjectId",
                "firstDayOfWeek",
                "geoNodeAllowedIps",
                "geoStatusTimeout",
                "gitRateLimitUsersAllowlists",
                "gitTwoFactorSessionExpiry",
                "gitalyTimeoutDefault",
                "gitalyTimeoutFast",
                "gitalyTimeoutMedium",
                "grafanaEnabled",
                "grafanaUrl",
                "gravatarEnabled",
                "groupOwnersCanManageDefaultBranchProtection",
                "hashedStorageEnabled",
                "helpPageHideCommercialContent",
                "helpPageSupportUrl",
                "helpPageText",
                "helpText",
                "hideThirdPartyOffers",
                "homePageUrl",
                "housekeepingEnabled",
                "housekeepingFullRepackPeriod",
                "housekeepingGcPeriod",
                "housekeepingIncrementalRepackPeriod",
                "htmlEmailsEnabled",
                "importSources",
                "inProductMarketingEmailsEnabled",
                "inactiveProjectsDeleteAfterMonths",
                "inactiveProjectsMinSizeMb",
                "inactiveProjectsSendWarningEmailAfterMonths",
                "invisibleCaptchaEnabled",
                "issuesCreateLimit",
                "keepLatestArtifact",
                "localMarkdownVersion",
                "mailgunEventsEnabled",
                "mailgunSigningKey",
                "maintenanceMode",
                "maintenanceModeMessage",
                "maxArtifactsSize",
                "maxAttachmentSize",
                "maxExportSize",
                "maxImportSize",
                "maxNumberOfRepositoryDownloads",
                "maxNumberOfRepositoryDownloadsWithinTimePeriod",
                "maxPagesSize",
                "maxPersonalAccessTokenLifetime",
                "maxSshKeyLifetime",
                "metricsMethodCallThreshold",
                "mirrorAvailable",
                "mirrorCapacityThreshold",
                "mirrorMaxCapacity",
                "mirrorMaxDelay",
                "npmPackageRequestsForwarding",
                "outboundLocalRequestsWhitelists",
                "packageRegistryCleanupPoliciesWorkerCapacity",
                "pagesDomainVerificationEnabled",
                "passwordAuthenticationEnabledForGit",
                "passwordAuthenticationEnabledForWeb",
                "passwordLowercaseRequired",
                "passwordNumberRequired",
                "passwordSymbolRequired",
                "passwordUppercaseRequired",
                "performanceBarAllowedGroupPath",
                "personalAccessTokenPrefix",
                "pipelineLimitPerProjectUserSha",
                "plantumlEnabled",
                "plantumlUrl",
                "pollingIntervalMultiplier",
                "projectExportEnabled",
                "prometheusMetricsEnabled",
                "protectedCiVariables",
                "pushEventActivitiesLimit",
                "pushEventHooksLimit",
                "pypiPackageRequestsForwarding",
                "rateLimitingResponseText",
                "rawBlobRequestLimit",
                "recaptchaEnabled",
                "recaptchaPrivateKey",
                "recaptchaSiteKey",
                "receiveMaxInputSize",
                "repositoryChecksEnabled",
                "repositorySizeLimit",
                "repositoryStorages",
                "repositoryStoragesWeighted",
                "requireAdminApprovalAfterUserSignup",
                "requireTwoFactorAuthentication",
                "restrictedVisibilityLevels",
                "rsaKeyRestriction",
                "searchRateLimit",
                "searchRateLimitUnauthenticated",
                "sendUserConfirmationEmail",
                "sessionExpireDelay",
                "sharedRunnersEnabled",
                "sharedRunnersMinutes",
                "sharedRunnersText",
                "sidekiqJobLimiterCompressionThresholdBytes",
                "sidekiqJobLimiterLimitBytes",
                "sidekiqJobLimiterMode",
                "signInText",
                "signupEnabled",
                "slackAppEnabled",
                "slackAppId",
                "slackAppSecret",
                "slackAppSigningSecret",
                "slackAppVerificationToken",
                "snippetSizeLimit",
                "snowplowAppId",
                "snowplowCollectorHostname",
                "snowplowCookieDomain",
                "snowplowEnabled",
                "sourcegraphEnabled",
                "sourcegraphPublicOnly",
                "sourcegraphUrl",
                "spamCheckApiKey",
                "spamCheckEndpointEnabled",
                "spamCheckEndpointUrl",
                "suggestPipelineEnabled",
                "terminalMaxSessionTime",
                "terms",
                "throttleAuthenticatedApiEnabled",
                "throttleAuthenticatedApiPeriodInSeconds",
                "throttleAuthenticatedApiRequestsPerPeriod",
                "throttleAuthenticatedPackagesApiEnabled",
                "throttleAuthenticatedPackagesApiPeriodInSeconds",
                "throttleAuthenticatedPackagesApiRequestsPerPeriod",
                "throttleAuthenticatedWebEnabled",
                "throttleAuthenticatedWebPeriodInSeconds",
                "throttleAuthenticatedWebRequestsPerPeriod",
                "throttleUnauthenticatedApiEnabled",
                "throttleUnauthenticatedApiPeriodInSeconds",
                "throttleUnauthenticatedApiRequestsPerPeriod",
                "throttleUnauthenticatedPackagesApiEnabled",
                "throttleUnauthenticatedPackagesApiPeriodInSeconds",
                "throttleUnauthenticatedPackagesApiRequestsPerPeriod",
                "throttleUnauthenticatedWebEnabled",
                "throttleUnauthenticatedWebPeriodInSeconds",
                "throttleUnauthenticatedWebRequestsPerPeriod",
                "timeTrackingLimitToHours",
                "twoFactorGracePeriod",
                "uniqueIpsLimitEnabled",
                "uniqueIpsLimitPerUser",
                "uniqueIpsLimitTimeWindow",
                "usagePingEnabled",
                "userDeactivationEmailsEnabled",
                "userDefaultExternal",
                "userDefaultInternalRegex",
                "userOauthApplications",
                "userShowAddSshKeyMessage",
                "versionCheckEnabled",
                "webIdeClientsidePreviewEnabled",
                "whatsNewVariant",
                "wikiPageMaxContentBytes"
            ],
            "inputProperties": {
                "abuseNotificationEmail": {
                    "type": "string",
                    "description": "If set, abuse reports are sent to this address. Abuse reports are always available in the Admin Area.\n"
                },
                "adminMode": {
                    "type": "boolean",
                    "description": "Require administrators to enable Admin Mode by re-authenticating for administrative tasks.\n"
                },
                "afterSignOutPath": {
                    "type": "string",
                    "description": "Where to redirect users after logout.\n"
                },
                "afterSignUpText": {
                    "type": "string",
                    "description": "Text shown to the user after signing up.\n"
                },
                "akismetApiKey": {
                    "type": "string",
                    "description": "API key for Akismet spam protection.\n",
                    "secret": true
                },
                "akismetEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: akismet*api*key) Enable or disable Akismet spam protection.\n"
                },
                "allowGroupOwnersToManageLdap": {
                    "type": "boolean",
                    "description": "Set to true to allow group owners to manage LDAP.\n"
                },
                "allowLocalRequestsFromSystemHooks": {
                    "type": "boolean",
                    "description": "Allow requests to the local network from system hooks.\n"
                },
                "allowLocalRequestsFromWebHooksAndServices": {
                    "type": "boolean",
                    "description": "Allow requests to the local network from web hooks and services.\n"
                },
                "archiveBuildsInHumanReadable": {
                    "type": "string",
                    "description": "Set the duration for which the jobs are considered as old and expired. After that time passes, the jobs are archived and no longer able to be retried. Make it empty to never expire jobs. It has to be no less than 1 day, for example: 15 days, 1 month, 2 years.\n"
                },
                "assetProxyAllowlists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Assets that match these domains are not proxied. Wildcards allowed. Your GitLab installation URL is automatically allowlisted. GitLab restart is required to apply changes.\n"
                },
                "assetProxyEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: asset*proxy*url) Enable proxying of assets. GitLab restart is required to apply changes.\n"
                },
                "assetProxySecretKey": {
                    "type": "string",
                    "description": "Shared secret with the asset proxy server. GitLab restart is required to apply changes.\n",
                    "secret": true
                },
                "assetProxyUrl": {
                    "type": "string",
                    "description": "URL of the asset proxy server. GitLab restart is required to apply changes.\n"
                },
                "authorizedKeysEnabled": {
                    "type": "boolean",
                    "description": "By default, we write to the authorized_keys file to support Git over SSH without additional configuration. GitLab can be optimized to authenticate SSH keys via the database file. Only disable this if you have configured your OpenSSH server to use the AuthorizedKeysCommand.\n"
                },
                "autoDevopsDomain": {
                    "type": "string",
                    "description": "Specify a domain to use by default for every project’s Auto Review Apps and Auto Deploy stages.\n"
                },
                "autoDevopsEnabled": {
                    "type": "boolean",
                    "description": "Enable Auto DevOps for projects by default. It automatically builds, tests, and deploys applications based on a predefined CI/CD configuration.\n"
                },
                "automaticPurchasedStorageAllocation": {
                    "type": "boolean",
                    "description": "Enabling this permits automatic allocation of purchased storage in a namespace.\n"
                },
                "canCreateGroup": {
                    "type": "boolean",
                    "description": "Indicates whether users can create top-level groups. Introduced in GitLab 15.5.\n"
                },
                "checkNamespacePlan": {
                    "type": "boolean",
                    "description": "Enabling this makes only licensed EE features available to projects if the project namespace’s plan includes the feature or if the project is public.\n"
                },
                "commitEmailHostname": {
                    "type": "string",
                    "description": "Custom hostname (for private commit emails).\n"
                },
                "containerExpirationPoliciesEnableHistoricEntries": {
                    "type": "boolean",
                    "description": "Enable cleanup policies for all projects.\n"
                },
                "containerRegistryCleanupTagsServiceMaxListSize": {
                    "type": "integer",
                    "description": "The maximum number of tags that can be deleted in a single execution of cleanup policies.\n"
                },
                "containerRegistryDeleteTagsServiceTimeout": {
                    "type": "integer",
                    "description": "The maximum time, in seconds, that the cleanup process can take to delete a batch of tags for cleanup policies.\n"
                },
                "containerRegistryExpirationPoliciesCaching": {
                    "type": "boolean",
                    "description": "Caching during the execution of cleanup policies.\n"
                },
                "containerRegistryExpirationPoliciesWorkerCapacity": {
                    "type": "integer",
                    "description": "Number of workers for cleanup policies.\n"
                },
                "containerRegistryTokenExpireDelay": {
                    "type": "integer",
                    "description": "Container Registry token duration in minutes.\n"
                },
                "deactivateDormantUsers": {
                    "type": "boolean",
                    "description": "Enable automatic deactivation of dormant users.\n"
                },
                "defaultArtifactsExpireIn": {
                    "type": "string",
                    "description": "Set the default expiration time for each job’s artifacts.\n"
                },
                "defaultBranchName": {
                    "type": "string",
                    "description": "Instance-level custom initial branch name (introduced in GitLab 13.2).\n"
                },
                "defaultBranchProtection": {
                    "type": "integer",
                    "description": "Determine if developers can push to the default branch. Can take: 0 (not protected, both users with the Developer role or Maintainer role can push new commits and force push), 1 (partially protected, users with the Developer role or Maintainer role can push new commits, but cannot force push) or 2 (fully protected, users with the Developer or Maintainer role cannot push new commits, but users with the Developer or Maintainer role can; no one can force push) as a parameter. Default is 2.\n"
                },
                "defaultCiConfigPath": {
                    "type": "string",
                    "description": "Default CI/CD configuration file and path for new projects (.gitlab-ci.yml if not set).\n"
                },
                "defaultGroupVisibility": {
                    "type": "string",
                    "description": "What visibility level new groups receive. Can take private, internal and public as a parameter.\n"
                },
                "defaultProjectCreation": {
                    "type": "integer",
                    "description": "Default project creation protection. Can take: 0 (No one), 1 (Maintainers) or 2 (Developers + Maintainers).\n"
                },
                "defaultProjectVisibility": {
                    "type": "string",
                    "description": "What visibility level new projects receive. Can take private, internal and public as a parameter.\n"
                },
                "defaultProjectsLimit": {
                    "type": "integer",
                    "description": "Project limit per user.\n"
                },
                "defaultSnippetVisibility": {
                    "type": "string",
                    "description": "What visibility level new snippets receive. Can take private, internal and public as a parameter.\n"
                },
                "delayedGroupDeletion": {
                    "type": "boolean",
                    "description": "Enable delayed group deletion. Introduced in GitLab 15.0. From GitLab 15.1, disables and locks the group-level setting for delayed protect deletion when set to false.\n"
                },
                "delayedProjectDeletion": {
                    "type": "boolean",
                    "description": "Enable delayed project deletion by default in new groups. From GitLab 15.1, can only be enabled when delayed*group*deletion is true.\n"
                },
                "deleteInactiveProjects": {
                    "type": "boolean",
                    "description": "Enable inactive project deletion feature. Introduced in GitLab 14.10. Became operational in GitLab 15.0 (with feature flag inactive*projects*deletion).\n"
                },
                "deletionAdjournedPeriod": {
                    "type": "integer",
                    "description": "The number of days to wait before deleting a project or group that is marked for deletion. Value must be between 1 and 90. From GitLab 15.1, a hook on deletion*adjourned*period sets the period to 1 on every update, and sets both delayed*project*deletion and delayed*group*deletion to false if the period is 0.\n"
                },
                "diffMaxFiles": {
                    "type": "integer",
                    "description": "Maximum files in a diff.\n"
                },
                "diffMaxLines": {
                    "type": "integer",
                    "description": "Maximum lines in a diff.\n"
                },
                "diffMaxPatchBytes": {
                    "type": "integer",
                    "description": "Maximum diff patch size, in bytes.\n"
                },
                "disableFeedToken": {
                    "type": "boolean",
                    "description": "Disable display of RSS/Atom and calendar feed tokens (introduced in GitLab 13.7).\n"
                },
                "disabledOauthSignInSources": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Disabled OAuth sign-in sources.\n"
                },
                "dnsRebindingProtectionEnabled": {
                    "type": "boolean",
                    "description": "Enforce DNS rebinding attack protection.\n"
                },
                "domainAllowlists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Force people to use only corporate emails for sign-up. Null means there is no restriction.\n"
                },
                "domainDenylistEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: domain_denylist) Allows blocking sign-ups from emails from specific domains.\n"
                },
                "domainDenylists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Users with email addresses that match these domains cannot sign up. Wildcards allowed. Use separate lines for multiple entries. Ex: domain.com, *.domain.com.\n"
                },
                "dsaKeyRestriction": {
                    "type": "integer",
                    "description": "The minimum allowed bit length of an uploaded DSA key. 0 means no restriction. -1 disables DSA keys.\n"
                },
                "ecdsaKeyRestriction": {
                    "type": "integer",
                    "description": "The minimum allowed curve size (in bits) of an uploaded ECDSA key. 0 means no restriction. -1 disables ECDSA keys.\n"
                },
                "ecdsaSkKeyRestriction": {
                    "type": "integer",
                    "description": "The minimum allowed curve size (in bits) of an uploaded ECDSA*SK key. 0 means no restriction. -1 disables ECDSA*SK keys.\n"
                },
                "ed25519KeyRestriction": {
                    "type": "integer",
                    "description": "The minimum allowed curve size (in bits) of an uploaded ED25519 key. 0 means no restriction. -1 disables ED25519 keys.\n"
                },
                "ed25519SkKeyRestriction": {
                    "type": "integer",
                    "description": "The minimum allowed curve size (in bits) of an uploaded ED25519*SK key. 0 means no restriction. -1 disables ED25519*SK keys.\n"
                },
                "eksAccessKeyId": {
                    "type": "string",
                    "description": "AWS IAM access key ID.\n",
                    "secret": true
                },
                "eksAccountId": {
                    "type": "string",
                    "description": "Amazon account ID.\n"
                },
                "eksIntegrationEnabled": {
                    "type": "boolean",
                    "description": "Enable integration with Amazon EKS.\n"
                },
                "eksSecretAccessKey": {
                    "type": "string",
                    "description": "AWS IAM secret access key.\n",
                    "secret": true
                },
                "elasticsearchAws": {
                    "type": "boolean",
                    "description": "Enable the use of AWS hosted Elasticsearch.\n"
                },
                "elasticsearchAwsAccessKey": {
                    "type": "string",
                    "description": "AWS IAM access key.\n",
                    "secret": true
                },
                "elasticsearchAwsRegion": {
                    "type": "string",
                    "description": "The AWS region the Elasticsearch domain is configured.\n"
                },
                "elasticsearchAwsSecretAccessKey": {
                    "type": "string",
                    "description": "AWS IAM secret access key.\n",
                    "secret": true
                },
                "elasticsearchIndexedFieldLengthLimit": {
                    "type": "integer",
                    "description": "Maximum size of text fields to index by Elasticsearch. 0 value means no limit. This does not apply to repository and wiki indexing.\n"
                },
                "elasticsearchIndexedFileSizeLimitKb": {
                    "type": "integer",
                    "description": "Maximum size of repository and wiki files that are indexed by Elasticsearch.\n"
                },
                "elasticsearchIndexing": {
                    "type": "boolean",
                    "description": "Enable Elasticsearch indexing.\n"
                },
                "elasticsearchLimitIndexing": {
                    "type": "boolean",
                    "description": "Limit Elasticsearch to index certain namespaces and projects.\n"
                },
                "elasticsearchMaxBulkConcurrency": {
                    "type": "integer",
                    "description": "Maximum concurrency of Elasticsearch bulk requests per indexing operation. This only applies to repository indexing operations.\n"
                },
                "elasticsearchMaxBulkSizeMb": {
                    "type": "integer",
                    "description": "Maximum size of Elasticsearch bulk indexing requests in MB. This only applies to repository indexing operations.\n"
                },
                "elasticsearchNamespaceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The namespaces to index via Elasticsearch if elasticsearch*limit*indexing is enabled.\n"
                },
                "elasticsearchPassword": {
                    "type": "string",
                    "description": "The password of your Elasticsearch instance.\n",
                    "secret": true
                },
                "elasticsearchProjectIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The projects to index via Elasticsearch if elasticsearch*limit*indexing is enabled.\n"
                },
                "elasticsearchSearch": {
                    "type": "boolean",
                    "description": "Enable Elasticsearch search.\n"
                },
                "elasticsearchUrls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The URL to use for connecting to Elasticsearch. Use a comma-separated list to support cluster (for example, http://localhost:9200, http://localhost:9201).\n"
                },
                "elasticsearchUsername": {
                    "type": "string",
                    "description": "The username of your Elasticsearch instance.\n"
                },
                "emailAdditionalText": {
                    "type": "string",
                    "description": "Additional text added to the bottom of every email for legal/auditing/compliance reasons.\n"
                },
                "emailAuthorInBody": {
                    "type": "boolean",
                    "description": "Some email servers do not support overriding the email sender name. Enable this option to include the name of the author of the issue, merge request or comment in the email body instead.\n"
                },
                "enabledGitAccessProtocol": {
                    "type": "string",
                    "description": "Enabled protocols for Git access. Allowed values are: ssh, http, and nil to allow both protocols.\n"
                },
                "enforceNamespaceStorageLimit": {
                    "type": "boolean",
                    "description": "Enabling this permits enforcement of namespace storage limits.\n"
                },
                "enforceTerms": {
                    "type": "boolean",
                    "description": "(If enabled, requires: terms) Enforce application ToS to all users.\n"
                },
                "externalAuthClientCert": {
                    "type": "string",
                    "description": "(If enabled, requires: external*auth*client_key) The certificate to use to authenticate with the external authorization service.\n"
                },
                "externalAuthClientKey": {
                    "type": "string",
                    "description": "Private key for the certificate when authentication is required for the external authorization service, this is encrypted when stored.\n",
                    "secret": true
                },
                "externalAuthClientKeyPass": {
                    "type": "string",
                    "description": "Passphrase to use for the private key when authenticating with the external service this is encrypted when stored.\n",
                    "secret": true
                },
                "externalAuthorizationServiceDefaultLabel": {
                    "type": "string",
                    "description": "The default classification label to use when requesting authorization and no classification label has been specified on the project.\n"
                },
                "externalAuthorizationServiceEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: external*authorization*service*default*label, external*authorization*service*timeout and external*authorization*service*url) Enable using an external authorization service for accessing projects.\n"
                },
                "externalAuthorizationServiceTimeout": {
                    "type": "number",
                    "description": "The timeout after which an authorization request is aborted, in seconds. When a request times out, access is denied to the user. (min: 0.001, max: 10, step: 0.001).\n"
                },
                "externalAuthorizationServiceUrl": {
                    "type": "string",
                    "description": "URL to which authorization requests are directed.\n"
                },
                "externalPipelineValidationServiceTimeout": {
                    "type": "integer",
                    "description": "How long to wait for a response from the pipeline validation service. Assumes OK if it times out.\n"
                },
                "externalPipelineValidationServiceToken": {
                    "type": "string",
                    "description": "Optional. Token to include as the X-Gitlab-Token header in requests to the URL in external*pipeline*validation*service*url.\n"
                },
                "externalPipelineValidationServiceUrl": {
                    "type": "string",
                    "description": "URL to use for pipeline validation requests.\n"
                },
                "fileTemplateProjectId": {
                    "type": "integer",
                    "description": "The ID of a project to load custom file templates from.\n"
                },
                "firstDayOfWeek": {
                    "type": "integer",
                    "description": "Start day of the week for calendar views and date pickers. Valid values are 0 for Sunday, 1 for Monday, and 6 for Saturday.\n"
                },
                "geoNodeAllowedIps": {
                    "type": "string",
                    "description": "Comma-separated list of IPs and CIDRs of allowed secondary nodes. For example, 1.1.1.1, 2.2.2.0/24.\n"
                },
                "geoStatusTimeout": {
                    "type": "integer",
                    "description": "The amount of seconds after which a request to get a secondary node status times out.\n"
                },
                "gitRateLimitUsersAllowlists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of usernames excluded from Git anti-abuse rate limits. Maximum: 100 usernames. Introduced in GitLab 15.2.\n"
                },
                "gitTwoFactorSessionExpiry": {
                    "type": "integer",
                    "description": "Maximum duration (in minutes) of a session for Git operations when 2FA is enabled.\n"
                },
                "gitalyTimeoutDefault": {
                    "type": "integer",
                    "description": "Default Gitaly timeout, in seconds. This timeout is not enforced for Git fetch/push operations or Sidekiq jobs. Set to 0 to disable timeouts.\n"
                },
                "gitalyTimeoutFast": {
                    "type": "integer",
                    "description": "Gitaly fast operation timeout, in seconds. Some Gitaly operations are expected to be fast. If they exceed this threshold, there may be a problem with a storage shard and ‘failing fast’ can help maintain the stability of the GitLab instance. Set to 0 to disable timeouts.\n"
                },
                "gitalyTimeoutMedium": {
                    "type": "integer",
                    "description": "Medium Gitaly timeout, in seconds. This should be a value between the Fast and the Default timeout. Set to 0 to disable timeouts.\n"
                },
                "grafanaEnabled": {
                    "type": "boolean",
                    "description": "Enable Grafana.\n"
                },
                "grafanaUrl": {
                    "type": "string",
                    "description": "Grafana URL.\n"
                },
                "gravatarEnabled": {
                    "type": "boolean",
                    "description": "Enable Gravatar.\n"
                },
                "groupOwnersCanManageDefaultBranchProtection": {
                    "type": "boolean",
                    "description": "Prevent overrides of default branch protection.\n"
                },
                "hashedStorageEnabled": {
                    "type": "boolean",
                    "description": "Create new projects using hashed storage paths: Enable immutable, hash-based paths and repository names to store repositories on disk. This prevents repositories from having to be moved or renamed when the Project URL changes and may improve disk I/O performance. (Always enabled in GitLab versions 13.0 and later, configuration is scheduled for removal in 14.0).\n"
                },
                "helpPageHideCommercialContent": {
                    "type": "boolean",
                    "description": "Hide marketing-related entries from help.\n"
                },
                "helpPageSupportUrl": {
                    "type": "string",
                    "description": "Alternate support URL for help page and help dropdown.\n"
                },
                "helpPageText": {
                    "type": "string",
                    "description": "Custom text displayed on the help page.\n"
                },
                "helpText": {
                    "type": "string",
                    "description": "GitLab server administrator information.\n"
                },
                "hideThirdPartyOffers": {
                    "type": "boolean",
                    "description": "Do not display offers from third parties in GitLab.\n"
                },
                "homePageUrl": {
                    "type": "string",
                    "description": "Redirect to this URL when not logged in.\n"
                },
                "housekeepingEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: housekeeping*bitmaps*enabled, housekeeping*full*repack*period, housekeeping*gc*period, and housekeeping*incremental*repack*period) Enable or disable Git housekeeping.\n"
                },
                "housekeepingFullRepackPeriod": {
                    "type": "integer",
                    "description": "Number of Git pushes after which an incremental git repack is run.\n"
                },
                "housekeepingGcPeriod": {
                    "type": "integer",
                    "description": "Number of Git pushes after which git gc is run.\n"
                },
                "housekeepingIncrementalRepackPeriod": {
                    "type": "integer",
                    "description": "Number of Git pushes after which an incremental git repack is run.\n"
                },
                "htmlEmailsEnabled": {
                    "type": "boolean",
                    "description": "Enable HTML emails.\n"
                },
                "importSources": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Sources to allow project import from, possible values: github, bitbucket, bitbucket*server, gitlab, fogbugz, git, gitlab*project, gitea, manifest, and phabricator.\n"
                },
                "inProductMarketingEmailsEnabled": {
                    "type": "boolean",
                    "description": "Enable in-product marketing emails.\n"
                },
                "inactiveProjectsDeleteAfterMonths": {
                    "type": "integer",
                    "description": "If delete*inactive*projects is true, the time (in months) to wait before deleting inactive projects. Introduced in GitLab 14.10. Became operational in GitLab 15.0.\n"
                },
                "inactiveProjectsMinSizeMb": {
                    "type": "integer",
                    "description": "If delete*inactive*projects is true, the minimum repository size for projects to be checked for inactivity. Introduced in GitLab 14.10. Became operational in GitLab 15.0.\n"
                },
                "inactiveProjectsSendWarningEmailAfterMonths": {
                    "type": "integer",
                    "description": "If delete*inactive*projects is true, sets the time (in months) to wait before emailing maintainers that the project is scheduled be deleted because it is inactive. Introduced in GitLab 14.10. Became operational in GitLab 15.0.\n"
                },
                "invisibleCaptchaEnabled": {
                    "type": "boolean",
                    "description": "Enable Invisible CAPTCHA spam detection during sign-up.\n"
                },
                "issuesCreateLimit": {
                    "type": "integer",
                    "description": "Max number of issue creation requests per minute per user.\n"
                },
                "keepLatestArtifact": {
                    "type": "boolean",
                    "description": "Prevent the deletion of the artifacts from the most recent successful jobs, regardless of the expiry time.\n"
                },
                "localMarkdownVersion": {
                    "type": "integer",
                    "description": "Increase this value when any cached Markdown should be invalidated.\n"
                },
                "mailgunEventsEnabled": {
                    "type": "boolean",
                    "description": "Enable Mailgun event receiver.\n"
                },
                "mailgunSigningKey": {
                    "type": "string",
                    "description": "The Mailgun HTTP webhook signing key for receiving events from webhook.\n",
                    "secret": true
                },
                "maintenanceMode": {
                    "type": "boolean",
                    "description": "When instance is in maintenance mode, non-administrative users can sign in with read-only access and make read-only API requests.\n"
                },
                "maintenanceModeMessage": {
                    "type": "string",
                    "description": "Message displayed when instance is in maintenance mode.\n"
                },
                "maxArtifactsSize": {
                    "type": "integer",
                    "description": "Maximum artifacts size in MB.\n"
                },
                "maxAttachmentSize": {
                    "type": "integer",
                    "description": "Limit attachment size in MB.\n"
                },
                "maxExportSize": {
                    "type": "integer",
                    "description": "Maximum export size in MB. 0 for unlimited.\n"
                },
                "maxImportSize": {
                    "type": "integer",
                    "description": "Maximum import size in MB. 0 for unlimited.\n"
                },
                "maxNumberOfRepositoryDownloads": {
                    "type": "integer",
                    "description": "Maximum number of unique repositories a user can download in the specified time period before they are banned. Maximum: 10,000 repositories. Introduced in GitLab 15.1.\n"
                },
                "maxNumberOfRepositoryDownloadsWithinTimePeriod": {
                    "type": "integer",
                    "description": "Reporting time period (in seconds). Maximum: 864000 seconds (10 days). Introduced in GitLab 15.1.\n"
                },
                "maxPagesSize": {
                    "type": "integer",
                    "description": "Maximum size of pages repositories in MB.\n"
                },
                "maxPersonalAccessTokenLifetime": {
                    "type": "integer",
                    "description": "Maximum allowable lifetime for access tokens in days.\n"
                },
                "maxSshKeyLifetime": {
                    "type": "integer",
                    "description": "Maximum allowable lifetime for SSH keys in days. Introduced in GitLab 14.6.\n"
                },
                "metricsMethodCallThreshold": {
                    "type": "integer",
                    "description": "A method call is only tracked when it takes longer than the given amount of milliseconds.\n"
                },
                "mirrorAvailable": {
                    "type": "boolean",
                    "description": "Allow repository mirroring to configured by project Maintainers. If disabled, only Administrators can configure repository mirroring.\n"
                },
                "mirrorCapacityThreshold": {
                    "type": "integer",
                    "description": "Minimum capacity to be available before scheduling more mirrors preemptively.\n"
                },
                "mirrorMaxCapacity": {
                    "type": "integer",
                    "description": "Maximum number of mirrors that can be synchronizing at the same time.\n"
                },
                "mirrorMaxDelay": {
                    "type": "integer",
                    "description": "Maximum time (in minutes) between updates that a mirror can have when scheduled to synchronize.\n"
                },
                "npmPackageRequestsForwarding": {
                    "type": "boolean",
                    "description": "Use npmjs.org as a default remote repository when the package is not found in the GitLab Package Registry for npm.\n"
                },
                "outboundLocalRequestsWhitelists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Define a list of trusted domains or IP addresses to which local requests are allowed when local requests for hooks and services are disabled.\n"
                },
                "packageRegistryCleanupPoliciesWorkerCapacity": {
                    "type": "integer",
                    "description": "Number of workers assigned to the packages cleanup policies.\n"
                },
                "pagesDomainVerificationEnabled": {
                    "type": "boolean",
                    "description": "Require users to prove ownership of custom domains. Domain verification is an essential security measure for public GitLab sites. Users are required to demonstrate they control a domain before it is enabled.\n"
                },
                "passwordAuthenticationEnabledForGit": {
                    "type": "boolean",
                    "description": "Enable authentication for Git over HTTP(S) via a GitLab account password.\n"
                },
                "passwordAuthenticationEnabledForWeb": {
                    "type": "boolean",
                    "description": "Enable authentication for the web interface via a GitLab account password.\n"
                },
                "passwordLowercaseRequired": {
                    "type": "boolean",
                    "description": "Indicates whether passwords require at least one lowercase letter. Introduced in GitLab 15.1.\n"
                },
                "passwordNumberRequired": {
                    "type": "boolean",
                    "description": "Indicates whether passwords require at least one number. Introduced in GitLab 15.1.\n"
                },
                "passwordSymbolRequired": {
                    "type": "boolean",
                    "description": "Indicates whether passwords require at least one symbol character. Introduced in GitLab 15.1.\n"
                },
                "passwordUppercaseRequired": {
                    "type": "boolean",
                    "description": "Indicates whether passwords require at least one uppercase letter. Introduced in GitLab 15.1.\n"
                },
                "performanceBarAllowedGroupPath": {
                    "type": "string",
                    "description": "Path of the group that is allowed to toggle the performance bar.\n"
                },
                "personalAccessTokenPrefix": {
                    "type": "string",
                    "description": "Prefix for all generated personal access tokens.\n"
                },
                "pipelineLimitPerProjectUserSha": {
                    "type": "integer",
                    "description": "Maximum number of pipeline creation requests per minute per user and commit.\n"
                },
                "plantumlEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: plantuml_url) Enable PlantUML integration.\n"
                },
                "plantumlUrl": {
                    "type": "string",
                    "description": "The PlantUML instance URL for integration.\n"
                },
                "pollingIntervalMultiplier": {
                    "type": "number",
                    "description": "Interval multiplier used by endpoints that perform polling. Set to 0 to disable polling.\n"
                },
                "projectExportEnabled": {
                    "type": "boolean",
                    "description": "Enable project export.\n"
                },
                "prometheusMetricsEnabled": {
                    "type": "boolean",
                    "description": "Enable Prometheus metrics.\n"
                },
                "protectedCiVariables": {
                    "type": "boolean",
                    "description": "CI/CD variables are protected by default.\n"
                },
                "pushEventActivitiesLimit": {
                    "type": "integer",
                    "description": "Number of changes (branches or tags) in a single push to determine whether individual push events or bulk push events are created. Bulk push events are created if it surpasses that value.\n"
                },
                "pushEventHooksLimit": {
                    "type": "integer",
                    "description": "Number of changes (branches or tags) in a single push to determine whether webhooks and services fire or not. Webhooks and services aren’t submitted if it surpasses that value.\n"
                },
                "pypiPackageRequestsForwarding": {
                    "type": "boolean",
                    "description": "Use pypi.org as a default remote repository when the package is not found in the GitLab Package Registry for PyPI.\n"
                },
                "rateLimitingResponseText": {
                    "type": "string",
                    "description": "When rate limiting is enabled via the throttle_* settings, send this plain text response when a rate limit is exceeded. ‘Retry later’ is sent if this is blank.\n"
                },
                "rawBlobRequestLimit": {
                    "type": "integer",
                    "description": "Max number of requests per minute for each raw path. To disable throttling set to 0.\n"
                },
                "recaptchaEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: recaptcha*private*key and recaptcha*site*key) Enable reCAPTCHA.\n"
                },
                "recaptchaPrivateKey": {
                    "type": "string",
                    "description": "Private key for reCAPTCHA.\n",
                    "secret": true
                },
                "recaptchaSiteKey": {
                    "type": "string",
                    "description": "Site key for reCAPTCHA.\n",
                    "secret": true
                },
                "receiveMaxInputSize": {
                    "type": "integer",
                    "description": "Maximum push size (MB).\n"
                },
                "repositoryChecksEnabled": {
                    "type": "boolean",
                    "description": "GitLab periodically runs git fsck in all project and wiki repositories to look for silent disk corruption issues.\n"
                },
                "repositorySizeLimit": {
                    "type": "integer",
                    "description": "Size limit per repository (MB).\n"
                },
                "repositoryStorages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(GitLab 13.0 and earlier) List of names of enabled storage paths, taken from gitlab.yml. New projects are created in one of these stores, chosen at random.\n"
                },
                "repositoryStoragesWeighted": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "integer"
                    },
                    "description": "(GitLab 13.1 and later) Hash of names of taken from gitlab.yml to weights. New projects are created in one of these stores, chosen by a weighted random selection.\n"
                },
                "requireAdminApprovalAfterUserSignup": {
                    "type": "boolean",
                    "description": "When enabled, any user that signs up for an account using the registration form is placed under a Pending approval state and has to be explicitly approved by an administrator.\n"
                },
                "requireTwoFactorAuthentication": {
                    "type": "boolean",
                    "description": "(If enabled, requires: two*factor*grace_period) Require all users to set up Two-factor authentication.\n"
                },
                "restrictedVisibilityLevels": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Selected levels cannot be used by non-Administrator users for groups, projects or snippets. Can take private, internal and public as a parameter. Null means there is no restriction.\n"
                },
                "rsaKeyRestriction": {
                    "type": "integer",
                    "description": "The minimum allowed bit length of an uploaded RSA key. 0 means no restriction. -1 disables RSA keys.\n"
                },
                "searchRateLimit": {
                    "type": "integer",
                    "description": "Max number of requests per minute for performing a search while authenticated. To disable throttling set to 0.\n"
                },
                "searchRateLimitUnauthenticated": {
                    "type": "integer",
                    "description": "Max number of requests per minute for performing a search while unauthenticated. To disable throttling set to 0.\n"
                },
                "sendUserConfirmationEmail": {
                    "type": "boolean",
                    "description": "Send confirmation email on sign-up.\n"
                },
                "sessionExpireDelay": {
                    "type": "integer",
                    "description": "Session duration in minutes. GitLab restart is required to apply changes.\n"
                },
                "sharedRunnersEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: shared*runners*text and shared*runners*minutes) Enable shared runners for new projects.\n"
                },
                "sharedRunnersMinutes": {
                    "type": "integer",
                    "description": "Set the maximum number of CI/CD minutes that a group can use on shared runners per month.\n"
                },
                "sharedRunnersText": {
                    "type": "string",
                    "description": "Shared runners text.\n"
                },
                "sidekiqJobLimiterCompressionThresholdBytes": {
                    "type": "integer",
                    "description": "The threshold in bytes at which Sidekiq jobs are compressed before being stored in Redis.\n"
                },
                "sidekiqJobLimiterLimitBytes": {
                    "type": "integer",
                    "description": "The threshold in bytes at which Sidekiq jobs are rejected. 0 means do not reject any job.\n"
                },
                "sidekiqJobLimiterMode": {
                    "type": "string",
                    "description": "track or compress. Sets the behavior for Sidekiq job size limits.\n"
                },
                "signInText": {
                    "type": "string",
                    "description": "Text on the login page.\n"
                },
                "signupEnabled": {
                    "type": "boolean",
                    "description": "Enable registration.\n"
                },
                "slackAppEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: slack*app*id, slack*app*secret and slack*app*secret) Enable Slack app.\n"
                },
                "slackAppId": {
                    "type": "string",
                    "description": "The app ID of the Slack-app.\n"
                },
                "slackAppSecret": {
                    "type": "string",
                    "description": "The app secret of the Slack-app.\n",
                    "secret": true
                },
                "slackAppSigningSecret": {
                    "type": "string",
                    "description": "The signing secret of the Slack-app.\n",
                    "secret": true
                },
                "slackAppVerificationToken": {
                    "type": "string",
                    "description": "The verification token of the Slack-app.\n"
                },
                "snippetSizeLimit": {
                    "type": "integer",
                    "description": "Max snippet content size in bytes.\n"
                },
                "snowplowAppId": {
                    "type": "string",
                    "description": "The Snowplow site name / application ID. (for example, gitlab)\n"
                },
                "snowplowCollectorHostname": {
                    "type": "string",
                    "description": "The Snowplow collector hostname. (for example, snowplow.trx.gitlab.net)\n"
                },
                "snowplowCookieDomain": {
                    "type": "string",
                    "description": "The Snowplow cookie domain. (for example, .gitlab.com)\n"
                },
                "snowplowEnabled": {
                    "type": "boolean",
                    "description": "Enable snowplow tracking.\n"
                },
                "sourcegraphEnabled": {
                    "type": "boolean",
                    "description": "Enables Sourcegraph integration. If enabled, requires sourcegraph_url.\n"
                },
                "sourcegraphPublicOnly": {
                    "type": "boolean",
                    "description": "Blocks Sourcegraph from being loaded on private and internal projects.\n"
                },
                "sourcegraphUrl": {
                    "type": "string",
                    "description": "The Sourcegraph instance URL for integration.\n"
                },
                "spamCheckApiKey": {
                    "type": "string",
                    "description": "API key used by GitLab for accessing the Spam Check service endpoint.\n",
                    "secret": true
                },
                "spamCheckEndpointEnabled": {
                    "type": "boolean",
                    "description": "Enables spam checking using external Spam Check API endpoint.\n"
                },
                "spamCheckEndpointUrl": {
                    "type": "string",
                    "description": "URL of the external Spamcheck service endpoint. Valid URI schemes are grpc or tls. Specifying tls forces communication to be encrypted.\n"
                },
                "suggestPipelineEnabled": {
                    "type": "boolean",
                    "description": "Enable pipeline suggestion banner.\n"
                },
                "terminalMaxSessionTime": {
                    "type": "integer",
                    "description": "Maximum time for web terminal websocket connection (in seconds). Set to 0 for unlimited time.\n"
                },
                "terms": {
                    "type": "string",
                    "description": "(Required by: enforce_terms) Markdown content for the ToS.\n"
                },
                "throttleAuthenticatedApiEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: throttle*authenticated*api*period*in*seconds and throttle*authenticated*api*requests*per*period) Enable authenticated API request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots).\n"
                },
                "throttleAuthenticatedApiPeriodInSeconds": {
                    "type": "integer",
                    "description": "Rate limit period (in seconds).\n"
                },
                "throttleAuthenticatedApiRequestsPerPeriod": {
                    "type": "integer",
                    "description": "Maximum requests per period per user.\n"
                },
                "throttleAuthenticatedPackagesApiEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: throttle*authenticated*packages*api*period*in*seconds and throttle*authenticated*packages*api*requests*per*period) Enable authenticated API request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots). View Package Registry rate limits for more details.\n"
                },
                "throttleAuthenticatedPackagesApiPeriodInSeconds": {
                    "type": "integer",
                    "description": "Rate limit period (in seconds). View Package Registry rate limits for more details.\n"
                },
                "throttleAuthenticatedPackagesApiRequestsPerPeriod": {
                    "type": "integer",
                    "description": "Maximum requests per period per user. View Package Registry rate limits for more details.\n"
                },
                "throttleAuthenticatedWebEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: throttle*authenticated*web*period*in*seconds and throttle*authenticated*web*requests*per*period) Enable authenticated web request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots).\n"
                },
                "throttleAuthenticatedWebPeriodInSeconds": {
                    "type": "integer",
                    "description": "Rate limit period (in seconds).\n"
                },
                "throttleAuthenticatedWebRequestsPerPeriod": {
                    "type": "integer",
                    "description": "Maximum requests per period per user.\n"
                },
                "throttleUnauthenticatedApiEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: throttle*unauthenticated*api*period*in*seconds and throttle*unauthenticated*api*requests*per*period) Enable unauthenticated API request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots).\n"
                },
                "throttleUnauthenticatedApiPeriodInSeconds": {
                    "type": "integer",
                    "description": "Rate limit period in seconds.\n"
                },
                "throttleUnauthenticatedApiRequestsPerPeriod": {
                    "type": "integer",
                    "description": "Max requests per period per IP.\n"
                },
                "throttleUnauthenticatedPackagesApiEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: throttle*unauthenticated*packages*api*period*in*seconds and throttle*unauthenticated*packages*api*requests*per*period) Enable authenticated API request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots). View Package Registry rate limits for more details.\n"
                },
                "throttleUnauthenticatedPackagesApiPeriodInSeconds": {
                    "type": "integer",
                    "description": "Rate limit period (in seconds). View Package Registry rate limits for more details.\n"
                },
                "throttleUnauthenticatedPackagesApiRequestsPerPeriod": {
                    "type": "integer",
                    "description": "Maximum requests per period per user. View Package Registry rate limits for more details.\n"
                },
                "throttleUnauthenticatedWebEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: throttle*unauthenticated*web*period*in*seconds and throttle*unauthenticated*web*requests*per*period) Enable unauthenticated web request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots).\n"
                },
                "throttleUnauthenticatedWebPeriodInSeconds": {
                    "type": "integer",
                    "description": "Rate limit period in seconds.\n"
                },
                "throttleUnauthenticatedWebRequestsPerPeriod": {
                    "type": "integer",
                    "description": "Max requests per period per IP.\n"
                },
                "timeTrackingLimitToHours": {
                    "type": "boolean",
                    "description": "Limit display of time tracking units to hours.\n"
                },
                "twoFactorGracePeriod": {
                    "type": "integer",
                    "description": "Amount of time (in hours) that users are allowed to skip forced configuration of two-factor authentication.\n"
                },
                "uniqueIpsLimitEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: unique*ips*limit*per*user and unique*ips*limit*time*window) Limit sign in from multiple IPs.\n"
                },
                "uniqueIpsLimitPerUser": {
                    "type": "integer",
                    "description": "Maximum number of IPs per user.\n"
                },
                "uniqueIpsLimitTimeWindow": {
                    "type": "integer",
                    "description": "How many seconds an IP is counted towards the limit.\n"
                },
                "usagePingEnabled": {
                    "type": "boolean",
                    "description": "Every week GitLab reports license usage back to GitLab, Inc.\n"
                },
                "userDeactivationEmailsEnabled": {
                    "type": "boolean",
                    "description": "Send an email to users upon account deactivation.\n"
                },
                "userDefaultExternal": {
                    "type": "boolean",
                    "description": "Newly registered users are external by default.\n"
                },
                "userDefaultInternalRegex": {
                    "type": "string",
                    "description": "Specify an email address regex pattern to identify default internal users.\n"
                },
                "userOauthApplications": {
                    "type": "boolean",
                    "description": "Allow users to register any application to use GitLab as an OAuth provider.\n"
                },
                "userShowAddSshKeyMessage": {
                    "type": "boolean",
                    "description": "When set to false disable the You won't be able to pull or push project code via SSH warning shown to users with no uploaded SSH key.\n"
                },
                "versionCheckEnabled": {
                    "type": "boolean",
                    "description": "Let GitLab inform you when an update is available.\n"
                },
                "webIdeClientsidePreviewEnabled": {
                    "type": "boolean",
                    "description": "Live Preview (allow live previews of JavaScript projects in the Web IDE using CodeSandbox Live Preview).\n"
                },
                "whatsNewVariant": {
                    "type": "string",
                    "description": "What’s new variant, possible values: all*tiers, current*tier, and disabled.\n"
                },
                "wikiPageMaxContentBytes": {
                    "type": "integer",
                    "description": "Maximum wiki page content size in bytes. The minimum value is 1024 bytes.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ApplicationSettings resources.\n",
                "properties": {
                    "abuseNotificationEmail": {
                        "type": "string",
                        "description": "If set, abuse reports are sent to this address. Abuse reports are always available in the Admin Area.\n"
                    },
                    "adminMode": {
                        "type": "boolean",
                        "description": "Require administrators to enable Admin Mode by re-authenticating for administrative tasks.\n"
                    },
                    "afterSignOutPath": {
                        "type": "string",
                        "description": "Where to redirect users after logout.\n"
                    },
                    "afterSignUpText": {
                        "type": "string",
                        "description": "Text shown to the user after signing up.\n"
                    },
                    "akismetApiKey": {
                        "type": "string",
                        "description": "API key for Akismet spam protection.\n",
                        "secret": true
                    },
                    "akismetEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: akismet*api*key) Enable or disable Akismet spam protection.\n"
                    },
                    "allowGroupOwnersToManageLdap": {
                        "type": "boolean",
                        "description": "Set to true to allow group owners to manage LDAP.\n"
                    },
                    "allowLocalRequestsFromSystemHooks": {
                        "type": "boolean",
                        "description": "Allow requests to the local network from system hooks.\n"
                    },
                    "allowLocalRequestsFromWebHooksAndServices": {
                        "type": "boolean",
                        "description": "Allow requests to the local network from web hooks and services.\n"
                    },
                    "archiveBuildsInHumanReadable": {
                        "type": "string",
                        "description": "Set the duration for which the jobs are considered as old and expired. After that time passes, the jobs are archived and no longer able to be retried. Make it empty to never expire jobs. It has to be no less than 1 day, for example: 15 days, 1 month, 2 years.\n"
                    },
                    "assetProxyAllowlists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Assets that match these domains are not proxied. Wildcards allowed. Your GitLab installation URL is automatically allowlisted. GitLab restart is required to apply changes.\n"
                    },
                    "assetProxyEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: asset*proxy*url) Enable proxying of assets. GitLab restart is required to apply changes.\n"
                    },
                    "assetProxySecretKey": {
                        "type": "string",
                        "description": "Shared secret with the asset proxy server. GitLab restart is required to apply changes.\n",
                        "secret": true
                    },
                    "assetProxyUrl": {
                        "type": "string",
                        "description": "URL of the asset proxy server. GitLab restart is required to apply changes.\n"
                    },
                    "authorizedKeysEnabled": {
                        "type": "boolean",
                        "description": "By default, we write to the authorized_keys file to support Git over SSH without additional configuration. GitLab can be optimized to authenticate SSH keys via the database file. Only disable this if you have configured your OpenSSH server to use the AuthorizedKeysCommand.\n"
                    },
                    "autoDevopsDomain": {
                        "type": "string",
                        "description": "Specify a domain to use by default for every project’s Auto Review Apps and Auto Deploy stages.\n"
                    },
                    "autoDevopsEnabled": {
                        "type": "boolean",
                        "description": "Enable Auto DevOps for projects by default. It automatically builds, tests, and deploys applications based on a predefined CI/CD configuration.\n"
                    },
                    "automaticPurchasedStorageAllocation": {
                        "type": "boolean",
                        "description": "Enabling this permits automatic allocation of purchased storage in a namespace.\n"
                    },
                    "canCreateGroup": {
                        "type": "boolean",
                        "description": "Indicates whether users can create top-level groups. Introduced in GitLab 15.5.\n"
                    },
                    "checkNamespacePlan": {
                        "type": "boolean",
                        "description": "Enabling this makes only licensed EE features available to projects if the project namespace’s plan includes the feature or if the project is public.\n"
                    },
                    "commitEmailHostname": {
                        "type": "string",
                        "description": "Custom hostname (for private commit emails).\n"
                    },
                    "containerExpirationPoliciesEnableHistoricEntries": {
                        "type": "boolean",
                        "description": "Enable cleanup policies for all projects.\n"
                    },
                    "containerRegistryCleanupTagsServiceMaxListSize": {
                        "type": "integer",
                        "description": "The maximum number of tags that can be deleted in a single execution of cleanup policies.\n"
                    },
                    "containerRegistryDeleteTagsServiceTimeout": {
                        "type": "integer",
                        "description": "The maximum time, in seconds, that the cleanup process can take to delete a batch of tags for cleanup policies.\n"
                    },
                    "containerRegistryExpirationPoliciesCaching": {
                        "type": "boolean",
                        "description": "Caching during the execution of cleanup policies.\n"
                    },
                    "containerRegistryExpirationPoliciesWorkerCapacity": {
                        "type": "integer",
                        "description": "Number of workers for cleanup policies.\n"
                    },
                    "containerRegistryTokenExpireDelay": {
                        "type": "integer",
                        "description": "Container Registry token duration in minutes.\n"
                    },
                    "deactivateDormantUsers": {
                        "type": "boolean",
                        "description": "Enable automatic deactivation of dormant users.\n"
                    },
                    "defaultArtifactsExpireIn": {
                        "type": "string",
                        "description": "Set the default expiration time for each job’s artifacts.\n"
                    },
                    "defaultBranchName": {
                        "type": "string",
                        "description": "Instance-level custom initial branch name (introduced in GitLab 13.2).\n"
                    },
                    "defaultBranchProtection": {
                        "type": "integer",
                        "description": "Determine if developers can push to the default branch. Can take: 0 (not protected, both users with the Developer role or Maintainer role can push new commits and force push), 1 (partially protected, users with the Developer role or Maintainer role can push new commits, but cannot force push) or 2 (fully protected, users with the Developer or Maintainer role cannot push new commits, but users with the Developer or Maintainer role can; no one can force push) as a parameter. Default is 2.\n"
                    },
                    "defaultCiConfigPath": {
                        "type": "string",
                        "description": "Default CI/CD configuration file and path for new projects (.gitlab-ci.yml if not set).\n"
                    },
                    "defaultGroupVisibility": {
                        "type": "string",
                        "description": "What visibility level new groups receive. Can take private, internal and public as a parameter.\n"
                    },
                    "defaultProjectCreation": {
                        "type": "integer",
                        "description": "Default project creation protection. Can take: 0 (No one), 1 (Maintainers) or 2 (Developers + Maintainers).\n"
                    },
                    "defaultProjectVisibility": {
                        "type": "string",
                        "description": "What visibility level new projects receive. Can take private, internal and public as a parameter.\n"
                    },
                    "defaultProjectsLimit": {
                        "type": "integer",
                        "description": "Project limit per user.\n"
                    },
                    "defaultSnippetVisibility": {
                        "type": "string",
                        "description": "What visibility level new snippets receive. Can take private, internal and public as a parameter.\n"
                    },
                    "delayedGroupDeletion": {
                        "type": "boolean",
                        "description": "Enable delayed group deletion. Introduced in GitLab 15.0. From GitLab 15.1, disables and locks the group-level setting for delayed protect deletion when set to false.\n"
                    },
                    "delayedProjectDeletion": {
                        "type": "boolean",
                        "description": "Enable delayed project deletion by default in new groups. From GitLab 15.1, can only be enabled when delayed*group*deletion is true.\n"
                    },
                    "deleteInactiveProjects": {
                        "type": "boolean",
                        "description": "Enable inactive project deletion feature. Introduced in GitLab 14.10. Became operational in GitLab 15.0 (with feature flag inactive*projects*deletion).\n"
                    },
                    "deletionAdjournedPeriod": {
                        "type": "integer",
                        "description": "The number of days to wait before deleting a project or group that is marked for deletion. Value must be between 1 and 90. From GitLab 15.1, a hook on deletion*adjourned*period sets the period to 1 on every update, and sets both delayed*project*deletion and delayed*group*deletion to false if the period is 0.\n"
                    },
                    "diffMaxFiles": {
                        "type": "integer",
                        "description": "Maximum files in a diff.\n"
                    },
                    "diffMaxLines": {
                        "type": "integer",
                        "description": "Maximum lines in a diff.\n"
                    },
                    "diffMaxPatchBytes": {
                        "type": "integer",
                        "description": "Maximum diff patch size, in bytes.\n"
                    },
                    "disableFeedToken": {
                        "type": "boolean",
                        "description": "Disable display of RSS/Atom and calendar feed tokens (introduced in GitLab 13.7).\n"
                    },
                    "disabledOauthSignInSources": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Disabled OAuth sign-in sources.\n"
                    },
                    "dnsRebindingProtectionEnabled": {
                        "type": "boolean",
                        "description": "Enforce DNS rebinding attack protection.\n"
                    },
                    "domainAllowlists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Force people to use only corporate emails for sign-up. Null means there is no restriction.\n"
                    },
                    "domainDenylistEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: domain_denylist) Allows blocking sign-ups from emails from specific domains.\n"
                    },
                    "domainDenylists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Users with email addresses that match these domains cannot sign up. Wildcards allowed. Use separate lines for multiple entries. Ex: domain.com, *.domain.com.\n"
                    },
                    "dsaKeyRestriction": {
                        "type": "integer",
                        "description": "The minimum allowed bit length of an uploaded DSA key. 0 means no restriction. -1 disables DSA keys.\n"
                    },
                    "ecdsaKeyRestriction": {
                        "type": "integer",
                        "description": "The minimum allowed curve size (in bits) of an uploaded ECDSA key. 0 means no restriction. -1 disables ECDSA keys.\n"
                    },
                    "ecdsaSkKeyRestriction": {
                        "type": "integer",
                        "description": "The minimum allowed curve size (in bits) of an uploaded ECDSA*SK key. 0 means no restriction. -1 disables ECDSA*SK keys.\n"
                    },
                    "ed25519KeyRestriction": {
                        "type": "integer",
                        "description": "The minimum allowed curve size (in bits) of an uploaded ED25519 key. 0 means no restriction. -1 disables ED25519 keys.\n"
                    },
                    "ed25519SkKeyRestriction": {
                        "type": "integer",
                        "description": "The minimum allowed curve size (in bits) of an uploaded ED25519*SK key. 0 means no restriction. -1 disables ED25519*SK keys.\n"
                    },
                    "eksAccessKeyId": {
                        "type": "string",
                        "description": "AWS IAM access key ID.\n",
                        "secret": true
                    },
                    "eksAccountId": {
                        "type": "string",
                        "description": "Amazon account ID.\n"
                    },
                    "eksIntegrationEnabled": {
                        "type": "boolean",
                        "description": "Enable integration with Amazon EKS.\n"
                    },
                    "eksSecretAccessKey": {
                        "type": "string",
                        "description": "AWS IAM secret access key.\n",
                        "secret": true
                    },
                    "elasticsearchAws": {
                        "type": "boolean",
                        "description": "Enable the use of AWS hosted Elasticsearch.\n"
                    },
                    "elasticsearchAwsAccessKey": {
                        "type": "string",
                        "description": "AWS IAM access key.\n",
                        "secret": true
                    },
                    "elasticsearchAwsRegion": {
                        "type": "string",
                        "description": "The AWS region the Elasticsearch domain is configured.\n"
                    },
                    "elasticsearchAwsSecretAccessKey": {
                        "type": "string",
                        "description": "AWS IAM secret access key.\n",
                        "secret": true
                    },
                    "elasticsearchIndexedFieldLengthLimit": {
                        "type": "integer",
                        "description": "Maximum size of text fields to index by Elasticsearch. 0 value means no limit. This does not apply to repository and wiki indexing.\n"
                    },
                    "elasticsearchIndexedFileSizeLimitKb": {
                        "type": "integer",
                        "description": "Maximum size of repository and wiki files that are indexed by Elasticsearch.\n"
                    },
                    "elasticsearchIndexing": {
                        "type": "boolean",
                        "description": "Enable Elasticsearch indexing.\n"
                    },
                    "elasticsearchLimitIndexing": {
                        "type": "boolean",
                        "description": "Limit Elasticsearch to index certain namespaces and projects.\n"
                    },
                    "elasticsearchMaxBulkConcurrency": {
                        "type": "integer",
                        "description": "Maximum concurrency of Elasticsearch bulk requests per indexing operation. This only applies to repository indexing operations.\n"
                    },
                    "elasticsearchMaxBulkSizeMb": {
                        "type": "integer",
                        "description": "Maximum size of Elasticsearch bulk indexing requests in MB. This only applies to repository indexing operations.\n"
                    },
                    "elasticsearchNamespaceIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The namespaces to index via Elasticsearch if elasticsearch*limit*indexing is enabled.\n"
                    },
                    "elasticsearchPassword": {
                        "type": "string",
                        "description": "The password of your Elasticsearch instance.\n",
                        "secret": true
                    },
                    "elasticsearchProjectIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The projects to index via Elasticsearch if elasticsearch*limit*indexing is enabled.\n"
                    },
                    "elasticsearchSearch": {
                        "type": "boolean",
                        "description": "Enable Elasticsearch search.\n"
                    },
                    "elasticsearchUrls": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The URL to use for connecting to Elasticsearch. Use a comma-separated list to support cluster (for example, http://localhost:9200, http://localhost:9201).\n"
                    },
                    "elasticsearchUsername": {
                        "type": "string",
                        "description": "The username of your Elasticsearch instance.\n"
                    },
                    "emailAdditionalText": {
                        "type": "string",
                        "description": "Additional text added to the bottom of every email for legal/auditing/compliance reasons.\n"
                    },
                    "emailAuthorInBody": {
                        "type": "boolean",
                        "description": "Some email servers do not support overriding the email sender name. Enable this option to include the name of the author of the issue, merge request or comment in the email body instead.\n"
                    },
                    "enabledGitAccessProtocol": {
                        "type": "string",
                        "description": "Enabled protocols for Git access. Allowed values are: ssh, http, and nil to allow both protocols.\n"
                    },
                    "enforceNamespaceStorageLimit": {
                        "type": "boolean",
                        "description": "Enabling this permits enforcement of namespace storage limits.\n"
                    },
                    "enforceTerms": {
                        "type": "boolean",
                        "description": "(If enabled, requires: terms) Enforce application ToS to all users.\n"
                    },
                    "externalAuthClientCert": {
                        "type": "string",
                        "description": "(If enabled, requires: external*auth*client_key) The certificate to use to authenticate with the external authorization service.\n"
                    },
                    "externalAuthClientKey": {
                        "type": "string",
                        "description": "Private key for the certificate when authentication is required for the external authorization service, this is encrypted when stored.\n",
                        "secret": true
                    },
                    "externalAuthClientKeyPass": {
                        "type": "string",
                        "description": "Passphrase to use for the private key when authenticating with the external service this is encrypted when stored.\n",
                        "secret": true
                    },
                    "externalAuthorizationServiceDefaultLabel": {
                        "type": "string",
                        "description": "The default classification label to use when requesting authorization and no classification label has been specified on the project.\n"
                    },
                    "externalAuthorizationServiceEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: external*authorization*service*default*label, external*authorization*service*timeout and external*authorization*service*url) Enable using an external authorization service for accessing projects.\n"
                    },
                    "externalAuthorizationServiceTimeout": {
                        "type": "number",
                        "description": "The timeout after which an authorization request is aborted, in seconds. When a request times out, access is denied to the user. (min: 0.001, max: 10, step: 0.001).\n"
                    },
                    "externalAuthorizationServiceUrl": {
                        "type": "string",
                        "description": "URL to which authorization requests are directed.\n"
                    },
                    "externalPipelineValidationServiceTimeout": {
                        "type": "integer",
                        "description": "How long to wait for a response from the pipeline validation service. Assumes OK if it times out.\n"
                    },
                    "externalPipelineValidationServiceToken": {
                        "type": "string",
                        "description": "Optional. Token to include as the X-Gitlab-Token header in requests to the URL in external*pipeline*validation*service*url.\n"
                    },
                    "externalPipelineValidationServiceUrl": {
                        "type": "string",
                        "description": "URL to use for pipeline validation requests.\n"
                    },
                    "fileTemplateProjectId": {
                        "type": "integer",
                        "description": "The ID of a project to load custom file templates from.\n"
                    },
                    "firstDayOfWeek": {
                        "type": "integer",
                        "description": "Start day of the week for calendar views and date pickers. Valid values are 0 for Sunday, 1 for Monday, and 6 for Saturday.\n"
                    },
                    "geoNodeAllowedIps": {
                        "type": "string",
                        "description": "Comma-separated list of IPs and CIDRs of allowed secondary nodes. For example, 1.1.1.1, 2.2.2.0/24.\n"
                    },
                    "geoStatusTimeout": {
                        "type": "integer",
                        "description": "The amount of seconds after which a request to get a secondary node status times out.\n"
                    },
                    "gitRateLimitUsersAllowlists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of usernames excluded from Git anti-abuse rate limits. Maximum: 100 usernames. Introduced in GitLab 15.2.\n"
                    },
                    "gitTwoFactorSessionExpiry": {
                        "type": "integer",
                        "description": "Maximum duration (in minutes) of a session for Git operations when 2FA is enabled.\n"
                    },
                    "gitalyTimeoutDefault": {
                        "type": "integer",
                        "description": "Default Gitaly timeout, in seconds. This timeout is not enforced for Git fetch/push operations or Sidekiq jobs. Set to 0 to disable timeouts.\n"
                    },
                    "gitalyTimeoutFast": {
                        "type": "integer",
                        "description": "Gitaly fast operation timeout, in seconds. Some Gitaly operations are expected to be fast. If they exceed this threshold, there may be a problem with a storage shard and ‘failing fast’ can help maintain the stability of the GitLab instance. Set to 0 to disable timeouts.\n"
                    },
                    "gitalyTimeoutMedium": {
                        "type": "integer",
                        "description": "Medium Gitaly timeout, in seconds. This should be a value between the Fast and the Default timeout. Set to 0 to disable timeouts.\n"
                    },
                    "grafanaEnabled": {
                        "type": "boolean",
                        "description": "Enable Grafana.\n"
                    },
                    "grafanaUrl": {
                        "type": "string",
                        "description": "Grafana URL.\n"
                    },
                    "gravatarEnabled": {
                        "type": "boolean",
                        "description": "Enable Gravatar.\n"
                    },
                    "groupOwnersCanManageDefaultBranchProtection": {
                        "type": "boolean",
                        "description": "Prevent overrides of default branch protection.\n"
                    },
                    "hashedStorageEnabled": {
                        "type": "boolean",
                        "description": "Create new projects using hashed storage paths: Enable immutable, hash-based paths and repository names to store repositories on disk. This prevents repositories from having to be moved or renamed when the Project URL changes and may improve disk I/O performance. (Always enabled in GitLab versions 13.0 and later, configuration is scheduled for removal in 14.0).\n"
                    },
                    "helpPageHideCommercialContent": {
                        "type": "boolean",
                        "description": "Hide marketing-related entries from help.\n"
                    },
                    "helpPageSupportUrl": {
                        "type": "string",
                        "description": "Alternate support URL for help page and help dropdown.\n"
                    },
                    "helpPageText": {
                        "type": "string",
                        "description": "Custom text displayed on the help page.\n"
                    },
                    "helpText": {
                        "type": "string",
                        "description": "GitLab server administrator information.\n"
                    },
                    "hideThirdPartyOffers": {
                        "type": "boolean",
                        "description": "Do not display offers from third parties in GitLab.\n"
                    },
                    "homePageUrl": {
                        "type": "string",
                        "description": "Redirect to this URL when not logged in.\n"
                    },
                    "housekeepingEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: housekeeping*bitmaps*enabled, housekeeping*full*repack*period, housekeeping*gc*period, and housekeeping*incremental*repack*period) Enable or disable Git housekeeping.\n"
                    },
                    "housekeepingFullRepackPeriod": {
                        "type": "integer",
                        "description": "Number of Git pushes after which an incremental git repack is run.\n"
                    },
                    "housekeepingGcPeriod": {
                        "type": "integer",
                        "description": "Number of Git pushes after which git gc is run.\n"
                    },
                    "housekeepingIncrementalRepackPeriod": {
                        "type": "integer",
                        "description": "Number of Git pushes after which an incremental git repack is run.\n"
                    },
                    "htmlEmailsEnabled": {
                        "type": "boolean",
                        "description": "Enable HTML emails.\n"
                    },
                    "importSources": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Sources to allow project import from, possible values: github, bitbucket, bitbucket*server, gitlab, fogbugz, git, gitlab*project, gitea, manifest, and phabricator.\n"
                    },
                    "inProductMarketingEmailsEnabled": {
                        "type": "boolean",
                        "description": "Enable in-product marketing emails.\n"
                    },
                    "inactiveProjectsDeleteAfterMonths": {
                        "type": "integer",
                        "description": "If delete*inactive*projects is true, the time (in months) to wait before deleting inactive projects. Introduced in GitLab 14.10. Became operational in GitLab 15.0.\n"
                    },
                    "inactiveProjectsMinSizeMb": {
                        "type": "integer",
                        "description": "If delete*inactive*projects is true, the minimum repository size for projects to be checked for inactivity. Introduced in GitLab 14.10. Became operational in GitLab 15.0.\n"
                    },
                    "inactiveProjectsSendWarningEmailAfterMonths": {
                        "type": "integer",
                        "description": "If delete*inactive*projects is true, sets the time (in months) to wait before emailing maintainers that the project is scheduled be deleted because it is inactive. Introduced in GitLab 14.10. Became operational in GitLab 15.0.\n"
                    },
                    "invisibleCaptchaEnabled": {
                        "type": "boolean",
                        "description": "Enable Invisible CAPTCHA spam detection during sign-up.\n"
                    },
                    "issuesCreateLimit": {
                        "type": "integer",
                        "description": "Max number of issue creation requests per minute per user.\n"
                    },
                    "keepLatestArtifact": {
                        "type": "boolean",
                        "description": "Prevent the deletion of the artifacts from the most recent successful jobs, regardless of the expiry time.\n"
                    },
                    "localMarkdownVersion": {
                        "type": "integer",
                        "description": "Increase this value when any cached Markdown should be invalidated.\n"
                    },
                    "mailgunEventsEnabled": {
                        "type": "boolean",
                        "description": "Enable Mailgun event receiver.\n"
                    },
                    "mailgunSigningKey": {
                        "type": "string",
                        "description": "The Mailgun HTTP webhook signing key for receiving events from webhook.\n",
                        "secret": true
                    },
                    "maintenanceMode": {
                        "type": "boolean",
                        "description": "When instance is in maintenance mode, non-administrative users can sign in with read-only access and make read-only API requests.\n"
                    },
                    "maintenanceModeMessage": {
                        "type": "string",
                        "description": "Message displayed when instance is in maintenance mode.\n"
                    },
                    "maxArtifactsSize": {
                        "type": "integer",
                        "description": "Maximum artifacts size in MB.\n"
                    },
                    "maxAttachmentSize": {
                        "type": "integer",
                        "description": "Limit attachment size in MB.\n"
                    },
                    "maxExportSize": {
                        "type": "integer",
                        "description": "Maximum export size in MB. 0 for unlimited.\n"
                    },
                    "maxImportSize": {
                        "type": "integer",
                        "description": "Maximum import size in MB. 0 for unlimited.\n"
                    },
                    "maxNumberOfRepositoryDownloads": {
                        "type": "integer",
                        "description": "Maximum number of unique repositories a user can download in the specified time period before they are banned. Maximum: 10,000 repositories. Introduced in GitLab 15.1.\n"
                    },
                    "maxNumberOfRepositoryDownloadsWithinTimePeriod": {
                        "type": "integer",
                        "description": "Reporting time period (in seconds). Maximum: 864000 seconds (10 days). Introduced in GitLab 15.1.\n"
                    },
                    "maxPagesSize": {
                        "type": "integer",
                        "description": "Maximum size of pages repositories in MB.\n"
                    },
                    "maxPersonalAccessTokenLifetime": {
                        "type": "integer",
                        "description": "Maximum allowable lifetime for access tokens in days.\n"
                    },
                    "maxSshKeyLifetime": {
                        "type": "integer",
                        "description": "Maximum allowable lifetime for SSH keys in days. Introduced in GitLab 14.6.\n"
                    },
                    "metricsMethodCallThreshold": {
                        "type": "integer",
                        "description": "A method call is only tracked when it takes longer than the given amount of milliseconds.\n"
                    },
                    "mirrorAvailable": {
                        "type": "boolean",
                        "description": "Allow repository mirroring to configured by project Maintainers. If disabled, only Administrators can configure repository mirroring.\n"
                    },
                    "mirrorCapacityThreshold": {
                        "type": "integer",
                        "description": "Minimum capacity to be available before scheduling more mirrors preemptively.\n"
                    },
                    "mirrorMaxCapacity": {
                        "type": "integer",
                        "description": "Maximum number of mirrors that can be synchronizing at the same time.\n"
                    },
                    "mirrorMaxDelay": {
                        "type": "integer",
                        "description": "Maximum time (in minutes) between updates that a mirror can have when scheduled to synchronize.\n"
                    },
                    "npmPackageRequestsForwarding": {
                        "type": "boolean",
                        "description": "Use npmjs.org as a default remote repository when the package is not found in the GitLab Package Registry for npm.\n"
                    },
                    "outboundLocalRequestsWhitelists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Define a list of trusted domains or IP addresses to which local requests are allowed when local requests for hooks and services are disabled.\n"
                    },
                    "packageRegistryCleanupPoliciesWorkerCapacity": {
                        "type": "integer",
                        "description": "Number of workers assigned to the packages cleanup policies.\n"
                    },
                    "pagesDomainVerificationEnabled": {
                        "type": "boolean",
                        "description": "Require users to prove ownership of custom domains. Domain verification is an essential security measure for public GitLab sites. Users are required to demonstrate they control a domain before it is enabled.\n"
                    },
                    "passwordAuthenticationEnabledForGit": {
                        "type": "boolean",
                        "description": "Enable authentication for Git over HTTP(S) via a GitLab account password.\n"
                    },
                    "passwordAuthenticationEnabledForWeb": {
                        "type": "boolean",
                        "description": "Enable authentication for the web interface via a GitLab account password.\n"
                    },
                    "passwordLowercaseRequired": {
                        "type": "boolean",
                        "description": "Indicates whether passwords require at least one lowercase letter. Introduced in GitLab 15.1.\n"
                    },
                    "passwordNumberRequired": {
                        "type": "boolean",
                        "description": "Indicates whether passwords require at least one number. Introduced in GitLab 15.1.\n"
                    },
                    "passwordSymbolRequired": {
                        "type": "boolean",
                        "description": "Indicates whether passwords require at least one symbol character. Introduced in GitLab 15.1.\n"
                    },
                    "passwordUppercaseRequired": {
                        "type": "boolean",
                        "description": "Indicates whether passwords require at least one uppercase letter. Introduced in GitLab 15.1.\n"
                    },
                    "performanceBarAllowedGroupPath": {
                        "type": "string",
                        "description": "Path of the group that is allowed to toggle the performance bar.\n"
                    },
                    "personalAccessTokenPrefix": {
                        "type": "string",
                        "description": "Prefix for all generated personal access tokens.\n"
                    },
                    "pipelineLimitPerProjectUserSha": {
                        "type": "integer",
                        "description": "Maximum number of pipeline creation requests per minute per user and commit.\n"
                    },
                    "plantumlEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: plantuml_url) Enable PlantUML integration.\n"
                    },
                    "plantumlUrl": {
                        "type": "string",
                        "description": "The PlantUML instance URL for integration.\n"
                    },
                    "pollingIntervalMultiplier": {
                        "type": "number",
                        "description": "Interval multiplier used by endpoints that perform polling. Set to 0 to disable polling.\n"
                    },
                    "projectExportEnabled": {
                        "type": "boolean",
                        "description": "Enable project export.\n"
                    },
                    "prometheusMetricsEnabled": {
                        "type": "boolean",
                        "description": "Enable Prometheus metrics.\n"
                    },
                    "protectedCiVariables": {
                        "type": "boolean",
                        "description": "CI/CD variables are protected by default.\n"
                    },
                    "pushEventActivitiesLimit": {
                        "type": "integer",
                        "description": "Number of changes (branches or tags) in a single push to determine whether individual push events or bulk push events are created. Bulk push events are created if it surpasses that value.\n"
                    },
                    "pushEventHooksLimit": {
                        "type": "integer",
                        "description": "Number of changes (branches or tags) in a single push to determine whether webhooks and services fire or not. Webhooks and services aren’t submitted if it surpasses that value.\n"
                    },
                    "pypiPackageRequestsForwarding": {
                        "type": "boolean",
                        "description": "Use pypi.org as a default remote repository when the package is not found in the GitLab Package Registry for PyPI.\n"
                    },
                    "rateLimitingResponseText": {
                        "type": "string",
                        "description": "When rate limiting is enabled via the throttle_* settings, send this plain text response when a rate limit is exceeded. ‘Retry later’ is sent if this is blank.\n"
                    },
                    "rawBlobRequestLimit": {
                        "type": "integer",
                        "description": "Max number of requests per minute for each raw path. To disable throttling set to 0.\n"
                    },
                    "recaptchaEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: recaptcha*private*key and recaptcha*site*key) Enable reCAPTCHA.\n"
                    },
                    "recaptchaPrivateKey": {
                        "type": "string",
                        "description": "Private key for reCAPTCHA.\n",
                        "secret": true
                    },
                    "recaptchaSiteKey": {
                        "type": "string",
                        "description": "Site key for reCAPTCHA.\n",
                        "secret": true
                    },
                    "receiveMaxInputSize": {
                        "type": "integer",
                        "description": "Maximum push size (MB).\n"
                    },
                    "repositoryChecksEnabled": {
                        "type": "boolean",
                        "description": "GitLab periodically runs git fsck in all project and wiki repositories to look for silent disk corruption issues.\n"
                    },
                    "repositorySizeLimit": {
                        "type": "integer",
                        "description": "Size limit per repository (MB).\n"
                    },
                    "repositoryStorages": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(GitLab 13.0 and earlier) List of names of enabled storage paths, taken from gitlab.yml. New projects are created in one of these stores, chosen at random.\n"
                    },
                    "repositoryStoragesWeighted": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "integer"
                        },
                        "description": "(GitLab 13.1 and later) Hash of names of taken from gitlab.yml to weights. New projects are created in one of these stores, chosen by a weighted random selection.\n"
                    },
                    "requireAdminApprovalAfterUserSignup": {
                        "type": "boolean",
                        "description": "When enabled, any user that signs up for an account using the registration form is placed under a Pending approval state and has to be explicitly approved by an administrator.\n"
                    },
                    "requireTwoFactorAuthentication": {
                        "type": "boolean",
                        "description": "(If enabled, requires: two*factor*grace_period) Require all users to set up Two-factor authentication.\n"
                    },
                    "restrictedVisibilityLevels": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Selected levels cannot be used by non-Administrator users for groups, projects or snippets. Can take private, internal and public as a parameter. Null means there is no restriction.\n"
                    },
                    "rsaKeyRestriction": {
                        "type": "integer",
                        "description": "The minimum allowed bit length of an uploaded RSA key. 0 means no restriction. -1 disables RSA keys.\n"
                    },
                    "searchRateLimit": {
                        "type": "integer",
                        "description": "Max number of requests per minute for performing a search while authenticated. To disable throttling set to 0.\n"
                    },
                    "searchRateLimitUnauthenticated": {
                        "type": "integer",
                        "description": "Max number of requests per minute for performing a search while unauthenticated. To disable throttling set to 0.\n"
                    },
                    "sendUserConfirmationEmail": {
                        "type": "boolean",
                        "description": "Send confirmation email on sign-up.\n"
                    },
                    "sessionExpireDelay": {
                        "type": "integer",
                        "description": "Session duration in minutes. GitLab restart is required to apply changes.\n"
                    },
                    "sharedRunnersEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: shared*runners*text and shared*runners*minutes) Enable shared runners for new projects.\n"
                    },
                    "sharedRunnersMinutes": {
                        "type": "integer",
                        "description": "Set the maximum number of CI/CD minutes that a group can use on shared runners per month.\n"
                    },
                    "sharedRunnersText": {
                        "type": "string",
                        "description": "Shared runners text.\n"
                    },
                    "sidekiqJobLimiterCompressionThresholdBytes": {
                        "type": "integer",
                        "description": "The threshold in bytes at which Sidekiq jobs are compressed before being stored in Redis.\n"
                    },
                    "sidekiqJobLimiterLimitBytes": {
                        "type": "integer",
                        "description": "The threshold in bytes at which Sidekiq jobs are rejected. 0 means do not reject any job.\n"
                    },
                    "sidekiqJobLimiterMode": {
                        "type": "string",
                        "description": "track or compress. Sets the behavior for Sidekiq job size limits.\n"
                    },
                    "signInText": {
                        "type": "string",
                        "description": "Text on the login page.\n"
                    },
                    "signupEnabled": {
                        "type": "boolean",
                        "description": "Enable registration.\n"
                    },
                    "slackAppEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: slack*app*id, slack*app*secret and slack*app*secret) Enable Slack app.\n"
                    },
                    "slackAppId": {
                        "type": "string",
                        "description": "The app ID of the Slack-app.\n"
                    },
                    "slackAppSecret": {
                        "type": "string",
                        "description": "The app secret of the Slack-app.\n",
                        "secret": true
                    },
                    "slackAppSigningSecret": {
                        "type": "string",
                        "description": "The signing secret of the Slack-app.\n",
                        "secret": true
                    },
                    "slackAppVerificationToken": {
                        "type": "string",
                        "description": "The verification token of the Slack-app.\n"
                    },
                    "snippetSizeLimit": {
                        "type": "integer",
                        "description": "Max snippet content size in bytes.\n"
                    },
                    "snowplowAppId": {
                        "type": "string",
                        "description": "The Snowplow site name / application ID. (for example, gitlab)\n"
                    },
                    "snowplowCollectorHostname": {
                        "type": "string",
                        "description": "The Snowplow collector hostname. (for example, snowplow.trx.gitlab.net)\n"
                    },
                    "snowplowCookieDomain": {
                        "type": "string",
                        "description": "The Snowplow cookie domain. (for example, .gitlab.com)\n"
                    },
                    "snowplowEnabled": {
                        "type": "boolean",
                        "description": "Enable snowplow tracking.\n"
                    },
                    "sourcegraphEnabled": {
                        "type": "boolean",
                        "description": "Enables Sourcegraph integration. If enabled, requires sourcegraph_url.\n"
                    },
                    "sourcegraphPublicOnly": {
                        "type": "boolean",
                        "description": "Blocks Sourcegraph from being loaded on private and internal projects.\n"
                    },
                    "sourcegraphUrl": {
                        "type": "string",
                        "description": "The Sourcegraph instance URL for integration.\n"
                    },
                    "spamCheckApiKey": {
                        "type": "string",
                        "description": "API key used by GitLab for accessing the Spam Check service endpoint.\n",
                        "secret": true
                    },
                    "spamCheckEndpointEnabled": {
                        "type": "boolean",
                        "description": "Enables spam checking using external Spam Check API endpoint.\n"
                    },
                    "spamCheckEndpointUrl": {
                        "type": "string",
                        "description": "URL of the external Spamcheck service endpoint. Valid URI schemes are grpc or tls. Specifying tls forces communication to be encrypted.\n"
                    },
                    "suggestPipelineEnabled": {
                        "type": "boolean",
                        "description": "Enable pipeline suggestion banner.\n"
                    },
                    "terminalMaxSessionTime": {
                        "type": "integer",
                        "description": "Maximum time for web terminal websocket connection (in seconds). Set to 0 for unlimited time.\n"
                    },
                    "terms": {
                        "type": "string",
                        "description": "(Required by: enforce_terms) Markdown content for the ToS.\n"
                    },
                    "throttleAuthenticatedApiEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: throttle*authenticated*api*period*in*seconds and throttle*authenticated*api*requests*per*period) Enable authenticated API request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots).\n"
                    },
                    "throttleAuthenticatedApiPeriodInSeconds": {
                        "type": "integer",
                        "description": "Rate limit period (in seconds).\n"
                    },
                    "throttleAuthenticatedApiRequestsPerPeriod": {
                        "type": "integer",
                        "description": "Maximum requests per period per user.\n"
                    },
                    "throttleAuthenticatedPackagesApiEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: throttle*authenticated*packages*api*period*in*seconds and throttle*authenticated*packages*api*requests*per*period) Enable authenticated API request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots). View Package Registry rate limits for more details.\n"
                    },
                    "throttleAuthenticatedPackagesApiPeriodInSeconds": {
                        "type": "integer",
                        "description": "Rate limit period (in seconds). View Package Registry rate limits for more details.\n"
                    },
                    "throttleAuthenticatedPackagesApiRequestsPerPeriod": {
                        "type": "integer",
                        "description": "Maximum requests per period per user. View Package Registry rate limits for more details.\n"
                    },
                    "throttleAuthenticatedWebEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: throttle*authenticated*web*period*in*seconds and throttle*authenticated*web*requests*per*period) Enable authenticated web request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots).\n"
                    },
                    "throttleAuthenticatedWebPeriodInSeconds": {
                        "type": "integer",
                        "description": "Rate limit period (in seconds).\n"
                    },
                    "throttleAuthenticatedWebRequestsPerPeriod": {
                        "type": "integer",
                        "description": "Maximum requests per period per user.\n"
                    },
                    "throttleUnauthenticatedApiEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: throttle*unauthenticated*api*period*in*seconds and throttle*unauthenticated*api*requests*per*period) Enable unauthenticated API request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots).\n"
                    },
                    "throttleUnauthenticatedApiPeriodInSeconds": {
                        "type": "integer",
                        "description": "Rate limit period in seconds.\n"
                    },
                    "throttleUnauthenticatedApiRequestsPerPeriod": {
                        "type": "integer",
                        "description": "Max requests per period per IP.\n"
                    },
                    "throttleUnauthenticatedPackagesApiEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: throttle*unauthenticated*packages*api*period*in*seconds and throttle*unauthenticated*packages*api*requests*per*period) Enable authenticated API request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots). View Package Registry rate limits for more details.\n"
                    },
                    "throttleUnauthenticatedPackagesApiPeriodInSeconds": {
                        "type": "integer",
                        "description": "Rate limit period (in seconds). View Package Registry rate limits for more details.\n"
                    },
                    "throttleUnauthenticatedPackagesApiRequestsPerPeriod": {
                        "type": "integer",
                        "description": "Maximum requests per period per user. View Package Registry rate limits for more details.\n"
                    },
                    "throttleUnauthenticatedWebEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: throttle*unauthenticated*web*period*in*seconds and throttle*unauthenticated*web*requests*per*period) Enable unauthenticated web request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots).\n"
                    },
                    "throttleUnauthenticatedWebPeriodInSeconds": {
                        "type": "integer",
                        "description": "Rate limit period in seconds.\n"
                    },
                    "throttleUnauthenticatedWebRequestsPerPeriod": {
                        "type": "integer",
                        "description": "Max requests per period per IP.\n"
                    },
                    "timeTrackingLimitToHours": {
                        "type": "boolean",
                        "description": "Limit display of time tracking units to hours.\n"
                    },
                    "twoFactorGracePeriod": {
                        "type": "integer",
                        "description": "Amount of time (in hours) that users are allowed to skip forced configuration of two-factor authentication.\n"
                    },
                    "uniqueIpsLimitEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: unique*ips*limit*per*user and unique*ips*limit*time*window) Limit sign in from multiple IPs.\n"
                    },
                    "uniqueIpsLimitPerUser": {
                        "type": "integer",
                        "description": "Maximum number of IPs per user.\n"
                    },
                    "uniqueIpsLimitTimeWindow": {
                        "type": "integer",
                        "description": "How many seconds an IP is counted towards the limit.\n"
                    },
                    "usagePingEnabled": {
                        "type": "boolean",
                        "description": "Every week GitLab reports license usage back to GitLab, Inc.\n"
                    },
                    "userDeactivationEmailsEnabled": {
                        "type": "boolean",
                        "description": "Send an email to users upon account deactivation.\n"
                    },
                    "userDefaultExternal": {
                        "type": "boolean",
                        "description": "Newly registered users are external by default.\n"
                    },
                    "userDefaultInternalRegex": {
                        "type": "string",
                        "description": "Specify an email address regex pattern to identify default internal users.\n"
                    },
                    "userOauthApplications": {
                        "type": "boolean",
                        "description": "Allow users to register any application to use GitLab as an OAuth provider.\n"
                    },
                    "userShowAddSshKeyMessage": {
                        "type": "boolean",
                        "description": "When set to false disable the You won't be able to pull or push project code via SSH warning shown to users with no uploaded SSH key.\n"
                    },
                    "versionCheckEnabled": {
                        "type": "boolean",
                        "description": "Let GitLab inform you when an update is available.\n"
                    },
                    "webIdeClientsidePreviewEnabled": {
                        "type": "boolean",
                        "description": "Live Preview (allow live previews of JavaScript projects in the Web IDE using CodeSandbox Live Preview).\n"
                    },
                    "whatsNewVariant": {
                        "type": "string",
                        "description": "What’s new variant, possible values: all*tiers, current*tier, and disabled.\n"
                    },
                    "wikiPageMaxContentBytes": {
                        "type": "integer",
                        "description": "Maximum wiki page content size in bytes. The minimum value is 1024 bytes.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/branch:Branch": {
            "description": "The `gitlab.Branch` resource allows to manage the lifecycle of a repository branch.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/branches.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\n// Create a project for the branch to use\nconst exampleProject = new gitlab.Project(\"exampleProject\", {\n    description: \"An example project\",\n    namespaceId: gitlab_group.example.id,\n});\nconst exampleBranch = new gitlab.Branch(\"exampleBranch\", {\n    ref: \"main\",\n    project: exampleProject.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\n# Create a project for the branch to use\nexample_project = gitlab.Project(\"exampleProject\",\n    description=\"An example project\",\n    namespace_id=gitlab_group[\"example\"][\"id\"])\nexample_branch = gitlab.Branch(\"exampleBranch\",\n    ref=\"main\",\n    project=example_project.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create a project for the branch to use\n    var exampleProject = new GitLab.Project(\"exampleProject\", new()\n    {\n        Description = \"An example project\",\n        NamespaceId = gitlab_group.Example.Id,\n    });\n\n    var exampleBranch = new GitLab.Branch(\"exampleBranch\", new()\n    {\n        Ref = \"main\",\n        Project = exampleProject.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleProject, err := gitlab.NewProject(ctx, \"exampleProject\", \u0026gitlab.ProjectArgs{\n\t\t\tDescription: pulumi.String(\"An example project\"),\n\t\t\tNamespaceId: pulumi.Any(gitlab_group.Example.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewBranch(ctx, \"exampleBranch\", \u0026gitlab.BranchArgs{\n\t\t\tRef:     pulumi.String(\"main\"),\n\t\t\tProject: exampleProject.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.Branch;\nimport com.pulumi.gitlab.BranchArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleProject = new Project(\"exampleProject\", ProjectArgs.builder()        \n            .description(\"An example project\")\n            .namespaceId(gitlab_group.example().id())\n            .build());\n\n        var exampleBranch = new Branch(\"exampleBranch\", BranchArgs.builder()        \n            .ref(\"main\")\n            .project(exampleProject.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a project for the branch to use\n  exampleProject:\n    type: gitlab:Project\n    properties:\n      description: An example project\n      namespaceId: ${gitlab_group.example.id}\n  exampleBranch:\n    type: gitlab:Branch\n    properties:\n      ref: main\n      project: ${exampleProject.id}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitlab branches can be imported with a key composed of `\u003cproject_id\u003e:\u003cbranch_name\u003e`, e.g.\n\n```sh\n $ pulumi import gitlab:index/branch:Branch example \"12345:develop\"\n```\n\n ",
            "properties": {
                "canPush": {
                    "type": "boolean",
                    "description": "Bool, true if you can push to the branch.\n"
                },
                "commits": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/BranchCommit:BranchCommit"
                    },
                    "description": "The commit associated with the branch ref.\n"
                },
                "default": {
                    "type": "boolean",
                    "description": "Bool, true if branch is the default branch for the project.\n"
                },
                "developerCanMerge": {
                    "type": "boolean",
                    "description": "Bool, true if developer level access allows to merge branch.\n"
                },
                "developerCanPush": {
                    "type": "boolean",
                    "description": "Bool, true if developer level access allows git push.\n"
                },
                "merged": {
                    "type": "boolean",
                    "description": "Bool, true if the branch has been merged into it's parent.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name for this branch.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project which the branch is created against.\n"
                },
                "protected": {
                    "type": "boolean",
                    "description": "Bool, true if branch has branch protection.\n"
                },
                "ref": {
                    "type": "string",
                    "description": "The ref which the branch is created from.\n"
                },
                "webUrl": {
                    "type": "string",
                    "description": "The url of the created branch (https).\n"
                }
            },
            "required": [
                "canPush",
                "commits",
                "default",
                "developerCanMerge",
                "developerCanPush",
                "merged",
                "name",
                "project",
                "protected",
                "ref",
                "webUrl"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "The name for this branch.\n",
                    "willReplaceOnChanges": true
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project which the branch is created against.\n",
                    "willReplaceOnChanges": true
                },
                "ref": {
                    "type": "string",
                    "description": "The ref which the branch is created from.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "project",
                "ref"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Branch resources.\n",
                "properties": {
                    "canPush": {
                        "type": "boolean",
                        "description": "Bool, true if you can push to the branch.\n"
                    },
                    "commits": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/BranchCommit:BranchCommit"
                        },
                        "description": "The commit associated with the branch ref.\n"
                    },
                    "default": {
                        "type": "boolean",
                        "description": "Bool, true if branch is the default branch for the project.\n"
                    },
                    "developerCanMerge": {
                        "type": "boolean",
                        "description": "Bool, true if developer level access allows to merge branch.\n"
                    },
                    "developerCanPush": {
                        "type": "boolean",
                        "description": "Bool, true if developer level access allows git push.\n"
                    },
                    "merged": {
                        "type": "boolean",
                        "description": "Bool, true if the branch has been merged into it's parent.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name for this branch.\n",
                        "willReplaceOnChanges": true
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or full path of the project which the branch is created against.\n",
                        "willReplaceOnChanges": true
                    },
                    "protected": {
                        "type": "boolean",
                        "description": "Bool, true if branch has branch protection.\n"
                    },
                    "ref": {
                        "type": "string",
                        "description": "The ref which the branch is created from.\n",
                        "willReplaceOnChanges": true
                    },
                    "webUrl": {
                        "type": "string",
                        "description": "The url of the created branch (https).\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/branchProtection:BranchProtection": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.BranchProtection;\nimport com.pulumi.gitlab.BranchProtectionArgs;\nimport com.pulumi.gitlab.inputs.BranchProtectionAllowedToPushArgs;\nimport com.pulumi.gitlab.inputs.BranchProtectionAllowedToMergeArgs;\nimport com.pulumi.gitlab.inputs.BranchProtectionAllowedToUnprotectArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var branchProtect = new BranchProtection(\"branchProtect\", BranchProtectionArgs.builder()        \n            .project(\"12345\")\n            .branch(\"BranchProtected\")\n            .pushAccessLevel(\"developer\")\n            .mergeAccessLevel(\"developer\")\n            .unprotectAccessLevel(\"developer\")\n            .allowForcePush(true)\n            .codeOwnerApprovalRequired(true)\n            .allowedToPushes(            \n                BranchProtectionAllowedToPushArgs.builder()\n                    .userId(5)\n                    .build(),\n                BranchProtectionAllowedToPushArgs.builder()\n                    .userId(521)\n                    .build())\n            .allowedToMerges(            \n                BranchProtectionAllowedToMergeArgs.builder()\n                    .userId(15)\n                    .build(),\n                BranchProtectionAllowedToMergeArgs.builder()\n                    .userId(37)\n                    .build())\n            .allowedToUnprotects(            \n                BranchProtectionAllowedToUnprotectArgs.builder()\n                    .userId(15)\n                    .build(),\n                BranchProtectionAllowedToUnprotectArgs.builder()\n                    .groupId(42)\n                    .build())\n            .build());\n\n        var main = new BranchProtection(\"main\", BranchProtectionArgs.builder()        \n            .project(\"12345\")\n            .branch(\"main\")\n            .pushAccessLevel(\"maintainer\")\n            .mergeAccessLevel(\"maintainer\")\n            .unprotectAccessLevel(\"maintainer\")\n            .dynamic(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  branchProtect:\n    type: gitlab:BranchProtection\n    properties:\n      project: '12345'\n      branch: BranchProtected\n      pushAccessLevel: developer\n      mergeAccessLevel: developer\n      unprotectAccessLevel: developer\n      allowForcePush: true\n      codeOwnerApprovalRequired: true\n      allowedToPushes:\n        - userId: 5\n        - userId: 521\n      allowedToMerges:\n        - userId: 15\n        - userId: 37\n      allowedToUnprotects:\n        - userId: 15\n        - groupId: 42\n  # Example using dynamic block\n  main:\n    type: gitlab:BranchProtection\n    properties:\n      project: '12345'\n      branch: main\n      pushAccessLevel: maintainer\n      mergeAccessLevel: maintainer\n      unprotectAccessLevel: maintainer\n      dynamic:\n        - forEach:\n            - 50\n            - 55\n            - 60\n          content:\n            - userId: ${allowed_to_push.value}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitlab protected branches can be imported with a key composed of `\u003cproject_id\u003e:\u003cbranch\u003e`, e.g.\n\n```sh\n $ pulumi import gitlab:index/branchProtection:BranchProtection BranchProtect \"12345:main\"\n```\n\n ",
            "properties": {
                "allowForcePush": {
                    "type": "boolean",
                    "description": "Can be set to true to allow users with push access to force push.\n"
                },
                "allowedToMerges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/BranchProtectionAllowedToMerge:BranchProtectionAllowedToMerge"
                    },
                    "description": "Defines permissions for action.\n"
                },
                "allowedToPushes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/BranchProtectionAllowedToPush:BranchProtectionAllowedToPush"
                    },
                    "description": "Defines permissions for action.\n"
                },
                "allowedToUnprotects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/BranchProtectionAllowedToUnprotect:BranchProtectionAllowedToUnprotect"
                    },
                    "description": "Defines permissions for action.\n"
                },
                "branch": {
                    "type": "string",
                    "description": "Name of the branch.\n"
                },
                "branchProtectionId": {
                    "type": "integer",
                    "description": "The ID of the branch protection (not the branch name).\n"
                },
                "codeOwnerApprovalRequired": {
                    "type": "boolean",
                    "description": "Can be set to true to require code owner approval before merging. Only available own Premium and Ultimate instances.\n"
                },
                "mergeAccessLevel": {
                    "type": "string",
                    "description": "Access levels allowed to merge. Valid values are: `no one`, `developer`, `maintainer`.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The id of the project.\n"
                },
                "pushAccessLevel": {
                    "type": "string",
                    "description": "Access levels allowed to push. Valid values are: `no one`, `developer`, `maintainer`.\n"
                },
                "unprotectAccessLevel": {
                    "type": "string",
                    "description": "Access levels allowed to unprotect. Valid values are: `no one`, `developer`, `maintainer`.\n"
                }
            },
            "required": [
                "branch",
                "branchProtectionId",
                "project"
            ],
            "inputProperties": {
                "allowForcePush": {
                    "type": "boolean",
                    "description": "Can be set to true to allow users with push access to force push.\n",
                    "willReplaceOnChanges": true
                },
                "allowedToMerges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/BranchProtectionAllowedToMerge:BranchProtectionAllowedToMerge"
                    },
                    "description": "Defines permissions for action.\n",
                    "willReplaceOnChanges": true
                },
                "allowedToPushes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/BranchProtectionAllowedToPush:BranchProtectionAllowedToPush"
                    },
                    "description": "Defines permissions for action.\n",
                    "willReplaceOnChanges": true
                },
                "allowedToUnprotects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/BranchProtectionAllowedToUnprotect:BranchProtectionAllowedToUnprotect"
                    },
                    "description": "Defines permissions for action.\n",
                    "willReplaceOnChanges": true
                },
                "branch": {
                    "type": "string",
                    "description": "Name of the branch.\n",
                    "willReplaceOnChanges": true
                },
                "codeOwnerApprovalRequired": {
                    "type": "boolean",
                    "description": "Can be set to true to require code owner approval before merging. Only available own Premium and Ultimate instances.\n"
                },
                "mergeAccessLevel": {
                    "type": "string",
                    "description": "Access levels allowed to merge. Valid values are: `no one`, `developer`, `maintainer`.\n",
                    "willReplaceOnChanges": true
                },
                "project": {
                    "type": "string",
                    "description": "The id of the project.\n",
                    "willReplaceOnChanges": true
                },
                "pushAccessLevel": {
                    "type": "string",
                    "description": "Access levels allowed to push. Valid values are: `no one`, `developer`, `maintainer`.\n",
                    "willReplaceOnChanges": true
                },
                "unprotectAccessLevel": {
                    "type": "string",
                    "description": "Access levels allowed to unprotect. Valid values are: `no one`, `developer`, `maintainer`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "branch",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering BranchProtection resources.\n",
                "properties": {
                    "allowForcePush": {
                        "type": "boolean",
                        "description": "Can be set to true to allow users with push access to force push.\n",
                        "willReplaceOnChanges": true
                    },
                    "allowedToMerges": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/BranchProtectionAllowedToMerge:BranchProtectionAllowedToMerge"
                        },
                        "description": "Defines permissions for action.\n",
                        "willReplaceOnChanges": true
                    },
                    "allowedToPushes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/BranchProtectionAllowedToPush:BranchProtectionAllowedToPush"
                        },
                        "description": "Defines permissions for action.\n",
                        "willReplaceOnChanges": true
                    },
                    "allowedToUnprotects": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/BranchProtectionAllowedToUnprotect:BranchProtectionAllowedToUnprotect"
                        },
                        "description": "Defines permissions for action.\n",
                        "willReplaceOnChanges": true
                    },
                    "branch": {
                        "type": "string",
                        "description": "Name of the branch.\n",
                        "willReplaceOnChanges": true
                    },
                    "branchProtectionId": {
                        "type": "integer",
                        "description": "The ID of the branch protection (not the branch name).\n"
                    },
                    "codeOwnerApprovalRequired": {
                        "type": "boolean",
                        "description": "Can be set to true to require code owner approval before merging. Only available own Premium and Ultimate instances.\n"
                    },
                    "mergeAccessLevel": {
                        "type": "string",
                        "description": "Access levels allowed to merge. Valid values are: `no one`, `developer`, `maintainer`.\n",
                        "willReplaceOnChanges": true
                    },
                    "project": {
                        "type": "string",
                        "description": "The id of the project.\n",
                        "willReplaceOnChanges": true
                    },
                    "pushAccessLevel": {
                        "type": "string",
                        "description": "Access levels allowed to push. Valid values are: `no one`, `developer`, `maintainer`.\n",
                        "willReplaceOnChanges": true
                    },
                    "unprotectAccessLevel": {
                        "type": "string",
                        "description": "Access levels allowed to unprotect. Valid values are: `no one`, `developer`, `maintainer`.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/clusterAgent:ClusterAgent": {
            "description": "The `gitlab.ClusterAgent` resource allows to manage the lifecycle of a GitLab Agent for Kubernetes.\n\n\u003e Note that this resource only registers the agent, but doesn't configure it.\n   The configuration needs to be manually added as described in\n   [the docs](https://docs.gitlab.com/ee/user/clusters/agent/install/index.html#create-an-agent-configuration-file).\n   However, a `gitlab.RepositoryFile` resource may be used to achieve that.\n\n\u003e Requires at least maintainer permissions on the project.\n\n\u003e Requires at least GitLab 14.10\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/cluster_agents.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = new gitlab.ClusterAgent(\"example\", {project: \"12345\"});\n// Optionally, configure the agent as described in\n// https://docs.gitlab.com/ee/user/clusters/agent/install/index.html#create-an-agent-configuration-file\nconst exampleAgentConfig = new gitlab.RepositoryFile(\"exampleAgentConfig\", {\n    project: example.project,\n    branch: \"main\",\n    filePath: pulumi.interpolate`.gitlab/agents/${example.name}`,\n    content: `  gitops:\n    ...\n`,\n    authorEmail: \"terraform@example.com\",\n    authorName: \"Terraform\",\n    commitMessage: pulumi.interpolate`feature: add agent config for ${example.name}`,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.ClusterAgent(\"example\", project=\"12345\")\n# Optionally, configure the agent as described in\n# https://docs.gitlab.com/ee/user/clusters/agent/install/index.html#create-an-agent-configuration-file\nexample_agent_config = gitlab.RepositoryFile(\"exampleAgentConfig\",\n    project=example.project,\n    branch=\"main\",\n    file_path=example.name.apply(lambda name: f\".gitlab/agents/{name}\"),\n    content=\"\"\"  gitops:\n    ...\n\"\"\",\n    author_email=\"terraform@example.com\",\n    author_name=\"Terraform\",\n    commit_message=example.name.apply(lambda name: f\"feature: add agent config for {name}\"))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new GitLab.ClusterAgent(\"example\", new()\n    {\n        Project = \"12345\",\n    });\n\n    // Optionally, configure the agent as described in\n    // https://docs.gitlab.com/ee/user/clusters/agent/install/index.html#create-an-agent-configuration-file\n    var exampleAgentConfig = new GitLab.RepositoryFile(\"exampleAgentConfig\", new()\n    {\n        Project = example.Project,\n        Branch = \"main\",\n        FilePath = example.Name.Apply(name =\u003e $\".gitlab/agents/{name}\"),\n        Content = @\"  gitops:\n    ...\n\",\n        AuthorEmail = \"terraform@example.com\",\n        AuthorName = \"Terraform\",\n        CommitMessage = example.Name.Apply(name =\u003e $\"feature: add agent config for {name}\"),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := gitlab.NewClusterAgent(ctx, \"example\", \u0026gitlab.ClusterAgentArgs{\n\t\t\tProject: pulumi.String(\"12345\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewRepositoryFile(ctx, \"exampleAgentConfig\", \u0026gitlab.RepositoryFileArgs{\n\t\t\tProject: example.Project,\n\t\t\tBranch:  pulumi.String(\"main\"),\n\t\t\tFilePath: example.Name.ApplyT(func(name string) (string, error) {\n\t\t\t\treturn fmt.Sprintf(\".gitlab/agents/%v\", name), nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t\tContent:     pulumi.String(\"  gitops:\\n    ...\\n\"),\n\t\t\tAuthorEmail: pulumi.String(\"terraform@example.com\"),\n\t\t\tAuthorName:  pulumi.String(\"Terraform\"),\n\t\t\tCommitMessage: example.Name.ApplyT(func(name string) (string, error) {\n\t\t\t\treturn fmt.Sprintf(\"feature: add agent config for %v\", name), nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ClusterAgent;\nimport com.pulumi.gitlab.ClusterAgentArgs;\nimport com.pulumi.gitlab.RepositoryFile;\nimport com.pulumi.gitlab.RepositoryFileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ClusterAgent(\"example\", ClusterAgentArgs.builder()        \n            .project(\"12345\")\n            .build());\n\n        var exampleAgentConfig = new RepositoryFile(\"exampleAgentConfig\", RepositoryFileArgs.builder()        \n            .project(example.project())\n            .branch(\"main\")\n            .filePath(example.name().applyValue(name -\u003e String.format(\".gitlab/agents/%s\", name)))\n            .content(\"\"\"\n  gitops:\n    ...\n            \"\"\")\n            .authorEmail(\"terraform@example.com\")\n            .authorName(\"Terraform\")\n            .commitMessage(example.name().applyValue(name -\u003e String.format(\"feature: add agent config for %s\", name)))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: gitlab:ClusterAgent\n    properties:\n      project: '12345'\n  # Optionally, configure the agent as described in\n  # // https://docs.gitlab.com/ee/user/clusters/agent/install/index.html#create-an-agent-configuration-file\n  exampleAgentConfig:\n    type: gitlab:RepositoryFile\n    properties:\n      project: ${example.project}\n      branch: main\n      # or use the `default_branch` attribute from a project data source / resource\n      filePath: .gitlab/agents/${example.name}\n      content: |2\n          gitops:\n            ...\n      authorEmail: terraform@example.com\n      authorName: Terraform\n      commitMessage: 'feature: add agent config for ${example.name}'\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitLab Agent for Kubernetes can be imported with the following command and the id pattern `\u003cproject\u003e:\u003cagent-id\u003e`\n\n```sh\n $ pulumi import gitlab:index/clusterAgent:ClusterAgent example '12345:42'\n```\n\n ",
            "properties": {
                "agentId": {
                    "type": "integer",
                    "description": "The ID of the agent.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "The ISO8601 datetime when the agent was created.\n"
                },
                "createdByUserId": {
                    "type": "integer",
                    "description": "The ID of the user who created the agent.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The Name of the agent.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID or full path of the project maintained by the authenticated user.\n"
                }
            },
            "required": [
                "agentId",
                "createdAt",
                "createdByUserId",
                "name",
                "project"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "The Name of the agent.\n",
                    "willReplaceOnChanges": true
                },
                "project": {
                    "type": "string",
                    "description": "ID or full path of the project maintained by the authenticated user.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClusterAgent resources.\n",
                "properties": {
                    "agentId": {
                        "type": "integer",
                        "description": "The ID of the agent.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "The ISO8601 datetime when the agent was created.\n"
                    },
                    "createdByUserId": {
                        "type": "integer",
                        "description": "The ID of the user who created the agent.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The Name of the agent.\n",
                        "willReplaceOnChanges": true
                    },
                    "project": {
                        "type": "string",
                        "description": "ID or full path of the project maintained by the authenticated user.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/clusterAgentToken:ClusterAgentToken": {
            "description": "The `gitlab.ClusterAgentToken` resource allows to manage the lifecycle of a token for a GitLab Agent for Kubernetes.\n\n\u003e Requires at least maintainer permissions on the project.\n\n\u003e Requires at least GitLab 15.0\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/cluster_agents.html#create-an-agent-token)\n\n\n## Import\n\nA token for a GitLab Agent for Kubernetes can be imported with the following command and the id pattern `\u003cproject\u003e:\u003cagent-id\u003e:\u003ctoken-id\u003e`\n\n```sh\n $ pulumi import gitlab:index/clusterAgentToken:ClusterAgentToken example '12345:42:1'\n```\n\n ATTENTIONthe `token` resource attribute is not available for imported resources as this information cannot be read from the GitLab API. ",
            "properties": {
                "agentId": {
                    "type": "integer",
                    "description": "The ID of the agent.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "The ISO8601 datetime when the agent was created.\n"
                },
                "createdByUserId": {
                    "type": "integer",
                    "description": "The ID of the user who created the agent.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The Description for the agent.\n"
                },
                "lastUsedAt": {
                    "type": "string",
                    "description": "The ISO8601 datetime when the token was last used.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The Name of the agent.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID or full path of the project maintained by the authenticated user.\n"
                },
                "status": {
                    "type": "string",
                    "description": "The status of the token. Valid values are `active`, `revoked`.\n"
                },
                "token": {
                    "type": "string",
                    "description": "The secret token for the agent. The `token` is not available in imported resources.\n"
                },
                "tokenId": {
                    "type": "integer",
                    "description": "The ID of the token.\n"
                }
            },
            "required": [
                "agentId",
                "createdAt",
                "createdByUserId",
                "lastUsedAt",
                "name",
                "project",
                "status",
                "token",
                "tokenId"
            ],
            "inputProperties": {
                "agentId": {
                    "type": "integer",
                    "description": "The ID of the agent.\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "The Description for the agent.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The Name of the agent.\n",
                    "willReplaceOnChanges": true
                },
                "project": {
                    "type": "string",
                    "description": "ID or full path of the project maintained by the authenticated user.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "agentId",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClusterAgentToken resources.\n",
                "properties": {
                    "agentId": {
                        "type": "integer",
                        "description": "The ID of the agent.\n",
                        "willReplaceOnChanges": true
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "The ISO8601 datetime when the agent was created.\n"
                    },
                    "createdByUserId": {
                        "type": "integer",
                        "description": "The ID of the user who created the agent.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The Description for the agent.\n",
                        "willReplaceOnChanges": true
                    },
                    "lastUsedAt": {
                        "type": "string",
                        "description": "The ISO8601 datetime when the token was last used.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The Name of the agent.\n",
                        "willReplaceOnChanges": true
                    },
                    "project": {
                        "type": "string",
                        "description": "ID or full path of the project maintained by the authenticated user.\n",
                        "willReplaceOnChanges": true
                    },
                    "status": {
                        "type": "string",
                        "description": "The status of the token. Valid values are `active`, `revoked`.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "The secret token for the agent. The `token` is not available in imported resources.\n"
                    },
                    "tokenId": {
                        "type": "integer",
                        "description": "The ID of the token.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/deployKey:DeployKey": {
            "description": "The `gitlab.DeployKey` resource allows to manage the lifecycle of a deploy key.\n\n\u003e To enable an already existing deploy key for another project use the `gitlab_project_deploy_key` resource.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/deploy_keys.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = new gitlab.DeployKey(\"example\", {\n    key: \"ssh-ed25519 AAAA...\",\n    project: \"example/deploying\",\n    title: \"Example deploy key\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.DeployKey(\"example\",\n    key=\"ssh-ed25519 AAAA...\",\n    project=\"example/deploying\",\n    title=\"Example deploy key\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new GitLab.DeployKey(\"example\", new()\n    {\n        Key = \"ssh-ed25519 AAAA...\",\n        Project = \"example/deploying\",\n        Title = \"Example deploy key\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewDeployKey(ctx, \"example\", \u0026gitlab.DeployKeyArgs{\n\t\t\tKey:     pulumi.String(\"ssh-ed25519 AAAA...\"),\n\t\t\tProject: pulumi.String(\"example/deploying\"),\n\t\t\tTitle:   pulumi.String(\"Example deploy key\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.DeployKey;\nimport com.pulumi.gitlab.DeployKeyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new DeployKey(\"example\", DeployKeyArgs.builder()        \n            .key(\"ssh-ed25519 AAAA...\")\n            .project(\"example/deploying\")\n            .title(\"Example deploy key\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: gitlab:DeployKey\n    properties:\n      key: ssh-ed25519 AAAA...\n      project: example/deploying\n      title: Example deploy key\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitLab deploy keys can be imported using an id made up of `{project_id}:{deploy_key_id}`, e.g. `project_id` can be whatever the [get single project api][get_single_project] takes for its `:id` value, so for example\n\n```sh\n $ pulumi import gitlab:index/deployKey:DeployKey test 1:3\n```\n\n\n\n```sh\n $ pulumi import gitlab:index/deployKey:DeployKey test richardc/example:3\n```\n\n ",
            "properties": {
                "canPush": {
                    "type": "boolean",
                    "description": "Allow this deploy key to be used to push changes to the project. Defaults to `false`.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The public ssh key body.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the deploy key to.\n"
                },
                "title": {
                    "type": "string",
                    "description": "A title to describe the deploy key with.\n"
                }
            },
            "required": [
                "key",
                "project",
                "title"
            ],
            "inputProperties": {
                "canPush": {
                    "type": "boolean",
                    "description": "Allow this deploy key to be used to push changes to the project. Defaults to `false`.\n",
                    "willReplaceOnChanges": true
                },
                "key": {
                    "type": "string",
                    "description": "The public ssh key body.\n",
                    "willReplaceOnChanges": true
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the deploy key to.\n",
                    "willReplaceOnChanges": true
                },
                "title": {
                    "type": "string",
                    "description": "A title to describe the deploy key with.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "key",
                "project",
                "title"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DeployKey resources.\n",
                "properties": {
                    "canPush": {
                        "type": "boolean",
                        "description": "Allow this deploy key to be used to push changes to the project. Defaults to `false`.\n",
                        "willReplaceOnChanges": true
                    },
                    "key": {
                        "type": "string",
                        "description": "The public ssh key body.\n",
                        "willReplaceOnChanges": true
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project to add the deploy key to.\n",
                        "willReplaceOnChanges": true
                    },
                    "title": {
                        "type": "string",
                        "description": "A title to describe the deploy key with.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/deployKeyEnable:DeployKeyEnable": {
            "description": "The `gitlab.DeployKeyEnable` resource allows to enable an already existing deploy key (see `gitlab.DeployKey resource`) for a specific project.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/deploy_keys.html#enable-a-deploy-key)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\n// A repo to host the deployment key\nconst parentProject = new gitlab.Project(\"parentProject\", {});\n// A second repo to use the deployment key from the parent project\nconst fooProject = new gitlab.Project(\"fooProject\", {});\n// Upload a deployment key for the parent repo\nconst parentDeployKey = new gitlab.DeployKey(\"parentDeployKey\", {\n    project: parentProject.id,\n    title: \"Example deploy key\",\n    key: \"ssh-ed25519 AAAA...\",\n});\n// Enable the deployment key on the second repo\nconst fooDeployKeyEnable = new gitlab.DeployKeyEnable(\"fooDeployKeyEnable\", {\n    project: fooProject.id,\n    keyId: parentDeployKey.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\n# A repo to host the deployment key\nparent_project = gitlab.Project(\"parentProject\")\n# A second repo to use the deployment key from the parent project\nfoo_project = gitlab.Project(\"fooProject\")\n# Upload a deployment key for the parent repo\nparent_deploy_key = gitlab.DeployKey(\"parentDeployKey\",\n    project=parent_project.id,\n    title=\"Example deploy key\",\n    key=\"ssh-ed25519 AAAA...\")\n# Enable the deployment key on the second repo\nfoo_deploy_key_enable = gitlab.DeployKeyEnable(\"fooDeployKeyEnable\",\n    project=foo_project.id,\n    key_id=parent_deploy_key.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // A repo to host the deployment key\n    var parentProject = new GitLab.Project(\"parentProject\");\n\n    // A second repo to use the deployment key from the parent project\n    var fooProject = new GitLab.Project(\"fooProject\");\n\n    // Upload a deployment key for the parent repo\n    var parentDeployKey = new GitLab.DeployKey(\"parentDeployKey\", new()\n    {\n        Project = parentProject.Id,\n        Title = \"Example deploy key\",\n        Key = \"ssh-ed25519 AAAA...\",\n    });\n\n    // Enable the deployment key on the second repo\n    var fooDeployKeyEnable = new GitLab.DeployKeyEnable(\"fooDeployKeyEnable\", new()\n    {\n        Project = fooProject.Id,\n        KeyId = parentDeployKey.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tparentProject, err := gitlab.NewProject(ctx, \"parentProject\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfooProject, err := gitlab.NewProject(ctx, \"fooProject\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tparentDeployKey, err := gitlab.NewDeployKey(ctx, \"parentDeployKey\", \u0026gitlab.DeployKeyArgs{\n\t\t\tProject: parentProject.ID(),\n\t\t\tTitle:   pulumi.String(\"Example deploy key\"),\n\t\t\tKey:     pulumi.String(\"ssh-ed25519 AAAA...\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewDeployKeyEnable(ctx, \"fooDeployKeyEnable\", \u0026gitlab.DeployKeyEnableArgs{\n\t\t\tProject: fooProject.ID(),\n\t\t\tKeyId:   parentDeployKey.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.DeployKey;\nimport com.pulumi.gitlab.DeployKeyArgs;\nimport com.pulumi.gitlab.DeployKeyEnable;\nimport com.pulumi.gitlab.DeployKeyEnableArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var parentProject = new Project(\"parentProject\");\n\n        var fooProject = new Project(\"fooProject\");\n\n        var parentDeployKey = new DeployKey(\"parentDeployKey\", DeployKeyArgs.builder()        \n            .project(parentProject.id())\n            .title(\"Example deploy key\")\n            .key(\"ssh-ed25519 AAAA...\")\n            .build());\n\n        var fooDeployKeyEnable = new DeployKeyEnable(\"fooDeployKeyEnable\", DeployKeyEnableArgs.builder()        \n            .project(fooProject.id())\n            .keyId(parentDeployKey.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # A repo to host the deployment key\n  parentProject:\n    type: gitlab:Project\n  # A second repo to use the deployment key from the parent project\n  fooProject:\n    type: gitlab:Project\n  # Upload a deployment key for the parent repo\n  parentDeployKey:\n    type: gitlab:DeployKey\n    properties:\n      project: ${parentProject.id}\n      title: Example deploy key\n      key: ssh-ed25519 AAAA...\n  # Enable the deployment key on the second repo\n  fooDeployKeyEnable:\n    type: gitlab:DeployKeyEnable\n    properties:\n      project: ${fooProject.id}\n      keyId: ${parentDeployKey.id}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitLab enabled deploy keys can be imported using an id made up of `{project_id}:{deploy_key_id}`, e.g. `project_id` can be whatever the [get single project api][get_single_project] takes for its `:id` value, so for example\n\n```sh\n $ pulumi import gitlab:index/deployKeyEnable:DeployKeyEnable example 12345:67890\n```\n\n\n\n```sh\n $ pulumi import gitlab:index/deployKeyEnable:DeployKeyEnable example richardc/example:67890\n```\n\n ",
            "properties": {
                "canPush": {
                    "type": "boolean",
                    "description": "Can deploy key push to the project's repository.\n"
                },
                "key": {
                    "type": "string",
                    "description": "Deploy key.\n"
                },
                "keyId": {
                    "type": "string",
                    "description": "The Gitlab key id for the pre-existing deploy key\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the deploy key to.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Deploy key's title.\n"
                }
            },
            "required": [
                "key",
                "keyId",
                "project",
                "title"
            ],
            "inputProperties": {
                "canPush": {
                    "type": "boolean",
                    "description": "Can deploy key push to the project's repository.\n",
                    "willReplaceOnChanges": true
                },
                "key": {
                    "type": "string",
                    "description": "Deploy key.\n"
                },
                "keyId": {
                    "type": "string",
                    "description": "The Gitlab key id for the pre-existing deploy key\n",
                    "willReplaceOnChanges": true
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the deploy key to.\n",
                    "willReplaceOnChanges": true
                },
                "title": {
                    "type": "string",
                    "description": "Deploy key's title.\n"
                }
            },
            "requiredInputs": [
                "keyId",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DeployKeyEnable resources.\n",
                "properties": {
                    "canPush": {
                        "type": "boolean",
                        "description": "Can deploy key push to the project's repository.\n",
                        "willReplaceOnChanges": true
                    },
                    "key": {
                        "type": "string",
                        "description": "Deploy key.\n"
                    },
                    "keyId": {
                        "type": "string",
                        "description": "The Gitlab key id for the pre-existing deploy key\n",
                        "willReplaceOnChanges": true
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project to add the deploy key to.\n",
                        "willReplaceOnChanges": true
                    },
                    "title": {
                        "type": "string",
                        "description": "Deploy key's title.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/deployToken:DeployToken": {
            "description": "The `gitlab.DeployToken` resource allows to manage the lifecycle of group and project deploy tokens.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/deploy_tokens.html)\n\n\n## Import\n\nGitLab deploy tokens can be imported using an id made up of `{type}:{type_id}:{deploy_token_id}`, where type is one ofproject, group.\n\n```sh\n $ pulumi import gitlab:index/deployToken:DeployToken group_token group:1:3\n```\n\n\n\n```sh\n $ pulumi import gitlab:index/deployToken:DeployToken project_token project:1:4\n```\n\n Notethe `token` resource attribute is not available for imported resources as this information cannot be read from the GitLab API. ",
            "properties": {
                "expiresAt": {
                    "type": "string",
                    "description": "Time the token will expire it, RFC3339 format. Will not expire per default.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The name or id of the group to add the deploy token to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A name to describe the deploy token with.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the deploy token to.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Valid values: `read_repository`, `read_registry`, `read_package_registry`, `write_registry`, `write_package_registry`.\n"
                },
                "token": {
                    "type": "string",
                    "description": "The secret token. This is only populated when creating a new deploy token. **Note**: The token is not available for imported resources.\n",
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "A username for the deploy token. Default is `gitlab+deploy-token-{n}`.\n"
                }
            },
            "required": [
                "name",
                "scopes",
                "token",
                "username"
            ],
            "inputProperties": {
                "expiresAt": {
                    "type": "string",
                    "description": "Time the token will expire it, RFC3339 format. Will not expire per default.\n",
                    "willReplaceOnChanges": true
                },
                "group": {
                    "type": "string",
                    "description": "The name or id of the group to add the deploy token to.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "A name to describe the deploy token with.\n",
                    "willReplaceOnChanges": true
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the deploy token to.\n",
                    "willReplaceOnChanges": true
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Valid values: `read_repository`, `read_registry`, `read_package_registry`, `write_registry`, `write_package_registry`.\n",
                    "willReplaceOnChanges": true
                },
                "username": {
                    "type": "string",
                    "description": "A username for the deploy token. Default is `gitlab+deploy-token-{n}`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "scopes"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DeployToken resources.\n",
                "properties": {
                    "expiresAt": {
                        "type": "string",
                        "description": "Time the token will expire it, RFC3339 format. Will not expire per default.\n",
                        "willReplaceOnChanges": true
                    },
                    "group": {
                        "type": "string",
                        "description": "The name or id of the group to add the deploy token to.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "A name to describe the deploy token with.\n",
                        "willReplaceOnChanges": true
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project to add the deploy token to.\n",
                        "willReplaceOnChanges": true
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Valid values: `read_repository`, `read_registry`, `read_package_registry`, `write_registry`, `write_package_registry`.\n",
                        "willReplaceOnChanges": true
                    },
                    "token": {
                        "type": "string",
                        "description": "The secret token. This is only populated when creating a new deploy token. **Note**: The token is not available for imported resources.\n",
                        "secret": true
                    },
                    "username": {
                        "type": "string",
                        "description": "A username for the deploy token. Default is `gitlab+deploy-token-{n}`.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/group:Group": {
            "description": "The `gitlab.Group` resource allows to manage the lifecycle of a group.\n\n\u003e On GitLab SaaS, you must use the GitLab UI to create groups without a parent group. You cannot use this provider nor the API to do this.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/groups.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst exampleGroup = new gitlab.Group(\"exampleGroup\", {\n    path: \"example\",\n    description: \"An example group\",\n});\n// Create a project in the example group\nconst exampleProject = new gitlab.Project(\"exampleProject\", {\n    description: \"An example project\",\n    namespaceId: exampleGroup.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample_group = gitlab.Group(\"exampleGroup\",\n    path=\"example\",\n    description=\"An example group\")\n# Create a project in the example group\nexample_project = gitlab.Project(\"exampleProject\",\n    description=\"An example project\",\n    namespace_id=example_group.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleGroup = new GitLab.Group(\"exampleGroup\", new()\n    {\n        Path = \"example\",\n        Description = \"An example group\",\n    });\n\n    // Create a project in the example group\n    var exampleProject = new GitLab.Project(\"exampleProject\", new()\n    {\n        Description = \"An example project\",\n        NamespaceId = exampleGroup.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleGroup, err := gitlab.NewGroup(ctx, \"exampleGroup\", \u0026gitlab.GroupArgs{\n\t\t\tPath:        pulumi.String(\"example\"),\n\t\t\tDescription: pulumi.String(\"An example group\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProject(ctx, \"exampleProject\", \u0026gitlab.ProjectArgs{\n\t\t\tDescription: pulumi.String(\"An example project\"),\n\t\t\tNamespaceId: exampleGroup.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Group;\nimport com.pulumi.gitlab.GroupArgs;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleGroup = new Group(\"exampleGroup\", GroupArgs.builder()        \n            .path(\"example\")\n            .description(\"An example group\")\n            .build());\n\n        var exampleProject = new Project(\"exampleProject\", ProjectArgs.builder()        \n            .description(\"An example project\")\n            .namespaceId(exampleGroup.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleGroup:\n    type: gitlab:Group\n    properties:\n      path: example\n      description: An example group\n  # Create a project in the example group\n  exampleProject:\n    type: gitlab:Project\n    properties:\n      description: An example project\n      namespaceId: ${exampleGroup.id}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import gitlab:index/group:Group You can import a group state using `\u003cresource\u003e \u003cid\u003e`. The\n```\n\n `id` can be whatever the [details of a group][details_of_a_group] api takes for its `:id` value, so for example\n\n```sh\n $ pulumi import gitlab:index/group:Group example example\n```\n\n ",
            "properties": {
                "autoDevopsEnabled": {
                    "type": "boolean",
                    "description": "Defaults to false. Default to Auto DevOps pipeline for all projects within this group.\n"
                },
                "avatar": {
                    "type": "string",
                    "description": "A local path to the avatar image to upload. **Note**: not available for imported resources.\n"
                },
                "avatarHash": {
                    "type": "string",
                    "description": "The hash of the avatar image. Use `filesha256(\"path/to/avatar.png\")` whenever possible. **Note**: this is used to trigger an update of the avatar. If it's not given, but an avatar is given, the avatar will be updated each time.\n"
                },
                "avatarUrl": {
                    "type": "string",
                    "description": "The URL of the avatar image.\n"
                },
                "defaultBranchProtection": {
                    "type": "integer",
                    "description": "Defaults to 2. See https://docs.gitlab.com/ee/api/groups.html#options-for-default*branch*protection\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the group.\n"
                },
                "emailsDisabled": {
                    "type": "boolean",
                    "description": "Defaults to false. Disable email notifications.\n"
                },
                "extraSharedRunnersMinutesLimit": {
                    "type": "integer",
                    "description": "Can be set by administrators only. Additional CI/CD minutes for this group.\n"
                },
                "fullName": {
                    "type": "string",
                    "description": "The full name of the group.\n"
                },
                "fullPath": {
                    "type": "string",
                    "description": "The full path of the group.\n"
                },
                "ipRestrictionRanges": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of IP addresses or subnet masks to restrict group access. Will be concatenated together into a comma separated string. Only allowed on top level groups.\n"
                },
                "lfsEnabled": {
                    "type": "boolean",
                    "description": "Defaults to true. Enable/disable Large File Storage (LFS) for the projects in this group.\n"
                },
                "membershipLock": {
                    "type": "boolean",
                    "description": "Users cannot be added to projects in this group.\n"
                },
                "mentionsDisabled": {
                    "type": "boolean",
                    "description": "Defaults to false. Disable the capability of a group from getting mentioned.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of this group.\n"
                },
                "parentId": {
                    "type": "integer",
                    "description": "Id of the parent group (creates a nested group).\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path of the group.\n"
                },
                "preventForkingOutsideGroup": {
                    "type": "boolean",
                    "description": "Defaults to false. When enabled, users can not fork projects from this group to external namespaces.\n"
                },
                "projectCreationLevel": {
                    "type": "string",
                    "description": "Defaults to maintainer. Determine if developers can create projects in the group.\n"
                },
                "requestAccessEnabled": {
                    "type": "boolean",
                    "description": "Defaults to false. Allow users to request member access.\n"
                },
                "requireTwoFactorAuthentication": {
                    "type": "boolean",
                    "description": "Defaults to false. Require all users in this group to setup Two-factor authentication.\n"
                },
                "runnersToken": {
                    "type": "string",
                    "description": "The group level registration token to use during runner setup.\n",
                    "secret": true
                },
                "shareWithGroupLock": {
                    "type": "boolean",
                    "description": "Defaults to false. Prevent sharing a project with another group within this group.\n"
                },
                "sharedRunnersMinutesLimit": {
                    "type": "integer",
                    "description": "Can be set by administrators only. Maximum number of monthly CI/CD minutes for this group. Can be nil (default; inherit system default), 0 (unlimited), or \u003e 0.\n"
                },
                "subgroupCreationLevel": {
                    "type": "string",
                    "description": "Defaults to owner. Allowed to create subgroups.\n"
                },
                "twoFactorGracePeriod": {
                    "type": "integer",
                    "description": "Defaults to 48. Time before Two-factor authentication is enforced (in hours).\n"
                },
                "visibilityLevel": {
                    "type": "string",
                    "description": "The group's visibility. Can be `private`, `internal`, or `public`.\n"
                },
                "webUrl": {
                    "type": "string",
                    "description": "Web URL of the group.\n"
                }
            },
            "required": [
                "autoDevopsEnabled",
                "avatarHash",
                "avatarUrl",
                "defaultBranchProtection",
                "emailsDisabled",
                "extraSharedRunnersMinutesLimit",
                "fullName",
                "fullPath",
                "lfsEnabled",
                "mentionsDisabled",
                "name",
                "parentId",
                "path",
                "preventForkingOutsideGroup",
                "projectCreationLevel",
                "requestAccessEnabled",
                "requireTwoFactorAuthentication",
                "runnersToken",
                "shareWithGroupLock",
                "sharedRunnersMinutesLimit",
                "subgroupCreationLevel",
                "twoFactorGracePeriod",
                "visibilityLevel",
                "webUrl"
            ],
            "inputProperties": {
                "autoDevopsEnabled": {
                    "type": "boolean",
                    "description": "Defaults to false. Default to Auto DevOps pipeline for all projects within this group.\n"
                },
                "avatar": {
                    "type": "string",
                    "description": "A local path to the avatar image to upload. **Note**: not available for imported resources.\n"
                },
                "avatarHash": {
                    "type": "string",
                    "description": "The hash of the avatar image. Use `filesha256(\"path/to/avatar.png\")` whenever possible. **Note**: this is used to trigger an update of the avatar. If it's not given, but an avatar is given, the avatar will be updated each time.\n"
                },
                "defaultBranchProtection": {
                    "type": "integer",
                    "description": "Defaults to 2. See https://docs.gitlab.com/ee/api/groups.html#options-for-default*branch*protection\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the group.\n"
                },
                "emailsDisabled": {
                    "type": "boolean",
                    "description": "Defaults to false. Disable email notifications.\n"
                },
                "extraSharedRunnersMinutesLimit": {
                    "type": "integer",
                    "description": "Can be set by administrators only. Additional CI/CD minutes for this group.\n"
                },
                "ipRestrictionRanges": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of IP addresses or subnet masks to restrict group access. Will be concatenated together into a comma separated string. Only allowed on top level groups.\n"
                },
                "lfsEnabled": {
                    "type": "boolean",
                    "description": "Defaults to true. Enable/disable Large File Storage (LFS) for the projects in this group.\n"
                },
                "membershipLock": {
                    "type": "boolean",
                    "description": "Users cannot be added to projects in this group.\n"
                },
                "mentionsDisabled": {
                    "type": "boolean",
                    "description": "Defaults to false. Disable the capability of a group from getting mentioned.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of this group.\n"
                },
                "parentId": {
                    "type": "integer",
                    "description": "Id of the parent group (creates a nested group).\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path of the group.\n"
                },
                "preventForkingOutsideGroup": {
                    "type": "boolean",
                    "description": "Defaults to false. When enabled, users can not fork projects from this group to external namespaces.\n"
                },
                "projectCreationLevel": {
                    "type": "string",
                    "description": "Defaults to maintainer. Determine if developers can create projects in the group.\n"
                },
                "requestAccessEnabled": {
                    "type": "boolean",
                    "description": "Defaults to false. Allow users to request member access.\n"
                },
                "requireTwoFactorAuthentication": {
                    "type": "boolean",
                    "description": "Defaults to false. Require all users in this group to setup Two-factor authentication.\n"
                },
                "shareWithGroupLock": {
                    "type": "boolean",
                    "description": "Defaults to false. Prevent sharing a project with another group within this group.\n"
                },
                "sharedRunnersMinutesLimit": {
                    "type": "integer",
                    "description": "Can be set by administrators only. Maximum number of monthly CI/CD minutes for this group. Can be nil (default; inherit system default), 0 (unlimited), or \u003e 0.\n"
                },
                "subgroupCreationLevel": {
                    "type": "string",
                    "description": "Defaults to owner. Allowed to create subgroups.\n"
                },
                "twoFactorGracePeriod": {
                    "type": "integer",
                    "description": "Defaults to 48. Time before Two-factor authentication is enforced (in hours).\n"
                },
                "visibilityLevel": {
                    "type": "string",
                    "description": "The group's visibility. Can be `private`, `internal`, or `public`.\n"
                }
            },
            "requiredInputs": [
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Group resources.\n",
                "properties": {
                    "autoDevopsEnabled": {
                        "type": "boolean",
                        "description": "Defaults to false. Default to Auto DevOps pipeline for all projects within this group.\n"
                    },
                    "avatar": {
                        "type": "string",
                        "description": "A local path to the avatar image to upload. **Note**: not available for imported resources.\n"
                    },
                    "avatarHash": {
                        "type": "string",
                        "description": "The hash of the avatar image. Use `filesha256(\"path/to/avatar.png\")` whenever possible. **Note**: this is used to trigger an update of the avatar. If it's not given, but an avatar is given, the avatar will be updated each time.\n"
                    },
                    "avatarUrl": {
                        "type": "string",
                        "description": "The URL of the avatar image.\n"
                    },
                    "defaultBranchProtection": {
                        "type": "integer",
                        "description": "Defaults to 2. See https://docs.gitlab.com/ee/api/groups.html#options-for-default*branch*protection\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the group.\n"
                    },
                    "emailsDisabled": {
                        "type": "boolean",
                        "description": "Defaults to false. Disable email notifications.\n"
                    },
                    "extraSharedRunnersMinutesLimit": {
                        "type": "integer",
                        "description": "Can be set by administrators only. Additional CI/CD minutes for this group.\n"
                    },
                    "fullName": {
                        "type": "string",
                        "description": "The full name of the group.\n"
                    },
                    "fullPath": {
                        "type": "string",
                        "description": "The full path of the group.\n"
                    },
                    "ipRestrictionRanges": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of IP addresses or subnet masks to restrict group access. Will be concatenated together into a comma separated string. Only allowed on top level groups.\n"
                    },
                    "lfsEnabled": {
                        "type": "boolean",
                        "description": "Defaults to true. Enable/disable Large File Storage (LFS) for the projects in this group.\n"
                    },
                    "membershipLock": {
                        "type": "boolean",
                        "description": "Users cannot be added to projects in this group.\n"
                    },
                    "mentionsDisabled": {
                        "type": "boolean",
                        "description": "Defaults to false. Disable the capability of a group from getting mentioned.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of this group.\n"
                    },
                    "parentId": {
                        "type": "integer",
                        "description": "Id of the parent group (creates a nested group).\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path of the group.\n"
                    },
                    "preventForkingOutsideGroup": {
                        "type": "boolean",
                        "description": "Defaults to false. When enabled, users can not fork projects from this group to external namespaces.\n"
                    },
                    "projectCreationLevel": {
                        "type": "string",
                        "description": "Defaults to maintainer. Determine if developers can create projects in the group.\n"
                    },
                    "requestAccessEnabled": {
                        "type": "boolean",
                        "description": "Defaults to false. Allow users to request member access.\n"
                    },
                    "requireTwoFactorAuthentication": {
                        "type": "boolean",
                        "description": "Defaults to false. Require all users in this group to setup Two-factor authentication.\n"
                    },
                    "runnersToken": {
                        "type": "string",
                        "description": "The group level registration token to use during runner setup.\n",
                        "secret": true
                    },
                    "shareWithGroupLock": {
                        "type": "boolean",
                        "description": "Defaults to false. Prevent sharing a project with another group within this group.\n"
                    },
                    "sharedRunnersMinutesLimit": {
                        "type": "integer",
                        "description": "Can be set by administrators only. Maximum number of monthly CI/CD minutes for this group. Can be nil (default; inherit system default), 0 (unlimited), or \u003e 0.\n"
                    },
                    "subgroupCreationLevel": {
                        "type": "string",
                        "description": "Defaults to owner. Allowed to create subgroups.\n"
                    },
                    "twoFactorGracePeriod": {
                        "type": "integer",
                        "description": "Defaults to 48. Time before Two-factor authentication is enforced (in hours).\n"
                    },
                    "visibilityLevel": {
                        "type": "string",
                        "description": "The group's visibility. Can be `private`, `internal`, or `public`.\n"
                    },
                    "webUrl": {
                        "type": "string",
                        "description": "Web URL of the group.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupAccessToken:GroupAccessToken": {
            "description": "The `gitlab_group_access`token resource allows to manage the lifecycle of a group access token.\n\n\u003e Group Access Token were introduced in GitLab 14.7\n\n**Upstream API**: [GitLab REST API](https://docs.gitlab.com/ee/api/group_access_tokens.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst exampleGroupAccessToken = new gitlab.GroupAccessToken(\"exampleGroupAccessToken\", {\n    group: \"25\",\n    expiresAt: \"2020-03-14\",\n    accessLevel: \"developer\",\n    scopes: [\"api\"],\n});\nconst exampleGroupVariable = new gitlab.GroupVariable(\"exampleGroupVariable\", {\n    group: \"25\",\n    key: \"gat\",\n    value: exampleGroupAccessToken.token,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample_group_access_token = gitlab.GroupAccessToken(\"exampleGroupAccessToken\",\n    group=\"25\",\n    expires_at=\"2020-03-14\",\n    access_level=\"developer\",\n    scopes=[\"api\"])\nexample_group_variable = gitlab.GroupVariable(\"exampleGroupVariable\",\n    group=\"25\",\n    key=\"gat\",\n    value=example_group_access_token.token)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleGroupAccessToken = new GitLab.GroupAccessToken(\"exampleGroupAccessToken\", new()\n    {\n        Group = \"25\",\n        ExpiresAt = \"2020-03-14\",\n        AccessLevel = \"developer\",\n        Scopes = new[]\n        {\n            \"api\",\n        },\n    });\n\n    var exampleGroupVariable = new GitLab.GroupVariable(\"exampleGroupVariable\", new()\n    {\n        Group = \"25\",\n        Key = \"gat\",\n        Value = exampleGroupAccessToken.Token,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleGroupAccessToken, err := gitlab.NewGroupAccessToken(ctx, \"exampleGroupAccessToken\", \u0026gitlab.GroupAccessTokenArgs{\n\t\t\tGroup:       pulumi.String(\"25\"),\n\t\t\tExpiresAt:   pulumi.String(\"2020-03-14\"),\n\t\t\tAccessLevel: pulumi.String(\"developer\"),\n\t\t\tScopes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"api\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewGroupVariable(ctx, \"exampleGroupVariable\", \u0026gitlab.GroupVariableArgs{\n\t\t\tGroup: pulumi.String(\"25\"),\n\t\t\tKey:   pulumi.String(\"gat\"),\n\t\t\tValue: exampleGroupAccessToken.Token,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GroupAccessToken;\nimport com.pulumi.gitlab.GroupAccessTokenArgs;\nimport com.pulumi.gitlab.GroupVariable;\nimport com.pulumi.gitlab.GroupVariableArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleGroupAccessToken = new GroupAccessToken(\"exampleGroupAccessToken\", GroupAccessTokenArgs.builder()        \n            .group(\"25\")\n            .expiresAt(\"2020-03-14\")\n            .accessLevel(\"developer\")\n            .scopes(\"api\")\n            .build());\n\n        var exampleGroupVariable = new GroupVariable(\"exampleGroupVariable\", GroupVariableArgs.builder()        \n            .group(\"25\")\n            .key(\"gat\")\n            .value(exampleGroupAccessToken.token())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleGroupAccessToken:\n    type: gitlab:GroupAccessToken\n    properties:\n      group: '25'\n      expiresAt: 2020-03-14\n      accessLevel: developer\n      scopes:\n        - api\n  exampleGroupVariable:\n    type: gitlab:GroupVariable\n    properties:\n      group: '25'\n      key: gat\n      value: ${exampleGroupAccessToken.token}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nA GitLab Group Access Token can be imported using a key composed of `\u003cgroup-id\u003e:\u003ctoken-id\u003e`, e.g.\n\n```sh\n $ pulumi import gitlab:index/groupAccessToken:GroupAccessToken example \"12345:1\"\n```\n\n ATTENTIONthe `token` resource attribute is not available for imported resources as this information cannot be read from the GitLab API. ",
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "The access level for the group access token. Valid values are: `guest`, `reporter`, `developer`, `maintainer`, `owner`.\n"
                },
                "active": {
                    "type": "boolean",
                    "description": "True if the token is active.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Time the token has been created, RFC3339 format.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "The token expires at midnight UTC on that date. The date must be in the format YYYY-MM-DD. Default is never.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The ID or path of the group to add the group access token to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the group access token.\n"
                },
                "revoked": {
                    "type": "boolean",
                    "description": "True if the token is revoked.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The scope for the group access token. It determines the actions which can be performed when authenticating with this token. Valid values are: `api`, `read_api`, `read_registry`, `write_registry`, `read_repository`, `write_repository`.\n"
                },
                "token": {
                    "type": "string",
                    "description": "The group access token. This is only populated when creating a new group access token. This attribute is not available for imported resources.\n",
                    "secret": true
                },
                "userId": {
                    "type": "integer",
                    "description": "The user id associated to the token.\n"
                }
            },
            "required": [
                "active",
                "createdAt",
                "group",
                "name",
                "revoked",
                "scopes",
                "token",
                "userId"
            ],
            "inputProperties": {
                "accessLevel": {
                    "type": "string",
                    "description": "The access level for the group access token. Valid values are: `guest`, `reporter`, `developer`, `maintainer`, `owner`.\n",
                    "willReplaceOnChanges": true
                },
                "expiresAt": {
                    "type": "string",
                    "description": "The token expires at midnight UTC on that date. The date must be in the format YYYY-MM-DD. Default is never.\n",
                    "willReplaceOnChanges": true
                },
                "group": {
                    "type": "string",
                    "description": "The ID or path of the group to add the group access token to.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the group access token.\n",
                    "willReplaceOnChanges": true
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The scope for the group access token. It determines the actions which can be performed when authenticating with this token. Valid values are: `api`, `read_api`, `read_registry`, `write_registry`, `read_repository`, `write_repository`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "group",
                "scopes"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupAccessToken resources.\n",
                "properties": {
                    "accessLevel": {
                        "type": "string",
                        "description": "The access level for the group access token. Valid values are: `guest`, `reporter`, `developer`, `maintainer`, `owner`.\n",
                        "willReplaceOnChanges": true
                    },
                    "active": {
                        "type": "boolean",
                        "description": "True if the token is active.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Time the token has been created, RFC3339 format.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "The token expires at midnight UTC on that date. The date must be in the format YYYY-MM-DD. Default is never.\n",
                        "willReplaceOnChanges": true
                    },
                    "group": {
                        "type": "string",
                        "description": "The ID or path of the group to add the group access token to.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the group access token.\n",
                        "willReplaceOnChanges": true
                    },
                    "revoked": {
                        "type": "boolean",
                        "description": "True if the token is revoked.\n"
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The scope for the group access token. It determines the actions which can be performed when authenticating with this token. Valid values are: `api`, `read_api`, `read_registry`, `write_registry`, `read_repository`, `write_repository`.\n",
                        "willReplaceOnChanges": true
                    },
                    "token": {
                        "type": "string",
                        "description": "The group access token. This is only populated when creating a new group access token. This attribute is not available for imported resources.\n",
                        "secret": true
                    },
                    "userId": {
                        "type": "integer",
                        "description": "The user id associated to the token.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupBadge:GroupBadge": {
            "description": "The `gitlab.GroupBadge` resource allows to mange the lifecycle of group badges.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/user/project/badges.html#group-badges)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = new gitlab.Group(\"foo\", {});\nconst example = new gitlab.GroupBadge(\"example\", {\n    group: foo.id,\n    linkUrl: \"https://example.com/badge-123\",\n    imageUrl: \"https://example.com/badge-123.svg\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.Group(\"foo\")\nexample = gitlab.GroupBadge(\"example\",\n    group=foo.id,\n    link_url=\"https://example.com/badge-123\",\n    image_url=\"https://example.com/badge-123.svg\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = new GitLab.Group(\"foo\");\n\n    var example = new GitLab.GroupBadge(\"example\", new()\n    {\n        Group = foo.Id,\n        LinkUrl = \"https://example.com/badge-123\",\n        ImageUrl = \"https://example.com/badge-123.svg\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfoo, err := gitlab.NewGroup(ctx, \"foo\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewGroupBadge(ctx, \"example\", \u0026gitlab.GroupBadgeArgs{\n\t\t\tGroup:    foo.ID(),\n\t\t\tLinkUrl:  pulumi.String(\"https://example.com/badge-123\"),\n\t\t\tImageUrl: pulumi.String(\"https://example.com/badge-123.svg\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Group;\nimport com.pulumi.gitlab.GroupBadge;\nimport com.pulumi.gitlab.GroupBadgeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var foo = new Group(\"foo\");\n\n        var example = new GroupBadge(\"example\", GroupBadgeArgs.builder()        \n            .group(foo.id())\n            .linkUrl(\"https://example.com/badge-123\")\n            .imageUrl(\"https://example.com/badge-123.svg\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  foo:\n    type: gitlab:Group\n  example:\n    type: gitlab:GroupBadge\n    properties:\n      group: ${foo.id}\n      linkUrl: https://example.com/badge-123\n      imageUrl: https://example.com/badge-123.svg\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitLab group badges can be imported using an id made up of `{group_id}:{badge_id}`, e.g.\n\n```sh\n $ pulumi import gitlab:index/groupBadge:GroupBadge foo 1:3\n```\n\n ",
            "properties": {
                "group": {
                    "type": "string",
                    "description": "The id of the group to add the badge to.\n"
                },
                "imageUrl": {
                    "type": "string",
                    "description": "The image url which will be presented on group overview.\n"
                },
                "linkUrl": {
                    "type": "string",
                    "description": "The url linked with the badge.\n"
                },
                "renderedImageUrl": {
                    "type": "string",
                    "description": "The image_url argument rendered (in case of use of placeholders).\n"
                },
                "renderedLinkUrl": {
                    "type": "string",
                    "description": "The link_url argument rendered (in case of use of placeholders).\n"
                }
            },
            "required": [
                "group",
                "imageUrl",
                "linkUrl",
                "renderedImageUrl",
                "renderedLinkUrl"
            ],
            "inputProperties": {
                "group": {
                    "type": "string",
                    "description": "The id of the group to add the badge to.\n"
                },
                "imageUrl": {
                    "type": "string",
                    "description": "The image url which will be presented on group overview.\n"
                },
                "linkUrl": {
                    "type": "string",
                    "description": "The url linked with the badge.\n"
                }
            },
            "requiredInputs": [
                "group",
                "imageUrl",
                "linkUrl"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupBadge resources.\n",
                "properties": {
                    "group": {
                        "type": "string",
                        "description": "The id of the group to add the badge to.\n"
                    },
                    "imageUrl": {
                        "type": "string",
                        "description": "The image url which will be presented on group overview.\n"
                    },
                    "linkUrl": {
                        "type": "string",
                        "description": "The url linked with the badge.\n"
                    },
                    "renderedImageUrl": {
                        "type": "string",
                        "description": "The image_url argument rendered (in case of use of placeholders).\n"
                    },
                    "renderedLinkUrl": {
                        "type": "string",
                        "description": "The link_url argument rendered (in case of use of placeholders).\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupCluster:GroupCluster": {
            "description": "The `gitlab.GroupCluster` resource allows to manage the lifecycle of a group cluster.\n\n\u003e This is deprecated GitLab feature since 14.5\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/group_clusters.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = new gitlab.Group(\"foo\", {path: \"foo-path\"});\nconst bar = new gitlab.GroupCluster(\"bar\", {\n    group: foo.id,\n    domain: \"example.com\",\n    enabled: true,\n    kubernetesApiUrl: \"https://124.124.124\",\n    kubernetesToken: \"some-token\",\n    kubernetesCaCert: \"some-cert\",\n    kubernetesAuthorizationType: \"rbac\",\n    environmentScope: \"*\",\n    managementProjectId: \"123456\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.Group(\"foo\", path=\"foo-path\")\nbar = gitlab.GroupCluster(\"bar\",\n    group=foo.id,\n    domain=\"example.com\",\n    enabled=True,\n    kubernetes_api_url=\"https://124.124.124\",\n    kubernetes_token=\"some-token\",\n    kubernetes_ca_cert=\"some-cert\",\n    kubernetes_authorization_type=\"rbac\",\n    environment_scope=\"*\",\n    management_project_id=\"123456\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = new GitLab.Group(\"foo\", new()\n    {\n        Path = \"foo-path\",\n    });\n\n    var bar = new GitLab.GroupCluster(\"bar\", new()\n    {\n        Group = foo.Id,\n        Domain = \"example.com\",\n        Enabled = true,\n        KubernetesApiUrl = \"https://124.124.124\",\n        KubernetesToken = \"some-token\",\n        KubernetesCaCert = \"some-cert\",\n        KubernetesAuthorizationType = \"rbac\",\n        EnvironmentScope = \"*\",\n        ManagementProjectId = \"123456\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfoo, err := gitlab.NewGroup(ctx, \"foo\", \u0026gitlab.GroupArgs{\n\t\t\tPath: pulumi.String(\"foo-path\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewGroupCluster(ctx, \"bar\", \u0026gitlab.GroupClusterArgs{\n\t\t\tGroup:                       foo.ID(),\n\t\t\tDomain:                      pulumi.String(\"example.com\"),\n\t\t\tEnabled:                     pulumi.Bool(true),\n\t\t\tKubernetesApiUrl:            pulumi.String(\"https://124.124.124\"),\n\t\t\tKubernetesToken:             pulumi.String(\"some-token\"),\n\t\t\tKubernetesCaCert:            pulumi.String(\"some-cert\"),\n\t\t\tKubernetesAuthorizationType: pulumi.String(\"rbac\"),\n\t\t\tEnvironmentScope:            pulumi.String(\"*\"),\n\t\t\tManagementProjectId:         pulumi.String(\"123456\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Group;\nimport com.pulumi.gitlab.GroupArgs;\nimport com.pulumi.gitlab.GroupCluster;\nimport com.pulumi.gitlab.GroupClusterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var foo = new Group(\"foo\", GroupArgs.builder()        \n            .path(\"foo-path\")\n            .build());\n\n        var bar = new GroupCluster(\"bar\", GroupClusterArgs.builder()        \n            .group(foo.id())\n            .domain(\"example.com\")\n            .enabled(true)\n            .kubernetesApiUrl(\"https://124.124.124\")\n            .kubernetesToken(\"some-token\")\n            .kubernetesCaCert(\"some-cert\")\n            .kubernetesAuthorizationType(\"rbac\")\n            .environmentScope(\"*\")\n            .managementProjectId(\"123456\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  foo:\n    type: gitlab:Group\n    properties:\n      path: foo-path\n  bar:\n    type: gitlab:GroupCluster\n    properties:\n      group: ${foo.id}\n      domain: example.com\n      enabled: true\n      kubernetesApiUrl: https://124.124.124\n      kubernetesToken: some-token\n      kubernetesCaCert: some-cert\n      kubernetesAuthorizationType: rbac\n      environmentScope: '*'\n      managementProjectId: '123456'\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitLab group clusters can be imported using an id made up of `groupid:clusterid`, e.g.\n\n```sh\n $ pulumi import gitlab:index/groupCluster:GroupCluster bar 123:321\n```\n\n ",
            "properties": {
                "clusterType": {
                    "type": "string",
                    "description": "Cluster type.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Create time.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The base domain of the cluster.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Determines if cluster is active or not. Defaults to `true`. This attribute cannot be read.\n"
                },
                "environmentScope": {
                    "type": "string",
                    "description": "The associated environment to the cluster. Defaults to `*`.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The id of the group to add the cluster to.\n"
                },
                "kubernetesApiUrl": {
                    "type": "string",
                    "description": "The URL to access the Kubernetes API.\n"
                },
                "kubernetesAuthorizationType": {
                    "type": "string",
                    "description": "The cluster authorization type. Valid values are `rbac`, `abac`, `unknown_authorization`. Defaults to `rbac`.\n"
                },
                "kubernetesCaCert": {
                    "type": "string",
                    "description": "TLS certificate (needed if API is using a self-signed TLS certificate).\n"
                },
                "kubernetesToken": {
                    "type": "string",
                    "description": "The token to authenticate against Kubernetes.\n",
                    "secret": true
                },
                "managed": {
                    "type": "boolean",
                    "description": "Determines if cluster is managed by gitlab or not. Defaults to `true`. This attribute cannot be read.\n"
                },
                "managementProjectId": {
                    "type": "string",
                    "description": "The ID of the management project for the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of cluster.\n"
                },
                "platformType": {
                    "type": "string",
                    "description": "Platform type.\n"
                },
                "providerType": {
                    "type": "string",
                    "description": "Provider type.\n"
                }
            },
            "required": [
                "clusterType",
                "createdAt",
                "group",
                "kubernetesApiUrl",
                "kubernetesToken",
                "name",
                "platformType",
                "providerType"
            ],
            "inputProperties": {
                "domain": {
                    "type": "string",
                    "description": "The base domain of the cluster.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Determines if cluster is active or not. Defaults to `true`. This attribute cannot be read.\n",
                    "willReplaceOnChanges": true
                },
                "environmentScope": {
                    "type": "string",
                    "description": "The associated environment to the cluster. Defaults to `*`.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The id of the group to add the cluster to.\n",
                    "willReplaceOnChanges": true
                },
                "kubernetesApiUrl": {
                    "type": "string",
                    "description": "The URL to access the Kubernetes API.\n"
                },
                "kubernetesAuthorizationType": {
                    "type": "string",
                    "description": "The cluster authorization type. Valid values are `rbac`, `abac`, `unknown_authorization`. Defaults to `rbac`.\n",
                    "willReplaceOnChanges": true
                },
                "kubernetesCaCert": {
                    "type": "string",
                    "description": "TLS certificate (needed if API is using a self-signed TLS certificate).\n"
                },
                "kubernetesToken": {
                    "type": "string",
                    "description": "The token to authenticate against Kubernetes.\n",
                    "secret": true
                },
                "managed": {
                    "type": "boolean",
                    "description": "Determines if cluster is managed by gitlab or not. Defaults to `true`. This attribute cannot be read.\n",
                    "willReplaceOnChanges": true
                },
                "managementProjectId": {
                    "type": "string",
                    "description": "The ID of the management project for the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of cluster.\n"
                }
            },
            "requiredInputs": [
                "group",
                "kubernetesApiUrl",
                "kubernetesToken"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupCluster resources.\n",
                "properties": {
                    "clusterType": {
                        "type": "string",
                        "description": "Cluster type.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Create time.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The base domain of the cluster.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Determines if cluster is active or not. Defaults to `true`. This attribute cannot be read.\n",
                        "willReplaceOnChanges": true
                    },
                    "environmentScope": {
                        "type": "string",
                        "description": "The associated environment to the cluster. Defaults to `*`.\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "The id of the group to add the cluster to.\n",
                        "willReplaceOnChanges": true
                    },
                    "kubernetesApiUrl": {
                        "type": "string",
                        "description": "The URL to access the Kubernetes API.\n"
                    },
                    "kubernetesAuthorizationType": {
                        "type": "string",
                        "description": "The cluster authorization type. Valid values are `rbac`, `abac`, `unknown_authorization`. Defaults to `rbac`.\n",
                        "willReplaceOnChanges": true
                    },
                    "kubernetesCaCert": {
                        "type": "string",
                        "description": "TLS certificate (needed if API is using a self-signed TLS certificate).\n"
                    },
                    "kubernetesToken": {
                        "type": "string",
                        "description": "The token to authenticate against Kubernetes.\n",
                        "secret": true
                    },
                    "managed": {
                        "type": "boolean",
                        "description": "Determines if cluster is managed by gitlab or not. Defaults to `true`. This attribute cannot be read.\n",
                        "willReplaceOnChanges": true
                    },
                    "managementProjectId": {
                        "type": "string",
                        "description": "The ID of the management project for the cluster.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of cluster.\n"
                    },
                    "platformType": {
                        "type": "string",
                        "description": "Platform type.\n"
                    },
                    "providerType": {
                        "type": "string",
                        "description": "Provider type.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupCustomAttribute:GroupCustomAttribute": {
            "description": "The `gitlab.GroupCustomAttribute` resource allows to manage custom attributes for a group.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/custom_attributes.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst attr = new gitlab.GroupCustomAttribute(\"attr\", {\n    group: 42,\n    key: \"location\",\n    value: \"Greenland\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nattr = gitlab.GroupCustomAttribute(\"attr\",\n    group=42,\n    key=\"location\",\n    value=\"Greenland\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var attr = new GitLab.GroupCustomAttribute(\"attr\", new()\n    {\n        Group = 42,\n        Key = \"location\",\n        Value = \"Greenland\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewGroupCustomAttribute(ctx, \"attr\", \u0026gitlab.GroupCustomAttributeArgs{\n\t\t\tGroup: pulumi.Int(42),\n\t\t\tKey:   pulumi.String(\"location\"),\n\t\t\tValue: pulumi.String(\"Greenland\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GroupCustomAttribute;\nimport com.pulumi.gitlab.GroupCustomAttributeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var attr = new GroupCustomAttribute(\"attr\", GroupCustomAttributeArgs.builder()        \n            .group(\"42\")\n            .key(\"location\")\n            .value(\"Greenland\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  attr:\n    type: gitlab:GroupCustomAttribute\n    properties:\n      group: '42'\n      key: location\n      value: Greenland\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nYou can import a group custom attribute using the an id made up of `{group-id}:{key}`, e.g.\n\n```sh\n $ pulumi import gitlab:index/groupCustomAttribute:GroupCustomAttribute attr 42:location\n```\n\n ",
            "properties": {
                "group": {
                    "type": "integer",
                    "description": "The id of the group.\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key for the Custom Attribute.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value for the Custom Attribute.\n"
                }
            },
            "required": [
                "group",
                "key",
                "value"
            ],
            "inputProperties": {
                "group": {
                    "type": "integer",
                    "description": "The id of the group.\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key for the Custom Attribute.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value for the Custom Attribute.\n"
                }
            },
            "requiredInputs": [
                "group",
                "key",
                "value"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupCustomAttribute resources.\n",
                "properties": {
                    "group": {
                        "type": "integer",
                        "description": "The id of the group.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "Key for the Custom Attribute.\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "Value for the Custom Attribute.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupHook:GroupHook": {
            "description": "The `gitlab.GroupHook` resource allows to manage the lifecycle of a group hook.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/groups.html#hooks)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = new gitlab.GroupHook(\"example\", {\n    group: \"example/hooked\",\n    mergeRequestsEvents: true,\n    url: \"https://example.com/hook/example\",\n});\n// Setting all attributes\nconst allAttributes = new gitlab.GroupHook(\"allAttributes\", {\n    confidentialIssuesEvents: false,\n    confidentialNoteEvents: true,\n    deploymentEvents: true,\n    enableSslVerification: false,\n    group: \"1\",\n    issuesEvents: false,\n    jobEvents: true,\n    mergeRequestsEvents: true,\n    noteEvents: true,\n    pipelineEvents: true,\n    pushEvents: true,\n    pushEventsBranchFilter: \"devel\",\n    releasesEvents: true,\n    subgroupEvents: true,\n    tagPushEvents: true,\n    token: \"supersecret\",\n    url: \"http://example.com\",\n    wikiPageEvents: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.GroupHook(\"example\",\n    group=\"example/hooked\",\n    merge_requests_events=True,\n    url=\"https://example.com/hook/example\")\n# Setting all attributes\nall_attributes = gitlab.GroupHook(\"allAttributes\",\n    confidential_issues_events=False,\n    confidential_note_events=True,\n    deployment_events=True,\n    enable_ssl_verification=False,\n    group=\"1\",\n    issues_events=False,\n    job_events=True,\n    merge_requests_events=True,\n    note_events=True,\n    pipeline_events=True,\n    push_events=True,\n    push_events_branch_filter=\"devel\",\n    releases_events=True,\n    subgroup_events=True,\n    tag_push_events=True,\n    token=\"supersecret\",\n    url=\"http://example.com\",\n    wiki_page_events=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new GitLab.GroupHook(\"example\", new()\n    {\n        Group = \"example/hooked\",\n        MergeRequestsEvents = true,\n        Url = \"https://example.com/hook/example\",\n    });\n\n    // Setting all attributes\n    var allAttributes = new GitLab.GroupHook(\"allAttributes\", new()\n    {\n        ConfidentialIssuesEvents = false,\n        ConfidentialNoteEvents = true,\n        DeploymentEvents = true,\n        EnableSslVerification = false,\n        Group = \"1\",\n        IssuesEvents = false,\n        JobEvents = true,\n        MergeRequestsEvents = true,\n        NoteEvents = true,\n        PipelineEvents = true,\n        PushEvents = true,\n        PushEventsBranchFilter = \"devel\",\n        ReleasesEvents = true,\n        SubgroupEvents = true,\n        TagPushEvents = true,\n        Token = \"supersecret\",\n        Url = \"http://example.com\",\n        WikiPageEvents = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewGroupHook(ctx, \"example\", \u0026gitlab.GroupHookArgs{\n\t\t\tGroup:               pulumi.String(\"example/hooked\"),\n\t\t\tMergeRequestsEvents: pulumi.Bool(true),\n\t\t\tUrl:                 pulumi.String(\"https://example.com/hook/example\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewGroupHook(ctx, \"allAttributes\", \u0026gitlab.GroupHookArgs{\n\t\t\tConfidentialIssuesEvents: pulumi.Bool(false),\n\t\t\tConfidentialNoteEvents:   pulumi.Bool(true),\n\t\t\tDeploymentEvents:         pulumi.Bool(true),\n\t\t\tEnableSslVerification:    pulumi.Bool(false),\n\t\t\tGroup:                    pulumi.String(\"1\"),\n\t\t\tIssuesEvents:             pulumi.Bool(false),\n\t\t\tJobEvents:                pulumi.Bool(true),\n\t\t\tMergeRequestsEvents:      pulumi.Bool(true),\n\t\t\tNoteEvents:               pulumi.Bool(true),\n\t\t\tPipelineEvents:           pulumi.Bool(true),\n\t\t\tPushEvents:               pulumi.Bool(true),\n\t\t\tPushEventsBranchFilter:   pulumi.String(\"devel\"),\n\t\t\tReleasesEvents:           pulumi.Bool(true),\n\t\t\tSubgroupEvents:           pulumi.Bool(true),\n\t\t\tTagPushEvents:            pulumi.Bool(true),\n\t\t\tToken:                    pulumi.String(\"supersecret\"),\n\t\t\tUrl:                      pulumi.String(\"http://example.com\"),\n\t\t\tWikiPageEvents:           pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GroupHook;\nimport com.pulumi.gitlab.GroupHookArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new GroupHook(\"example\", GroupHookArgs.builder()        \n            .group(\"example/hooked\")\n            .mergeRequestsEvents(true)\n            .url(\"https://example.com/hook/example\")\n            .build());\n\n        var allAttributes = new GroupHook(\"allAttributes\", GroupHookArgs.builder()        \n            .confidentialIssuesEvents(false)\n            .confidentialNoteEvents(true)\n            .deploymentEvents(true)\n            .enableSslVerification(false)\n            .group(1)\n            .issuesEvents(false)\n            .jobEvents(true)\n            .mergeRequestsEvents(true)\n            .noteEvents(true)\n            .pipelineEvents(true)\n            .pushEvents(true)\n            .pushEventsBranchFilter(\"devel\")\n            .releasesEvents(true)\n            .subgroupEvents(true)\n            .tagPushEvents(true)\n            .token(\"supersecret\")\n            .url(\"http://example.com\")\n            .wikiPageEvents(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: gitlab:GroupHook\n    properties:\n      group: example/hooked\n      mergeRequestsEvents: true\n      url: https://example.com/hook/example\n  # Setting all attributes\n  allAttributes:\n    type: gitlab:GroupHook\n    properties:\n      confidentialIssuesEvents: false\n      confidentialNoteEvents: true\n      deploymentEvents: true\n      enableSslVerification: false\n      group: 1\n      issuesEvents: false\n      jobEvents: true\n      mergeRequestsEvents: true\n      noteEvents: true\n      pipelineEvents: true\n      pushEvents: true\n      pushEventsBranchFilter: devel\n      releasesEvents: true\n      subgroupEvents: true\n      tagPushEvents: true\n      token: supersecret\n      url: http://example.com\n      wikiPageEvents: true\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nA GitLab Group Hook can be imported using a key composed of `\u003cgroup-id\u003e:\u003chook-id\u003e`, e.g.\n\n```sh\n $ pulumi import gitlab:index/groupHook:GroupHook example \"12345:1\"\n```\n\n NOTEthe `token` resource attribute is not available for imported resources as this information cannot be read from the GitLab API. ",
            "properties": {
                "confidentialIssuesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for confidential issues events.\n"
                },
                "confidentialNoteEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for confidential notes events.\n"
                },
                "deploymentEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for deployment events.\n"
                },
                "enableSslVerification": {
                    "type": "boolean",
                    "description": "Enable ssl verification when invoking the hook.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The ID or full path of the group.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The id of the group for the hook.\n"
                },
                "hookId": {
                    "type": "integer",
                    "description": "The id of the group hook.\n"
                },
                "issuesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for issues events.\n"
                },
                "jobEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for job events.\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for merge requests.\n"
                },
                "noteEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for notes events.\n"
                },
                "pipelineEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for pipeline events.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for push events.\n"
                },
                "pushEventsBranchFilter": {
                    "type": "string",
                    "description": "Invoke the hook for push events on matching branches only.\n"
                },
                "releasesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for releases events.\n"
                },
                "subgroupEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for subgroup events.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for tag push events.\n"
                },
                "token": {
                    "type": "string",
                    "description": "A token to present when invoking the hook. The token is not available for imported resources.\n",
                    "secret": true
                },
                "url": {
                    "type": "string",
                    "description": "The url of the hook to invoke.\n"
                },
                "wikiPageEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for wiki page events.\n"
                }
            },
            "required": [
                "group",
                "groupId",
                "hookId",
                "url"
            ],
            "inputProperties": {
                "confidentialIssuesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for confidential issues events.\n"
                },
                "confidentialNoteEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for confidential notes events.\n"
                },
                "deploymentEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for deployment events.\n"
                },
                "enableSslVerification": {
                    "type": "boolean",
                    "description": "Enable ssl verification when invoking the hook.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The ID or full path of the group.\n"
                },
                "issuesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for issues events.\n"
                },
                "jobEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for job events.\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for merge requests.\n"
                },
                "noteEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for notes events.\n"
                },
                "pipelineEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for pipeline events.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for push events.\n"
                },
                "pushEventsBranchFilter": {
                    "type": "string",
                    "description": "Invoke the hook for push events on matching branches only.\n"
                },
                "releasesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for releases events.\n"
                },
                "subgroupEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for subgroup events.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for tag push events.\n"
                },
                "token": {
                    "type": "string",
                    "description": "A token to present when invoking the hook. The token is not available for imported resources.\n",
                    "secret": true
                },
                "url": {
                    "type": "string",
                    "description": "The url of the hook to invoke.\n"
                },
                "wikiPageEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for wiki page events.\n"
                }
            },
            "requiredInputs": [
                "group",
                "url"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupHook resources.\n",
                "properties": {
                    "confidentialIssuesEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for confidential issues events.\n"
                    },
                    "confidentialNoteEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for confidential notes events.\n"
                    },
                    "deploymentEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for deployment events.\n"
                    },
                    "enableSslVerification": {
                        "type": "boolean",
                        "description": "Enable ssl verification when invoking the hook.\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "The ID or full path of the group.\n"
                    },
                    "groupId": {
                        "type": "integer",
                        "description": "The id of the group for the hook.\n"
                    },
                    "hookId": {
                        "type": "integer",
                        "description": "The id of the group hook.\n"
                    },
                    "issuesEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for issues events.\n"
                    },
                    "jobEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for job events.\n"
                    },
                    "mergeRequestsEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for merge requests.\n"
                    },
                    "noteEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for notes events.\n"
                    },
                    "pipelineEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for pipeline events.\n"
                    },
                    "pushEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for push events.\n"
                    },
                    "pushEventsBranchFilter": {
                        "type": "string",
                        "description": "Invoke the hook for push events on matching branches only.\n"
                    },
                    "releasesEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for releases events.\n"
                    },
                    "subgroupEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for subgroup events.\n"
                    },
                    "tagPushEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for tag push events.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "A token to present when invoking the hook. The token is not available for imported resources.\n",
                        "secret": true
                    },
                    "url": {
                        "type": "string",
                        "description": "The url of the hook to invoke.\n"
                    },
                    "wikiPageEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for wiki page events.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupLabel:GroupLabel": {
            "description": "The `gitlab.GroupLabel` resource allows to manage the lifecycle of labels within a group.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/user/project/labels.html#group-labels)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst fixme = new gitlab.GroupLabel(\"fixme\", {\n    color: \"#ffcc00\",\n    description: \"issue with failing tests\",\n    group: \"example\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfixme = gitlab.GroupLabel(\"fixme\",\n    color=\"#ffcc00\",\n    description=\"issue with failing tests\",\n    group=\"example\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var fixme = new GitLab.GroupLabel(\"fixme\", new()\n    {\n        Color = \"#ffcc00\",\n        Description = \"issue with failing tests\",\n        Group = \"example\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewGroupLabel(ctx, \"fixme\", \u0026gitlab.GroupLabelArgs{\n\t\t\tColor:       pulumi.String(\"#ffcc00\"),\n\t\t\tDescription: pulumi.String(\"issue with failing tests\"),\n\t\t\tGroup:       pulumi.String(\"example\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GroupLabel;\nimport com.pulumi.gitlab.GroupLabelArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var fixme = new GroupLabel(\"fixme\", GroupLabelArgs.builder()        \n            .color(\"#ffcc00\")\n            .description(\"issue with failing tests\")\n            .group(\"example\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  fixme:\n    type: gitlab:GroupLabel\n    properties:\n      color: '#ffcc00'\n      description: issue with failing tests\n      group: example\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitlab group labels can be imported using an id made up of `{group_id}:{group_label_id}`, e.g.\n\n```sh\n $ pulumi import gitlab:index/groupLabel:GroupLabel example 12345:fixme\n```\n\n ",
            "properties": {
                "color": {
                    "type": "string",
                    "description": "The color of the label given in 6-digit hex notation with leading '#' sign (e.g. #FFAABB) or one of the [CSS color names](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords).\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the label.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The name or id of the group to add the label to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the label.\n"
                }
            },
            "required": [
                "color",
                "group",
                "name"
            ],
            "inputProperties": {
                "color": {
                    "type": "string",
                    "description": "The color of the label given in 6-digit hex notation with leading '#' sign (e.g. #FFAABB) or one of the [CSS color names](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords).\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the label.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The name or id of the group to add the label to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the label.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "color",
                "group"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupLabel resources.\n",
                "properties": {
                    "color": {
                        "type": "string",
                        "description": "The color of the label given in 6-digit hex notation with leading '#' sign (e.g. #FFAABB) or one of the [CSS color names](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords).\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the label.\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "The name or id of the group to add the label to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the label.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupLdapLink:GroupLdapLink": {
            "description": "The `gitlab.GroupLdapLink` resource allows to manage the lifecycle of an LDAP integration with a group.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/groups.html#ldap-group-links)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst test = new gitlab.GroupLdapLink(\"test\", {\n    cn: \"testuser\",\n    groupAccess: \"developer\",\n    groupId: \"12345\",\n    ldapProvider: \"ldapmain\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\ntest = gitlab.GroupLdapLink(\"test\",\n    cn=\"testuser\",\n    group_access=\"developer\",\n    group_id=\"12345\",\n    ldap_provider=\"ldapmain\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new GitLab.GroupLdapLink(\"test\", new()\n    {\n        Cn = \"testuser\",\n        GroupAccess = \"developer\",\n        GroupId = \"12345\",\n        LdapProvider = \"ldapmain\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewGroupLdapLink(ctx, \"test\", \u0026gitlab.GroupLdapLinkArgs{\n\t\t\tCn:           pulumi.String(\"testuser\"),\n\t\t\tGroupAccess:  pulumi.String(\"developer\"),\n\t\t\tGroupId:      pulumi.String(\"12345\"),\n\t\t\tLdapProvider: pulumi.String(\"ldapmain\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GroupLdapLink;\nimport com.pulumi.gitlab.GroupLdapLinkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new GroupLdapLink(\"test\", GroupLdapLinkArgs.builder()        \n            .cn(\"testuser\")\n            .groupAccess(\"developer\")\n            .groupId(\"12345\")\n            .ldapProvider(\"ldapmain\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: gitlab:GroupLdapLink\n    properties:\n      cn: testuser\n      groupAccess: developer\n      groupId: '12345'\n      ldapProvider: ldapmain\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitLab group ldap links can be imported using an id made up of `group_id:ldap_provider:cn`, e.g.\n\n```sh\n $ pulumi import gitlab:index/groupLdapLink:GroupLdapLink test \"12345:ldapmain:testuser\"\n```\n\n ",
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Minimum access level for members of the LDAP group. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`, `master`\n",
                    "deprecationMessage": "Use `group_access` instead of the `access_level` attribute."
                },
                "cn": {
                    "type": "string",
                    "description": "The CN of the LDAP group to link with.\n"
                },
                "force": {
                    "type": "boolean",
                    "description": "If true, then delete and replace an existing LDAP link if one exists.\n"
                },
                "groupAccess": {
                    "type": "string",
                    "description": "Minimum access level for members of the LDAP group. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`, `master`\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "The id of the GitLab group.\n"
                },
                "ldapProvider": {
                    "type": "string",
                    "description": "The name of the LDAP provider as stored in the GitLab database. Note that this is NOT the value of the `label` attribute as shown in the web UI. In most cases this will be `ldapmain` but you may use the [LDAP check rake task](https://docs.gitlab.com/ee/administration/raketasks/ldap.html#check) for receiving the LDAP server name: `LDAP: ... Server: ldapmain`\n"
                }
            },
            "required": [
                "cn",
                "groupId",
                "ldapProvider"
            ],
            "inputProperties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Minimum access level for members of the LDAP group. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`, `master`\n",
                    "deprecationMessage": "Use `group_access` instead of the `access_level` attribute.",
                    "willReplaceOnChanges": true
                },
                "cn": {
                    "type": "string",
                    "description": "The CN of the LDAP group to link with.\n",
                    "willReplaceOnChanges": true
                },
                "force": {
                    "type": "boolean",
                    "description": "If true, then delete and replace an existing LDAP link if one exists.\n",
                    "willReplaceOnChanges": true
                },
                "groupAccess": {
                    "type": "string",
                    "description": "Minimum access level for members of the LDAP group. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`, `master`\n",
                    "willReplaceOnChanges": true
                },
                "groupId": {
                    "type": "string",
                    "description": "The id of the GitLab group.\n",
                    "willReplaceOnChanges": true
                },
                "ldapProvider": {
                    "type": "string",
                    "description": "The name of the LDAP provider as stored in the GitLab database. Note that this is NOT the value of the `label` attribute as shown in the web UI. In most cases this will be `ldapmain` but you may use the [LDAP check rake task](https://docs.gitlab.com/ee/administration/raketasks/ldap.html#check) for receiving the LDAP server name: `LDAP: ... Server: ldapmain`\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "cn",
                "groupId",
                "ldapProvider"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupLdapLink resources.\n",
                "properties": {
                    "accessLevel": {
                        "type": "string",
                        "description": "Minimum access level for members of the LDAP group. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`, `master`\n",
                        "deprecationMessage": "Use `group_access` instead of the `access_level` attribute.",
                        "willReplaceOnChanges": true
                    },
                    "cn": {
                        "type": "string",
                        "description": "The CN of the LDAP group to link with.\n",
                        "willReplaceOnChanges": true
                    },
                    "force": {
                        "type": "boolean",
                        "description": "If true, then delete and replace an existing LDAP link if one exists.\n",
                        "willReplaceOnChanges": true
                    },
                    "groupAccess": {
                        "type": "string",
                        "description": "Minimum access level for members of the LDAP group. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`, `master`\n",
                        "willReplaceOnChanges": true
                    },
                    "groupId": {
                        "type": "string",
                        "description": "The id of the GitLab group.\n",
                        "willReplaceOnChanges": true
                    },
                    "ldapProvider": {
                        "type": "string",
                        "description": "The name of the LDAP provider as stored in the GitLab database. Note that this is NOT the value of the `label` attribute as shown in the web UI. In most cases this will be `ldapmain` but you may use the [LDAP check rake task](https://docs.gitlab.com/ee/administration/raketasks/ldap.html#check) for receiving the LDAP server name: `LDAP: ... Server: ldapmain`\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupMembership:GroupMembership": {
            "description": "The `gitlab.GroupMembership` resource allows to manage the lifecycle of a users group membership.\n\n\u003e If a group should grant membership to another group use the `gitlab.GroupShareGroup` resource instead.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/members.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst test = new gitlab.GroupMembership(\"test\", {\n    accessLevel: \"guest\",\n    expiresAt: \"2020-12-31\",\n    groupId: \"12345\",\n    userId: 1337,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\ntest = gitlab.GroupMembership(\"test\",\n    access_level=\"guest\",\n    expires_at=\"2020-12-31\",\n    group_id=\"12345\",\n    user_id=1337)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new GitLab.GroupMembership(\"test\", new()\n    {\n        AccessLevel = \"guest\",\n        ExpiresAt = \"2020-12-31\",\n        GroupId = \"12345\",\n        UserId = 1337,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewGroupMembership(ctx, \"test\", \u0026gitlab.GroupMembershipArgs{\n\t\t\tAccessLevel: pulumi.String(\"guest\"),\n\t\t\tExpiresAt:   pulumi.String(\"2020-12-31\"),\n\t\t\tGroupId:     pulumi.String(\"12345\"),\n\t\t\tUserId:      pulumi.Int(1337),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GroupMembership;\nimport com.pulumi.gitlab.GroupMembershipArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new GroupMembership(\"test\", GroupMembershipArgs.builder()        \n            .accessLevel(\"guest\")\n            .expiresAt(\"2020-12-31\")\n            .groupId(\"12345\")\n            .userId(1337)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: gitlab:GroupMembership\n    properties:\n      accessLevel: guest\n      expiresAt: 2020-12-31\n      groupId: '12345'\n      userId: 1337\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitLab group membership can be imported using an id made up of `group_id:user_id`, e.g.\n\n```sh\n $ pulumi import gitlab:index/groupMembership:GroupMembership test \"12345:1337\"\n```\n\n ",
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Access level for the member. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`, `master`.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "Expiration date for the group membership. Format: `YYYY-MM-DD`\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "The id of the group.\n"
                },
                "skipSubresourcesOnDestroy": {
                    "type": "boolean",
                    "description": "Whether the deletion of direct memberships of the removed member in subgroups and projects should be skipped. Only used during a destroy.\n"
                },
                "unassignIssuablesOnDestroy": {
                    "type": "boolean",
                    "description": "Whether the removed member should be unassigned from any issues or merge requests inside a given group or project. Only used during a destroy.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The id of the user.\n"
                }
            },
            "required": [
                "accessLevel",
                "groupId",
                "userId"
            ],
            "inputProperties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Access level for the member. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`, `master`.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "Expiration date for the group membership. Format: `YYYY-MM-DD`\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "The id of the group.\n",
                    "willReplaceOnChanges": true
                },
                "skipSubresourcesOnDestroy": {
                    "type": "boolean",
                    "description": "Whether the deletion of direct memberships of the removed member in subgroups and projects should be skipped. Only used during a destroy.\n"
                },
                "unassignIssuablesOnDestroy": {
                    "type": "boolean",
                    "description": "Whether the removed member should be unassigned from any issues or merge requests inside a given group or project. Only used during a destroy.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The id of the user.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accessLevel",
                "groupId",
                "userId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupMembership resources.\n",
                "properties": {
                    "accessLevel": {
                        "type": "string",
                        "description": "Access level for the member. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`, `master`.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "Expiration date for the group membership. Format: `YYYY-MM-DD`\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "The id of the group.\n",
                        "willReplaceOnChanges": true
                    },
                    "skipSubresourcesOnDestroy": {
                        "type": "boolean",
                        "description": "Whether the deletion of direct memberships of the removed member in subgroups and projects should be skipped. Only used during a destroy.\n"
                    },
                    "unassignIssuablesOnDestroy": {
                        "type": "boolean",
                        "description": "Whether the removed member should be unassigned from any issues or merge requests inside a given group or project. Only used during a destroy.\n"
                    },
                    "userId": {
                        "type": "integer",
                        "description": "The id of the user.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupProjectFileTemplate:GroupProjectFileTemplate": {
            "description": "The `gitlab.GroupProjectFileTemplate` resource allows setting a project from which\ncustom file templates will be loaded. In order to use this resource, the project selected must be a direct child of\nthe group selected. After the resource has run, `gitlab_project_template.template_project_id` is available for use.\nFor more information about which file types are available as templates, view \n[GitLab's documentation](https://docs.gitlab.com/ee/user/group/custom_project_templates.html)\n\n\u003e This resource requires a GitLab Enterprise instance with a Premium license.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/groups.html#update-group)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = new gitlab.Group(\"foo\", {\n    path: \"group\",\n    description: \"An example group\",\n});\nconst bar = new gitlab.Project(\"bar\", {\n    description: \"contains file templates\",\n    visibilityLevel: \"public\",\n    namespaceId: foo.id,\n});\nconst templateLink = new gitlab.GroupProjectFileTemplate(\"templateLink\", {\n    groupId: foo.id,\n    fileTemplateProjectId: bar.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.Group(\"foo\",\n    path=\"group\",\n    description=\"An example group\")\nbar = gitlab.Project(\"bar\",\n    description=\"contains file templates\",\n    visibility_level=\"public\",\n    namespace_id=foo.id)\ntemplate_link = gitlab.GroupProjectFileTemplate(\"templateLink\",\n    group_id=foo.id,\n    file_template_project_id=bar.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = new GitLab.Group(\"foo\", new()\n    {\n        Path = \"group\",\n        Description = \"An example group\",\n    });\n\n    var bar = new GitLab.Project(\"bar\", new()\n    {\n        Description = \"contains file templates\",\n        VisibilityLevel = \"public\",\n        NamespaceId = foo.Id,\n    });\n\n    var templateLink = new GitLab.GroupProjectFileTemplate(\"templateLink\", new()\n    {\n        GroupId = foo.Id,\n        FileTemplateProjectId = bar.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfoo, err := gitlab.NewGroup(ctx, \"foo\", \u0026gitlab.GroupArgs{\n\t\t\tPath:        pulumi.String(\"group\"),\n\t\t\tDescription: pulumi.String(\"An example group\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tbar, err := gitlab.NewProject(ctx, \"bar\", \u0026gitlab.ProjectArgs{\n\t\t\tDescription:     pulumi.String(\"contains file templates\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t\tNamespaceId:     foo.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewGroupProjectFileTemplate(ctx, \"templateLink\", \u0026gitlab.GroupProjectFileTemplateArgs{\n\t\t\tGroupId:               foo.ID(),\n\t\t\tFileTemplateProjectId: bar.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Group;\nimport com.pulumi.gitlab.GroupArgs;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.GroupProjectFileTemplate;\nimport com.pulumi.gitlab.GroupProjectFileTemplateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var foo = new Group(\"foo\", GroupArgs.builder()        \n            .path(\"group\")\n            .description(\"An example group\")\n            .build());\n\n        var bar = new Project(\"bar\", ProjectArgs.builder()        \n            .description(\"contains file templates\")\n            .visibilityLevel(\"public\")\n            .namespaceId(foo.id())\n            .build());\n\n        var templateLink = new GroupProjectFileTemplate(\"templateLink\", GroupProjectFileTemplateArgs.builder()        \n            .groupId(foo.id())\n            .fileTemplateProjectId(bar.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  foo:\n    type: gitlab:Group\n    properties:\n      path: group\n      description: An example group\n  bar:\n    type: gitlab:Project\n    properties:\n      description: contains file templates\n      visibilityLevel: public\n      namespaceId: ${foo.id}\n  templateLink:\n    type: gitlab:GroupProjectFileTemplate\n    properties:\n      groupId: ${foo.id}\n      fileTemplateProjectId: ${bar.id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "fileTemplateProjectId": {
                    "type": "integer",
                    "description": "The ID of the project that will be used for file templates. This project must be the direct\n\t\t\tchild of the project defined by the group_id\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of the group that will use the file template project. This group must be the direct\n            parent of the project defined by project_id\n"
                }
            },
            "required": [
                "fileTemplateProjectId",
                "groupId"
            ],
            "inputProperties": {
                "fileTemplateProjectId": {
                    "type": "integer",
                    "description": "The ID of the project that will be used for file templates. This project must be the direct\n\t\t\tchild of the project defined by the group_id\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of the group that will use the file template project. This group must be the direct\n            parent of the project defined by project_id\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "fileTemplateProjectId",
                "groupId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupProjectFileTemplate resources.\n",
                "properties": {
                    "fileTemplateProjectId": {
                        "type": "integer",
                        "description": "The ID of the project that will be used for file templates. This project must be the direct\n\t\t\tchild of the project defined by the group_id\n"
                    },
                    "groupId": {
                        "type": "integer",
                        "description": "The ID of the group that will use the file template project. This group must be the direct\n            parent of the project defined by project_id\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupSamlLink:GroupSamlLink": {
            "description": "The `gitlab.GroupSamlLink` resource allows to manage the lifecycle of an SAML integration with a group.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/groups.html#saml-group-links)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst test = new gitlab.GroupSamlLink(\"test\", {\n    accessLevel: \"developer\",\n    group: \"12345\",\n    samlGroupName: \"samlgroupname1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\ntest = gitlab.GroupSamlLink(\"test\",\n    access_level=\"developer\",\n    group=\"12345\",\n    saml_group_name=\"samlgroupname1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new GitLab.GroupSamlLink(\"test\", new()\n    {\n        AccessLevel = \"developer\",\n        Group = \"12345\",\n        SamlGroupName = \"samlgroupname1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewGroupSamlLink(ctx, \"test\", \u0026gitlab.GroupSamlLinkArgs{\n\t\t\tAccessLevel:   pulumi.String(\"developer\"),\n\t\t\tGroup:         pulumi.String(\"12345\"),\n\t\t\tSamlGroupName: pulumi.String(\"samlgroupname1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GroupSamlLink;\nimport com.pulumi.gitlab.GroupSamlLinkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new GroupSamlLink(\"test\", GroupSamlLinkArgs.builder()        \n            .accessLevel(\"developer\")\n            .group(\"12345\")\n            .samlGroupName(\"samlgroupname1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: gitlab:GroupSamlLink\n    properties:\n      accessLevel: developer\n      group: '12345'\n      samlGroupName: samlgroupname1\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitLab group saml links can be imported using an id made up of `group_id:saml_group_name`, e.g.\n\n```sh\n $ pulumi import gitlab:index/groupSamlLink:GroupSamlLink test \"12345:samlgroupname1\"\n```\n\n ",
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Access level for members of the SAML group. Valid values are: `guest`, `reporter`, `developer`, `maintainer`, `owner`.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The ID or path of the group to add the SAML Group Link to.\n"
                },
                "samlGroupName": {
                    "type": "string",
                    "description": "The name of the SAML group.\n"
                }
            },
            "required": [
                "accessLevel",
                "group",
                "samlGroupName"
            ],
            "inputProperties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Access level for members of the SAML group. Valid values are: `guest`, `reporter`, `developer`, `maintainer`, `owner`.\n",
                    "willReplaceOnChanges": true
                },
                "group": {
                    "type": "string",
                    "description": "The ID or path of the group to add the SAML Group Link to.\n",
                    "willReplaceOnChanges": true
                },
                "samlGroupName": {
                    "type": "string",
                    "description": "The name of the SAML group.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accessLevel",
                "group",
                "samlGroupName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupSamlLink resources.\n",
                "properties": {
                    "accessLevel": {
                        "type": "string",
                        "description": "Access level for members of the SAML group. Valid values are: `guest`, `reporter`, `developer`, `maintainer`, `owner`.\n",
                        "willReplaceOnChanges": true
                    },
                    "group": {
                        "type": "string",
                        "description": "The ID or path of the group to add the SAML Group Link to.\n",
                        "willReplaceOnChanges": true
                    },
                    "samlGroupName": {
                        "type": "string",
                        "description": "The name of the SAML group.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupShareGroup:GroupShareGroup": {
            "description": "The `gitlab.GroupShareGroup` resource allows to manage the lifecycle of group shared with another group.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/groups.html#share-groups-with-groups)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst test = new gitlab.GroupShareGroup(\"test\", {\n    groupId: gitlab_group.foo.id,\n    shareGroupId: gitlab_group.bar.id,\n    groupAccess: \"guest\",\n    expiresAt: \"2099-01-01\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\ntest = gitlab.GroupShareGroup(\"test\",\n    group_id=gitlab_group[\"foo\"][\"id\"],\n    share_group_id=gitlab_group[\"bar\"][\"id\"],\n    group_access=\"guest\",\n    expires_at=\"2099-01-01\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new GitLab.GroupShareGroup(\"test\", new()\n    {\n        GroupId = gitlab_group.Foo.Id,\n        ShareGroupId = gitlab_group.Bar.Id,\n        GroupAccess = \"guest\",\n        ExpiresAt = \"2099-01-01\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewGroupShareGroup(ctx, \"test\", \u0026gitlab.GroupShareGroupArgs{\n\t\t\tGroupId:      pulumi.Any(gitlab_group.Foo.Id),\n\t\t\tShareGroupId: pulumi.Any(gitlab_group.Bar.Id),\n\t\t\tGroupAccess:  pulumi.String(\"guest\"),\n\t\t\tExpiresAt:    pulumi.String(\"2099-01-01\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GroupShareGroup;\nimport com.pulumi.gitlab.GroupShareGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new GroupShareGroup(\"test\", GroupShareGroupArgs.builder()        \n            .groupId(gitlab_group.foo().id())\n            .shareGroupId(gitlab_group.bar().id())\n            .groupAccess(\"guest\")\n            .expiresAt(\"2099-01-01\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: gitlab:GroupShareGroup\n    properties:\n      groupId: ${gitlab_group.foo.id}\n      shareGroupId: ${gitlab_group.bar.id}\n      groupAccess: guest\n      expiresAt: 2099-01-01\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitLab group shares can be imported using an id made up of `mainGroupId:shareGroupId`, e.g.\n\n```sh\n $ pulumi import gitlab:index/groupShareGroup:GroupShareGroup test 12345:1337\n```\n\n ",
            "properties": {
                "expiresAt": {
                    "type": "string",
                    "description": "Share expiration date. Format: `YYYY-MM-DD`\n"
                },
                "groupAccess": {
                    "type": "string",
                    "description": "The access level to grant the group. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`, `master`\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "The id of the main group to be shared.\n"
                },
                "shareGroupId": {
                    "type": "integer",
                    "description": "The id of the additional group with which the main group will be shared.\n"
                }
            },
            "required": [
                "groupAccess",
                "groupId",
                "shareGroupId"
            ],
            "inputProperties": {
                "expiresAt": {
                    "type": "string",
                    "description": "Share expiration date. Format: `YYYY-MM-DD`\n",
                    "willReplaceOnChanges": true
                },
                "groupAccess": {
                    "type": "string",
                    "description": "The access level to grant the group. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`, `master`\n",
                    "willReplaceOnChanges": true
                },
                "groupId": {
                    "type": "string",
                    "description": "The id of the main group to be shared.\n",
                    "willReplaceOnChanges": true
                },
                "shareGroupId": {
                    "type": "integer",
                    "description": "The id of the additional group with which the main group will be shared.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "groupAccess",
                "groupId",
                "shareGroupId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupShareGroup resources.\n",
                "properties": {
                    "expiresAt": {
                        "type": "string",
                        "description": "Share expiration date. Format: `YYYY-MM-DD`\n",
                        "willReplaceOnChanges": true
                    },
                    "groupAccess": {
                        "type": "string",
                        "description": "The access level to grant the group. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`, `master`\n",
                        "willReplaceOnChanges": true
                    },
                    "groupId": {
                        "type": "string",
                        "description": "The id of the main group to be shared.\n",
                        "willReplaceOnChanges": true
                    },
                    "shareGroupId": {
                        "type": "integer",
                        "description": "The id of the additional group with which the main group will be shared.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupVariable:GroupVariable": {
            "description": "The `gitlab.GroupVariable` resource allows to manage the lifecycle of a CI/CD variable for a group.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/group_level_variables.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = new gitlab.GroupVariable(\"example\", {\n    environmentScope: \"*\",\n    group: \"12345\",\n    key: \"group_variable_key\",\n    masked: false,\n    \"protected\": false,\n    value: \"group_variable_value\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.GroupVariable(\"example\",\n    environment_scope=\"*\",\n    group=\"12345\",\n    key=\"group_variable_key\",\n    masked=False,\n    protected=False,\n    value=\"group_variable_value\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new GitLab.GroupVariable(\"example\", new()\n    {\n        EnvironmentScope = \"*\",\n        Group = \"12345\",\n        Key = \"group_variable_key\",\n        Masked = false,\n        Protected = false,\n        Value = \"group_variable_value\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewGroupVariable(ctx, \"example\", \u0026gitlab.GroupVariableArgs{\n\t\t\tEnvironmentScope: pulumi.String(\"*\"),\n\t\t\tGroup:            pulumi.String(\"12345\"),\n\t\t\tKey:              pulumi.String(\"group_variable_key\"),\n\t\t\tMasked:           pulumi.Bool(false),\n\t\t\tProtected:        pulumi.Bool(false),\n\t\t\tValue:            pulumi.String(\"group_variable_value\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GroupVariable;\nimport com.pulumi.gitlab.GroupVariableArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new GroupVariable(\"example\", GroupVariableArgs.builder()        \n            .environmentScope(\"*\")\n            .group(\"12345\")\n            .key(\"group_variable_key\")\n            .masked(false)\n            .protected_(false)\n            .value(\"group_variable_value\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: gitlab:GroupVariable\n    properties:\n      environmentScope: '*'\n      group: '12345'\n      key: group_variable_key\n      masked: false\n      protected: false\n      value: group_variable_value\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitLab group variables can be imported using an id made up of `groupid:variablename:scope`, e.g.\n\n```sh\n $ pulumi import gitlab:index/groupVariable:GroupVariable example 12345:group_variable_key:*\n```\n\n ",
            "properties": {
                "environmentScope": {
                    "type": "string",
                    "description": "The environment scope of the variable. Defaults to all environment (`*`). Note that in Community Editions of Gitlab, values other than `*` will cause inconsistent plans.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The name or id of the group.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The name of the variable.\n"
                },
                "masked": {
                    "type": "boolean",
                    "description": "If set to `true`, the value of the variable will be hidden in job logs. The value must meet the [masking requirements](https://docs.gitlab.com/ee/ci/variables/#masked-variables). Defaults to `false`.\n"
                },
                "protected": {
                    "type": "boolean",
                    "description": "If set to `true`, the variable will be passed only to pipelines running on protected branches and tags. Defaults to `false`.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the variable.\n",
                    "secret": true
                },
                "variableType": {
                    "type": "string",
                    "description": "The type of a variable. Valid values are: `env_var`, `file`. Default is `env_var`.\n"
                }
            },
            "required": [
                "group",
                "key",
                "value"
            ],
            "inputProperties": {
                "environmentScope": {
                    "type": "string",
                    "description": "The environment scope of the variable. Defaults to all environment (`*`). Note that in Community Editions of Gitlab, values other than `*` will cause inconsistent plans.\n",
                    "willReplaceOnChanges": true
                },
                "group": {
                    "type": "string",
                    "description": "The name or id of the group.\n",
                    "willReplaceOnChanges": true
                },
                "key": {
                    "type": "string",
                    "description": "The name of the variable.\n",
                    "willReplaceOnChanges": true
                },
                "masked": {
                    "type": "boolean",
                    "description": "If set to `true`, the value of the variable will be hidden in job logs. The value must meet the [masking requirements](https://docs.gitlab.com/ee/ci/variables/#masked-variables). Defaults to `false`.\n"
                },
                "protected": {
                    "type": "boolean",
                    "description": "If set to `true`, the variable will be passed only to pipelines running on protected branches and tags. Defaults to `false`.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the variable.\n",
                    "secret": true
                },
                "variableType": {
                    "type": "string",
                    "description": "The type of a variable. Valid values are: `env_var`, `file`. Default is `env_var`.\n"
                }
            },
            "requiredInputs": [
                "group",
                "key",
                "value"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupVariable resources.\n",
                "properties": {
                    "environmentScope": {
                        "type": "string",
                        "description": "The environment scope of the variable. Defaults to all environment (`*`). Note that in Community Editions of Gitlab, values other than `*` will cause inconsistent plans.\n",
                        "willReplaceOnChanges": true
                    },
                    "group": {
                        "type": "string",
                        "description": "The name or id of the group.\n",
                        "willReplaceOnChanges": true
                    },
                    "key": {
                        "type": "string",
                        "description": "The name of the variable.\n",
                        "willReplaceOnChanges": true
                    },
                    "masked": {
                        "type": "boolean",
                        "description": "If set to `true`, the value of the variable will be hidden in job logs. The value must meet the [masking requirements](https://docs.gitlab.com/ee/ci/variables/#masked-variables). Defaults to `false`.\n"
                    },
                    "protected": {
                        "type": "boolean",
                        "description": "If set to `true`, the variable will be passed only to pipelines running on protected branches and tags. Defaults to `false`.\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "The value of the variable.\n",
                        "secret": true
                    },
                    "variableType": {
                        "type": "string",
                        "description": "The type of a variable. Valid values are: `env_var`, `file`. Default is `env_var`.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/instanceCluster:InstanceCluster": {
            "description": "The `gitlab.InstanceCluster` resource allows to manage the lifecycle of an instance cluster.\n\n\u003e This is deprecated GitLab feature since 14.5\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/instance_clusters.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst bar = new gitlab.InstanceCluster(\"bar\", {\n    domain: \"example.com\",\n    enabled: true,\n    environmentScope: \"*\",\n    kubernetesApiUrl: \"https://124.124.124\",\n    kubernetesAuthorizationType: \"rbac\",\n    kubernetesCaCert: \"some-cert\",\n    kubernetesNamespace: \"namespace\",\n    kubernetesToken: \"some-token\",\n    managementProjectId: \"123456\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nbar = gitlab.InstanceCluster(\"bar\",\n    domain=\"example.com\",\n    enabled=True,\n    environment_scope=\"*\",\n    kubernetes_api_url=\"https://124.124.124\",\n    kubernetes_authorization_type=\"rbac\",\n    kubernetes_ca_cert=\"some-cert\",\n    kubernetes_namespace=\"namespace\",\n    kubernetes_token=\"some-token\",\n    management_project_id=\"123456\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var bar = new GitLab.InstanceCluster(\"bar\", new()\n    {\n        Domain = \"example.com\",\n        Enabled = true,\n        EnvironmentScope = \"*\",\n        KubernetesApiUrl = \"https://124.124.124\",\n        KubernetesAuthorizationType = \"rbac\",\n        KubernetesCaCert = \"some-cert\",\n        KubernetesNamespace = \"namespace\",\n        KubernetesToken = \"some-token\",\n        ManagementProjectId = \"123456\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewInstanceCluster(ctx, \"bar\", \u0026gitlab.InstanceClusterArgs{\n\t\t\tDomain:                      pulumi.String(\"example.com\"),\n\t\t\tEnabled:                     pulumi.Bool(true),\n\t\t\tEnvironmentScope:            pulumi.String(\"*\"),\n\t\t\tKubernetesApiUrl:            pulumi.String(\"https://124.124.124\"),\n\t\t\tKubernetesAuthorizationType: pulumi.String(\"rbac\"),\n\t\t\tKubernetesCaCert:            pulumi.String(\"some-cert\"),\n\t\t\tKubernetesNamespace:         pulumi.String(\"namespace\"),\n\t\t\tKubernetesToken:             pulumi.String(\"some-token\"),\n\t\t\tManagementProjectId:         pulumi.String(\"123456\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.InstanceCluster;\nimport com.pulumi.gitlab.InstanceClusterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var bar = new InstanceCluster(\"bar\", InstanceClusterArgs.builder()        \n            .domain(\"example.com\")\n            .enabled(true)\n            .environmentScope(\"*\")\n            .kubernetesApiUrl(\"https://124.124.124\")\n            .kubernetesAuthorizationType(\"rbac\")\n            .kubernetesCaCert(\"some-cert\")\n            .kubernetesNamespace(\"namespace\")\n            .kubernetesToken(\"some-token\")\n            .managementProjectId(\"123456\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  bar:\n    type: gitlab:InstanceCluster\n    properties:\n      domain: example.com\n      enabled: true\n      environmentScope: '*'\n      kubernetesApiUrl: https://124.124.124\n      kubernetesAuthorizationType: rbac\n      kubernetesCaCert: some-cert\n      kubernetesNamespace: namespace\n      kubernetesToken: some-token\n      managementProjectId: '123456'\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitLab instance clusters can be imported using a `clusterid`, e.g.\n\n```sh\n $ pulumi import gitlab:index/instanceCluster:InstanceCluster bar 123\n```\n\n ",
            "properties": {
                "clusterType": {
                    "type": "string",
                    "description": "Cluster type.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Create time.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The base domain of the cluster.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Determines if cluster is active or not. Defaults to `true`. This attribute cannot be read.\n"
                },
                "environmentScope": {
                    "type": "string",
                    "description": "The associated environment to the cluster. Defaults to `*`.\n"
                },
                "kubernetesApiUrl": {
                    "type": "string",
                    "description": "The URL to access the Kubernetes API.\n"
                },
                "kubernetesAuthorizationType": {
                    "type": "string",
                    "description": "The cluster authorization type. Valid values are `rbac`, `abac`, `unknown_authorization`. Defaults to `rbac`.\n"
                },
                "kubernetesCaCert": {
                    "type": "string",
                    "description": "TLS certificate (needed if API is using a self-signed TLS certificate).\n"
                },
                "kubernetesNamespace": {
                    "type": "string",
                    "description": "The unique namespace related to the instance.\n"
                },
                "kubernetesToken": {
                    "type": "string",
                    "description": "The token to authenticate against Kubernetes. This attribute cannot be read.\n",
                    "secret": true
                },
                "managed": {
                    "type": "boolean",
                    "description": "Determines if cluster is managed by gitlab or not. Defaults to `true`. This attribute cannot be read.\n"
                },
                "managementProjectId": {
                    "type": "string",
                    "description": "The ID of the management project for the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of cluster.\n"
                },
                "platformType": {
                    "type": "string",
                    "description": "Platform type.\n"
                },
                "providerType": {
                    "type": "string",
                    "description": "Provider type.\n"
                }
            },
            "required": [
                "clusterType",
                "createdAt",
                "kubernetesApiUrl",
                "kubernetesToken",
                "name",
                "platformType",
                "providerType"
            ],
            "inputProperties": {
                "domain": {
                    "type": "string",
                    "description": "The base domain of the cluster.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Determines if cluster is active or not. Defaults to `true`. This attribute cannot be read.\n",
                    "willReplaceOnChanges": true
                },
                "environmentScope": {
                    "type": "string",
                    "description": "The associated environment to the cluster. Defaults to `*`.\n"
                },
                "kubernetesApiUrl": {
                    "type": "string",
                    "description": "The URL to access the Kubernetes API.\n"
                },
                "kubernetesAuthorizationType": {
                    "type": "string",
                    "description": "The cluster authorization type. Valid values are `rbac`, `abac`, `unknown_authorization`. Defaults to `rbac`.\n",
                    "willReplaceOnChanges": true
                },
                "kubernetesCaCert": {
                    "type": "string",
                    "description": "TLS certificate (needed if API is using a self-signed TLS certificate).\n"
                },
                "kubernetesNamespace": {
                    "type": "string",
                    "description": "The unique namespace related to the instance.\n"
                },
                "kubernetesToken": {
                    "type": "string",
                    "description": "The token to authenticate against Kubernetes. This attribute cannot be read.\n",
                    "secret": true
                },
                "managed": {
                    "type": "boolean",
                    "description": "Determines if cluster is managed by gitlab or not. Defaults to `true`. This attribute cannot be read.\n",
                    "willReplaceOnChanges": true
                },
                "managementProjectId": {
                    "type": "string",
                    "description": "The ID of the management project for the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of cluster.\n"
                }
            },
            "requiredInputs": [
                "kubernetesApiUrl",
                "kubernetesToken"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering InstanceCluster resources.\n",
                "properties": {
                    "clusterType": {
                        "type": "string",
                        "description": "Cluster type.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Create time.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The base domain of the cluster.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Determines if cluster is active or not. Defaults to `true`. This attribute cannot be read.\n",
                        "willReplaceOnChanges": true
                    },
                    "environmentScope": {
                        "type": "string",
                        "description": "The associated environment to the cluster. Defaults to `*`.\n"
                    },
                    "kubernetesApiUrl": {
                        "type": "string",
                        "description": "The URL to access the Kubernetes API.\n"
                    },
                    "kubernetesAuthorizationType": {
                        "type": "string",
                        "description": "The cluster authorization type. Valid values are `rbac`, `abac`, `unknown_authorization`. Defaults to `rbac`.\n",
                        "willReplaceOnChanges": true
                    },
                    "kubernetesCaCert": {
                        "type": "string",
                        "description": "TLS certificate (needed if API is using a self-signed TLS certificate).\n"
                    },
                    "kubernetesNamespace": {
                        "type": "string",
                        "description": "The unique namespace related to the instance.\n"
                    },
                    "kubernetesToken": {
                        "type": "string",
                        "description": "The token to authenticate against Kubernetes. This attribute cannot be read.\n",
                        "secret": true
                    },
                    "managed": {
                        "type": "boolean",
                        "description": "Determines if cluster is managed by gitlab or not. Defaults to `true`. This attribute cannot be read.\n",
                        "willReplaceOnChanges": true
                    },
                    "managementProjectId": {
                        "type": "string",
                        "description": "The ID of the management project for the cluster.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of cluster.\n"
                    },
                    "platformType": {
                        "type": "string",
                        "description": "Platform type.\n"
                    },
                    "providerType": {
                        "type": "string",
                        "description": "Provider type.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/instanceVariable:InstanceVariable": {
            "description": "The `gitlab.InstanceVariable` resource allows to manage the lifecycle of an instance-level CI/CD variable.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/instance_level_ci_variables.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = new gitlab.InstanceVariable(\"example\", {\n    key: \"instance_variable_key\",\n    masked: false,\n    \"protected\": false,\n    value: \"instance_variable_value\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.InstanceVariable(\"example\",\n    key=\"instance_variable_key\",\n    masked=False,\n    protected=False,\n    value=\"instance_variable_value\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new GitLab.InstanceVariable(\"example\", new()\n    {\n        Key = \"instance_variable_key\",\n        Masked = false,\n        Protected = false,\n        Value = \"instance_variable_value\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewInstanceVariable(ctx, \"example\", \u0026gitlab.InstanceVariableArgs{\n\t\t\tKey:       pulumi.String(\"instance_variable_key\"),\n\t\t\tMasked:    pulumi.Bool(false),\n\t\t\tProtected: pulumi.Bool(false),\n\t\t\tValue:     pulumi.String(\"instance_variable_value\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.InstanceVariable;\nimport com.pulumi.gitlab.InstanceVariableArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new InstanceVariable(\"example\", InstanceVariableArgs.builder()        \n            .key(\"instance_variable_key\")\n            .masked(false)\n            .protected_(false)\n            .value(\"instance_variable_value\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: gitlab:InstanceVariable\n    properties:\n      key: instance_variable_key\n      masked: false\n      protected: false\n      value: instance_variable_value\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitLab instance variables can be imported using an id made up of `variablename`, e.g.\n\n```sh\n $ pulumi import gitlab:index/instanceVariable:InstanceVariable example instance_variable_key\n```\n\n ",
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The name of the variable.\n"
                },
                "masked": {
                    "type": "boolean",
                    "description": "If set to `true`, the value of the variable will be hidden in job logs. The value must meet the [masking requirements](https://docs.gitlab.com/ee/ci/variables/#masked-variables). Defaults to `false`.\n"
                },
                "protected": {
                    "type": "boolean",
                    "description": "If set to `true`, the variable will be passed only to pipelines running on protected branches and tags. Defaults to `false`.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the variable.\n",
                    "secret": true
                },
                "variableType": {
                    "type": "string",
                    "description": "The type of a variable. Valid values are: `env_var`, `file`. Default is `env_var`.\n"
                }
            },
            "required": [
                "key",
                "value"
            ],
            "inputProperties": {
                "key": {
                    "type": "string",
                    "description": "The name of the variable.\n",
                    "willReplaceOnChanges": true
                },
                "masked": {
                    "type": "boolean",
                    "description": "If set to `true`, the value of the variable will be hidden in job logs. The value must meet the [masking requirements](https://docs.gitlab.com/ee/ci/variables/#masked-variables). Defaults to `false`.\n"
                },
                "protected": {
                    "type": "boolean",
                    "description": "If set to `true`, the variable will be passed only to pipelines running on protected branches and tags. Defaults to `false`.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the variable.\n",
                    "secret": true
                },
                "variableType": {
                    "type": "string",
                    "description": "The type of a variable. Valid values are: `env_var`, `file`. Default is `env_var`.\n"
                }
            },
            "requiredInputs": [
                "key",
                "value"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering InstanceVariable resources.\n",
                "properties": {
                    "key": {
                        "type": "string",
                        "description": "The name of the variable.\n",
                        "willReplaceOnChanges": true
                    },
                    "masked": {
                        "type": "boolean",
                        "description": "If set to `true`, the value of the variable will be hidden in job logs. The value must meet the [masking requirements](https://docs.gitlab.com/ee/ci/variables/#masked-variables). Defaults to `false`.\n"
                    },
                    "protected": {
                        "type": "boolean",
                        "description": "If set to `true`, the variable will be passed only to pipelines running on protected branches and tags. Defaults to `false`.\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "The value of the variable.\n",
                        "secret": true
                    },
                    "variableType": {
                        "type": "string",
                        "description": "The type of a variable. Valid values are: `env_var`, `file`. Default is `env_var`.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/label:Label": {
            "description": "The `gitlab.Label` resource allows to manage the lifecycle of a project label.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/labels.html#project-labels)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst fixme = new gitlab.Label(\"fixme\", {\n    project: \"example\",\n    description: \"issue with failing tests\",\n    color: \"#ffcc00\",\n});\n// Scoped label\nconst devopsCreate = new gitlab.Label(\"devopsCreate\", {\n    project: gitlab_project.example.id,\n    description: \"issue for creating infrastructure resources\",\n    color: \"#ffa500\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfixme = gitlab.Label(\"fixme\",\n    project=\"example\",\n    description=\"issue with failing tests\",\n    color=\"#ffcc00\")\n# Scoped label\ndevops_create = gitlab.Label(\"devopsCreate\",\n    project=gitlab_project[\"example\"][\"id\"],\n    description=\"issue for creating infrastructure resources\",\n    color=\"#ffa500\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var fixme = new GitLab.Label(\"fixme\", new()\n    {\n        Project = \"example\",\n        Description = \"issue with failing tests\",\n        Color = \"#ffcc00\",\n    });\n\n    // Scoped label\n    var devopsCreate = new GitLab.Label(\"devopsCreate\", new()\n    {\n        Project = gitlab_project.Example.Id,\n        Description = \"issue for creating infrastructure resources\",\n        Color = \"#ffa500\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewLabel(ctx, \"fixme\", \u0026gitlab.LabelArgs{\n\t\t\tProject:     pulumi.String(\"example\"),\n\t\t\tDescription: pulumi.String(\"issue with failing tests\"),\n\t\t\tColor:       pulumi.String(\"#ffcc00\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewLabel(ctx, \"devopsCreate\", \u0026gitlab.LabelArgs{\n\t\t\tProject:     pulumi.Any(gitlab_project.Example.Id),\n\t\t\tDescription: pulumi.String(\"issue for creating infrastructure resources\"),\n\t\t\tColor:       pulumi.String(\"#ffa500\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Label;\nimport com.pulumi.gitlab.LabelArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var fixme = new Label(\"fixme\", LabelArgs.builder()        \n            .project(\"example\")\n            .description(\"issue with failing tests\")\n            .color(\"#ffcc00\")\n            .build());\n\n        var devopsCreate = new Label(\"devopsCreate\", LabelArgs.builder()        \n            .project(gitlab_project.example().id())\n            .description(\"issue for creating infrastructure resources\")\n            .color(\"#ffa500\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  fixme:\n    type: gitlab:Label\n    properties:\n      project: example\n      description: issue with failing tests\n      color: '#ffcc00'\n  # Scoped label\n  devopsCreate:\n    type: gitlab:Label\n    properties:\n      project: ${gitlab_project.example.id}\n      description: issue for creating infrastructure resources\n      color: '#ffa500'\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitlab labels can be imported using an id made up of `{project_id}:{group_label_id}`, e.g.\n\n```sh\n $ pulumi import gitlab:index/label:Label example 12345:fixme\n```\n\n ",
            "properties": {
                "color": {
                    "type": "string",
                    "description": "The color of the label given in 6-digit hex notation with leading '#' sign (e.g. #FFAABB) or one of the [CSS color names](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords).\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the label.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the label.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the label to.\n"
                }
            },
            "required": [
                "color",
                "name",
                "project"
            ],
            "inputProperties": {
                "color": {
                    "type": "string",
                    "description": "The color of the label given in 6-digit hex notation with leading '#' sign (e.g. #FFAABB) or one of the [CSS color names](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords).\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the label.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the label.\n",
                    "willReplaceOnChanges": true
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the label to.\n"
                }
            },
            "requiredInputs": [
                "color",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Label resources.\n",
                "properties": {
                    "color": {
                        "type": "string",
                        "description": "The color of the label given in 6-digit hex notation with leading '#' sign (e.g. #FFAABB) or one of the [CSS color names](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords).\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the label.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the label.\n",
                        "willReplaceOnChanges": true
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project to add the label to.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/managedLicense:ManagedLicense": {
            "description": "The `gitlab.ManagedLicense` resource allows to manage the lifecycle of a managed license.\n\n\u003e This resource requires a GitLab Enterprise instance.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/managed_licenses.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = new gitlab.Project(\"foo\", {\n    description: \"Lorem Ipsum\",\n    visibilityLevel: \"public\",\n});\nconst mit = new gitlab.ManagedLicense(\"mit\", {\n    project: foo.id,\n    approvalStatus: \"allowed\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.Project(\"foo\",\n    description=\"Lorem Ipsum\",\n    visibility_level=\"public\")\nmit = gitlab.ManagedLicense(\"mit\",\n    project=foo.id,\n    approval_status=\"allowed\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = new GitLab.Project(\"foo\", new()\n    {\n        Description = \"Lorem Ipsum\",\n        VisibilityLevel = \"public\",\n    });\n\n    var mit = new GitLab.ManagedLicense(\"mit\", new()\n    {\n        Project = foo.Id,\n        ApprovalStatus = \"allowed\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfoo, err := gitlab.NewProject(ctx, \"foo\", \u0026gitlab.ProjectArgs{\n\t\t\tDescription:     pulumi.String(\"Lorem Ipsum\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewManagedLicense(ctx, \"mit\", \u0026gitlab.ManagedLicenseArgs{\n\t\t\tProject:        foo.ID(),\n\t\t\tApprovalStatus: pulumi.String(\"allowed\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ManagedLicense;\nimport com.pulumi.gitlab.ManagedLicenseArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var foo = new Project(\"foo\", ProjectArgs.builder()        \n            .description(\"Lorem Ipsum\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var mit = new ManagedLicense(\"mit\", ManagedLicenseArgs.builder()        \n            .project(foo.id())\n            .approvalStatus(\"allowed\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  foo:\n    type: gitlab:Project\n    properties:\n      description: Lorem Ipsum\n      visibilityLevel: public\n  mit:\n    type: gitlab:ManagedLicense\n    properties:\n      project: ${foo.id}\n      approvalStatus: allowed\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nYou can import this resource with an id made up of `{project-id}:{license-id}`, e.g.\n\n```sh\n $ pulumi import gitlab:index/managedLicense:ManagedLicense foo 1:2\n```\n\n ",
            "properties": {
                "approvalStatus": {
                    "type": "string",
                    "description": "The approval status of the license. Valid values are: `approved`, `blacklisted`, `allowed`, `denied`. \"approved\" and \"blacklisted\"\n\t\t\thave been deprecated in favor of \"allowed\" and \"denied\"; use \"allowed\" and \"denied\" for GitLab versions 15.0 and higher.\n\t\t\tPrior to version 15.0 and after 14.6, the values are equivalent.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the managed license (I.e., 'Apache License 2.0' or 'MIT license')\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID of the project under which the managed license will be created.\n"
                }
            },
            "required": [
                "approvalStatus",
                "name",
                "project"
            ],
            "inputProperties": {
                "approvalStatus": {
                    "type": "string",
                    "description": "The approval status of the license. Valid values are: `approved`, `blacklisted`, `allowed`, `denied`. \"approved\" and \"blacklisted\"\n\t\t\thave been deprecated in favor of \"allowed\" and \"denied\"; use \"allowed\" and \"denied\" for GitLab versions 15.0 and higher.\n\t\t\tPrior to version 15.0 and after 14.6, the values are equivalent.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the managed license (I.e., 'Apache License 2.0' or 'MIT license')\n",
                    "willReplaceOnChanges": true
                },
                "project": {
                    "type": "string",
                    "description": "The ID of the project under which the managed license will be created.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "approvalStatus",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ManagedLicense resources.\n",
                "properties": {
                    "approvalStatus": {
                        "type": "string",
                        "description": "The approval status of the license. Valid values are: `approved`, `blacklisted`, `allowed`, `denied`. \"approved\" and \"blacklisted\"\n\t\t\thave been deprecated in favor of \"allowed\" and \"denied\"; use \"allowed\" and \"denied\" for GitLab versions 15.0 and higher.\n\t\t\tPrior to version 15.0 and after 14.6, the values are equivalent.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the managed license (I.e., 'Apache License 2.0' or 'MIT license')\n",
                        "willReplaceOnChanges": true
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID of the project under which the managed license will be created.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/pagesDomain:PagesDomain": {
            "description": "The `gitlab.PagesDomain` resource allows connecting custom domains and TLS certificates in GitLab Pages.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/pages_domains.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as fs from \"fs\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\n// Example using auto_ssl_enabled, which uses lets encrypt to generate a certificate\nconst thisPagesDomain = new gitlab.PagesDomain(\"thisPagesDomain\", {\n    project: \"123\",\n    domain: \"example.com\",\n    autoSslEnabled: true,\n});\n// Example using a manually generated certificate and key\nconst thisIndex_pagesDomainPagesDomain = new gitlab.PagesDomain(\"thisIndex/pagesDomainPagesDomain\", {\n    project: \"123\",\n    domain: \"example.com\",\n    key: fs.readFileSync(`${path.module}/key.pem`),\n    certificate: fs.readFileSync(`${path.module}/cert.pem`),\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\n# Example using auto_ssl_enabled, which uses lets encrypt to generate a certificate\nthis_pages_domain = gitlab.PagesDomain(\"thisPagesDomain\",\n    project=\"123\",\n    domain=\"example.com\",\n    auto_ssl_enabled=True)\n# Example using a manually generated certificate and key\nthis_index_pages_domain_pages_domain = gitlab.PagesDomain(\"thisIndex/pagesDomainPagesDomain\",\n    project=\"123\",\n    domain=\"example.com\",\n    key=(lambda path: open(path).read())(f\"{path['module']}/key.pem\"),\n    certificate=(lambda path: open(path).read())(f\"{path['module']}/cert.pem\"))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Example using auto_ssl_enabled, which uses lets encrypt to generate a certificate\n    var thisPagesDomain = new GitLab.PagesDomain(\"thisPagesDomain\", new()\n    {\n        Project = \"123\",\n        Domain = \"example.com\",\n        AutoSslEnabled = true,\n    });\n\n    // Example using a manually generated certificate and key\n    var thisIndex_pagesDomainPagesDomain = new GitLab.PagesDomain(\"thisIndex/pagesDomainPagesDomain\", new()\n    {\n        Project = \"123\",\n        Domain = \"example.com\",\n        Key = File.ReadAllText($\"{path.Module}/key.pem\"),\n        Certificate = File.ReadAllText($\"{path.Module}/cert.pem\"),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := os.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewPagesDomain(ctx, \"thisPagesDomain\", \u0026gitlab.PagesDomainArgs{\n\t\t\tProject:        pulumi.String(\"123\"),\n\t\t\tDomain:         pulumi.String(\"example.com\"),\n\t\t\tAutoSslEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewPagesDomain(ctx, \"thisIndex/pagesDomainPagesDomain\", \u0026gitlab.PagesDomainArgs{\n\t\t\tProject:     pulumi.String(\"123\"),\n\t\t\tDomain:      pulumi.String(\"example.com\"),\n\t\t\tKey:         readFileOrPanic(fmt.Sprintf(\"%v/key.pem\", path.Module)),\n\t\t\tCertificate: readFileOrPanic(fmt.Sprintf(\"%v/cert.pem\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.PagesDomain;\nimport com.pulumi.gitlab.PagesDomainArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var thisPagesDomain = new PagesDomain(\"thisPagesDomain\", PagesDomainArgs.builder()        \n            .project(123)\n            .domain(\"example.com\")\n            .autoSslEnabled(true)\n            .build());\n\n        var thisIndex_pagesDomainPagesDomain = new PagesDomain(\"thisIndex/pagesDomainPagesDomain\", PagesDomainArgs.builder()        \n            .project(123)\n            .domain(\"example.com\")\n            .key(Files.readString(Paths.get(String.format(\"%s/key.pem\", path.module()))))\n            .certificate(Files.readString(Paths.get(String.format(\"%s/cert.pem\", path.module()))))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Example using auto_ssl_enabled, which uses lets encrypt to generate a certificate\n  thisPagesDomain:\n    type: gitlab:PagesDomain\n    properties:\n      project: 123\n      domain: example.com\n      autoSslEnabled: true\n  # Example using a manually generated certificate and key\n  thisIndex/pagesDomainPagesDomain:\n    type: gitlab:PagesDomain\n    properties:\n      project: 123\n      domain: example.com\n      key:\n        fn::readFile: ${path.module}/key.pem\n      certificate:\n        fn::readFile: ${path.module}/cert.pem\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitLab pages domain can be imported using an id made up of `projectId:domain` _without_ the http protocol, e.g.\n\n```sh\n $ pulumi import gitlab:index/pagesDomain:PagesDomain this 123:example.com\n```\n\n ",
            "properties": {
                "autoSslEnabled": {
                    "type": "boolean",
                    "description": "Enables [automatic generation](https://docs.gitlab.com/ee/user/project/pages/custom_domains_ssl_tls_certification/lets_encrypt_integration.html) of SSL certificates issued by Let’s Encrypt for custom domains. When this is set to \"true\", certificate can't be provided.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The certificate in PEM format with intermediates following in most specific to least specific order.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The custom domain indicated by the user.\n"
                },
                "expired": {
                    "type": "boolean",
                    "description": "Whether the certificate is expired.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The certificate key in PEM format.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or [URL-encoded path of the project](https://docs.gitlab.com/ee/api/index.html#namespaced-path-encoding) owned by the authenticated user.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL for the given domain.\n"
                },
                "verificationCode": {
                    "type": "string",
                    "description": "The verification code for the domain.\n",
                    "secret": true
                },
                "verified": {
                    "type": "boolean",
                    "description": "The certificate data.\n"
                }
            },
            "required": [
                "autoSslEnabled",
                "certificate",
                "domain",
                "expired",
                "project",
                "url",
                "verificationCode",
                "verified"
            ],
            "inputProperties": {
                "autoSslEnabled": {
                    "type": "boolean",
                    "description": "Enables [automatic generation](https://docs.gitlab.com/ee/user/project/pages/custom_domains_ssl_tls_certification/lets_encrypt_integration.html) of SSL certificates issued by Let’s Encrypt for custom domains. When this is set to \"true\", certificate can't be provided.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The certificate in PEM format with intermediates following in most specific to least specific order.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The custom domain indicated by the user.\n"
                },
                "expired": {
                    "type": "boolean",
                    "description": "Whether the certificate is expired.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The certificate key in PEM format.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or [URL-encoded path of the project](https://docs.gitlab.com/ee/api/index.html#namespaced-path-encoding) owned by the authenticated user.\n"
                }
            },
            "requiredInputs": [
                "domain",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PagesDomain resources.\n",
                "properties": {
                    "autoSslEnabled": {
                        "type": "boolean",
                        "description": "Enables [automatic generation](https://docs.gitlab.com/ee/user/project/pages/custom_domains_ssl_tls_certification/lets_encrypt_integration.html) of SSL certificates issued by Let’s Encrypt for custom domains. When this is set to \"true\", certificate can't be provided.\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "The certificate in PEM format with intermediates following in most specific to least specific order.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The custom domain indicated by the user.\n"
                    },
                    "expired": {
                        "type": "boolean",
                        "description": "Whether the certificate is expired.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "The certificate key in PEM format.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or [URL-encoded path of the project](https://docs.gitlab.com/ee/api/index.html#namespaced-path-encoding) owned by the authenticated user.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "The URL for the given domain.\n"
                    },
                    "verificationCode": {
                        "type": "string",
                        "description": "The verification code for the domain.\n",
                        "secret": true
                    },
                    "verified": {
                        "type": "boolean",
                        "description": "The certificate data.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/personalAccessToken:PersonalAccessToken": {
            "description": "The `gitlab.PersonalAccessToken` resource allows to manage the lifecycle of a personal access token for a specified user.\n\n\u003e This resource requires administration privileges.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/personal_access_tokens.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst examplePersonalAccessToken = new gitlab.PersonalAccessToken(\"examplePersonalAccessToken\", {\n    userId: 25,\n    expiresAt: \"2020-03-14\",\n    scopes: [\"api\"],\n});\nconst exampleProjectVariable = new gitlab.ProjectVariable(\"exampleProjectVariable\", {\n    project: gitlab_project.example.id,\n    key: \"pat\",\n    value: examplePersonalAccessToken.token,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample_personal_access_token = gitlab.PersonalAccessToken(\"examplePersonalAccessToken\",\n    user_id=25,\n    expires_at=\"2020-03-14\",\n    scopes=[\"api\"])\nexample_project_variable = gitlab.ProjectVariable(\"exampleProjectVariable\",\n    project=gitlab_project[\"example\"][\"id\"],\n    key=\"pat\",\n    value=example_personal_access_token.token)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var examplePersonalAccessToken = new GitLab.PersonalAccessToken(\"examplePersonalAccessToken\", new()\n    {\n        UserId = 25,\n        ExpiresAt = \"2020-03-14\",\n        Scopes = new[]\n        {\n            \"api\",\n        },\n    });\n\n    var exampleProjectVariable = new GitLab.ProjectVariable(\"exampleProjectVariable\", new()\n    {\n        Project = gitlab_project.Example.Id,\n        Key = \"pat\",\n        Value = examplePersonalAccessToken.Token,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texamplePersonalAccessToken, err := gitlab.NewPersonalAccessToken(ctx, \"examplePersonalAccessToken\", \u0026gitlab.PersonalAccessTokenArgs{\n\t\t\tUserId:    pulumi.Int(25),\n\t\t\tExpiresAt: pulumi.String(\"2020-03-14\"),\n\t\t\tScopes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"api\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectVariable(ctx, \"exampleProjectVariable\", \u0026gitlab.ProjectVariableArgs{\n\t\t\tProject: pulumi.Any(gitlab_project.Example.Id),\n\t\t\tKey:     pulumi.String(\"pat\"),\n\t\t\tValue:   examplePersonalAccessToken.Token,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.PersonalAccessToken;\nimport com.pulumi.gitlab.PersonalAccessTokenArgs;\nimport com.pulumi.gitlab.ProjectVariable;\nimport com.pulumi.gitlab.ProjectVariableArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var examplePersonalAccessToken = new PersonalAccessToken(\"examplePersonalAccessToken\", PersonalAccessTokenArgs.builder()        \n            .userId(\"25\")\n            .expiresAt(\"2020-03-14\")\n            .scopes(\"api\")\n            .build());\n\n        var exampleProjectVariable = new ProjectVariable(\"exampleProjectVariable\", ProjectVariableArgs.builder()        \n            .project(gitlab_project.example().id())\n            .key(\"pat\")\n            .value(examplePersonalAccessToken.token())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  examplePersonalAccessToken:\n    type: gitlab:PersonalAccessToken\n    properties:\n      userId: '25'\n      expiresAt: 2020-03-14\n      scopes:\n        - api\n  exampleProjectVariable:\n    type: gitlab:ProjectVariable\n    properties:\n      project: ${gitlab_project.example.id}\n      key: pat\n      value: ${examplePersonalAccessToken.token}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nA GitLab Personal Access Token can be imported using a key composed of `\u003cuser-id\u003e:\u003ctoken-id\u003e`, e.g.\n\n```sh\n $ pulumi import gitlab:index/personalAccessToken:PersonalAccessToken example \"12345:1\"\n```\n\n NOTEthe `token` resource attribute is not available for imported resources as this information cannot be read from the GitLab API. ",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "True if the token is active.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Time the token has been created, RFC3339 format.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "The token expires at midnight UTC on that date. The date must be in the format YYYY-MM-DD. Default is never.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the personal access token.\n"
                },
                "revoked": {
                    "type": "boolean",
                    "description": "True if the token is revoked.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The scope for the personal access token. It determines the actions which can be performed when authenticating with this token. Valid values are: `api`, `read_user`, `read_api`, `read_repository`, `write_repository`, `read_registry`, `write_registry`, `sudo`, `admin_mode`.\n"
                },
                "token": {
                    "type": "string",
                    "description": "The personal access token. This is only populated when creating a new personal access token. This attribute is not available for imported resources.\n",
                    "secret": true
                },
                "userId": {
                    "type": "integer",
                    "description": "The id of the user.\n"
                }
            },
            "required": [
                "active",
                "createdAt",
                "name",
                "revoked",
                "scopes",
                "token",
                "userId"
            ],
            "inputProperties": {
                "expiresAt": {
                    "type": "string",
                    "description": "The token expires at midnight UTC on that date. The date must be in the format YYYY-MM-DD. Default is never.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the personal access token.\n",
                    "willReplaceOnChanges": true
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The scope for the personal access token. It determines the actions which can be performed when authenticating with this token. Valid values are: `api`, `read_user`, `read_api`, `read_repository`, `write_repository`, `read_registry`, `write_registry`, `sudo`, `admin_mode`.\n",
                    "willReplaceOnChanges": true
                },
                "userId": {
                    "type": "integer",
                    "description": "The id of the user.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "scopes",
                "userId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PersonalAccessToken resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "True if the token is active.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Time the token has been created, RFC3339 format.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "The token expires at midnight UTC on that date. The date must be in the format YYYY-MM-DD. Default is never.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the personal access token.\n",
                        "willReplaceOnChanges": true
                    },
                    "revoked": {
                        "type": "boolean",
                        "description": "True if the token is revoked.\n"
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The scope for the personal access token. It determines the actions which can be performed when authenticating with this token. Valid values are: `api`, `read_user`, `read_api`, `read_repository`, `write_repository`, `read_registry`, `write_registry`, `sudo`, `admin_mode`.\n",
                        "willReplaceOnChanges": true
                    },
                    "token": {
                        "type": "string",
                        "description": "The personal access token. This is only populated when creating a new personal access token. This attribute is not available for imported resources.\n",
                        "secret": true
                    },
                    "userId": {
                        "type": "integer",
                        "description": "The id of the user.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/pipelineSchedule:PipelineSchedule": {
            "description": "The `gitlab.PipelineSchedule` resource allows to manage the lifecycle of a scheduled pipeline.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/pipeline_schedules.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = new gitlab.PipelineSchedule(\"example\", {\n    cron: \"0 1 * * *\",\n    description: \"Used to schedule builds\",\n    project: \"12345\",\n    ref: \"master\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.PipelineSchedule(\"example\",\n    cron=\"0 1 * * *\",\n    description=\"Used to schedule builds\",\n    project=\"12345\",\n    ref=\"master\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new GitLab.PipelineSchedule(\"example\", new()\n    {\n        Cron = \"0 1 * * *\",\n        Description = \"Used to schedule builds\",\n        Project = \"12345\",\n        Ref = \"master\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewPipelineSchedule(ctx, \"example\", \u0026gitlab.PipelineScheduleArgs{\n\t\t\tCron:        pulumi.String(\"0 1 * * *\"),\n\t\t\tDescription: pulumi.String(\"Used to schedule builds\"),\n\t\t\tProject:     pulumi.String(\"12345\"),\n\t\t\tRef:         pulumi.String(\"master\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.PipelineSchedule;\nimport com.pulumi.gitlab.PipelineScheduleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new PipelineSchedule(\"example\", PipelineScheduleArgs.builder()        \n            .cron(\"0 1 * * *\")\n            .description(\"Used to schedule builds\")\n            .project(\"12345\")\n            .ref(\"master\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: gitlab:PipelineSchedule\n    properties:\n      cron: 0 1 * * *\n      description: Used to schedule builds\n      project: '12345'\n      ref: master\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitLab pipeline schedules can be imported using an id made up of `{project_id}:{pipeline_schedule_id}`, e.g.\n\n```sh\n $ pulumi import gitlab:index/pipelineSchedule:PipelineSchedule test 1:3\n```\n\n ",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "The activation of pipeline schedule. If false is set, the pipeline schedule will deactivated initially.\n"
                },
                "cron": {
                    "type": "string",
                    "description": "The cron (e.g. `0 1 * * *`).\n"
                },
                "cronTimezone": {
                    "type": "string",
                    "description": "The timezone.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the pipeline schedule.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the schedule to.\n"
                },
                "ref": {
                    "type": "string",
                    "description": "The branch/tag name to be triggered.\n"
                }
            },
            "required": [
                "cron",
                "description",
                "project",
                "ref"
            ],
            "inputProperties": {
                "active": {
                    "type": "boolean",
                    "description": "The activation of pipeline schedule. If false is set, the pipeline schedule will deactivated initially.\n"
                },
                "cron": {
                    "type": "string",
                    "description": "The cron (e.g. `0 1 * * *`).\n"
                },
                "cronTimezone": {
                    "type": "string",
                    "description": "The timezone.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the pipeline schedule.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the schedule to.\n",
                    "willReplaceOnChanges": true
                },
                "ref": {
                    "type": "string",
                    "description": "The branch/tag name to be triggered.\n"
                }
            },
            "requiredInputs": [
                "cron",
                "description",
                "project",
                "ref"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PipelineSchedule resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "The activation of pipeline schedule. If false is set, the pipeline schedule will deactivated initially.\n"
                    },
                    "cron": {
                        "type": "string",
                        "description": "The cron (e.g. `0 1 * * *`).\n"
                    },
                    "cronTimezone": {
                        "type": "string",
                        "description": "The timezone.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the pipeline schedule.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project to add the schedule to.\n",
                        "willReplaceOnChanges": true
                    },
                    "ref": {
                        "type": "string",
                        "description": "The branch/tag name to be triggered.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/pipelineScheduleVariable:PipelineScheduleVariable": {
            "description": "The `gitlab.PipelineScheduleVariable` resource allows to manage the lifecycle of a variable for a pipeline schedule.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/pipeline_schedules.html#pipeline-schedule-variables)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst examplePipelineSchedule = new gitlab.PipelineSchedule(\"examplePipelineSchedule\", {\n    project: \"12345\",\n    description: \"Used to schedule builds\",\n    ref: \"master\",\n    cron: \"0 1 * * *\",\n});\nconst examplePipelineScheduleVariable = new gitlab.PipelineScheduleVariable(\"examplePipelineScheduleVariable\", {\n    project: examplePipelineSchedule.project,\n    pipelineScheduleId: examplePipelineSchedule.id,\n    key: \"EXAMPLE_KEY\",\n    value: \"example\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample_pipeline_schedule = gitlab.PipelineSchedule(\"examplePipelineSchedule\",\n    project=\"12345\",\n    description=\"Used to schedule builds\",\n    ref=\"master\",\n    cron=\"0 1 * * *\")\nexample_pipeline_schedule_variable = gitlab.PipelineScheduleVariable(\"examplePipelineScheduleVariable\",\n    project=example_pipeline_schedule.project,\n    pipeline_schedule_id=example_pipeline_schedule.id,\n    key=\"EXAMPLE_KEY\",\n    value=\"example\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var examplePipelineSchedule = new GitLab.PipelineSchedule(\"examplePipelineSchedule\", new()\n    {\n        Project = \"12345\",\n        Description = \"Used to schedule builds\",\n        Ref = \"master\",\n        Cron = \"0 1 * * *\",\n    });\n\n    var examplePipelineScheduleVariable = new GitLab.PipelineScheduleVariable(\"examplePipelineScheduleVariable\", new()\n    {\n        Project = examplePipelineSchedule.Project,\n        PipelineScheduleId = examplePipelineSchedule.Id,\n        Key = \"EXAMPLE_KEY\",\n        Value = \"example\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texamplePipelineSchedule, err := gitlab.NewPipelineSchedule(ctx, \"examplePipelineSchedule\", \u0026gitlab.PipelineScheduleArgs{\n\t\t\tProject:     pulumi.String(\"12345\"),\n\t\t\tDescription: pulumi.String(\"Used to schedule builds\"),\n\t\t\tRef:         pulumi.String(\"master\"),\n\t\t\tCron:        pulumi.String(\"0 1 * * *\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewPipelineScheduleVariable(ctx, \"examplePipelineScheduleVariable\", \u0026gitlab.PipelineScheduleVariableArgs{\n\t\t\tProject:            examplePipelineSchedule.Project,\n\t\t\tPipelineScheduleId: examplePipelineSchedule.ID(),\n\t\t\tKey:                pulumi.String(\"EXAMPLE_KEY\"),\n\t\t\tValue:              pulumi.String(\"example\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.PipelineSchedule;\nimport com.pulumi.gitlab.PipelineScheduleArgs;\nimport com.pulumi.gitlab.PipelineScheduleVariable;\nimport com.pulumi.gitlab.PipelineScheduleVariableArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var examplePipelineSchedule = new PipelineSchedule(\"examplePipelineSchedule\", PipelineScheduleArgs.builder()        \n            .project(\"12345\")\n            .description(\"Used to schedule builds\")\n            .ref(\"master\")\n            .cron(\"0 1 * * *\")\n            .build());\n\n        var examplePipelineScheduleVariable = new PipelineScheduleVariable(\"examplePipelineScheduleVariable\", PipelineScheduleVariableArgs.builder()        \n            .project(examplePipelineSchedule.project())\n            .pipelineScheduleId(examplePipelineSchedule.id())\n            .key(\"EXAMPLE_KEY\")\n            .value(\"example\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  examplePipelineSchedule:\n    type: gitlab:PipelineSchedule\n    properties:\n      project: '12345'\n      description: Used to schedule builds\n      ref: master\n      cron: 0 1 * * *\n  examplePipelineScheduleVariable:\n    type: gitlab:PipelineScheduleVariable\n    properties:\n      project: ${examplePipelineSchedule.project}\n      pipelineScheduleId: ${examplePipelineSchedule.id}\n      key: EXAMPLE_KEY\n      value: example\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nPipeline schedule variables can be imported using an id made up of `project_id:pipeline_schedule_id:key`, e.g.\n\n```sh\n $ pulumi import gitlab:index/pipelineScheduleVariable:PipelineScheduleVariable example 123456789:13:mykey\n```\n\n ",
            "properties": {
                "key": {
                    "type": "string",
                    "description": "Name of the variable.\n"
                },
                "pipelineScheduleId": {
                    "type": "integer",
                    "description": "The id of the pipeline schedule.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The id of the project to add the schedule to.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of the variable.\n"
                }
            },
            "required": [
                "key",
                "pipelineScheduleId",
                "project",
                "value"
            ],
            "inputProperties": {
                "key": {
                    "type": "string",
                    "description": "Name of the variable.\n",
                    "willReplaceOnChanges": true
                },
                "pipelineScheduleId": {
                    "type": "integer",
                    "description": "The id of the pipeline schedule.\n",
                    "willReplaceOnChanges": true
                },
                "project": {
                    "type": "string",
                    "description": "The id of the project to add the schedule to.\n",
                    "willReplaceOnChanges": true
                },
                "value": {
                    "type": "string",
                    "description": "Value of the variable.\n"
                }
            },
            "requiredInputs": [
                "key",
                "pipelineScheduleId",
                "project",
                "value"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PipelineScheduleVariable resources.\n",
                "properties": {
                    "key": {
                        "type": "string",
                        "description": "Name of the variable.\n",
                        "willReplaceOnChanges": true
                    },
                    "pipelineScheduleId": {
                        "type": "integer",
                        "description": "The id of the pipeline schedule.\n",
                        "willReplaceOnChanges": true
                    },
                    "project": {
                        "type": "string",
                        "description": "The id of the project to add the schedule to.\n",
                        "willReplaceOnChanges": true
                    },
                    "value": {
                        "type": "string",
                        "description": "Value of the variable.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/pipelineTrigger:PipelineTrigger": {
            "description": "The `gitlab.PipelineTrigger` resource allows to manage the lifecycle of a pipeline trigger.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/pipeline_triggers.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = new gitlab.PipelineTrigger(\"example\", {\n    description: \"Used to trigger builds\",\n    project: \"12345\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.PipelineTrigger(\"example\",\n    description=\"Used to trigger builds\",\n    project=\"12345\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new GitLab.PipelineTrigger(\"example\", new()\n    {\n        Description = \"Used to trigger builds\",\n        Project = \"12345\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewPipelineTrigger(ctx, \"example\", \u0026gitlab.PipelineTriggerArgs{\n\t\t\tDescription: pulumi.String(\"Used to trigger builds\"),\n\t\t\tProject:     pulumi.String(\"12345\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.PipelineTrigger;\nimport com.pulumi.gitlab.PipelineTriggerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new PipelineTrigger(\"example\", PipelineTriggerArgs.builder()        \n            .description(\"Used to trigger builds\")\n            .project(\"12345\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: gitlab:PipelineTrigger\n    properties:\n      description: Used to trigger builds\n      project: '12345'\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitLab pipeline triggers can be imported using an id made up of `{project_id}:{pipeline_trigger_id}`, e.g.\n\n```sh\n $ pulumi import gitlab:index/pipelineTrigger:PipelineTrigger test 1:3\n```\n\n ",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "The description of the pipeline trigger.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the trigger to.\n"
                },
                "token": {
                    "type": "string",
                    "description": "The pipeline trigger token.\n",
                    "secret": true
                }
            },
            "required": [
                "description",
                "project",
                "token"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "The description of the pipeline trigger.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the trigger to.\n"
                }
            },
            "requiredInputs": [
                "description",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PipelineTrigger resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "The description of the pipeline trigger.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project to add the trigger to.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "The pipeline trigger token.\n",
                        "secret": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/project:Project": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = new gitlab.Project(\"example\", {\n    description: \"My awesome codebase\",\n    visibilityLevel: \"public\",\n});\n// Project with custom push rules\nconst example_two = new gitlab.Project(\"example-two\", {pushRules: {\n    authorEmailRegex: \"@example\\\\.com$\",\n    commitCommitterCheck: true,\n    memberCheck: true,\n    preventSecrets: true,\n}});\nconst peterParker = gitlab.getUser({\n    username: \"peter_parker\",\n});\nconst petersRepo = new gitlab.Project(\"petersRepo\", {\n    description: \"This is a description\",\n    namespaceId: peterParker.then(peterParker =\u003e peterParker.namespaceId),\n});\n// Fork a project\nconst forkProject = new gitlab.Project(\"forkProject\", {\n    description: \"This is a fork\",\n    forkedFromProjectId: example.id,\n});\n// Fork a project and setup a pull mirror\nconst forkIndex_projectProject = new gitlab.Project(\"forkIndex/projectProject\", {\n    description: \"This is a fork\",\n    forkedFromProjectId: example.id,\n    importUrl: example.httpUrlToRepo,\n    mirror: true,\n});\n// Create a project by importing it from a public project\nconst importPublic = new gitlab.Project(\"importPublic\", {importUrl: \"https://gitlab.example.com/repo.git\"});\n// Create a project by importing it from a public project and setup the pull mirror\nconst importPublicWithMirror = new gitlab.Project(\"importPublicWithMirror\", {\n    importUrl: \"https://gitlab.example.com/repo.git\",\n    mirror: true,\n});\n// Create a project by importing it from a private project\nconst importPrivateProject = new gitlab.Project(\"importPrivateProject\", {\n    importUrl: \"https://gitlab.example.com/repo.git\",\n    importUrlUsername: \"user\",\n    importUrlPassword: \"pass\",\n});\n// Create a project by importing it from a private project and setup the pull mirror\nconst importPrivateWithMirror = new gitlab.Project(\"importPrivateWithMirror\", {\n    importUrl: \"https://gitlab.example.com/repo.git\",\n    importUrlUsername: \"user\",\n    importUrlPassword: \"pass\",\n    mirror: true,\n});\n// Create a project by importing it from a private project and provide credentials in `import_url`\n// NOTE: only use this if you really must, use `import_url_username` and `import_url_password` whenever possible\n//       GitLab API will always return the `import_url` without credentials, therefore you must ignore the `import_url` for changes:\nconst importPrivateIndex_projectProject = new gitlab.Project(\"importPrivateIndex/projectProject\", {importUrl: \"https://user:pass@gitlab.example.com/repo.git\"});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.Project(\"example\",\n    description=\"My awesome codebase\",\n    visibility_level=\"public\")\n# Project with custom push rules\nexample_two = gitlab.Project(\"example-two\", push_rules=gitlab.ProjectPushRulesArgs(\n    author_email_regex=\"@example\\\\.com$\",\n    commit_committer_check=True,\n    member_check=True,\n    prevent_secrets=True,\n))\npeter_parker = gitlab.get_user(username=\"peter_parker\")\npeters_repo = gitlab.Project(\"petersRepo\",\n    description=\"This is a description\",\n    namespace_id=peter_parker.namespace_id)\n# Fork a project\nfork_project = gitlab.Project(\"forkProject\",\n    description=\"This is a fork\",\n    forked_from_project_id=example.id)\n# Fork a project and setup a pull mirror\nfork_index_project_project = gitlab.Project(\"forkIndex/projectProject\",\n    description=\"This is a fork\",\n    forked_from_project_id=example.id,\n    import_url=example.http_url_to_repo,\n    mirror=True)\n# Create a project by importing it from a public project\nimport_public = gitlab.Project(\"importPublic\", import_url=\"https://gitlab.example.com/repo.git\")\n# Create a project by importing it from a public project and setup the pull mirror\nimport_public_with_mirror = gitlab.Project(\"importPublicWithMirror\",\n    import_url=\"https://gitlab.example.com/repo.git\",\n    mirror=True)\n# Create a project by importing it from a private project\nimport_private_project = gitlab.Project(\"importPrivateProject\",\n    import_url=\"https://gitlab.example.com/repo.git\",\n    import_url_username=\"user\",\n    import_url_password=\"pass\")\n# Create a project by importing it from a private project and setup the pull mirror\nimport_private_with_mirror = gitlab.Project(\"importPrivateWithMirror\",\n    import_url=\"https://gitlab.example.com/repo.git\",\n    import_url_username=\"user\",\n    import_url_password=\"pass\",\n    mirror=True)\n# Create a project by importing it from a private project and provide credentials in `import_url`\n# NOTE: only use this if you really must, use `import_url_username` and `import_url_password` whenever possible\n#       GitLab API will always return the `import_url` without credentials, therefore you must ignore the `import_url` for changes:\nimport_private_index_project_project = gitlab.Project(\"importPrivateIndex/projectProject\", import_url=\"https://user:pass@gitlab.example.com/repo.git\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new GitLab.Project(\"example\", new()\n    {\n        Description = \"My awesome codebase\",\n        VisibilityLevel = \"public\",\n    });\n\n    // Project with custom push rules\n    var example_two = new GitLab.Project(\"example-two\", new()\n    {\n        PushRules = new GitLab.Inputs.ProjectPushRulesArgs\n        {\n            AuthorEmailRegex = \"@example\\\\.com$\",\n            CommitCommitterCheck = true,\n            MemberCheck = true,\n            PreventSecrets = true,\n        },\n    });\n\n    var peterParker = GitLab.GetUser.Invoke(new()\n    {\n        Username = \"peter_parker\",\n    });\n\n    var petersRepo = new GitLab.Project(\"petersRepo\", new()\n    {\n        Description = \"This is a description\",\n        NamespaceId = peterParker.Apply(getUserResult =\u003e getUserResult.NamespaceId),\n    });\n\n    // Fork a project\n    var forkProject = new GitLab.Project(\"forkProject\", new()\n    {\n        Description = \"This is a fork\",\n        ForkedFromProjectId = example.Id,\n    });\n\n    // Fork a project and setup a pull mirror\n    var forkIndex_projectProject = new GitLab.Project(\"forkIndex/projectProject\", new()\n    {\n        Description = \"This is a fork\",\n        ForkedFromProjectId = example.Id,\n        ImportUrl = example.HttpUrlToRepo,\n        Mirror = true,\n    });\n\n    // Create a project by importing it from a public project\n    var importPublic = new GitLab.Project(\"importPublic\", new()\n    {\n        ImportUrl = \"https://gitlab.example.com/repo.git\",\n    });\n\n    // Create a project by importing it from a public project and setup the pull mirror\n    var importPublicWithMirror = new GitLab.Project(\"importPublicWithMirror\", new()\n    {\n        ImportUrl = \"https://gitlab.example.com/repo.git\",\n        Mirror = true,\n    });\n\n    // Create a project by importing it from a private project\n    var importPrivateProject = new GitLab.Project(\"importPrivateProject\", new()\n    {\n        ImportUrl = \"https://gitlab.example.com/repo.git\",\n        ImportUrlUsername = \"user\",\n        ImportUrlPassword = \"pass\",\n    });\n\n    // Create a project by importing it from a private project and setup the pull mirror\n    var importPrivateWithMirror = new GitLab.Project(\"importPrivateWithMirror\", new()\n    {\n        ImportUrl = \"https://gitlab.example.com/repo.git\",\n        ImportUrlUsername = \"user\",\n        ImportUrlPassword = \"pass\",\n        Mirror = true,\n    });\n\n    // Create a project by importing it from a private project and provide credentials in `import_url`\n    // NOTE: only use this if you really must, use `import_url_username` and `import_url_password` whenever possible\n    //       GitLab API will always return the `import_url` without credentials, therefore you must ignore the `import_url` for changes:\n    var importPrivateIndex_projectProject = new GitLab.Project(\"importPrivateIndex/projectProject\", new()\n    {\n        ImportUrl = \"https://user:pass@gitlab.example.com/repo.git\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := gitlab.NewProject(ctx, \"example\", \u0026gitlab.ProjectArgs{\n\t\t\tDescription:     pulumi.String(\"My awesome codebase\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProject(ctx, \"example-two\", \u0026gitlab.ProjectArgs{\n\t\t\tPushRules: \u0026gitlab.ProjectPushRulesArgs{\n\t\t\t\tAuthorEmailRegex:     pulumi.String(\"@example\\\\.com$\"),\n\t\t\t\tCommitCommitterCheck: pulumi.Bool(true),\n\t\t\t\tMemberCheck:          pulumi.Bool(true),\n\t\t\t\tPreventSecrets:       pulumi.Bool(true),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpeterParker, err := gitlab.LookupUser(ctx, \u0026gitlab.LookupUserArgs{\n\t\t\tUsername: pulumi.StringRef(\"peter_parker\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProject(ctx, \"petersRepo\", \u0026gitlab.ProjectArgs{\n\t\t\tDescription: pulumi.String(\"This is a description\"),\n\t\t\tNamespaceId: *pulumi.Int(peterParker.NamespaceId),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProject(ctx, \"forkProject\", \u0026gitlab.ProjectArgs{\n\t\t\tDescription:         pulumi.String(\"This is a fork\"),\n\t\t\tForkedFromProjectId: example.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProject(ctx, \"forkIndex/projectProject\", \u0026gitlab.ProjectArgs{\n\t\t\tDescription:         pulumi.String(\"This is a fork\"),\n\t\t\tForkedFromProjectId: example.ID(),\n\t\t\tImportUrl:           example.HttpUrlToRepo,\n\t\t\tMirror:              pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProject(ctx, \"importPublic\", \u0026gitlab.ProjectArgs{\n\t\t\tImportUrl: pulumi.String(\"https://gitlab.example.com/repo.git\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProject(ctx, \"importPublicWithMirror\", \u0026gitlab.ProjectArgs{\n\t\t\tImportUrl: pulumi.String(\"https://gitlab.example.com/repo.git\"),\n\t\t\tMirror:    pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProject(ctx, \"importPrivateProject\", \u0026gitlab.ProjectArgs{\n\t\t\tImportUrl:         pulumi.String(\"https://gitlab.example.com/repo.git\"),\n\t\t\tImportUrlUsername: pulumi.String(\"user\"),\n\t\t\tImportUrlPassword: pulumi.String(\"pass\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProject(ctx, \"importPrivateWithMirror\", \u0026gitlab.ProjectArgs{\n\t\t\tImportUrl:         pulumi.String(\"https://gitlab.example.com/repo.git\"),\n\t\t\tImportUrlUsername: pulumi.String(\"user\"),\n\t\t\tImportUrlPassword: pulumi.String(\"pass\"),\n\t\t\tMirror:            pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProject(ctx, \"importPrivateIndex/projectProject\", \u0026gitlab.ProjectArgs{\n\t\t\tImportUrl: pulumi.String(\"https://user:pass@gitlab.example.com/repo.git\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.inputs.ProjectPushRulesArgs;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetUserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Project(\"example\", ProjectArgs.builder()        \n            .description(\"My awesome codebase\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var example_two = new Project(\"example-two\", ProjectArgs.builder()        \n            .pushRules(ProjectPushRulesArgs.builder()\n                .authorEmailRegex(\"@example\\\\.com$\")\n                .commitCommitterCheck(true)\n                .memberCheck(true)\n                .preventSecrets(true)\n                .build())\n            .build());\n\n        final var peterParker = GitlabFunctions.getUser(GetUserArgs.builder()\n            .username(\"peter_parker\")\n            .build());\n\n        var petersRepo = new Project(\"petersRepo\", ProjectArgs.builder()        \n            .description(\"This is a description\")\n            .namespaceId(peterParker.applyValue(getUserResult -\u003e getUserResult.namespaceId()))\n            .build());\n\n        var forkProject = new Project(\"forkProject\", ProjectArgs.builder()        \n            .description(\"This is a fork\")\n            .forkedFromProjectId(example.id())\n            .build());\n\n        var forkIndex_projectProject = new Project(\"forkIndex/projectProject\", ProjectArgs.builder()        \n            .description(\"This is a fork\")\n            .forkedFromProjectId(example.id())\n            .importUrl(example.httpUrlToRepo())\n            .mirror(true)\n            .build());\n\n        var importPublic = new Project(\"importPublic\", ProjectArgs.builder()        \n            .importUrl(\"https://gitlab.example.com/repo.git\")\n            .build());\n\n        var importPublicWithMirror = new Project(\"importPublicWithMirror\", ProjectArgs.builder()        \n            .importUrl(\"https://gitlab.example.com/repo.git\")\n            .mirror(true)\n            .build());\n\n        var importPrivateProject = new Project(\"importPrivateProject\", ProjectArgs.builder()        \n            .importUrl(\"https://gitlab.example.com/repo.git\")\n            .importUrlUsername(\"user\")\n            .importUrlPassword(\"pass\")\n            .build());\n\n        var importPrivateWithMirror = new Project(\"importPrivateWithMirror\", ProjectArgs.builder()        \n            .importUrl(\"https://gitlab.example.com/repo.git\")\n            .importUrlUsername(\"user\")\n            .importUrlPassword(\"pass\")\n            .mirror(true)\n            .build());\n\n        var importPrivateIndex_projectProject = new Project(\"importPrivateIndex/projectProject\", ProjectArgs.builder()        \n            .importUrl(\"https://user:pass@gitlab.example.com/repo.git\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: gitlab:Project\n    properties:\n      description: My awesome codebase\n      visibilityLevel: public\n  # Project with custom push rules\n  example-two:\n    type: gitlab:Project\n    properties:\n      pushRules:\n        authorEmailRegex: '@example\\.com$'\n        commitCommitterCheck: true\n        memberCheck: true\n        preventSecrets: true\n  petersRepo:\n    type: gitlab:Project\n    properties:\n      description: This is a description\n      namespaceId: ${peterParker.namespaceId}\n  # Fork a project\n  forkProject:\n    type: gitlab:Project\n    properties:\n      description: This is a fork\n      forkedFromProjectId: ${example.id}\n  # Fork a project and setup a pull mirror\n  forkIndex/projectProject:\n    type: gitlab:Project\n    properties:\n      description: This is a fork\n      forkedFromProjectId: ${example.id}\n      importUrl: ${example.httpUrlToRepo}\n      mirror: true\n  # Create a project by importing it from a public project\n  importPublic:\n    type: gitlab:Project\n    properties:\n      importUrl: https://gitlab.example.com/repo.git\n  # Create a project by importing it from a public project and setup the pull mirror\n  importPublicWithMirror:\n    type: gitlab:Project\n    properties:\n      importUrl: https://gitlab.example.com/repo.git\n      mirror: true\n  # Create a project by importing it from a private project\n  importPrivateProject:\n    type: gitlab:Project\n    properties:\n      importUrl: https://gitlab.example.com/repo.git\n      importUrlUsername: user\n      importUrlPassword: pass\n  # Create a project by importing it from a private project and setup the pull mirror\n  importPrivateWithMirror:\n    type: gitlab:Project\n    properties:\n      importUrl: https://gitlab.example.com/repo.git\n      importUrlUsername: user\n      importUrlPassword: pass\n      mirror: true\n  # Create a project by importing it from a private project and provide credentials in `import_url`\n  # NOTE: only use this if you really must, use `import_url_username` and `import_url_password` whenever possible\n  #       GitLab API will always return the `import_url` without credentials, therefore you must ignore the `import_url` for changes:\n  importPrivateIndex/projectProject:\n    type: gitlab:Project\n    properties:\n      importUrl: https://user:pass@gitlab.example.com/repo.git\nvariables:\n  peterParker:\n    fn::invoke:\n      Function: gitlab:getUser\n      Arguments:\n        username: peter_parker\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import gitlab:index/project:Project You can import a project state using `\u003cresource\u003e \u003cid\u003e`. The\n```\n\n `id` can be whatever the [get single project api][get_single_project] takes for its `:id` value, so for example\n\n```sh\n $ pulumi import gitlab:index/project:Project example richardc/example\n```\n\n NOTEthe `import_url_username` and `import_url_password` cannot be imported. ",
            "properties": {
                "allowMergeOnSkippedPipeline": {
                    "type": "boolean",
                    "description": "Set to true if you want to treat skipped pipelines as if they finished with success.\n"
                },
                "analyticsAccessLevel": {
                    "type": "string",
                    "description": "Set the analytics access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "approvalsBeforeMerge": {
                    "type": "integer",
                    "description": "Number of merge request approvals required for merging. Default is 0.\nThis field **does not** work well in combination with the `gitlab.ProjectApprovalRule` resource\nand is most likely gonna be deprecated in a future GitLab version (see [this upstream epic](https://gitlab.com/groups/gitlab-org/-/epics/7572)).\nIn the meantime we recommend against using this attribute and use `gitlab.ProjectApprovalRule` instead.\n"
                },
                "archiveOnDestroy": {
                    "type": "boolean",
                    "description": "Set to `true` to archive the project instead of deleting on destroy. If set to `true` it will entire omit the `DELETE` operation.\n"
                },
                "archived": {
                    "type": "boolean",
                    "description": "Whether the project is in read-only mode (archived). Repositories can be archived/unarchived by toggling this parameter.\n"
                },
                "autoCancelPendingPipelines": {
                    "type": "string",
                    "description": "Auto-cancel pending pipelines. This isn’t a boolean, but enabled/disabled.\n"
                },
                "autoDevopsDeployStrategy": {
                    "type": "string",
                    "description": "Auto Deploy strategy. Valid values are `continuous`, `manual`, `timed_incremental`.\n"
                },
                "autoDevopsEnabled": {
                    "type": "boolean",
                    "description": "Enable Auto DevOps for this project.\n"
                },
                "autocloseReferencedIssues": {
                    "type": "boolean",
                    "description": "Set whether auto-closing referenced issues on default branch.\n"
                },
                "avatar": {
                    "type": "string",
                    "description": "A local path to the avatar image to upload. **Note**: not available for imported resources.\n"
                },
                "avatarHash": {
                    "type": "string",
                    "description": "The hash of the avatar image. Use `filesha256(\"path/to/avatar.png\")` whenever possible. **Note**: this is used to trigger an update of the avatar. If it's not given, but an avatar is given, the avatar will be updated each time.\n"
                },
                "avatarUrl": {
                    "type": "string",
                    "description": "The URL of the avatar image.\n"
                },
                "buildCoverageRegex": {
                    "type": "string",
                    "description": "Test coverage parsing for the project. This is deprecated feature in GitLab 15.0.\n",
                    "deprecationMessage": "build_coverage_regex is removed in GitLab 15.0."
                },
                "buildGitStrategy": {
                    "type": "string",
                    "description": "The Git strategy. Defaults to fetch.\n"
                },
                "buildTimeout": {
                    "type": "integer",
                    "description": "The maximum amount of time, in seconds, that a job can run.\n"
                },
                "buildsAccessLevel": {
                    "type": "string",
                    "description": "Set the builds access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "ciConfigPath": {
                    "type": "string",
                    "description": "Custom Path to CI config file.\n"
                },
                "ciDefaultGitDepth": {
                    "type": "integer",
                    "description": "Default number of revisions for shallow cloning.\n"
                },
                "ciForwardDeploymentEnabled": {
                    "type": "boolean",
                    "description": "When a new deployment job starts, skip older deployment jobs that are still pending.\n"
                },
                "ciSeparatedCaches": {
                    "type": "boolean",
                    "description": "Use separate caches for protected branches.\n"
                },
                "containerExpirationPolicy": {
                    "$ref": "#/types/gitlab:index/ProjectContainerExpirationPolicy:ProjectContainerExpirationPolicy",
                    "description": "Set the image cleanup policy for this project. **Note**: this field is sometimes named `container_expiration_policy_attributes` in the GitLab Upstream API.\n"
                },
                "containerRegistryAccessLevel": {
                    "type": "string",
                    "description": "Set visibility of container registry, for this project. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "containerRegistryEnabled": {
                    "type": "boolean",
                    "description": "Enable container registry for the project.\n",
                    "deprecationMessage": "Use `container_registry_access_level` instead."
                },
                "defaultBranch": {
                    "type": "string",
                    "description": "The default branch for the project.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description of the project.\n"
                },
                "emailsDisabled": {
                    "type": "boolean",
                    "description": "Disable email notifications.\n"
                },
                "environmentsAccessLevel": {
                    "type": "string",
                    "description": "Set the environments access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "externalAuthorizationClassificationLabel": {
                    "type": "string",
                    "description": "The classification label for the project.\n"
                },
                "featureFlagsAccessLevel": {
                    "type": "string",
                    "description": "Set the feature flags access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "forkedFromProjectId": {
                    "type": "integer",
                    "description": "The id of the project to fork. During create the project is forked and during an update the fork relation is changed.\n"
                },
                "forkingAccessLevel": {
                    "type": "string",
                    "description": "Set the forking access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "groupWithProjectTemplatesId": {
                    "type": "integer",
                    "description": "For group-level custom templates, specifies ID of group from which all the custom project templates are sourced. Leave empty for instance-level templates. Requires use*custom*template to be true (enterprise edition).\n"
                },
                "httpUrlToRepo": {
                    "type": "string",
                    "description": "URL that can be provided to `git clone` to clone the\n"
                },
                "importUrl": {
                    "type": "string",
                    "description": "Git URL to a repository to be imported. Together with `mirror = true` it will setup a Pull Mirror. This can also be used\ntogether with `forked_from_project_id` to setup a Pull Mirror for a fork. The fork takes precedence over the import.\nMake sure to provide the credentials in `import_url_username` and `import_url_password`. GitLab never returns the\ncredentials, thus the provider cannot detect configuration drift in the credentials. They can also not be imported using\n`terraform import`. See the examples section for how to properly use it.\n"
                },
                "importUrlPassword": {
                    "type": "string",
                    "description": "The password for the `import_url`. The value of this field is used to construct a valid `import_url` and is only related\nto the provider. This field cannot be imported using `terraform import`. See the examples section for how to properly\nuse it.\n",
                    "secret": true
                },
                "importUrlUsername": {
                    "type": "string",
                    "description": "The username for the `import_url`. The value of this field is used to construct a valid `import_url` and is only related\nto the provider. This field cannot be imported using `terraform import`. See the examples section for how to properly\nuse it.\n"
                },
                "infrastructureAccessLevel": {
                    "type": "string",
                    "description": "Set the infrastructure access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "initializeWithReadme": {
                    "type": "boolean",
                    "description": "Create main branch with first commit containing a README.md file.\n"
                },
                "issuesAccessLevel": {
                    "type": "string",
                    "description": "Set the issues access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "issuesEnabled": {
                    "type": "boolean",
                    "description": "Enable issue tracking for the project.\n"
                },
                "issuesTemplate": {
                    "type": "string",
                    "description": "Sets the template for new issues in the project.\n"
                },
                "keepLatestArtifact": {
                    "type": "boolean",
                    "description": "Disable or enable the ability to keep the latest artifact for this project.\n"
                },
                "lfsEnabled": {
                    "type": "boolean",
                    "description": "Enable LFS for the project.\n"
                },
                "mergeCommitTemplate": {
                    "type": "string",
                    "description": "Template used to create merge commit message in merge requests. (Introduced in GitLab 14.5.)\n"
                },
                "mergeMethod": {
                    "type": "string",
                    "description": "Set the merge method. Valid values are `merge`, `rebase_merge`, `ff`.\n"
                },
                "mergePipelinesEnabled": {
                    "type": "boolean",
                    "description": "Enable or disable merge pipelines.\n"
                },
                "mergeRequestsAccessLevel": {
                    "type": "string",
                    "description": "Set the merge requests access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "mergeRequestsEnabled": {
                    "type": "boolean",
                    "description": "Enable merge requests for the project.\n"
                },
                "mergeRequestsTemplate": {
                    "type": "string",
                    "description": "Sets the template for new merge requests in the project.\n"
                },
                "mergeTrainsEnabled": {
                    "type": "boolean",
                    "description": "Enable or disable merge trains. Requires `merge_pipelines_enabled` to be set to `true` to take effect.\n"
                },
                "mirror": {
                    "type": "boolean",
                    "description": "Enable project pull mirror.\n"
                },
                "mirrorOverwritesDivergedBranches": {
                    "type": "boolean",
                    "description": "Enable overwrite diverged branches for a mirrored project.\n"
                },
                "mirrorTriggerBuilds": {
                    "type": "boolean",
                    "description": "Enable trigger builds on pushes for a mirrored project.\n"
                },
                "monitorAccessLevel": {
                    "type": "string",
                    "description": "Set the monitor access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "mrDefaultTargetSelf": {
                    "type": "boolean",
                    "description": "For forked projects, target merge requests to this project. If false, the target will be the upstream project.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the project.\n"
                },
                "namespaceId": {
                    "type": "integer",
                    "description": "The namespace (group or user) of the project. Defaults to your user.\n"
                },
                "onlyAllowMergeIfAllDiscussionsAreResolved": {
                    "type": "boolean",
                    "description": "Set to true if you want allow merges only if all discussions are resolved.\n"
                },
                "onlyAllowMergeIfPipelineSucceeds": {
                    "type": "boolean",
                    "description": "Set to true if you want allow merges only if a pipeline succeeds.\n"
                },
                "onlyMirrorProtectedBranches": {
                    "type": "boolean",
                    "description": "Enable only mirror protected branches for a mirrored project.\n"
                },
                "operationsAccessLevel": {
                    "type": "string",
                    "description": "Set the operations access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "packagesEnabled": {
                    "type": "boolean",
                    "description": "Enable packages repository for the project.\n"
                },
                "pagesAccessLevel": {
                    "type": "string",
                    "description": "Enable pages access control\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path of the repository.\n"
                },
                "pathWithNamespace": {
                    "type": "string",
                    "description": "The path of the repository with namespace.\n"
                },
                "pipelinesEnabled": {
                    "type": "boolean",
                    "description": "Enable pipelines for the project. The `pipelines_enabled` field is being sent as `jobs_enabled` in the GitLab API calls.\n",
                    "deprecationMessage": "Deprecated in favor of `builds_access_level`"
                },
                "printingMergeRequestLinkEnabled": {
                    "type": "boolean",
                    "description": "Show link to create/view merge request when pushing from the command line\n"
                },
                "publicBuilds": {
                    "type": "boolean",
                    "description": "If true, jobs can be viewed by non-project members.\n"
                },
                "pushRules": {
                    "$ref": "#/types/gitlab:index/ProjectPushRules:ProjectPushRules",
                    "description": "Push rules for the project.\n"
                },
                "releasesAccessLevel": {
                    "type": "string",
                    "description": "Set the releases access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "removeSourceBranchAfterMerge": {
                    "type": "boolean",
                    "description": "Enable `Delete source branch` option by default for all new merge requests.\n"
                },
                "repositoryAccessLevel": {
                    "type": "string",
                    "description": "Set the repository access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "repositoryStorage": {
                    "type": "string",
                    "description": "Which storage shard the repository is on. (administrator only)\n"
                },
                "requestAccessEnabled": {
                    "type": "boolean",
                    "description": "Allow users to request member access.\n"
                },
                "requirementsAccessLevel": {
                    "type": "string",
                    "description": "Set the requirements access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "resolveOutdatedDiffDiscussions": {
                    "type": "boolean",
                    "description": "Automatically resolve merge request diffs discussions on lines changed with a push.\n"
                },
                "restrictUserDefinedVariables": {
                    "type": "boolean",
                    "description": "Allow only users with the Maintainer role to pass user-defined variables when triggering a pipeline.\n"
                },
                "runnersToken": {
                    "type": "string",
                    "description": "Registration token to use during runner setup.\n",
                    "secret": true
                },
                "securityAndComplianceAccessLevel": {
                    "type": "string",
                    "description": "Set the security and compliance access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "sharedRunnersEnabled": {
                    "type": "boolean",
                    "description": "Enable shared runners for this project.\n"
                },
                "skipWaitForDefaultBranchProtection": {
                    "type": "boolean",
                    "description": "If `true`, the default behavior to wait for the default branch protection to be created is skipped.\nThis is necessary if the current user is not an admin and the default branch protection is disabled on an instance-level.\nThere is currently no known way to determine if the default branch protection is disabled on an instance-level for non-admin users.\nThis attribute is only used during resource creation, thus changes are suppressed and the attribute cannot be imported.\n"
                },
                "snippetsAccessLevel": {
                    "type": "string",
                    "description": "Set the snippets access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "snippetsEnabled": {
                    "type": "boolean",
                    "description": "Enable snippets for the project.\n"
                },
                "squashCommitTemplate": {
                    "type": "string",
                    "description": "Template used to create squash commit message in merge requests. (Introduced in GitLab 14.6.)\n"
                },
                "squashOption": {
                    "type": "string",
                    "description": "Squash commits when merge request. Valid values are `never`, `always`, `default_on`, or `default_off`. The default value is `default_off`. [GitLab \u003e= 14.1]\n"
                },
                "sshUrlToRepo": {
                    "type": "string",
                    "description": "URL that can be provided to `git clone` to clone the\n"
                },
                "suggestionCommitMessage": {
                    "type": "string",
                    "description": "The commit message used to apply merge request suggestions.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of tags for a project; put array of tags, that should be finally assigned to a project. Use topics instead.\n"
                },
                "templateName": {
                    "type": "string",
                    "description": "When used without use*custom*template, name of a built-in project template. When used with use*custom*template, name of a custom project template. This option is mutually exclusive with `template_project_id`.\n"
                },
                "templateProjectId": {
                    "type": "integer",
                    "description": "When used with use*custom*template, project ID of a custom project template. This is preferable to using template*name since template*name may be ambiguous (enterprise edition). This option is mutually exclusive with `template_name`. See `gitlab.GroupProjectFileTemplate` to set a project as a template project. If a project has not been set as a template, using it here will result in an error.\n"
                },
                "topics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of topics for the project.\n"
                },
                "useCustomTemplate": {
                    "type": "boolean",
                    "description": "Use either custom instance or group (with group*with*project*templates*id) project template (enterprise edition).\n\t\u003e When using a custom template, [Group Tokens won't work](https://docs.gitlab.com/15.7/ee/user/project/settings/import_export_troubleshooting.html#import-using-the-rest-api-fails-when-using-a-group-access-token). You must use a real user's Personal Access Token.\n"
                },
                "visibilityLevel": {
                    "type": "string",
                    "description": "Set to `public` to create a public project.\n"
                },
                "webUrl": {
                    "type": "string",
                    "description": "URL that can be used to find the project in a browser.\n"
                },
                "wikiAccessLevel": {
                    "type": "string",
                    "description": "Set the wiki access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "wikiEnabled": {
                    "type": "boolean",
                    "description": "Enable wiki for the project.\n"
                }
            },
            "required": [
                "allowMergeOnSkippedPipeline",
                "analyticsAccessLevel",
                "autoCancelPendingPipelines",
                "autoDevopsDeployStrategy",
                "autoDevopsEnabled",
                "autocloseReferencedIssues",
                "avatarHash",
                "avatarUrl",
                "buildGitStrategy",
                "buildTimeout",
                "buildsAccessLevel",
                "ciDefaultGitDepth",
                "ciForwardDeploymentEnabled",
                "ciSeparatedCaches",
                "containerExpirationPolicy",
                "containerRegistryAccessLevel",
                "containerRegistryEnabled",
                "defaultBranch",
                "environmentsAccessLevel",
                "featureFlagsAccessLevel",
                "forkingAccessLevel",
                "httpUrlToRepo",
                "infrastructureAccessLevel",
                "issuesAccessLevel",
                "issuesEnabled",
                "keepLatestArtifact",
                "lfsEnabled",
                "mergeMethod",
                "mergePipelinesEnabled",
                "mergeRequestsAccessLevel",
                "mergeRequestsEnabled",
                "mergeTrainsEnabled",
                "mirrorOverwritesDivergedBranches",
                "mirrorTriggerBuilds",
                "monitorAccessLevel",
                "name",
                "namespaceId",
                "onlyAllowMergeIfAllDiscussionsAreResolved",
                "onlyAllowMergeIfPipelineSucceeds",
                "onlyMirrorProtectedBranches",
                "operationsAccessLevel",
                "packagesEnabled",
                "pagesAccessLevel",
                "pathWithNamespace",
                "pipelinesEnabled",
                "printingMergeRequestLinkEnabled",
                "publicBuilds",
                "pushRules",
                "releasesAccessLevel",
                "removeSourceBranchAfterMerge",
                "repositoryAccessLevel",
                "repositoryStorage",
                "requestAccessEnabled",
                "requirementsAccessLevel",
                "runnersToken",
                "securityAndComplianceAccessLevel",
                "sharedRunnersEnabled",
                "snippetsAccessLevel",
                "snippetsEnabled",
                "squashOption",
                "sshUrlToRepo",
                "tags",
                "topics",
                "visibilityLevel",
                "webUrl",
                "wikiAccessLevel",
                "wikiEnabled"
            ],
            "inputProperties": {
                "allowMergeOnSkippedPipeline": {
                    "type": "boolean",
                    "description": "Set to true if you want to treat skipped pipelines as if they finished with success.\n"
                },
                "analyticsAccessLevel": {
                    "type": "string",
                    "description": "Set the analytics access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "approvalsBeforeMerge": {
                    "type": "integer",
                    "description": "Number of merge request approvals required for merging. Default is 0.\nThis field **does not** work well in combination with the `gitlab.ProjectApprovalRule` resource\nand is most likely gonna be deprecated in a future GitLab version (see [this upstream epic](https://gitlab.com/groups/gitlab-org/-/epics/7572)).\nIn the meantime we recommend against using this attribute and use `gitlab.ProjectApprovalRule` instead.\n"
                },
                "archiveOnDestroy": {
                    "type": "boolean",
                    "description": "Set to `true` to archive the project instead of deleting on destroy. If set to `true` it will entire omit the `DELETE` operation.\n"
                },
                "archived": {
                    "type": "boolean",
                    "description": "Whether the project is in read-only mode (archived). Repositories can be archived/unarchived by toggling this parameter.\n"
                },
                "autoCancelPendingPipelines": {
                    "type": "string",
                    "description": "Auto-cancel pending pipelines. This isn’t a boolean, but enabled/disabled.\n"
                },
                "autoDevopsDeployStrategy": {
                    "type": "string",
                    "description": "Auto Deploy strategy. Valid values are `continuous`, `manual`, `timed_incremental`.\n"
                },
                "autoDevopsEnabled": {
                    "type": "boolean",
                    "description": "Enable Auto DevOps for this project.\n"
                },
                "autocloseReferencedIssues": {
                    "type": "boolean",
                    "description": "Set whether auto-closing referenced issues on default branch.\n"
                },
                "avatar": {
                    "type": "string",
                    "description": "A local path to the avatar image to upload. **Note**: not available for imported resources.\n"
                },
                "avatarHash": {
                    "type": "string",
                    "description": "The hash of the avatar image. Use `filesha256(\"path/to/avatar.png\")` whenever possible. **Note**: this is used to trigger an update of the avatar. If it's not given, but an avatar is given, the avatar will be updated each time.\n"
                },
                "buildCoverageRegex": {
                    "type": "string",
                    "description": "Test coverage parsing for the project. This is deprecated feature in GitLab 15.0.\n",
                    "deprecationMessage": "build_coverage_regex is removed in GitLab 15.0."
                },
                "buildGitStrategy": {
                    "type": "string",
                    "description": "The Git strategy. Defaults to fetch.\n"
                },
                "buildTimeout": {
                    "type": "integer",
                    "description": "The maximum amount of time, in seconds, that a job can run.\n"
                },
                "buildsAccessLevel": {
                    "type": "string",
                    "description": "Set the builds access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "ciConfigPath": {
                    "type": "string",
                    "description": "Custom Path to CI config file.\n"
                },
                "ciDefaultGitDepth": {
                    "type": "integer",
                    "description": "Default number of revisions for shallow cloning.\n"
                },
                "ciForwardDeploymentEnabled": {
                    "type": "boolean",
                    "description": "When a new deployment job starts, skip older deployment jobs that are still pending.\n"
                },
                "ciSeparatedCaches": {
                    "type": "boolean",
                    "description": "Use separate caches for protected branches.\n"
                },
                "containerExpirationPolicy": {
                    "$ref": "#/types/gitlab:index/ProjectContainerExpirationPolicy:ProjectContainerExpirationPolicy",
                    "description": "Set the image cleanup policy for this project. **Note**: this field is sometimes named `container_expiration_policy_attributes` in the GitLab Upstream API.\n"
                },
                "containerRegistryAccessLevel": {
                    "type": "string",
                    "description": "Set visibility of container registry, for this project. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "containerRegistryEnabled": {
                    "type": "boolean",
                    "description": "Enable container registry for the project.\n",
                    "deprecationMessage": "Use `container_registry_access_level` instead."
                },
                "defaultBranch": {
                    "type": "string",
                    "description": "The default branch for the project.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description of the project.\n"
                },
                "emailsDisabled": {
                    "type": "boolean",
                    "description": "Disable email notifications.\n"
                },
                "environmentsAccessLevel": {
                    "type": "string",
                    "description": "Set the environments access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "externalAuthorizationClassificationLabel": {
                    "type": "string",
                    "description": "The classification label for the project.\n"
                },
                "featureFlagsAccessLevel": {
                    "type": "string",
                    "description": "Set the feature flags access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "forkedFromProjectId": {
                    "type": "integer",
                    "description": "The id of the project to fork. During create the project is forked and during an update the fork relation is changed.\n"
                },
                "forkingAccessLevel": {
                    "type": "string",
                    "description": "Set the forking access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "groupWithProjectTemplatesId": {
                    "type": "integer",
                    "description": "For group-level custom templates, specifies ID of group from which all the custom project templates are sourced. Leave empty for instance-level templates. Requires use*custom*template to be true (enterprise edition).\n"
                },
                "importUrl": {
                    "type": "string",
                    "description": "Git URL to a repository to be imported. Together with `mirror = true` it will setup a Pull Mirror. This can also be used\ntogether with `forked_from_project_id` to setup a Pull Mirror for a fork. The fork takes precedence over the import.\nMake sure to provide the credentials in `import_url_username` and `import_url_password`. GitLab never returns the\ncredentials, thus the provider cannot detect configuration drift in the credentials. They can also not be imported using\n`terraform import`. See the examples section for how to properly use it.\n"
                },
                "importUrlPassword": {
                    "type": "string",
                    "description": "The password for the `import_url`. The value of this field is used to construct a valid `import_url` and is only related\nto the provider. This field cannot be imported using `terraform import`. See the examples section for how to properly\nuse it.\n",
                    "secret": true
                },
                "importUrlUsername": {
                    "type": "string",
                    "description": "The username for the `import_url`. The value of this field is used to construct a valid `import_url` and is only related\nto the provider. This field cannot be imported using `terraform import`. See the examples section for how to properly\nuse it.\n"
                },
                "infrastructureAccessLevel": {
                    "type": "string",
                    "description": "Set the infrastructure access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "initializeWithReadme": {
                    "type": "boolean",
                    "description": "Create main branch with first commit containing a README.md file.\n"
                },
                "issuesAccessLevel": {
                    "type": "string",
                    "description": "Set the issues access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "issuesEnabled": {
                    "type": "boolean",
                    "description": "Enable issue tracking for the project.\n"
                },
                "issuesTemplate": {
                    "type": "string",
                    "description": "Sets the template for new issues in the project.\n"
                },
                "keepLatestArtifact": {
                    "type": "boolean",
                    "description": "Disable or enable the ability to keep the latest artifact for this project.\n"
                },
                "lfsEnabled": {
                    "type": "boolean",
                    "description": "Enable LFS for the project.\n"
                },
                "mergeCommitTemplate": {
                    "type": "string",
                    "description": "Template used to create merge commit message in merge requests. (Introduced in GitLab 14.5.)\n"
                },
                "mergeMethod": {
                    "type": "string",
                    "description": "Set the merge method. Valid values are `merge`, `rebase_merge`, `ff`.\n"
                },
                "mergePipelinesEnabled": {
                    "type": "boolean",
                    "description": "Enable or disable merge pipelines.\n"
                },
                "mergeRequestsAccessLevel": {
                    "type": "string",
                    "description": "Set the merge requests access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "mergeRequestsEnabled": {
                    "type": "boolean",
                    "description": "Enable merge requests for the project.\n"
                },
                "mergeRequestsTemplate": {
                    "type": "string",
                    "description": "Sets the template for new merge requests in the project.\n"
                },
                "mergeTrainsEnabled": {
                    "type": "boolean",
                    "description": "Enable or disable merge trains. Requires `merge_pipelines_enabled` to be set to `true` to take effect.\n"
                },
                "mirror": {
                    "type": "boolean",
                    "description": "Enable project pull mirror.\n"
                },
                "mirrorOverwritesDivergedBranches": {
                    "type": "boolean",
                    "description": "Enable overwrite diverged branches for a mirrored project.\n"
                },
                "mirrorTriggerBuilds": {
                    "type": "boolean",
                    "description": "Enable trigger builds on pushes for a mirrored project.\n"
                },
                "monitorAccessLevel": {
                    "type": "string",
                    "description": "Set the monitor access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "mrDefaultTargetSelf": {
                    "type": "boolean",
                    "description": "For forked projects, target merge requests to this project. If false, the target will be the upstream project.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the project.\n"
                },
                "namespaceId": {
                    "type": "integer",
                    "description": "The namespace (group or user) of the project. Defaults to your user.\n"
                },
                "onlyAllowMergeIfAllDiscussionsAreResolved": {
                    "type": "boolean",
                    "description": "Set to true if you want allow merges only if all discussions are resolved.\n"
                },
                "onlyAllowMergeIfPipelineSucceeds": {
                    "type": "boolean",
                    "description": "Set to true if you want allow merges only if a pipeline succeeds.\n"
                },
                "onlyMirrorProtectedBranches": {
                    "type": "boolean",
                    "description": "Enable only mirror protected branches for a mirrored project.\n"
                },
                "operationsAccessLevel": {
                    "type": "string",
                    "description": "Set the operations access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "packagesEnabled": {
                    "type": "boolean",
                    "description": "Enable packages repository for the project.\n"
                },
                "pagesAccessLevel": {
                    "type": "string",
                    "description": "Enable pages access control\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path of the repository.\n"
                },
                "pipelinesEnabled": {
                    "type": "boolean",
                    "description": "Enable pipelines for the project. The `pipelines_enabled` field is being sent as `jobs_enabled` in the GitLab API calls.\n",
                    "deprecationMessage": "Deprecated in favor of `builds_access_level`"
                },
                "printingMergeRequestLinkEnabled": {
                    "type": "boolean",
                    "description": "Show link to create/view merge request when pushing from the command line\n"
                },
                "publicBuilds": {
                    "type": "boolean",
                    "description": "If true, jobs can be viewed by non-project members.\n"
                },
                "pushRules": {
                    "$ref": "#/types/gitlab:index/ProjectPushRules:ProjectPushRules",
                    "description": "Push rules for the project.\n"
                },
                "releasesAccessLevel": {
                    "type": "string",
                    "description": "Set the releases access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "removeSourceBranchAfterMerge": {
                    "type": "boolean",
                    "description": "Enable `Delete source branch` option by default for all new merge requests.\n"
                },
                "repositoryAccessLevel": {
                    "type": "string",
                    "description": "Set the repository access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "repositoryStorage": {
                    "type": "string",
                    "description": "Which storage shard the repository is on. (administrator only)\n"
                },
                "requestAccessEnabled": {
                    "type": "boolean",
                    "description": "Allow users to request member access.\n"
                },
                "requirementsAccessLevel": {
                    "type": "string",
                    "description": "Set the requirements access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "resolveOutdatedDiffDiscussions": {
                    "type": "boolean",
                    "description": "Automatically resolve merge request diffs discussions on lines changed with a push.\n"
                },
                "restrictUserDefinedVariables": {
                    "type": "boolean",
                    "description": "Allow only users with the Maintainer role to pass user-defined variables when triggering a pipeline.\n"
                },
                "securityAndComplianceAccessLevel": {
                    "type": "string",
                    "description": "Set the security and compliance access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "sharedRunnersEnabled": {
                    "type": "boolean",
                    "description": "Enable shared runners for this project.\n"
                },
                "skipWaitForDefaultBranchProtection": {
                    "type": "boolean",
                    "description": "If `true`, the default behavior to wait for the default branch protection to be created is skipped.\nThis is necessary if the current user is not an admin and the default branch protection is disabled on an instance-level.\nThere is currently no known way to determine if the default branch protection is disabled on an instance-level for non-admin users.\nThis attribute is only used during resource creation, thus changes are suppressed and the attribute cannot be imported.\n"
                },
                "snippetsAccessLevel": {
                    "type": "string",
                    "description": "Set the snippets access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "snippetsEnabled": {
                    "type": "boolean",
                    "description": "Enable snippets for the project.\n"
                },
                "squashCommitTemplate": {
                    "type": "string",
                    "description": "Template used to create squash commit message in merge requests. (Introduced in GitLab 14.6.)\n"
                },
                "squashOption": {
                    "type": "string",
                    "description": "Squash commits when merge request. Valid values are `never`, `always`, `default_on`, or `default_off`. The default value is `default_off`. [GitLab \u003e= 14.1]\n"
                },
                "suggestionCommitMessage": {
                    "type": "string",
                    "description": "The commit message used to apply merge request suggestions.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of tags for a project; put array of tags, that should be finally assigned to a project. Use topics instead.\n"
                },
                "templateName": {
                    "type": "string",
                    "description": "When used without use*custom*template, name of a built-in project template. When used with use*custom*template, name of a custom project template. This option is mutually exclusive with `template_project_id`.\n",
                    "willReplaceOnChanges": true
                },
                "templateProjectId": {
                    "type": "integer",
                    "description": "When used with use*custom*template, project ID of a custom project template. This is preferable to using template*name since template*name may be ambiguous (enterprise edition). This option is mutually exclusive with `template_name`. See `gitlab.GroupProjectFileTemplate` to set a project as a template project. If a project has not been set as a template, using it here will result in an error.\n",
                    "willReplaceOnChanges": true
                },
                "topics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of topics for the project.\n"
                },
                "useCustomTemplate": {
                    "type": "boolean",
                    "description": "Use either custom instance or group (with group*with*project*templates*id) project template (enterprise edition).\n\t\u003e When using a custom template, [Group Tokens won't work](https://docs.gitlab.com/15.7/ee/user/project/settings/import_export_troubleshooting.html#import-using-the-rest-api-fails-when-using-a-group-access-token). You must use a real user's Personal Access Token.\n"
                },
                "visibilityLevel": {
                    "type": "string",
                    "description": "Set to `public` to create a public project.\n"
                },
                "wikiAccessLevel": {
                    "type": "string",
                    "description": "Set the wiki access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "wikiEnabled": {
                    "type": "boolean",
                    "description": "Enable wiki for the project.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Project resources.\n",
                "properties": {
                    "allowMergeOnSkippedPipeline": {
                        "type": "boolean",
                        "description": "Set to true if you want to treat skipped pipelines as if they finished with success.\n"
                    },
                    "analyticsAccessLevel": {
                        "type": "string",
                        "description": "Set the analytics access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "approvalsBeforeMerge": {
                        "type": "integer",
                        "description": "Number of merge request approvals required for merging. Default is 0.\nThis field **does not** work well in combination with the `gitlab.ProjectApprovalRule` resource\nand is most likely gonna be deprecated in a future GitLab version (see [this upstream epic](https://gitlab.com/groups/gitlab-org/-/epics/7572)).\nIn the meantime we recommend against using this attribute and use `gitlab.ProjectApprovalRule` instead.\n"
                    },
                    "archiveOnDestroy": {
                        "type": "boolean",
                        "description": "Set to `true` to archive the project instead of deleting on destroy. If set to `true` it will entire omit the `DELETE` operation.\n"
                    },
                    "archived": {
                        "type": "boolean",
                        "description": "Whether the project is in read-only mode (archived). Repositories can be archived/unarchived by toggling this parameter.\n"
                    },
                    "autoCancelPendingPipelines": {
                        "type": "string",
                        "description": "Auto-cancel pending pipelines. This isn’t a boolean, but enabled/disabled.\n"
                    },
                    "autoDevopsDeployStrategy": {
                        "type": "string",
                        "description": "Auto Deploy strategy. Valid values are `continuous`, `manual`, `timed_incremental`.\n"
                    },
                    "autoDevopsEnabled": {
                        "type": "boolean",
                        "description": "Enable Auto DevOps for this project.\n"
                    },
                    "autocloseReferencedIssues": {
                        "type": "boolean",
                        "description": "Set whether auto-closing referenced issues on default branch.\n"
                    },
                    "avatar": {
                        "type": "string",
                        "description": "A local path to the avatar image to upload. **Note**: not available for imported resources.\n"
                    },
                    "avatarHash": {
                        "type": "string",
                        "description": "The hash of the avatar image. Use `filesha256(\"path/to/avatar.png\")` whenever possible. **Note**: this is used to trigger an update of the avatar. If it's not given, but an avatar is given, the avatar will be updated each time.\n"
                    },
                    "avatarUrl": {
                        "type": "string",
                        "description": "The URL of the avatar image.\n"
                    },
                    "buildCoverageRegex": {
                        "type": "string",
                        "description": "Test coverage parsing for the project. This is deprecated feature in GitLab 15.0.\n",
                        "deprecationMessage": "build_coverage_regex is removed in GitLab 15.0."
                    },
                    "buildGitStrategy": {
                        "type": "string",
                        "description": "The Git strategy. Defaults to fetch.\n"
                    },
                    "buildTimeout": {
                        "type": "integer",
                        "description": "The maximum amount of time, in seconds, that a job can run.\n"
                    },
                    "buildsAccessLevel": {
                        "type": "string",
                        "description": "Set the builds access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "ciConfigPath": {
                        "type": "string",
                        "description": "Custom Path to CI config file.\n"
                    },
                    "ciDefaultGitDepth": {
                        "type": "integer",
                        "description": "Default number of revisions for shallow cloning.\n"
                    },
                    "ciForwardDeploymentEnabled": {
                        "type": "boolean",
                        "description": "When a new deployment job starts, skip older deployment jobs that are still pending.\n"
                    },
                    "ciSeparatedCaches": {
                        "type": "boolean",
                        "description": "Use separate caches for protected branches.\n"
                    },
                    "containerExpirationPolicy": {
                        "$ref": "#/types/gitlab:index/ProjectContainerExpirationPolicy:ProjectContainerExpirationPolicy",
                        "description": "Set the image cleanup policy for this project. **Note**: this field is sometimes named `container_expiration_policy_attributes` in the GitLab Upstream API.\n"
                    },
                    "containerRegistryAccessLevel": {
                        "type": "string",
                        "description": "Set visibility of container registry, for this project. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "containerRegistryEnabled": {
                        "type": "boolean",
                        "description": "Enable container registry for the project.\n",
                        "deprecationMessage": "Use `container_registry_access_level` instead."
                    },
                    "defaultBranch": {
                        "type": "string",
                        "description": "The default branch for the project.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description of the project.\n"
                    },
                    "emailsDisabled": {
                        "type": "boolean",
                        "description": "Disable email notifications.\n"
                    },
                    "environmentsAccessLevel": {
                        "type": "string",
                        "description": "Set the environments access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "externalAuthorizationClassificationLabel": {
                        "type": "string",
                        "description": "The classification label for the project.\n"
                    },
                    "featureFlagsAccessLevel": {
                        "type": "string",
                        "description": "Set the feature flags access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "forkedFromProjectId": {
                        "type": "integer",
                        "description": "The id of the project to fork. During create the project is forked and during an update the fork relation is changed.\n"
                    },
                    "forkingAccessLevel": {
                        "type": "string",
                        "description": "Set the forking access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "groupWithProjectTemplatesId": {
                        "type": "integer",
                        "description": "For group-level custom templates, specifies ID of group from which all the custom project templates are sourced. Leave empty for instance-level templates. Requires use*custom*template to be true (enterprise edition).\n"
                    },
                    "httpUrlToRepo": {
                        "type": "string",
                        "description": "URL that can be provided to `git clone` to clone the\n"
                    },
                    "importUrl": {
                        "type": "string",
                        "description": "Git URL to a repository to be imported. Together with `mirror = true` it will setup a Pull Mirror. This can also be used\ntogether with `forked_from_project_id` to setup a Pull Mirror for a fork. The fork takes precedence over the import.\nMake sure to provide the credentials in `import_url_username` and `import_url_password`. GitLab never returns the\ncredentials, thus the provider cannot detect configuration drift in the credentials. They can also not be imported using\n`terraform import`. See the examples section for how to properly use it.\n"
                    },
                    "importUrlPassword": {
                        "type": "string",
                        "description": "The password for the `import_url`. The value of this field is used to construct a valid `import_url` and is only related\nto the provider. This field cannot be imported using `terraform import`. See the examples section for how to properly\nuse it.\n",
                        "secret": true
                    },
                    "importUrlUsername": {
                        "type": "string",
                        "description": "The username for the `import_url`. The value of this field is used to construct a valid `import_url` and is only related\nto the provider. This field cannot be imported using `terraform import`. See the examples section for how to properly\nuse it.\n"
                    },
                    "infrastructureAccessLevel": {
                        "type": "string",
                        "description": "Set the infrastructure access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "initializeWithReadme": {
                        "type": "boolean",
                        "description": "Create main branch with first commit containing a README.md file.\n"
                    },
                    "issuesAccessLevel": {
                        "type": "string",
                        "description": "Set the issues access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "issuesEnabled": {
                        "type": "boolean",
                        "description": "Enable issue tracking for the project.\n"
                    },
                    "issuesTemplate": {
                        "type": "string",
                        "description": "Sets the template for new issues in the project.\n"
                    },
                    "keepLatestArtifact": {
                        "type": "boolean",
                        "description": "Disable or enable the ability to keep the latest artifact for this project.\n"
                    },
                    "lfsEnabled": {
                        "type": "boolean",
                        "description": "Enable LFS for the project.\n"
                    },
                    "mergeCommitTemplate": {
                        "type": "string",
                        "description": "Template used to create merge commit message in merge requests. (Introduced in GitLab 14.5.)\n"
                    },
                    "mergeMethod": {
                        "type": "string",
                        "description": "Set the merge method. Valid values are `merge`, `rebase_merge`, `ff`.\n"
                    },
                    "mergePipelinesEnabled": {
                        "type": "boolean",
                        "description": "Enable or disable merge pipelines.\n"
                    },
                    "mergeRequestsAccessLevel": {
                        "type": "string",
                        "description": "Set the merge requests access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "mergeRequestsEnabled": {
                        "type": "boolean",
                        "description": "Enable merge requests for the project.\n"
                    },
                    "mergeRequestsTemplate": {
                        "type": "string",
                        "description": "Sets the template for new merge requests in the project.\n"
                    },
                    "mergeTrainsEnabled": {
                        "type": "boolean",
                        "description": "Enable or disable merge trains. Requires `merge_pipelines_enabled` to be set to `true` to take effect.\n"
                    },
                    "mirror": {
                        "type": "boolean",
                        "description": "Enable project pull mirror.\n"
                    },
                    "mirrorOverwritesDivergedBranches": {
                        "type": "boolean",
                        "description": "Enable overwrite diverged branches for a mirrored project.\n"
                    },
                    "mirrorTriggerBuilds": {
                        "type": "boolean",
                        "description": "Enable trigger builds on pushes for a mirrored project.\n"
                    },
                    "monitorAccessLevel": {
                        "type": "string",
                        "description": "Set the monitor access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "mrDefaultTargetSelf": {
                        "type": "boolean",
                        "description": "For forked projects, target merge requests to this project. If false, the target will be the upstream project.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the project.\n"
                    },
                    "namespaceId": {
                        "type": "integer",
                        "description": "The namespace (group or user) of the project. Defaults to your user.\n"
                    },
                    "onlyAllowMergeIfAllDiscussionsAreResolved": {
                        "type": "boolean",
                        "description": "Set to true if you want allow merges only if all discussions are resolved.\n"
                    },
                    "onlyAllowMergeIfPipelineSucceeds": {
                        "type": "boolean",
                        "description": "Set to true if you want allow merges only if a pipeline succeeds.\n"
                    },
                    "onlyMirrorProtectedBranches": {
                        "type": "boolean",
                        "description": "Enable only mirror protected branches for a mirrored project.\n"
                    },
                    "operationsAccessLevel": {
                        "type": "string",
                        "description": "Set the operations access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "packagesEnabled": {
                        "type": "boolean",
                        "description": "Enable packages repository for the project.\n"
                    },
                    "pagesAccessLevel": {
                        "type": "string",
                        "description": "Enable pages access control\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path of the repository.\n"
                    },
                    "pathWithNamespace": {
                        "type": "string",
                        "description": "The path of the repository with namespace.\n"
                    },
                    "pipelinesEnabled": {
                        "type": "boolean",
                        "description": "Enable pipelines for the project. The `pipelines_enabled` field is being sent as `jobs_enabled` in the GitLab API calls.\n",
                        "deprecationMessage": "Deprecated in favor of `builds_access_level`"
                    },
                    "printingMergeRequestLinkEnabled": {
                        "type": "boolean",
                        "description": "Show link to create/view merge request when pushing from the command line\n"
                    },
                    "publicBuilds": {
                        "type": "boolean",
                        "description": "If true, jobs can be viewed by non-project members.\n"
                    },
                    "pushRules": {
                        "$ref": "#/types/gitlab:index/ProjectPushRules:ProjectPushRules",
                        "description": "Push rules for the project.\n"
                    },
                    "releasesAccessLevel": {
                        "type": "string",
                        "description": "Set the releases access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "removeSourceBranchAfterMerge": {
                        "type": "boolean",
                        "description": "Enable `Delete source branch` option by default for all new merge requests.\n"
                    },
                    "repositoryAccessLevel": {
                        "type": "string",
                        "description": "Set the repository access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "repositoryStorage": {
                        "type": "string",
                        "description": "Which storage shard the repository is on. (administrator only)\n"
                    },
                    "requestAccessEnabled": {
                        "type": "boolean",
                        "description": "Allow users to request member access.\n"
                    },
                    "requirementsAccessLevel": {
                        "type": "string",
                        "description": "Set the requirements access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "resolveOutdatedDiffDiscussions": {
                        "type": "boolean",
                        "description": "Automatically resolve merge request diffs discussions on lines changed with a push.\n"
                    },
                    "restrictUserDefinedVariables": {
                        "type": "boolean",
                        "description": "Allow only users with the Maintainer role to pass user-defined variables when triggering a pipeline.\n"
                    },
                    "runnersToken": {
                        "type": "string",
                        "description": "Registration token to use during runner setup.\n",
                        "secret": true
                    },
                    "securityAndComplianceAccessLevel": {
                        "type": "string",
                        "description": "Set the security and compliance access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "sharedRunnersEnabled": {
                        "type": "boolean",
                        "description": "Enable shared runners for this project.\n"
                    },
                    "skipWaitForDefaultBranchProtection": {
                        "type": "boolean",
                        "description": "If `true`, the default behavior to wait for the default branch protection to be created is skipped.\nThis is necessary if the current user is not an admin and the default branch protection is disabled on an instance-level.\nThere is currently no known way to determine if the default branch protection is disabled on an instance-level for non-admin users.\nThis attribute is only used during resource creation, thus changes are suppressed and the attribute cannot be imported.\n"
                    },
                    "snippetsAccessLevel": {
                        "type": "string",
                        "description": "Set the snippets access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "snippetsEnabled": {
                        "type": "boolean",
                        "description": "Enable snippets for the project.\n"
                    },
                    "squashCommitTemplate": {
                        "type": "string",
                        "description": "Template used to create squash commit message in merge requests. (Introduced in GitLab 14.6.)\n"
                    },
                    "squashOption": {
                        "type": "string",
                        "description": "Squash commits when merge request. Valid values are `never`, `always`, `default_on`, or `default_off`. The default value is `default_off`. [GitLab \u003e= 14.1]\n"
                    },
                    "sshUrlToRepo": {
                        "type": "string",
                        "description": "URL that can be provided to `git clone` to clone the\n"
                    },
                    "suggestionCommitMessage": {
                        "type": "string",
                        "description": "The commit message used to apply merge request suggestions.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of tags for a project; put array of tags, that should be finally assigned to a project. Use topics instead.\n"
                    },
                    "templateName": {
                        "type": "string",
                        "description": "When used without use*custom*template, name of a built-in project template. When used with use*custom*template, name of a custom project template. This option is mutually exclusive with `template_project_id`.\n",
                        "willReplaceOnChanges": true
                    },
                    "templateProjectId": {
                        "type": "integer",
                        "description": "When used with use*custom*template, project ID of a custom project template. This is preferable to using template*name since template*name may be ambiguous (enterprise edition). This option is mutually exclusive with `template_name`. See `gitlab.GroupProjectFileTemplate` to set a project as a template project. If a project has not been set as a template, using it here will result in an error.\n",
                        "willReplaceOnChanges": true
                    },
                    "topics": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of topics for the project.\n"
                    },
                    "useCustomTemplate": {
                        "type": "boolean",
                        "description": "Use either custom instance or group (with group*with*project*templates*id) project template (enterprise edition).\n\t\u003e When using a custom template, [Group Tokens won't work](https://docs.gitlab.com/15.7/ee/user/project/settings/import_export_troubleshooting.html#import-using-the-rest-api-fails-when-using-a-group-access-token). You must use a real user's Personal Access Token.\n"
                    },
                    "visibilityLevel": {
                        "type": "string",
                        "description": "Set to `public` to create a public project.\n"
                    },
                    "webUrl": {
                        "type": "string",
                        "description": "URL that can be used to find the project in a browser.\n"
                    },
                    "wikiAccessLevel": {
                        "type": "string",
                        "description": "Set the wiki access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "wikiEnabled": {
                        "type": "boolean",
                        "description": "Enable wiki for the project.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectAccessToken:ProjectAccessToken": {
            "description": "The `gitlab.ProjectAccessToken` resource allows to manage the lifecycle of a project access token.\n\n**Upstream API**: [GitLab API docs](https://docs.gitlab.com/ee/api/project_access_tokens.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst exampleProjectAccessToken = new gitlab.ProjectAccessToken(\"exampleProjectAccessToken\", {\n    project: \"25\",\n    expiresAt: \"2020-03-14\",\n    accessLevel: \"reporter\",\n    scopes: [\"api\"],\n});\nconst exampleProjectVariable = new gitlab.ProjectVariable(\"exampleProjectVariable\", {\n    project: gitlab_project.example.id,\n    key: \"pat\",\n    value: exampleProjectAccessToken.token,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample_project_access_token = gitlab.ProjectAccessToken(\"exampleProjectAccessToken\",\n    project=\"25\",\n    expires_at=\"2020-03-14\",\n    access_level=\"reporter\",\n    scopes=[\"api\"])\nexample_project_variable = gitlab.ProjectVariable(\"exampleProjectVariable\",\n    project=gitlab_project[\"example\"][\"id\"],\n    key=\"pat\",\n    value=example_project_access_token.token)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleProjectAccessToken = new GitLab.ProjectAccessToken(\"exampleProjectAccessToken\", new()\n    {\n        Project = \"25\",\n        ExpiresAt = \"2020-03-14\",\n        AccessLevel = \"reporter\",\n        Scopes = new[]\n        {\n            \"api\",\n        },\n    });\n\n    var exampleProjectVariable = new GitLab.ProjectVariable(\"exampleProjectVariable\", new()\n    {\n        Project = gitlab_project.Example.Id,\n        Key = \"pat\",\n        Value = exampleProjectAccessToken.Token,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleProjectAccessToken, err := gitlab.NewProjectAccessToken(ctx, \"exampleProjectAccessToken\", \u0026gitlab.ProjectAccessTokenArgs{\n\t\t\tProject:     pulumi.String(\"25\"),\n\t\t\tExpiresAt:   pulumi.String(\"2020-03-14\"),\n\t\t\tAccessLevel: pulumi.String(\"reporter\"),\n\t\t\tScopes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"api\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectVariable(ctx, \"exampleProjectVariable\", \u0026gitlab.ProjectVariableArgs{\n\t\t\tProject: pulumi.Any(gitlab_project.Example.Id),\n\t\t\tKey:     pulumi.String(\"pat\"),\n\t\t\tValue:   exampleProjectAccessToken.Token,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ProjectAccessToken;\nimport com.pulumi.gitlab.ProjectAccessTokenArgs;\nimport com.pulumi.gitlab.ProjectVariable;\nimport com.pulumi.gitlab.ProjectVariableArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleProjectAccessToken = new ProjectAccessToken(\"exampleProjectAccessToken\", ProjectAccessTokenArgs.builder()        \n            .project(\"25\")\n            .expiresAt(\"2020-03-14\")\n            .accessLevel(\"reporter\")\n            .scopes(\"api\")\n            .build());\n\n        var exampleProjectVariable = new ProjectVariable(\"exampleProjectVariable\", ProjectVariableArgs.builder()        \n            .project(gitlab_project.example().id())\n            .key(\"pat\")\n            .value(exampleProjectAccessToken.token())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleProjectAccessToken:\n    type: gitlab:ProjectAccessToken\n    properties:\n      project: '25'\n      expiresAt: 2020-03-14\n      accessLevel: reporter\n      scopes:\n        - api\n  exampleProjectVariable:\n    type: gitlab:ProjectVariable\n    properties:\n      project: ${gitlab_project.example.id}\n      key: pat\n      value: ${exampleProjectAccessToken.token}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nA GitLab Project Access Token can be imported using a key composed of `\u003cproject-id\u003e:\u003ctoken-id\u003e`, e.g.\n\n```sh\n $ pulumi import gitlab:index/projectAccessToken:ProjectAccessToken example \"12345:1\"\n```\n\n NOTEthe `token` resource attribute is not available for imported resources as this information cannot be read from the GitLab API. ",
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "The access level for the project access token. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`, `master`. Default is `maintainer`.\n"
                },
                "active": {
                    "type": "boolean",
                    "description": "True if the token is active.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Time the token has been created, RFC3339 format.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "Time the token will expire it, YYYY-MM-DD format. Will not expire per default.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A name to describe the project access token.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The id of the project to add the project access token to.\n"
                },
                "revoked": {
                    "type": "boolean",
                    "description": "True if the token is revoked.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Valid values: `api`, `read_api`, `read_repository`, `write_repository`, `read_registry`, `write_registry`.\n"
                },
                "token": {
                    "type": "string",
                    "description": "The secret token. **Note**: the token is not available for imported resources.\n",
                    "secret": true
                },
                "userId": {
                    "type": "integer",
                    "description": "The user_id associated to the token.\n"
                }
            },
            "required": [
                "active",
                "createdAt",
                "name",
                "project",
                "revoked",
                "scopes",
                "token",
                "userId"
            ],
            "inputProperties": {
                "accessLevel": {
                    "type": "string",
                    "description": "The access level for the project access token. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`, `master`. Default is `maintainer`.\n",
                    "willReplaceOnChanges": true
                },
                "expiresAt": {
                    "type": "string",
                    "description": "Time the token will expire it, YYYY-MM-DD format. Will not expire per default.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "A name to describe the project access token.\n",
                    "willReplaceOnChanges": true
                },
                "project": {
                    "type": "string",
                    "description": "The id of the project to add the project access token to.\n",
                    "willReplaceOnChanges": true
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Valid values: `api`, `read_api`, `read_repository`, `write_repository`, `read_registry`, `write_registry`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "project",
                "scopes"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectAccessToken resources.\n",
                "properties": {
                    "accessLevel": {
                        "type": "string",
                        "description": "The access level for the project access token. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`, `master`. Default is `maintainer`.\n",
                        "willReplaceOnChanges": true
                    },
                    "active": {
                        "type": "boolean",
                        "description": "True if the token is active.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Time the token has been created, RFC3339 format.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "Time the token will expire it, YYYY-MM-DD format. Will not expire per default.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "A name to describe the project access token.\n",
                        "willReplaceOnChanges": true
                    },
                    "project": {
                        "type": "string",
                        "description": "The id of the project to add the project access token to.\n",
                        "willReplaceOnChanges": true
                    },
                    "revoked": {
                        "type": "boolean",
                        "description": "True if the token is revoked.\n"
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Valid values: `api`, `read_api`, `read_repository`, `write_repository`, `read_registry`, `write_registry`.\n",
                        "willReplaceOnChanges": true
                    },
                    "token": {
                        "type": "string",
                        "description": "The secret token. **Note**: the token is not available for imported resources.\n",
                        "secret": true
                    },
                    "userId": {
                        "type": "integer",
                        "description": "The user_id associated to the token.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectApprovalRule:ProjectApprovalRule": {
            "description": "\n\n## Import\n\nGitLab project approval rules can be imported using a key composed of `\u003cproject-id\u003e:\u003crule-id\u003e`, e.g.\n\n```sh\n $ pulumi import gitlab:index/projectApprovalRule:ProjectApprovalRule example \"12345:6\"\n```\n\n ",
            "properties": {
                "approvalsRequired": {
                    "type": "integer",
                    "description": "The number of approvals required for this rule.\n"
                },
                "disableImportingDefaultAnyApproverRuleOnCreate": {
                    "type": "boolean",
                    "description": "When this flag is set, the default `any_approver` rule will not be imported if present.\n"
                },
                "groupIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A list of group IDs whose members can approve of the merge request.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the approval rule.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the approval rules.\n"
                },
                "protectedBranchIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A list of protected branch IDs (not branch names) for which the rule applies.\n"
                },
                "ruleType": {
                    "type": "string",
                    "description": "String, defaults to 'regular'. The type of rule. `any_approver` is a pre-configured default rule with `approvals_required` at `0`. Valid values are `regular`, `any_approver`.\n"
                },
                "userIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A list of specific User IDs to add to the list of approvers.\n"
                }
            },
            "required": [
                "approvalsRequired",
                "name",
                "project",
                "ruleType"
            ],
            "inputProperties": {
                "approvalsRequired": {
                    "type": "integer",
                    "description": "The number of approvals required for this rule.\n"
                },
                "disableImportingDefaultAnyApproverRuleOnCreate": {
                    "type": "boolean",
                    "description": "When this flag is set, the default `any_approver` rule will not be imported if present.\n"
                },
                "groupIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A list of group IDs whose members can approve of the merge request.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the approval rule.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the approval rules.\n",
                    "willReplaceOnChanges": true
                },
                "protectedBranchIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A list of protected branch IDs (not branch names) for which the rule applies.\n"
                },
                "ruleType": {
                    "type": "string",
                    "description": "String, defaults to 'regular'. The type of rule. `any_approver` is a pre-configured default rule with `approvals_required` at `0`. Valid values are `regular`, `any_approver`.\n",
                    "willReplaceOnChanges": true
                },
                "userIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A list of specific User IDs to add to the list of approvers.\n"
                }
            },
            "requiredInputs": [
                "approvalsRequired",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectApprovalRule resources.\n",
                "properties": {
                    "approvalsRequired": {
                        "type": "integer",
                        "description": "The number of approvals required for this rule.\n"
                    },
                    "disableImportingDefaultAnyApproverRuleOnCreate": {
                        "type": "boolean",
                        "description": "When this flag is set, the default `any_approver` rule will not be imported if present.\n"
                    },
                    "groupIds": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "A list of group IDs whose members can approve of the merge request.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the approval rule.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project to add the approval rules.\n",
                        "willReplaceOnChanges": true
                    },
                    "protectedBranchIds": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "A list of protected branch IDs (not branch names) for which the rule applies.\n"
                    },
                    "ruleType": {
                        "type": "string",
                        "description": "String, defaults to 'regular'. The type of rule. `any_approver` is a pre-configured default rule with `approvals_required` at `0`. Valid values are `regular`, `any_approver`.\n",
                        "willReplaceOnChanges": true
                    },
                    "userIds": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "A list of specific User IDs to add to the list of approvers.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectBadge:ProjectBadge": {
            "description": "The `gitlab.ProjectBadge` resource allows to mange the lifecycle of project badges.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/user/project/badges.html#project-badges)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = new gitlab.Project(\"foo\", {});\nconst example = new gitlab.ProjectBadge(\"example\", {\n    project: foo.id,\n    linkUrl: \"https://example.com/badge-123\",\n    imageUrl: \"https://example.com/badge-123.svg\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.Project(\"foo\")\nexample = gitlab.ProjectBadge(\"example\",\n    project=foo.id,\n    link_url=\"https://example.com/badge-123\",\n    image_url=\"https://example.com/badge-123.svg\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = new GitLab.Project(\"foo\");\n\n    var example = new GitLab.ProjectBadge(\"example\", new()\n    {\n        Project = foo.Id,\n        LinkUrl = \"https://example.com/badge-123\",\n        ImageUrl = \"https://example.com/badge-123.svg\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfoo, err := gitlab.NewProject(ctx, \"foo\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectBadge(ctx, \"example\", \u0026gitlab.ProjectBadgeArgs{\n\t\t\tProject:  foo.ID(),\n\t\t\tLinkUrl:  pulumi.String(\"https://example.com/badge-123\"),\n\t\t\tImageUrl: pulumi.String(\"https://example.com/badge-123.svg\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectBadge;\nimport com.pulumi.gitlab.ProjectBadgeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var foo = new Project(\"foo\");\n\n        var example = new ProjectBadge(\"example\", ProjectBadgeArgs.builder()        \n            .project(foo.id())\n            .linkUrl(\"https://example.com/badge-123\")\n            .imageUrl(\"https://example.com/badge-123.svg\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  foo:\n    type: gitlab:Project\n  example:\n    type: gitlab:ProjectBadge\n    properties:\n      project: ${foo.id}\n      linkUrl: https://example.com/badge-123\n      imageUrl: https://example.com/badge-123.svg\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitLab project badges can be imported using an id made up of `{project_id}:{badge_id}`, e.g.\n\n```sh\n $ pulumi import gitlab:index/projectBadge:ProjectBadge foo 1:3\n```\n\n ",
            "properties": {
                "imageUrl": {
                    "type": "string",
                    "description": "The image url which will be presented on project overview.\n"
                },
                "linkUrl": {
                    "type": "string",
                    "description": "The url linked with the badge.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the badge.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The id of the project to add the badge to.\n"
                },
                "renderedImageUrl": {
                    "type": "string",
                    "description": "The image_url argument rendered (in case of use of placeholders).\n"
                },
                "renderedLinkUrl": {
                    "type": "string",
                    "description": "The link_url argument rendered (in case of use of placeholders).\n"
                }
            },
            "required": [
                "imageUrl",
                "linkUrl",
                "name",
                "project",
                "renderedImageUrl",
                "renderedLinkUrl"
            ],
            "inputProperties": {
                "imageUrl": {
                    "type": "string",
                    "description": "The image url which will be presented on project overview.\n"
                },
                "linkUrl": {
                    "type": "string",
                    "description": "The url linked with the badge.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the badge.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The id of the project to add the badge to.\n"
                }
            },
            "requiredInputs": [
                "imageUrl",
                "linkUrl",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectBadge resources.\n",
                "properties": {
                    "imageUrl": {
                        "type": "string",
                        "description": "The image url which will be presented on project overview.\n"
                    },
                    "linkUrl": {
                        "type": "string",
                        "description": "The url linked with the badge.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the badge.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The id of the project to add the badge to.\n"
                    },
                    "renderedImageUrl": {
                        "type": "string",
                        "description": "The image_url argument rendered (in case of use of placeholders).\n"
                    },
                    "renderedLinkUrl": {
                        "type": "string",
                        "description": "The link_url argument rendered (in case of use of placeholders).\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectCluster:ProjectCluster": {
            "description": "The `gitlab.ProjectCluster` resource allows to manage the lifecycle of a project cluster.\n\n\u003e This is deprecated GitLab feature since 14.5\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/project_clusters.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = new gitlab.Project(\"foo\", {});\nconst bar = new gitlab.ProjectCluster(\"bar\", {\n    project: foo.id,\n    domain: \"example.com\",\n    enabled: true,\n    kubernetesApiUrl: \"https://124.124.124\",\n    kubernetesToken: \"some-token\",\n    kubernetesCaCert: \"some-cert\",\n    kubernetesNamespace: \"namespace\",\n    kubernetesAuthorizationType: \"rbac\",\n    environmentScope: \"*\",\n    managementProjectId: \"123456\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.Project(\"foo\")\nbar = gitlab.ProjectCluster(\"bar\",\n    project=foo.id,\n    domain=\"example.com\",\n    enabled=True,\n    kubernetes_api_url=\"https://124.124.124\",\n    kubernetes_token=\"some-token\",\n    kubernetes_ca_cert=\"some-cert\",\n    kubernetes_namespace=\"namespace\",\n    kubernetes_authorization_type=\"rbac\",\n    environment_scope=\"*\",\n    management_project_id=\"123456\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = new GitLab.Project(\"foo\");\n\n    var bar = new GitLab.ProjectCluster(\"bar\", new()\n    {\n        Project = foo.Id,\n        Domain = \"example.com\",\n        Enabled = true,\n        KubernetesApiUrl = \"https://124.124.124\",\n        KubernetesToken = \"some-token\",\n        KubernetesCaCert = \"some-cert\",\n        KubernetesNamespace = \"namespace\",\n        KubernetesAuthorizationType = \"rbac\",\n        EnvironmentScope = \"*\",\n        ManagementProjectId = \"123456\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfoo, err := gitlab.NewProject(ctx, \"foo\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectCluster(ctx, \"bar\", \u0026gitlab.ProjectClusterArgs{\n\t\t\tProject:                     foo.ID(),\n\t\t\tDomain:                      pulumi.String(\"example.com\"),\n\t\t\tEnabled:                     pulumi.Bool(true),\n\t\t\tKubernetesApiUrl:            pulumi.String(\"https://124.124.124\"),\n\t\t\tKubernetesToken:             pulumi.String(\"some-token\"),\n\t\t\tKubernetesCaCert:            pulumi.String(\"some-cert\"),\n\t\t\tKubernetesNamespace:         pulumi.String(\"namespace\"),\n\t\t\tKubernetesAuthorizationType: pulumi.String(\"rbac\"),\n\t\t\tEnvironmentScope:            pulumi.String(\"*\"),\n\t\t\tManagementProjectId:         pulumi.String(\"123456\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectCluster;\nimport com.pulumi.gitlab.ProjectClusterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var foo = new Project(\"foo\");\n\n        var bar = new ProjectCluster(\"bar\", ProjectClusterArgs.builder()        \n            .project(foo.id())\n            .domain(\"example.com\")\n            .enabled(true)\n            .kubernetesApiUrl(\"https://124.124.124\")\n            .kubernetesToken(\"some-token\")\n            .kubernetesCaCert(\"some-cert\")\n            .kubernetesNamespace(\"namespace\")\n            .kubernetesAuthorizationType(\"rbac\")\n            .environmentScope(\"*\")\n            .managementProjectId(\"123456\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  foo:\n    type: gitlab:Project\n  bar:\n    type: gitlab:ProjectCluster\n    properties:\n      project: ${foo.id}\n      domain: example.com\n      enabled: true\n      kubernetesApiUrl: https://124.124.124\n      kubernetesToken: some-token\n      kubernetesCaCert: some-cert\n      kubernetesNamespace: namespace\n      kubernetesAuthorizationType: rbac\n      environmentScope: '*'\n      managementProjectId: '123456'\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitLab project clusters can be imported using an id made up of `projectid:clusterid`, e.g.\n\n```sh\n $ pulumi import gitlab:index/projectCluster:ProjectCluster bar 123:321\n```\n\n ",
            "properties": {
                "clusterType": {
                    "type": "string",
                    "description": "Cluster type.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Create time.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The base domain of the cluster.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Determines if cluster is active or not. Defaults to `true`. This attribute cannot be read.\n"
                },
                "environmentScope": {
                    "type": "string",
                    "description": "The associated environment to the cluster. Defaults to `*`.\n"
                },
                "kubernetesApiUrl": {
                    "type": "string",
                    "description": "The URL to access the Kubernetes API.\n"
                },
                "kubernetesAuthorizationType": {
                    "type": "string",
                    "description": "The cluster authorization type. Valid values are `rbac`, `abac`, `unknown_authorization`. Defaults to `rbac`.\n"
                },
                "kubernetesCaCert": {
                    "type": "string",
                    "description": "TLS certificate (needed if API is using a self-signed TLS certificate).\n"
                },
                "kubernetesNamespace": {
                    "type": "string",
                    "description": "The unique namespace related to the project.\n"
                },
                "kubernetesToken": {
                    "type": "string",
                    "description": "The token to authenticate against Kubernetes.\n",
                    "secret": true
                },
                "managed": {
                    "type": "boolean",
                    "description": "Determines if cluster is managed by gitlab or not. Defaults to `true`. This attribute cannot be read.\n"
                },
                "managementProjectId": {
                    "type": "string",
                    "description": "The ID of the management project for the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of cluster.\n"
                },
                "platformType": {
                    "type": "string",
                    "description": "Platform type.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The id of the project to add the cluster to.\n"
                },
                "providerType": {
                    "type": "string",
                    "description": "Provider type.\n"
                }
            },
            "required": [
                "clusterType",
                "createdAt",
                "kubernetesApiUrl",
                "kubernetesToken",
                "name",
                "platformType",
                "project",
                "providerType"
            ],
            "inputProperties": {
                "domain": {
                    "type": "string",
                    "description": "The base domain of the cluster.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Determines if cluster is active or not. Defaults to `true`. This attribute cannot be read.\n",
                    "willReplaceOnChanges": true
                },
                "environmentScope": {
                    "type": "string",
                    "description": "The associated environment to the cluster. Defaults to `*`.\n"
                },
                "kubernetesApiUrl": {
                    "type": "string",
                    "description": "The URL to access the Kubernetes API.\n"
                },
                "kubernetesAuthorizationType": {
                    "type": "string",
                    "description": "The cluster authorization type. Valid values are `rbac`, `abac`, `unknown_authorization`. Defaults to `rbac`.\n",
                    "willReplaceOnChanges": true
                },
                "kubernetesCaCert": {
                    "type": "string",
                    "description": "TLS certificate (needed if API is using a self-signed TLS certificate).\n"
                },
                "kubernetesNamespace": {
                    "type": "string",
                    "description": "The unique namespace related to the project.\n"
                },
                "kubernetesToken": {
                    "type": "string",
                    "description": "The token to authenticate against Kubernetes.\n",
                    "secret": true
                },
                "managed": {
                    "type": "boolean",
                    "description": "Determines if cluster is managed by gitlab or not. Defaults to `true`. This attribute cannot be read.\n",
                    "willReplaceOnChanges": true
                },
                "managementProjectId": {
                    "type": "string",
                    "description": "The ID of the management project for the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of cluster.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The id of the project to add the cluster to.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "kubernetesApiUrl",
                "kubernetesToken",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectCluster resources.\n",
                "properties": {
                    "clusterType": {
                        "type": "string",
                        "description": "Cluster type.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Create time.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The base domain of the cluster.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Determines if cluster is active or not. Defaults to `true`. This attribute cannot be read.\n",
                        "willReplaceOnChanges": true
                    },
                    "environmentScope": {
                        "type": "string",
                        "description": "The associated environment to the cluster. Defaults to `*`.\n"
                    },
                    "kubernetesApiUrl": {
                        "type": "string",
                        "description": "The URL to access the Kubernetes API.\n"
                    },
                    "kubernetesAuthorizationType": {
                        "type": "string",
                        "description": "The cluster authorization type. Valid values are `rbac`, `abac`, `unknown_authorization`. Defaults to `rbac`.\n",
                        "willReplaceOnChanges": true
                    },
                    "kubernetesCaCert": {
                        "type": "string",
                        "description": "TLS certificate (needed if API is using a self-signed TLS certificate).\n"
                    },
                    "kubernetesNamespace": {
                        "type": "string",
                        "description": "The unique namespace related to the project.\n"
                    },
                    "kubernetesToken": {
                        "type": "string",
                        "description": "The token to authenticate against Kubernetes.\n",
                        "secret": true
                    },
                    "managed": {
                        "type": "boolean",
                        "description": "Determines if cluster is managed by gitlab or not. Defaults to `true`. This attribute cannot be read.\n",
                        "willReplaceOnChanges": true
                    },
                    "managementProjectId": {
                        "type": "string",
                        "description": "The ID of the management project for the cluster.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of cluster.\n"
                    },
                    "platformType": {
                        "type": "string",
                        "description": "Platform type.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The id of the project to add the cluster to.\n",
                        "willReplaceOnChanges": true
                    },
                    "providerType": {
                        "type": "string",
                        "description": "Provider type.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectCustomAttribute:ProjectCustomAttribute": {
            "description": "The `gitlab.ProjectCustomAttribute` resource allows to manage custom attributes for a project.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/custom_attributes.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst attr = new gitlab.ProjectCustomAttribute(\"attr\", {\n    key: \"location\",\n    project: 42,\n    value: \"Greenland\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nattr = gitlab.ProjectCustomAttribute(\"attr\",\n    key=\"location\",\n    project=42,\n    value=\"Greenland\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var attr = new GitLab.ProjectCustomAttribute(\"attr\", new()\n    {\n        Key = \"location\",\n        Project = 42,\n        Value = \"Greenland\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewProjectCustomAttribute(ctx, \"attr\", \u0026gitlab.ProjectCustomAttributeArgs{\n\t\t\tKey:     pulumi.String(\"location\"),\n\t\t\tProject: pulumi.Int(42),\n\t\t\tValue:   pulumi.String(\"Greenland\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ProjectCustomAttribute;\nimport com.pulumi.gitlab.ProjectCustomAttributeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var attr = new ProjectCustomAttribute(\"attr\", ProjectCustomAttributeArgs.builder()        \n            .key(\"location\")\n            .project(\"42\")\n            .value(\"Greenland\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  attr:\n    type: gitlab:ProjectCustomAttribute\n    properties:\n      key: location\n      project: '42'\n      value: Greenland\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nYou can import a project custom attribute using an id made up of `{project-id}:{key}`, e.g.\n\n```sh\n $ pulumi import gitlab:index/projectCustomAttribute:ProjectCustomAttribute attr 42:location\n```\n\n ",
            "properties": {
                "key": {
                    "type": "string",
                    "description": "Key for the Custom Attribute.\n"
                },
                "project": {
                    "type": "integer",
                    "description": "The id of the project.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value for the Custom Attribute.\n"
                }
            },
            "required": [
                "key",
                "project",
                "value"
            ],
            "inputProperties": {
                "key": {
                    "type": "string",
                    "description": "Key for the Custom Attribute.\n"
                },
                "project": {
                    "type": "integer",
                    "description": "The id of the project.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value for the Custom Attribute.\n"
                }
            },
            "requiredInputs": [
                "key",
                "project",
                "value"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectCustomAttribute resources.\n",
                "properties": {
                    "key": {
                        "type": "string",
                        "description": "Key for the Custom Attribute.\n"
                    },
                    "project": {
                        "type": "integer",
                        "description": "The id of the project.\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "Value for the Custom Attribute.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectEnvironment:ProjectEnvironment": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst thisGroup = new gitlab.Group(\"thisGroup\", {\n    path: \"example\",\n    description: \"An example group\",\n});\nconst thisProject = new gitlab.Project(\"thisProject\", {\n    namespaceId: thisGroup.id,\n    initializeWithReadme: true,\n});\nconst thisProjectEnvironment = new gitlab.ProjectEnvironment(\"thisProjectEnvironment\", {\n    project: thisProject.id,\n    externalUrl: \"www.example.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nthis_group = gitlab.Group(\"thisGroup\",\n    path=\"example\",\n    description=\"An example group\")\nthis_project = gitlab.Project(\"thisProject\",\n    namespace_id=this_group.id,\n    initialize_with_readme=True)\nthis_project_environment = gitlab.ProjectEnvironment(\"thisProjectEnvironment\",\n    project=this_project.id,\n    external_url=\"www.example.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var thisGroup = new GitLab.Group(\"thisGroup\", new()\n    {\n        Path = \"example\",\n        Description = \"An example group\",\n    });\n\n    var thisProject = new GitLab.Project(\"thisProject\", new()\n    {\n        NamespaceId = thisGroup.Id,\n        InitializeWithReadme = true,\n    });\n\n    var thisProjectEnvironment = new GitLab.ProjectEnvironment(\"thisProjectEnvironment\", new()\n    {\n        Project = thisProject.Id,\n        ExternalUrl = \"www.example.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tthisGroup, err := gitlab.NewGroup(ctx, \"thisGroup\", \u0026gitlab.GroupArgs{\n\t\t\tPath:        pulumi.String(\"example\"),\n\t\t\tDescription: pulumi.String(\"An example group\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tthisProject, err := gitlab.NewProject(ctx, \"thisProject\", \u0026gitlab.ProjectArgs{\n\t\t\tNamespaceId:          thisGroup.ID(),\n\t\t\tInitializeWithReadme: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectEnvironment(ctx, \"thisProjectEnvironment\", \u0026gitlab.ProjectEnvironmentArgs{\n\t\t\tProject:     thisProject.ID(),\n\t\t\tExternalUrl: pulumi.String(\"www.example.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Group;\nimport com.pulumi.gitlab.GroupArgs;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ProjectEnvironment;\nimport com.pulumi.gitlab.ProjectEnvironmentArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var thisGroup = new Group(\"thisGroup\", GroupArgs.builder()        \n            .path(\"example\")\n            .description(\"An example group\")\n            .build());\n\n        var thisProject = new Project(\"thisProject\", ProjectArgs.builder()        \n            .namespaceId(thisGroup.id())\n            .initializeWithReadme(true)\n            .build());\n\n        var thisProjectEnvironment = new ProjectEnvironment(\"thisProjectEnvironment\", ProjectEnvironmentArgs.builder()        \n            .project(thisProject.id())\n            .externalUrl(\"www.example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  thisGroup:\n    type: gitlab:Group\n    properties:\n      path: example\n      description: An example group\n  thisProject:\n    type: gitlab:Project\n    properties:\n      namespaceId: ${thisGroup.id}\n      initializeWithReadme: true\n  thisProjectEnvironment:\n    type: gitlab:ProjectEnvironment\n    properties:\n      project: ${thisProject.id}\n      externalUrl: www.example.com\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitLab project environments can be imported using an id made up of `projectId:environmenId`, e.g.\n\n```sh\n $ pulumi import gitlab:index/projectEnvironment:ProjectEnvironment bar 123:321\n```\n\n ",
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "The ISO8601 date/time that this environment was created at in UTC.\n"
                },
                "externalUrl": {
                    "type": "string",
                    "description": "Place to link to for this environment.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the environment.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project to environment is created for.\n"
                },
                "slug": {
                    "type": "string",
                    "description": "The name of the environment in lowercase, shortened to 63 bytes, and with everything except 0-9 and a-z replaced with -. No leading / trailing -. Use in URLs, host names and domain names.\n"
                },
                "state": {
                    "type": "string",
                    "description": "State the environment is in. Valid values are `available`, `stopped`.\n"
                },
                "stopBeforeDestroy": {
                    "type": "boolean",
                    "description": "Determines whether the environment is attempted to be stopped before the environment is deleted.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "The ISO8601 date/time that this environment was last updated at in UTC.\n"
                }
            },
            "required": [
                "createdAt",
                "name",
                "project",
                "slug",
                "state",
                "updatedAt"
            ],
            "inputProperties": {
                "externalUrl": {
                    "type": "string",
                    "description": "Place to link to for this environment.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the environment.\n",
                    "willReplaceOnChanges": true
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project to environment is created for.\n",
                    "willReplaceOnChanges": true
                },
                "stopBeforeDestroy": {
                    "type": "boolean",
                    "description": "Determines whether the environment is attempted to be stopped before the environment is deleted.\n"
                }
            },
            "requiredInputs": [
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectEnvironment resources.\n",
                "properties": {
                    "createdAt": {
                        "type": "string",
                        "description": "The ISO8601 date/time that this environment was created at in UTC.\n"
                    },
                    "externalUrl": {
                        "type": "string",
                        "description": "Place to link to for this environment.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the environment.\n",
                        "willReplaceOnChanges": true
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or full path of the project to environment is created for.\n",
                        "willReplaceOnChanges": true
                    },
                    "slug": {
                        "type": "string",
                        "description": "The name of the environment in lowercase, shortened to 63 bytes, and with everything except 0-9 and a-z replaced with -. No leading / trailing -. Use in URLs, host names and domain names.\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "State the environment is in. Valid values are `available`, `stopped`.\n"
                    },
                    "stopBeforeDestroy": {
                        "type": "boolean",
                        "description": "Determines whether the environment is attempted to be stopped before the environment is deleted.\n"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "The ISO8601 date/time that this environment was last updated at in UTC.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectFreezePeriod:ProjectFreezePeriod": {
            "description": "The `gitlab.ProjectFreezePeriod` resource allows to manage the lifecycle of a freeze period for a project.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/freeze_periods.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst schedule = new gitlab.ProjectFreezePeriod(\"schedule\", {\n    projectId: gitlab_project.foo.id,\n    freezeStart: \"0 23 * * 5\",\n    freezeEnd: \"0 7 * * 1\",\n    cronTimezone: \"UTC\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nschedule = gitlab.ProjectFreezePeriod(\"schedule\",\n    project_id=gitlab_project[\"foo\"][\"id\"],\n    freeze_start=\"0 23 * * 5\",\n    freeze_end=\"0 7 * * 1\",\n    cron_timezone=\"UTC\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var schedule = new GitLab.ProjectFreezePeriod(\"schedule\", new()\n    {\n        ProjectId = gitlab_project.Foo.Id,\n        FreezeStart = \"0 23 * * 5\",\n        FreezeEnd = \"0 7 * * 1\",\n        CronTimezone = \"UTC\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewProjectFreezePeriod(ctx, \"schedule\", \u0026gitlab.ProjectFreezePeriodArgs{\n\t\t\tProjectId:    pulumi.Any(gitlab_project.Foo.Id),\n\t\t\tFreezeStart:  pulumi.String(\"0 23 * * 5\"),\n\t\t\tFreezeEnd:    pulumi.String(\"0 7 * * 1\"),\n\t\t\tCronTimezone: pulumi.String(\"UTC\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ProjectFreezePeriod;\nimport com.pulumi.gitlab.ProjectFreezePeriodArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var schedule = new ProjectFreezePeriod(\"schedule\", ProjectFreezePeriodArgs.builder()        \n            .projectId(gitlab_project.foo().id())\n            .freezeStart(\"0 23 * * 5\")\n            .freezeEnd(\"0 7 * * 1\")\n            .cronTimezone(\"UTC\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  schedule:\n    type: gitlab:ProjectFreezePeriod\n    properties:\n      projectId: ${gitlab_project.foo.id}\n      freezeStart: 0 23 * * 5\n      freezeEnd: 0 7 * * 1\n      cronTimezone: UTC\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitLab project freeze periods can be imported using an id made up of `project_id:freeze_period_id`, e.g.\n\n```sh\n $ pulumi import gitlab:index/projectFreezePeriod:ProjectFreezePeriod schedule \"12345:1337\"\n```\n\n ",
            "properties": {
                "cronTimezone": {
                    "type": "string",
                    "description": "The timezone.\n"
                },
                "freezeEnd": {
                    "type": "string",
                    "description": "End of the Freeze Period in cron format (e.g. `0 2 * * *`).\n"
                },
                "freezeStart": {
                    "type": "string",
                    "description": "Start of the Freeze Period in cron format (e.g. `0 1 * * *`).\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The id of the project to add the schedule to.\n"
                }
            },
            "required": [
                "freezeEnd",
                "freezeStart",
                "projectId"
            ],
            "inputProperties": {
                "cronTimezone": {
                    "type": "string",
                    "description": "The timezone.\n"
                },
                "freezeEnd": {
                    "type": "string",
                    "description": "End of the Freeze Period in cron format (e.g. `0 2 * * *`).\n"
                },
                "freezeStart": {
                    "type": "string",
                    "description": "Start of the Freeze Period in cron format (e.g. `0 1 * * *`).\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The id of the project to add the schedule to.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "freezeEnd",
                "freezeStart",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectFreezePeriod resources.\n",
                "properties": {
                    "cronTimezone": {
                        "type": "string",
                        "description": "The timezone.\n"
                    },
                    "freezeEnd": {
                        "type": "string",
                        "description": "End of the Freeze Period in cron format (e.g. `0 2 * * *`).\n"
                    },
                    "freezeStart": {
                        "type": "string",
                        "description": "Start of the Freeze Period in cron format (e.g. `0 1 * * *`).\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The id of the project to add the schedule to.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectHook:ProjectHook": {
            "description": "The `gitlab.ProjectHook` resource allows to manage the lifecycle of a project hook.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/projects.html#hooks)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = new gitlab.ProjectHook(\"example\", {\n    mergeRequestsEvents: true,\n    project: \"example/hooked\",\n    url: \"https://example.com/hook/example\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.ProjectHook(\"example\",\n    merge_requests_events=True,\n    project=\"example/hooked\",\n    url=\"https://example.com/hook/example\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new GitLab.ProjectHook(\"example\", new()\n    {\n        MergeRequestsEvents = true,\n        Project = \"example/hooked\",\n        Url = \"https://example.com/hook/example\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewProjectHook(ctx, \"example\", \u0026gitlab.ProjectHookArgs{\n\t\t\tMergeRequestsEvents: pulumi.Bool(true),\n\t\t\tProject:             pulumi.String(\"example/hooked\"),\n\t\t\tUrl:                 pulumi.String(\"https://example.com/hook/example\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ProjectHook;\nimport com.pulumi.gitlab.ProjectHookArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ProjectHook(\"example\", ProjectHookArgs.builder()        \n            .mergeRequestsEvents(true)\n            .project(\"example/hooked\")\n            .url(\"https://example.com/hook/example\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: gitlab:ProjectHook\n    properties:\n      mergeRequestsEvents: true\n      project: example/hooked\n      url: https://example.com/hook/example\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nA GitLab Project Hook can be imported using a key composed of `\u003cproject-id\u003e:\u003chook-id\u003e`, e.g.\n\n```sh\n $ pulumi import gitlab:index/projectHook:ProjectHook example \"12345:1\"\n```\n\n NOTEthe `token` resource attribute is not available for imported resources as this information cannot be read from the GitLab API. ",
            "properties": {
                "confidentialIssuesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for confidential issues events.\n"
                },
                "confidentialNoteEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for confidential notes events.\n"
                },
                "deploymentEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for deployment events.\n"
                },
                "enableSslVerification": {
                    "type": "boolean",
                    "description": "Enable ssl verification when invoking the hook.\n"
                },
                "hookId": {
                    "type": "integer",
                    "description": "The id of the project hook.\n"
                },
                "issuesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for issues events.\n"
                },
                "jobEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for job events.\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for merge requests.\n"
                },
                "noteEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for notes events.\n"
                },
                "pipelineEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for pipeline events.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the hook to.\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "The id of the project for the hook.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for push events.\n"
                },
                "pushEventsBranchFilter": {
                    "type": "string",
                    "description": "Invoke the hook for push events on matching branches only.\n"
                },
                "releasesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for releases events.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for tag push events.\n"
                },
                "token": {
                    "type": "string",
                    "description": "A token to present when invoking the hook. The token is not available for imported resources.\n",
                    "secret": true
                },
                "url": {
                    "type": "string",
                    "description": "The url of the hook to invoke.\n"
                },
                "wikiPageEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for wiki page events.\n"
                }
            },
            "required": [
                "hookId",
                "project",
                "projectId",
                "url"
            ],
            "inputProperties": {
                "confidentialIssuesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for confidential issues events.\n"
                },
                "confidentialNoteEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for confidential notes events.\n"
                },
                "deploymentEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for deployment events.\n"
                },
                "enableSslVerification": {
                    "type": "boolean",
                    "description": "Enable ssl verification when invoking the hook.\n"
                },
                "issuesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for issues events.\n"
                },
                "jobEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for job events.\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for merge requests.\n"
                },
                "noteEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for notes events.\n"
                },
                "pipelineEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for pipeline events.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the hook to.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for push events.\n"
                },
                "pushEventsBranchFilter": {
                    "type": "string",
                    "description": "Invoke the hook for push events on matching branches only.\n"
                },
                "releasesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for releases events.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for tag push events.\n"
                },
                "token": {
                    "type": "string",
                    "description": "A token to present when invoking the hook. The token is not available for imported resources.\n",
                    "secret": true
                },
                "url": {
                    "type": "string",
                    "description": "The url of the hook to invoke.\n"
                },
                "wikiPageEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for wiki page events.\n"
                }
            },
            "requiredInputs": [
                "project",
                "url"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectHook resources.\n",
                "properties": {
                    "confidentialIssuesEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for confidential issues events.\n"
                    },
                    "confidentialNoteEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for confidential notes events.\n"
                    },
                    "deploymentEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for deployment events.\n"
                    },
                    "enableSslVerification": {
                        "type": "boolean",
                        "description": "Enable ssl verification when invoking the hook.\n"
                    },
                    "hookId": {
                        "type": "integer",
                        "description": "The id of the project hook.\n"
                    },
                    "issuesEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for issues events.\n"
                    },
                    "jobEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for job events.\n"
                    },
                    "mergeRequestsEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for merge requests.\n"
                    },
                    "noteEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for notes events.\n"
                    },
                    "pipelineEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for pipeline events.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project to add the hook to.\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "The id of the project for the hook.\n"
                    },
                    "pushEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for push events.\n"
                    },
                    "pushEventsBranchFilter": {
                        "type": "string",
                        "description": "Invoke the hook for push events on matching branches only.\n"
                    },
                    "releasesEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for releases events.\n"
                    },
                    "tagPushEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for tag push events.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "A token to present when invoking the hook. The token is not available for imported resources.\n",
                        "secret": true
                    },
                    "url": {
                        "type": "string",
                        "description": "The url of the hook to invoke.\n"
                    },
                    "wikiPageEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for wiki page events.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectIssue:ProjectIssue": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = new gitlab.Project(\"foo\", {\n    description: \"Lorem Ipsum\",\n    visibilityLevel: \"public\",\n});\nconst welcomeIssue = new gitlab.ProjectIssue(\"welcomeIssue\", {\n    project: foo.id,\n    title: \"Welcome!\",\n    description: pulumi.interpolate`  Welcome to the ${foo.name} project!\n\n`,\n    discussionLocked: true,\n});\nexport const welcomeIssueWebUrl = data.gitlab_project_issue.web_url;\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.Project(\"foo\",\n    description=\"Lorem Ipsum\",\n    visibility_level=\"public\")\nwelcome_issue = gitlab.ProjectIssue(\"welcomeIssue\",\n    project=foo.id,\n    title=\"Welcome!\",\n    description=foo.name.apply(lambda name: f\"\"\"  Welcome to the {name} project!\n\n\"\"\"),\n    discussion_locked=True)\npulumi.export(\"welcomeIssueWebUrl\", data[\"gitlab_project_issue\"][\"web_url\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = new GitLab.Project(\"foo\", new()\n    {\n        Description = \"Lorem Ipsum\",\n        VisibilityLevel = \"public\",\n    });\n\n    var welcomeIssue = new GitLab.ProjectIssue(\"welcomeIssue\", new()\n    {\n        Project = foo.Id,\n        Title = \"Welcome!\",\n        Description = foo.Name.Apply(name =\u003e @$\"  Welcome to the {name} project!\n\n\"),\n        DiscussionLocked = true,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"welcomeIssueWebUrl\"] = data.Gitlab_project_issue.Web_url,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfoo, err := gitlab.NewProject(ctx, \"foo\", \u0026gitlab.ProjectArgs{\n\t\t\tDescription:     pulumi.String(\"Lorem Ipsum\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectIssue(ctx, \"welcomeIssue\", \u0026gitlab.ProjectIssueArgs{\n\t\t\tProject: foo.ID(),\n\t\t\tTitle:   pulumi.String(\"Welcome!\"),\n\t\t\tDescription: foo.Name.ApplyT(func(name string) (string, error) {\n\t\t\t\treturn fmt.Sprintf(\"  Welcome to the %v project!\\n\\n\", name), nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t\tDiscussionLocked: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"welcomeIssueWebUrl\", data.Gitlab_project_issue.Web_url)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ProjectIssue;\nimport com.pulumi.gitlab.ProjectIssueArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var foo = new Project(\"foo\", ProjectArgs.builder()        \n            .description(\"Lorem Ipsum\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var welcomeIssue = new ProjectIssue(\"welcomeIssue\", ProjectIssueArgs.builder()        \n            .project(foo.id())\n            .title(\"Welcome!\")\n            .description(foo.name().applyValue(name -\u003e \"\"\"\n  Welcome to the %s project!\n\n\", name)))\n            .discussionLocked(true)\n            .build());\n\n        ctx.export(\"welcomeIssueWebUrl\", data.gitlab_project_issue().web_url());\n    }\n}\n```\n```yaml\nresources:\n  foo:\n    type: gitlab:Project\n    properties:\n      description: Lorem Ipsum\n      visibilityLevel: public\n  welcomeIssue:\n    type: gitlab:ProjectIssue\n    properties:\n      project: ${foo.id}\n      title: Welcome!\n      description: |2+\n          Welcome to the ${foo.name} project!\n\n      discussionLocked: true\noutputs:\n  welcomeIssueWebUrl: ${data.gitlab_project_issue.web_url}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nYou can import this resource with an id made up of `{project-id}:{issue-id}`, e.g.\n\n```sh\n $ pulumi import gitlab:index/projectIssue:ProjectIssue welcome_issue 42:1\n```\n\n ",
            "properties": {
                "assigneeIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "The IDs of the users to assign the issue to.\n"
                },
                "authorId": {
                    "type": "integer",
                    "description": "The ID of the author of the issue. Use `gitlab.User` data source to get more information about the user.\n"
                },
                "closedAt": {
                    "type": "string",
                    "description": "When the issue was closed. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n"
                },
                "closedByUserId": {
                    "type": "integer",
                    "description": "The ID of the user that closed the issue. Use `gitlab.User` data source to get more information about the user.\n"
                },
                "confidential": {
                    "type": "boolean",
                    "description": "Set an issue to be confidential.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "When the issue was created. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z. Requires administrator or project/group owner rights.\n"
                },
                "deleteOnDestroy": {
                    "type": "boolean",
                    "description": "Whether the issue is deleted instead of closed during destroy.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of an issue. Limited to 1,048,576 characters.\n"
                },
                "discussionLocked": {
                    "type": "boolean",
                    "description": "Whether the issue is locked for discussions or not.\n"
                },
                "discussionToResolve": {
                    "type": "string",
                    "description": "The ID of a discussion to resolve. This fills out the issue with a default description and mark the discussion as resolved. Use in combination with merge*request*to*resolve*discussions_of.\n"
                },
                "downvotes": {
                    "type": "integer",
                    "description": "The number of downvotes the issue has received.\n"
                },
                "dueDate": {
                    "type": "string",
                    "description": "The due date. Date time string in the format YYYY-MM-DD, for example 2016-03-11.\n"
                },
                "epicId": {
                    "type": "integer",
                    "description": "ID of the epic to add the issue to. Valid values are greater than or equal to 0.\n"
                },
                "epicIssueId": {
                    "type": "integer",
                    "description": "The ID of the epic issue.\n"
                },
                "externalId": {
                    "type": "string",
                    "description": "The external ID of the issue.\n"
                },
                "humanTimeEstimate": {
                    "type": "string",
                    "description": "The human-readable time estimate of the issue.\n"
                },
                "humanTotalTimeSpent": {
                    "type": "string",
                    "description": "The human-readable total time spent of the issue.\n"
                },
                "iid": {
                    "type": "integer",
                    "description": "The internal ID of the project's issue.\n"
                },
                "issueId": {
                    "type": "integer",
                    "description": "The instance-wide ID of the issue.\n"
                },
                "issueLinkId": {
                    "type": "integer",
                    "description": "The ID of the issue link.\n"
                },
                "issueType": {
                    "type": "string",
                    "description": "The type of issue. Valid values are: `issue`, `incident`, `test_case`.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The labels of an issue.\n"
                },
                "links": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The links of the issue.\n"
                },
                "mergeRequestToResolveDiscussionsOf": {
                    "type": "integer",
                    "description": "The IID of a merge request in which to resolve all issues. This fills out the issue with a default description and mark all discussions as resolved. When passing a description or title, these values take precedence over the default values.\n"
                },
                "mergeRequestsCount": {
                    "type": "integer",
                    "description": "The number of merge requests associated with the issue.\n"
                },
                "milestoneId": {
                    "type": "integer",
                    "description": "The global ID of a milestone to assign issue. To find the milestone_id associated with a milestone, view an issue with the milestone assigned and use the API to retrieve the issue's details.\n"
                },
                "movedToId": {
                    "type": "integer",
                    "description": "The ID of the issue that was moved to.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or ID of the project.\n"
                },
                "references": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The references of the issue.\n"
                },
                "state": {
                    "type": "string",
                    "description": "The state of the issue. Valid values are: `opened`, `closed`.\n"
                },
                "subscribed": {
                    "type": "boolean",
                    "description": "Whether the authenticated user is subscribed to the issue or not.\n"
                },
                "taskCompletionStatuses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/ProjectIssueTaskCompletionStatus:ProjectIssueTaskCompletionStatus"
                    },
                    "description": "The task completion status. It's always a one element list.\n"
                },
                "timeEstimate": {
                    "type": "integer",
                    "description": "The time estimate of the issue.\n"
                },
                "title": {
                    "type": "string",
                    "description": "The title of the issue.\n"
                },
                "totalTimeSpent": {
                    "type": "integer",
                    "description": "The total time spent of the issue.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "When the issue was updated. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n"
                },
                "upvotes": {
                    "type": "integer",
                    "description": "The number of upvotes the issue has received.\n"
                },
                "userNotesCount": {
                    "type": "integer",
                    "description": "The number of user notes on the issue.\n"
                },
                "webUrl": {
                    "type": "string",
                    "description": "The web URL of the issue.\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "The weight of the issue. Valid values are greater than or equal to 0.\n"
                }
            },
            "required": [
                "authorId",
                "closedAt",
                "closedByUserId",
                "createdAt",
                "downvotes",
                "epicId",
                "epicIssueId",
                "externalId",
                "humanTimeEstimate",
                "humanTotalTimeSpent",
                "iid",
                "issueId",
                "issueLinkId",
                "links",
                "mergeRequestsCount",
                "movedToId",
                "project",
                "references",
                "subscribed",
                "taskCompletionStatuses",
                "timeEstimate",
                "title",
                "totalTimeSpent",
                "updatedAt",
                "upvotes",
                "userNotesCount",
                "webUrl",
                "weight"
            ],
            "inputProperties": {
                "assigneeIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "The IDs of the users to assign the issue to.\n"
                },
                "confidential": {
                    "type": "boolean",
                    "description": "Set an issue to be confidential.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "When the issue was created. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z. Requires administrator or project/group owner rights.\n",
                    "willReplaceOnChanges": true
                },
                "deleteOnDestroy": {
                    "type": "boolean",
                    "description": "Whether the issue is deleted instead of closed during destroy.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of an issue. Limited to 1,048,576 characters.\n"
                },
                "discussionLocked": {
                    "type": "boolean",
                    "description": "Whether the issue is locked for discussions or not.\n"
                },
                "discussionToResolve": {
                    "type": "string",
                    "description": "The ID of a discussion to resolve. This fills out the issue with a default description and mark the discussion as resolved. Use in combination with merge*request*to*resolve*discussions_of.\n"
                },
                "dueDate": {
                    "type": "string",
                    "description": "The due date. Date time string in the format YYYY-MM-DD, for example 2016-03-11.\n"
                },
                "epicIssueId": {
                    "type": "integer",
                    "description": "The ID of the epic issue.\n"
                },
                "iid": {
                    "type": "integer",
                    "description": "The internal ID of the project's issue.\n",
                    "willReplaceOnChanges": true
                },
                "issueType": {
                    "type": "string",
                    "description": "The type of issue. Valid values are: `issue`, `incident`, `test_case`.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The labels of an issue.\n"
                },
                "mergeRequestToResolveDiscussionsOf": {
                    "type": "integer",
                    "description": "The IID of a merge request in which to resolve all issues. This fills out the issue with a default description and mark all discussions as resolved. When passing a description or title, these values take precedence over the default values.\n"
                },
                "milestoneId": {
                    "type": "integer",
                    "description": "The global ID of a milestone to assign issue. To find the milestone_id associated with a milestone, view an issue with the milestone assigned and use the API to retrieve the issue's details.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or ID of the project.\n",
                    "willReplaceOnChanges": true
                },
                "state": {
                    "type": "string",
                    "description": "The state of the issue. Valid values are: `opened`, `closed`.\n"
                },
                "title": {
                    "type": "string",
                    "description": "The title of the issue.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "When the issue was updated. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "The weight of the issue. Valid values are greater than or equal to 0.\n"
                }
            },
            "requiredInputs": [
                "project",
                "title"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectIssue resources.\n",
                "properties": {
                    "assigneeIds": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "The IDs of the users to assign the issue to.\n"
                    },
                    "authorId": {
                        "type": "integer",
                        "description": "The ID of the author of the issue. Use `gitlab.User` data source to get more information about the user.\n"
                    },
                    "closedAt": {
                        "type": "string",
                        "description": "When the issue was closed. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n"
                    },
                    "closedByUserId": {
                        "type": "integer",
                        "description": "The ID of the user that closed the issue. Use `gitlab.User` data source to get more information about the user.\n"
                    },
                    "confidential": {
                        "type": "boolean",
                        "description": "Set an issue to be confidential.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "When the issue was created. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z. Requires administrator or project/group owner rights.\n",
                        "willReplaceOnChanges": true
                    },
                    "deleteOnDestroy": {
                        "type": "boolean",
                        "description": "Whether the issue is deleted instead of closed during destroy.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of an issue. Limited to 1,048,576 characters.\n"
                    },
                    "discussionLocked": {
                        "type": "boolean",
                        "description": "Whether the issue is locked for discussions or not.\n"
                    },
                    "discussionToResolve": {
                        "type": "string",
                        "description": "The ID of a discussion to resolve. This fills out the issue with a default description and mark the discussion as resolved. Use in combination with merge*request*to*resolve*discussions_of.\n"
                    },
                    "downvotes": {
                        "type": "integer",
                        "description": "The number of downvotes the issue has received.\n"
                    },
                    "dueDate": {
                        "type": "string",
                        "description": "The due date. Date time string in the format YYYY-MM-DD, for example 2016-03-11.\n"
                    },
                    "epicId": {
                        "type": "integer",
                        "description": "ID of the epic to add the issue to. Valid values are greater than or equal to 0.\n"
                    },
                    "epicIssueId": {
                        "type": "integer",
                        "description": "The ID of the epic issue.\n"
                    },
                    "externalId": {
                        "type": "string",
                        "description": "The external ID of the issue.\n"
                    },
                    "humanTimeEstimate": {
                        "type": "string",
                        "description": "The human-readable time estimate of the issue.\n"
                    },
                    "humanTotalTimeSpent": {
                        "type": "string",
                        "description": "The human-readable total time spent of the issue.\n"
                    },
                    "iid": {
                        "type": "integer",
                        "description": "The internal ID of the project's issue.\n",
                        "willReplaceOnChanges": true
                    },
                    "issueId": {
                        "type": "integer",
                        "description": "The instance-wide ID of the issue.\n"
                    },
                    "issueLinkId": {
                        "type": "integer",
                        "description": "The ID of the issue link.\n"
                    },
                    "issueType": {
                        "type": "string",
                        "description": "The type of issue. Valid values are: `issue`, `incident`, `test_case`.\n"
                    },
                    "labels": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The labels of an issue.\n"
                    },
                    "links": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "The links of the issue.\n"
                    },
                    "mergeRequestToResolveDiscussionsOf": {
                        "type": "integer",
                        "description": "The IID of a merge request in which to resolve all issues. This fills out the issue with a default description and mark all discussions as resolved. When passing a description or title, these values take precedence over the default values.\n"
                    },
                    "mergeRequestsCount": {
                        "type": "integer",
                        "description": "The number of merge requests associated with the issue.\n"
                    },
                    "milestoneId": {
                        "type": "integer",
                        "description": "The global ID of a milestone to assign issue. To find the milestone_id associated with a milestone, view an issue with the milestone assigned and use the API to retrieve the issue's details.\n"
                    },
                    "movedToId": {
                        "type": "integer",
                        "description": "The ID of the issue that was moved to.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or ID of the project.\n",
                        "willReplaceOnChanges": true
                    },
                    "references": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "The references of the issue.\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "The state of the issue. Valid values are: `opened`, `closed`.\n"
                    },
                    "subscribed": {
                        "type": "boolean",
                        "description": "Whether the authenticated user is subscribed to the issue or not.\n"
                    },
                    "taskCompletionStatuses": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/ProjectIssueTaskCompletionStatus:ProjectIssueTaskCompletionStatus"
                        },
                        "description": "The task completion status. It's always a one element list.\n"
                    },
                    "timeEstimate": {
                        "type": "integer",
                        "description": "The time estimate of the issue.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "The title of the issue.\n"
                    },
                    "totalTimeSpent": {
                        "type": "integer",
                        "description": "The total time spent of the issue.\n"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "When the issue was updated. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n"
                    },
                    "upvotes": {
                        "type": "integer",
                        "description": "The number of upvotes the issue has received.\n"
                    },
                    "userNotesCount": {
                        "type": "integer",
                        "description": "The number of user notes on the issue.\n"
                    },
                    "webUrl": {
                        "type": "string",
                        "description": "The web URL of the issue.\n"
                    },
                    "weight": {
                        "type": "integer",
                        "description": "The weight of the issue. Valid values are greater than or equal to 0.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectIssueBoard:ProjectIssueBoard": {
            "description": "The `gitlab.ProjectIssueBoard` resource allows to manage the lifecycle of a Project Issue Board.\n\n\u003e **NOTE:** If the board lists are changed all lists will be recreated.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/boards.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst exampleProject = new gitlab.Project(\"exampleProject\", {\n    description: \"Lorem Ipsum\",\n    visibilityLevel: \"public\",\n});\nconst exampleUser = new gitlab.User(\"exampleUser\", {\n    username: \"example\",\n    email: \"example@example.com\",\n    password: \"example1$$$\",\n});\nconst exampleProjectMembership = new gitlab.ProjectMembership(\"exampleProjectMembership\", {\n    projectId: exampleProject.id,\n    userId: exampleUser.id,\n    accessLevel: \"developer\",\n});\nconst exampleProjectMilestone = new gitlab.ProjectMilestone(\"exampleProjectMilestone\", {\n    project: exampleProject.id,\n    title: \"m1\",\n});\nconst _this = new gitlab.ProjectIssueBoard(\"this\", {\n    project: exampleProject.id,\n    lists: [\n        {\n            assigneeId: exampleUser.id,\n        },\n        {\n            milestoneId: exampleProjectMilestone.milestoneId,\n        },\n    ],\n}, {\n    dependsOn: [exampleProjectMembership],\n});\nconst listSyntax = new gitlab.ProjectIssueBoard(\"listSyntax\", {\n    project: exampleProject.id,\n    lists: [\n        {\n            assigneeId: exampleUser.id,\n        },\n        {\n            milestoneId: exampleProjectMilestone.milestoneId,\n        },\n    ],\n}, {\n    dependsOn: [exampleProjectMembership],\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample_project = gitlab.Project(\"exampleProject\",\n    description=\"Lorem Ipsum\",\n    visibility_level=\"public\")\nexample_user = gitlab.User(\"exampleUser\",\n    username=\"example\",\n    email=\"example@example.com\",\n    password=\"example1$$$\")\nexample_project_membership = gitlab.ProjectMembership(\"exampleProjectMembership\",\n    project_id=example_project.id,\n    user_id=example_user.id,\n    access_level=\"developer\")\nexample_project_milestone = gitlab.ProjectMilestone(\"exampleProjectMilestone\",\n    project=example_project.id,\n    title=\"m1\")\nthis = gitlab.ProjectIssueBoard(\"this\",\n    project=example_project.id,\n    lists=[\n        gitlab.ProjectIssueBoardListArgs(\n            assignee_id=example_user.id,\n        ),\n        gitlab.ProjectIssueBoardListArgs(\n            milestone_id=example_project_milestone.milestone_id,\n        ),\n    ],\n    opts=pulumi.ResourceOptions(depends_on=[example_project_membership]))\nlist_syntax = gitlab.ProjectIssueBoard(\"listSyntax\",\n    project=example_project.id,\n    lists=[\n        gitlab.ProjectIssueBoardListArgs(\n            assignee_id=example_user.id,\n        ),\n        gitlab.ProjectIssueBoardListArgs(\n            milestone_id=example_project_milestone.milestone_id,\n        ),\n    ],\n    opts=pulumi.ResourceOptions(depends_on=[example_project_membership]))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleProject = new GitLab.Project(\"exampleProject\", new()\n    {\n        Description = \"Lorem Ipsum\",\n        VisibilityLevel = \"public\",\n    });\n\n    var exampleUser = new GitLab.User(\"exampleUser\", new()\n    {\n        Username = \"example\",\n        Email = \"example@example.com\",\n        Password = \"example1$$$\",\n    });\n\n    var exampleProjectMembership = new GitLab.ProjectMembership(\"exampleProjectMembership\", new()\n    {\n        ProjectId = exampleProject.Id,\n        UserId = exampleUser.Id,\n        AccessLevel = \"developer\",\n    });\n\n    var exampleProjectMilestone = new GitLab.ProjectMilestone(\"exampleProjectMilestone\", new()\n    {\n        Project = exampleProject.Id,\n        Title = \"m1\",\n    });\n\n    var @this = new GitLab.ProjectIssueBoard(\"this\", new()\n    {\n        Project = exampleProject.Id,\n        Lists = new[]\n        {\n            new GitLab.Inputs.ProjectIssueBoardListArgs\n            {\n                AssigneeId = exampleUser.Id,\n            },\n            new GitLab.Inputs.ProjectIssueBoardListArgs\n            {\n                MilestoneId = exampleProjectMilestone.MilestoneId,\n            },\n        },\n    }, new CustomResourceOptions\n    {\n        DependsOn = new[]\n        {\n            exampleProjectMembership,\n        },\n    });\n\n    var listSyntax = new GitLab.ProjectIssueBoard(\"listSyntax\", new()\n    {\n        Project = exampleProject.Id,\n        Lists = new[]\n        {\n            new GitLab.Inputs.ProjectIssueBoardListArgs\n            {\n                AssigneeId = exampleUser.Id,\n            },\n            new GitLab.Inputs.ProjectIssueBoardListArgs\n            {\n                MilestoneId = exampleProjectMilestone.MilestoneId,\n            },\n        },\n    }, new CustomResourceOptions\n    {\n        DependsOn = new[]\n        {\n            exampleProjectMembership,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleProject, err := gitlab.NewProject(ctx, \"exampleProject\", \u0026gitlab.ProjectArgs{\n\t\t\tDescription:     pulumi.String(\"Lorem Ipsum\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleUser, err := gitlab.NewUser(ctx, \"exampleUser\", \u0026gitlab.UserArgs{\n\t\t\tUsername: pulumi.String(\"example\"),\n\t\t\tEmail:    pulumi.String(\"example@example.com\"),\n\t\t\tPassword: pulumi.String(\"example1$$$\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleProjectMembership, err := gitlab.NewProjectMembership(ctx, \"exampleProjectMembership\", \u0026gitlab.ProjectMembershipArgs{\n\t\t\tProjectId:   exampleProject.ID(),\n\t\t\tUserId:      exampleUser.ID(),\n\t\t\tAccessLevel: pulumi.String(\"developer\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleProjectMilestone, err := gitlab.NewProjectMilestone(ctx, \"exampleProjectMilestone\", \u0026gitlab.ProjectMilestoneArgs{\n\t\t\tProject: exampleProject.ID(),\n\t\t\tTitle:   pulumi.String(\"m1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectIssueBoard(ctx, \"this\", \u0026gitlab.ProjectIssueBoardArgs{\n\t\t\tProject: exampleProject.ID(),\n\t\t\tLists: gitlab.ProjectIssueBoardListArray{\n\t\t\t\t\u0026gitlab.ProjectIssueBoardListArgs{\n\t\t\t\t\tAssigneeId: exampleUser.ID(),\n\t\t\t\t},\n\t\t\t\t\u0026gitlab.ProjectIssueBoardListArgs{\n\t\t\t\t\tMilestoneId: exampleProjectMilestone.MilestoneId,\n\t\t\t\t},\n\t\t\t},\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\texampleProjectMembership,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectIssueBoard(ctx, \"listSyntax\", \u0026gitlab.ProjectIssueBoardArgs{\n\t\t\tProject: exampleProject.ID(),\n\t\t\tLists: gitlab.ProjectIssueBoardListArray{\n\t\t\t\t\u0026gitlab.ProjectIssueBoardListArgs{\n\t\t\t\t\tAssigneeId: exampleUser.ID(),\n\t\t\t\t},\n\t\t\t\t\u0026gitlab.ProjectIssueBoardListArgs{\n\t\t\t\t\tMilestoneId: exampleProjectMilestone.MilestoneId,\n\t\t\t\t},\n\t\t\t},\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\texampleProjectMembership,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.User;\nimport com.pulumi.gitlab.UserArgs;\nimport com.pulumi.gitlab.ProjectMembership;\nimport com.pulumi.gitlab.ProjectMembershipArgs;\nimport com.pulumi.gitlab.ProjectMilestone;\nimport com.pulumi.gitlab.ProjectMilestoneArgs;\nimport com.pulumi.gitlab.ProjectIssueBoard;\nimport com.pulumi.gitlab.ProjectIssueBoardArgs;\nimport com.pulumi.gitlab.inputs.ProjectIssueBoardListArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleProject = new Project(\"exampleProject\", ProjectArgs.builder()        \n            .description(\"Lorem Ipsum\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var exampleUser = new User(\"exampleUser\", UserArgs.builder()        \n            .username(\"example\")\n            .email(\"example@example.com\")\n            .password(\"example1$$$\")\n            .build());\n\n        var exampleProjectMembership = new ProjectMembership(\"exampleProjectMembership\", ProjectMembershipArgs.builder()        \n            .projectId(exampleProject.id())\n            .userId(exampleUser.id())\n            .accessLevel(\"developer\")\n            .build());\n\n        var exampleProjectMilestone = new ProjectMilestone(\"exampleProjectMilestone\", ProjectMilestoneArgs.builder()        \n            .project(exampleProject.id())\n            .title(\"m1\")\n            .build());\n\n        var this_ = new ProjectIssueBoard(\"this\", ProjectIssueBoardArgs.builder()        \n            .project(exampleProject.id())\n            .lists(            \n                ProjectIssueBoardListArgs.builder()\n                    .assigneeId(exampleUser.id())\n                    .build(),\n                ProjectIssueBoardListArgs.builder()\n                    .milestoneId(exampleProjectMilestone.milestoneId())\n                    .build())\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(exampleProjectMembership)\n                .build());\n\n        var listSyntax = new ProjectIssueBoard(\"listSyntax\", ProjectIssueBoardArgs.builder()        \n            .project(exampleProject.id())\n            .lists(            \n                ProjectIssueBoardListArgs.builder()\n                    .assigneeId(exampleUser.id())\n                    .build(),\n                ProjectIssueBoardListArgs.builder()\n                    .milestoneId(exampleProjectMilestone.milestoneId())\n                    .build())\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(exampleProjectMembership)\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleProject:\n    type: gitlab:Project\n    properties:\n      description: Lorem Ipsum\n      visibilityLevel: public\n  exampleUser:\n    type: gitlab:User\n    properties:\n      username: example\n      email: example@example.com\n      password: example1$$$\n  exampleProjectMembership:\n    type: gitlab:ProjectMembership\n    properties:\n      projectId: ${exampleProject.id}\n      userId: ${exampleUser.id}\n      accessLevel: developer\n  exampleProjectMilestone:\n    type: gitlab:ProjectMilestone\n    properties:\n      project: ${exampleProject.id}\n      title: m1\n  this:\n    type: gitlab:ProjectIssueBoard\n    properties:\n      project: ${exampleProject.id}\n      lists:\n        - assigneeId: ${exampleUser.id}\n        - milestoneId: ${exampleProjectMilestone.milestoneId}\n    options:\n      dependson:\n        - ${exampleProjectMembership}\n  listSyntax:\n    type: gitlab:ProjectIssueBoard\n    properties:\n      project: ${exampleProject.id}\n      lists:\n        - assigneeId: ${exampleUser.id}\n        - milestoneId: ${exampleProjectMilestone.milestoneId}\n    options:\n      dependson:\n        - ${exampleProjectMembership}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nYou can import this resource with an id made up of `{project-id}:{issue-board-id}`, e.g.\n\n```sh\n $ pulumi import gitlab:index/projectIssueBoard:ProjectIssueBoard kanban 42:1\n```\n\n ",
            "properties": {
                "assigneeId": {
                    "type": "integer",
                    "description": "The assignee the board should be scoped to. Requires a GitLab EE license.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of label names which the board should be scoped to. Requires a GitLab EE license.\n"
                },
                "lists": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/ProjectIssueBoardList:ProjectIssueBoardList"
                    },
                    "description": "The list of issue board lists\n"
                },
                "milestoneId": {
                    "type": "integer",
                    "description": "The milestone the board should be scoped to. Requires a GitLab EE license.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the board.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project maintained by the authenticated user.\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "The weight range from 0 to 9, to which the board should be scoped to. Requires a GitLab EE license.\n"
                }
            },
            "required": [
                "name",
                "project"
            ],
            "inputProperties": {
                "assigneeId": {
                    "type": "integer",
                    "description": "The assignee the board should be scoped to. Requires a GitLab EE license.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of label names which the board should be scoped to. Requires a GitLab EE license.\n"
                },
                "lists": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/ProjectIssueBoardList:ProjectIssueBoardList"
                    },
                    "description": "The list of issue board lists\n"
                },
                "milestoneId": {
                    "type": "integer",
                    "description": "The milestone the board should be scoped to. Requires a GitLab EE license.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the board.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project maintained by the authenticated user.\n",
                    "willReplaceOnChanges": true
                },
                "weight": {
                    "type": "integer",
                    "description": "The weight range from 0 to 9, to which the board should be scoped to. Requires a GitLab EE license.\n"
                }
            },
            "requiredInputs": [
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectIssueBoard resources.\n",
                "properties": {
                    "assigneeId": {
                        "type": "integer",
                        "description": "The assignee the board should be scoped to. Requires a GitLab EE license.\n"
                    },
                    "labels": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of label names which the board should be scoped to. Requires a GitLab EE license.\n"
                    },
                    "lists": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/ProjectIssueBoardList:ProjectIssueBoardList"
                        },
                        "description": "The list of issue board lists\n"
                    },
                    "milestoneId": {
                        "type": "integer",
                        "description": "The milestone the board should be scoped to. Requires a GitLab EE license.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the board.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or full path of the project maintained by the authenticated user.\n",
                        "willReplaceOnChanges": true
                    },
                    "weight": {
                        "type": "integer",
                        "description": "The weight range from 0 to 9, to which the board should be scoped to. Requires a GitLab EE license.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectLevelMrApprovals:ProjectLevelMrApprovals": {
            "description": "The `gitlab_project_level_mr_approval_rule` resource allows to manage the lifecycle of a Merge Request-level approval rule.\n\n\u003e This resource requires a GitLab Enterprise instance.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/merge_request_approvals.html#merge-request-level-mr-approvals)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst fooProject = new gitlab.Project(\"fooProject\", {description: \"My example project\"});\nconst fooProjectLevelMrApprovals = new gitlab.ProjectLevelMrApprovals(\"fooProjectLevelMrApprovals\", {\n    projectId: fooProject.id,\n    resetApprovalsOnPush: true,\n    disableOverridingApproversPerMergeRequest: false,\n    mergeRequestsAuthorApproval: false,\n    mergeRequestsDisableCommittersApproval: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo_project = gitlab.Project(\"fooProject\", description=\"My example project\")\nfoo_project_level_mr_approvals = gitlab.ProjectLevelMrApprovals(\"fooProjectLevelMrApprovals\",\n    project_id=foo_project.id,\n    reset_approvals_on_push=True,\n    disable_overriding_approvers_per_merge_request=False,\n    merge_requests_author_approval=False,\n    merge_requests_disable_committers_approval=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var fooProject = new GitLab.Project(\"fooProject\", new()\n    {\n        Description = \"My example project\",\n    });\n\n    var fooProjectLevelMrApprovals = new GitLab.ProjectLevelMrApprovals(\"fooProjectLevelMrApprovals\", new()\n    {\n        ProjectId = fooProject.Id,\n        ResetApprovalsOnPush = true,\n        DisableOverridingApproversPerMergeRequest = false,\n        MergeRequestsAuthorApproval = false,\n        MergeRequestsDisableCommittersApproval = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfooProject, err := gitlab.NewProject(ctx, \"fooProject\", \u0026gitlab.ProjectArgs{\n\t\t\tDescription: pulumi.String(\"My example project\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectLevelMrApprovals(ctx, \"fooProjectLevelMrApprovals\", \u0026gitlab.ProjectLevelMrApprovalsArgs{\n\t\t\tProjectId:            fooProject.ID(),\n\t\t\tResetApprovalsOnPush: pulumi.Bool(true),\n\t\t\tDisableOverridingApproversPerMergeRequest: pulumi.Bool(false),\n\t\t\tMergeRequestsAuthorApproval:               pulumi.Bool(false),\n\t\t\tMergeRequestsDisableCommittersApproval:    pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ProjectLevelMrApprovals;\nimport com.pulumi.gitlab.ProjectLevelMrApprovalsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var fooProject = new Project(\"fooProject\", ProjectArgs.builder()        \n            .description(\"My example project\")\n            .build());\n\n        var fooProjectLevelMrApprovals = new ProjectLevelMrApprovals(\"fooProjectLevelMrApprovals\", ProjectLevelMrApprovalsArgs.builder()        \n            .projectId(fooProject.id())\n            .resetApprovalsOnPush(true)\n            .disableOverridingApproversPerMergeRequest(false)\n            .mergeRequestsAuthorApproval(false)\n            .mergeRequestsDisableCommittersApproval(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  fooProject:\n    type: gitlab:Project\n    properties:\n      description: My example project\n  fooProjectLevelMrApprovals:\n    type: gitlab:ProjectLevelMrApprovals\n    properties:\n      projectId: ${fooProject.id}\n      resetApprovalsOnPush: true\n      disableOverridingApproversPerMergeRequest: false\n      mergeRequestsAuthorApproval: false\n      mergeRequestsDisableCommittersApproval: true\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import gitlab:index/projectLevelMrApprovals:ProjectLevelMrApprovals You can import an approval configuration state using `\u003cresource\u003e \u003cproject_id\u003e`.\n```\n\n # For example\n\n```sh\n $ pulumi import gitlab:index/projectLevelMrApprovals:ProjectLevelMrApprovals foo 1234\n```\n\n ",
            "properties": {
                "disableOverridingApproversPerMergeRequest": {
                    "type": "boolean",
                    "description": "By default, users are able to edit the approval rules in merge requests. If set to true,\n"
                },
                "mergeRequestsAuthorApproval": {
                    "type": "boolean",
                    "description": "Set to `true` if you want to allow merge request authors to self-approve merge requests. Authors\n"
                },
                "mergeRequestsDisableCommittersApproval": {
                    "type": "boolean",
                    "description": "Set to `true` if you want to prevent approval of merge requests by merge request committers.\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "The ID of the project to change MR approval configuration.\n"
                },
                "requirePasswordToApprove": {
                    "type": "boolean",
                    "description": "Set to `true` if you want to require authentication when approving a merge request.\n"
                },
                "resetApprovalsOnPush": {
                    "type": "boolean",
                    "description": "Set to `true` if you want to remove all approvals in a merge request when new commits are pushed to its source branch. Default is `true`.\n"
                }
            },
            "required": [
                "projectId"
            ],
            "inputProperties": {
                "disableOverridingApproversPerMergeRequest": {
                    "type": "boolean",
                    "description": "By default, users are able to edit the approval rules in merge requests. If set to true,\n"
                },
                "mergeRequestsAuthorApproval": {
                    "type": "boolean",
                    "description": "Set to `true` if you want to allow merge request authors to self-approve merge requests. Authors\n"
                },
                "mergeRequestsDisableCommittersApproval": {
                    "type": "boolean",
                    "description": "Set to `true` if you want to prevent approval of merge requests by merge request committers.\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "The ID of the project to change MR approval configuration.\n",
                    "willReplaceOnChanges": true
                },
                "requirePasswordToApprove": {
                    "type": "boolean",
                    "description": "Set to `true` if you want to require authentication when approving a merge request.\n"
                },
                "resetApprovalsOnPush": {
                    "type": "boolean",
                    "description": "Set to `true` if you want to remove all approvals in a merge request when new commits are pushed to its source branch. Default is `true`.\n"
                }
            },
            "requiredInputs": [
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectLevelMrApprovals resources.\n",
                "properties": {
                    "disableOverridingApproversPerMergeRequest": {
                        "type": "boolean",
                        "description": "By default, users are able to edit the approval rules in merge requests. If set to true,\n"
                    },
                    "mergeRequestsAuthorApproval": {
                        "type": "boolean",
                        "description": "Set to `true` if you want to allow merge request authors to self-approve merge requests. Authors\n"
                    },
                    "mergeRequestsDisableCommittersApproval": {
                        "type": "boolean",
                        "description": "Set to `true` if you want to prevent approval of merge requests by merge request committers.\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "The ID of the project to change MR approval configuration.\n",
                        "willReplaceOnChanges": true
                    },
                    "requirePasswordToApprove": {
                        "type": "boolean",
                        "description": "Set to `true` if you want to require authentication when approving a merge request.\n"
                    },
                    "resetApprovalsOnPush": {
                        "type": "boolean",
                        "description": "Set to `true` if you want to remove all approvals in a merge request when new commits are pushed to its source branch. Default is `true`.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectMembership:ProjectMembership": {
            "description": "The `gitlab.ProjectMembership` resource allows to manage the lifecycle of a users project membership.\n\n\u003e If a project should grant membership to an entire group use the `gitlab.ProjectShareGroup` resource instead.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/members.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst test = new gitlab.ProjectMembership(\"test\", {\n    accessLevel: \"guest\",\n    projectId: \"12345\",\n    userId: 1337,\n});\nconst example = new gitlab.ProjectMembership(\"example\", {\n    accessLevel: \"guest\",\n    expiresAt: \"2022-12-31\",\n    projectId: \"67890\",\n    userId: 1234,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\ntest = gitlab.ProjectMembership(\"test\",\n    access_level=\"guest\",\n    project_id=\"12345\",\n    user_id=1337)\nexample = gitlab.ProjectMembership(\"example\",\n    access_level=\"guest\",\n    expires_at=\"2022-12-31\",\n    project_id=\"67890\",\n    user_id=1234)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new GitLab.ProjectMembership(\"test\", new()\n    {\n        AccessLevel = \"guest\",\n        ProjectId = \"12345\",\n        UserId = 1337,\n    });\n\n    var example = new GitLab.ProjectMembership(\"example\", new()\n    {\n        AccessLevel = \"guest\",\n        ExpiresAt = \"2022-12-31\",\n        ProjectId = \"67890\",\n        UserId = 1234,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewProjectMembership(ctx, \"test\", \u0026gitlab.ProjectMembershipArgs{\n\t\t\tAccessLevel: pulumi.String(\"guest\"),\n\t\t\tProjectId:   pulumi.String(\"12345\"),\n\t\t\tUserId:      pulumi.Int(1337),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectMembership(ctx, \"example\", \u0026gitlab.ProjectMembershipArgs{\n\t\t\tAccessLevel: pulumi.String(\"guest\"),\n\t\t\tExpiresAt:   pulumi.String(\"2022-12-31\"),\n\t\t\tProjectId:   pulumi.String(\"67890\"),\n\t\t\tUserId:      pulumi.Int(1234),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ProjectMembership;\nimport com.pulumi.gitlab.ProjectMembershipArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new ProjectMembership(\"test\", ProjectMembershipArgs.builder()        \n            .accessLevel(\"guest\")\n            .projectId(\"12345\")\n            .userId(1337)\n            .build());\n\n        var example = new ProjectMembership(\"example\", ProjectMembershipArgs.builder()        \n            .accessLevel(\"guest\")\n            .expiresAt(\"2022-12-31\")\n            .projectId(\"67890\")\n            .userId(1234)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: gitlab:ProjectMembership\n    properties:\n      accessLevel: guest\n      projectId: '12345'\n      userId: 1337\n  example:\n    type: gitlab:ProjectMembership\n    properties:\n      accessLevel: guest\n      expiresAt: 2022-12-31\n      projectId: '67890'\n      userId: 1234\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitLab project membership can be imported using an id made up of `project_id:user_id`, e.g.\n\n```sh\n $ pulumi import gitlab:index/projectMembership:ProjectMembership test \"12345:1337\"\n```\n\n ",
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "The access level for the member. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`, `master`\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "Expiration date for the project membership. Format: `YYYY-MM-DD`\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The id of the project.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The id of the user.\n"
                }
            },
            "required": [
                "accessLevel",
                "projectId",
                "userId"
            ],
            "inputProperties": {
                "accessLevel": {
                    "type": "string",
                    "description": "The access level for the member. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`, `master`\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "Expiration date for the project membership. Format: `YYYY-MM-DD`\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The id of the project.\n",
                    "willReplaceOnChanges": true
                },
                "userId": {
                    "type": "integer",
                    "description": "The id of the user.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accessLevel",
                "projectId",
                "userId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectMembership resources.\n",
                "properties": {
                    "accessLevel": {
                        "type": "string",
                        "description": "The access level for the member. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`, `master`\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "Expiration date for the project membership. Format: `YYYY-MM-DD`\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The id of the project.\n",
                        "willReplaceOnChanges": true
                    },
                    "userId": {
                        "type": "integer",
                        "description": "The id of the user.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectMilestone:ProjectMilestone": {
            "description": "The `gitlab.ProjectMilestone` resource allows to manage the lifecycle of a project milestone.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/milestones.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\n// Create a project for the milestone to use\nconst exampleProject = new gitlab.Project(\"exampleProject\", {\n    description: \"An example project\",\n    namespaceId: gitlab_group.example.id,\n});\nconst exampleProjectMilestone = new gitlab.ProjectMilestone(\"exampleProjectMilestone\", {\n    project: exampleProject.id,\n    title: \"example\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\n# Create a project for the milestone to use\nexample_project = gitlab.Project(\"exampleProject\",\n    description=\"An example project\",\n    namespace_id=gitlab_group[\"example\"][\"id\"])\nexample_project_milestone = gitlab.ProjectMilestone(\"exampleProjectMilestone\",\n    project=example_project.id,\n    title=\"example\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create a project for the milestone to use\n    var exampleProject = new GitLab.Project(\"exampleProject\", new()\n    {\n        Description = \"An example project\",\n        NamespaceId = gitlab_group.Example.Id,\n    });\n\n    var exampleProjectMilestone = new GitLab.ProjectMilestone(\"exampleProjectMilestone\", new()\n    {\n        Project = exampleProject.Id,\n        Title = \"example\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleProject, err := gitlab.NewProject(ctx, \"exampleProject\", \u0026gitlab.ProjectArgs{\n\t\t\tDescription: pulumi.String(\"An example project\"),\n\t\t\tNamespaceId: pulumi.Any(gitlab_group.Example.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectMilestone(ctx, \"exampleProjectMilestone\", \u0026gitlab.ProjectMilestoneArgs{\n\t\t\tProject: exampleProject.ID(),\n\t\t\tTitle:   pulumi.String(\"example\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ProjectMilestone;\nimport com.pulumi.gitlab.ProjectMilestoneArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleProject = new Project(\"exampleProject\", ProjectArgs.builder()        \n            .description(\"An example project\")\n            .namespaceId(gitlab_group.example().id())\n            .build());\n\n        var exampleProjectMilestone = new ProjectMilestone(\"exampleProjectMilestone\", ProjectMilestoneArgs.builder()        \n            .project(exampleProject.id())\n            .title(\"example\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a project for the milestone to use\n  exampleProject:\n    type: gitlab:Project\n    properties:\n      description: An example project\n      namespaceId: ${gitlab_group.example.id}\n  exampleProjectMilestone:\n    type: gitlab:ProjectMilestone\n    properties:\n      project: ${exampleProject.id}\n      title: example\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitlab project milestone can be imported with a key composed of `\u003cproject\u003e:\u003cmilestone_id\u003e`, e.g.\n\n```sh\n $ pulumi import gitlab:index/projectMilestone:ProjectMilestone example \"12345:11\"\n```\n\n ",
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "The time of creation of the milestone. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the milestone.\n"
                },
                "dueDate": {
                    "type": "string",
                    "description": "The due date of the milestone. Date time string in the format YYYY-MM-DD, for example 2016-03-11.\n"
                },
                "expired": {
                    "type": "boolean",
                    "description": "Bool, true if milestone expired.\n"
                },
                "iid": {
                    "type": "integer",
                    "description": "The ID of the project's milestone.\n"
                },
                "milestoneId": {
                    "type": "integer",
                    "description": "The instance-wide ID of the project’s milestone.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "The project ID of milestone.\n"
                },
                "startDate": {
                    "type": "string",
                    "description": "The start date of the milestone. Date time string in the format YYYY-MM-DD, for example 2016-03-11.\n"
                },
                "state": {
                    "type": "string",
                    "description": "The state of the milestone. Valid values are: `active`, `closed`.\n"
                },
                "title": {
                    "type": "string",
                    "description": "The title of a milestone.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "The last update time of the milestone. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n"
                },
                "webUrl": {
                    "type": "string",
                    "description": "The web URL of the milestone.\n"
                }
            },
            "required": [
                "createdAt",
                "expired",
                "iid",
                "milestoneId",
                "project",
                "projectId",
                "title",
                "updatedAt",
                "webUrl"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "The description of the milestone.\n"
                },
                "dueDate": {
                    "type": "string",
                    "description": "The due date of the milestone. Date time string in the format YYYY-MM-DD, for example 2016-03-11.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n",
                    "willReplaceOnChanges": true
                },
                "startDate": {
                    "type": "string",
                    "description": "The start date of the milestone. Date time string in the format YYYY-MM-DD, for example 2016-03-11.\n"
                },
                "state": {
                    "type": "string",
                    "description": "The state of the milestone. Valid values are: `active`, `closed`.\n"
                },
                "title": {
                    "type": "string",
                    "description": "The title of a milestone.\n"
                }
            },
            "requiredInputs": [
                "project",
                "title"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectMilestone resources.\n",
                "properties": {
                    "createdAt": {
                        "type": "string",
                        "description": "The time of creation of the milestone. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the milestone.\n"
                    },
                    "dueDate": {
                        "type": "string",
                        "description": "The due date of the milestone. Date time string in the format YYYY-MM-DD, for example 2016-03-11.\n"
                    },
                    "expired": {
                        "type": "boolean",
                        "description": "Bool, true if milestone expired.\n"
                    },
                    "iid": {
                        "type": "integer",
                        "description": "The ID of the project's milestone.\n"
                    },
                    "milestoneId": {
                        "type": "integer",
                        "description": "The instance-wide ID of the project’s milestone.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n",
                        "willReplaceOnChanges": true
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "The project ID of milestone.\n"
                    },
                    "startDate": {
                        "type": "string",
                        "description": "The start date of the milestone. Date time string in the format YYYY-MM-DD, for example 2016-03-11.\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "The state of the milestone. Valid values are: `active`, `closed`.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "The title of a milestone.\n"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "The last update time of the milestone. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n"
                    },
                    "webUrl": {
                        "type": "string",
                        "description": "The web URL of the milestone.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectMirror:ProjectMirror": {
            "description": "The `gitlab.ProjectMirror` resource allows to manage the lifecycle of a project mirror.\n\nThis is for *pushing* changes to a remote repository. *Pull Mirroring* can be configured using a combination of the\nimport_url, mirror, and mirror_trigger_builds properties on the gitlab.Project resource.\n\n\u003e **Destroy Behavior** GitLab 14.10 introduced an API endpoint to delete a project mirror.\n   Therefore, for GitLab 14.10 and newer the project mirror will be destroyed when the resource is destroyed.\n   For older versions, the mirror will be disabled and the resource will be destroyed.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/remote_mirrors.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = new gitlab.ProjectMirror(\"foo\", {\n    project: \"1\",\n    url: \"https://username:password@github.com/org/repository.git\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.ProjectMirror(\"foo\",\n    project=\"1\",\n    url=\"https://username:password@github.com/org/repository.git\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = new GitLab.ProjectMirror(\"foo\", new()\n    {\n        Project = \"1\",\n        Url = \"https://username:password@github.com/org/repository.git\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewProjectMirror(ctx, \"foo\", \u0026gitlab.ProjectMirrorArgs{\n\t\t\tProject: pulumi.String(\"1\"),\n\t\t\tUrl:     pulumi.String(\"https://username:password@github.com/org/repository.git\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ProjectMirror;\nimport com.pulumi.gitlab.ProjectMirrorArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var foo = new ProjectMirror(\"foo\", ProjectMirrorArgs.builder()        \n            .project(\"1\")\n            .url(\"https://username:password@github.com/org/repository.git\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  foo:\n    type: gitlab:ProjectMirror\n    properties:\n      project: '1'\n      url: https://username:password@github.com/org/repository.git\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitLab project mirror can be imported using an id made up of `project_id:mirror_id`, e.g.\n\n```sh\n $ pulumi import gitlab:index/projectMirror:ProjectMirror foo \"12345:1337\"\n```\n\n ",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Determines if the mirror is enabled.\n"
                },
                "keepDivergentRefs": {
                    "type": "boolean",
                    "description": "Determines if divergent refs are skipped.\n"
                },
                "mirrorId": {
                    "type": "integer",
                    "description": "Mirror ID.\n"
                },
                "onlyProtectedBranches": {
                    "type": "boolean",
                    "description": "Determines if only protected branches are mirrored.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The id of the project.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL of the remote repository to be mirrored.\n",
                    "secret": true
                }
            },
            "required": [
                "mirrorId",
                "project",
                "url"
            ],
            "inputProperties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Determines if the mirror is enabled.\n"
                },
                "keepDivergentRefs": {
                    "type": "boolean",
                    "description": "Determines if divergent refs are skipped.\n"
                },
                "onlyProtectedBranches": {
                    "type": "boolean",
                    "description": "Determines if only protected branches are mirrored.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The id of the project.\n",
                    "willReplaceOnChanges": true
                },
                "url": {
                    "type": "string",
                    "description": "The URL of the remote repository to be mirrored.\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "project",
                "url"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectMirror resources.\n",
                "properties": {
                    "enabled": {
                        "type": "boolean",
                        "description": "Determines if the mirror is enabled.\n"
                    },
                    "keepDivergentRefs": {
                        "type": "boolean",
                        "description": "Determines if divergent refs are skipped.\n"
                    },
                    "mirrorId": {
                        "type": "integer",
                        "description": "Mirror ID.\n"
                    },
                    "onlyProtectedBranches": {
                        "type": "boolean",
                        "description": "Determines if only protected branches are mirrored.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The id of the project.\n",
                        "willReplaceOnChanges": true
                    },
                    "url": {
                        "type": "string",
                        "description": "The URL of the remote repository to be mirrored.\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectProtectedEnvironment:ProjectProtectedEnvironment": {
            "description": "The `gitlab.ProjectProtectedEnvironment` resource allows to manage the lifecycle of a protected environment in a project.\n\n\u003e In order to use a user or group in the `deploy_access_levels` configuration,\n   you need to make sure that users have access to the project and groups must have this project shared.\n   You may use the `gitlab.ProjectMembership` and `gitlab_project_shared_group` resources to achieve this.\n   Unfortunately, the GitLab API does not complain about users and groups without access to the project and just ignores those.\n   In case this happens you will get perpetual state diffs.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/protected_environments.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst _this = new gitlab.ProjectEnvironment(\"this\", {\n    project: \"123\",\n    externalUrl: \"www.example.com\",\n});\n// Example with access level\nconst exampleWithAccessLevel = new gitlab.ProjectProtectedEnvironment(\"exampleWithAccessLevel\", {\n    project: _this.project,\n    requiredApprovalCount: 1,\n    environment: _this.name,\n    deployAccessLevels: [{\n        accessLevel: \"developer\",\n    }],\n});\n// Example with group\nconst exampleWithGroup = new gitlab.ProjectProtectedEnvironment(\"exampleWithGroup\", {\n    project: _this.project,\n    environment: _this.name,\n    deployAccessLevels: [{\n        groupId: 456,\n    }],\n});\n// Example with user\nconst exampleWithUser = new gitlab.ProjectProtectedEnvironment(\"exampleWithUser\", {\n    project: _this.project,\n    environment: _this.name,\n    deployAccessLevels: [{\n        userId: 789,\n    }],\n});\n// Example with multiple access levels\nconst exampleWithMultiple = new gitlab.ProjectProtectedEnvironment(\"exampleWithMultiple\", {\n    project: _this.project,\n    requiredApprovalCount: 2,\n    environment: _this.name,\n    deployAccessLevels: [\n        {\n            accessLevel: \"developer\",\n        },\n        {\n            groupId: 456,\n        },\n        {\n            userId: 789,\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nthis = gitlab.ProjectEnvironment(\"this\",\n    project=\"123\",\n    external_url=\"www.example.com\")\n# Example with access level\nexample_with_access_level = gitlab.ProjectProtectedEnvironment(\"exampleWithAccessLevel\",\n    project=this.project,\n    required_approval_count=1,\n    environment=this.name,\n    deploy_access_levels=[gitlab.ProjectProtectedEnvironmentDeployAccessLevelArgs(\n        access_level=\"developer\",\n    )])\n# Example with group\nexample_with_group = gitlab.ProjectProtectedEnvironment(\"exampleWithGroup\",\n    project=this.project,\n    environment=this.name,\n    deploy_access_levels=[gitlab.ProjectProtectedEnvironmentDeployAccessLevelArgs(\n        group_id=456,\n    )])\n# Example with user\nexample_with_user = gitlab.ProjectProtectedEnvironment(\"exampleWithUser\",\n    project=this.project,\n    environment=this.name,\n    deploy_access_levels=[gitlab.ProjectProtectedEnvironmentDeployAccessLevelArgs(\n        user_id=789,\n    )])\n# Example with multiple access levels\nexample_with_multiple = gitlab.ProjectProtectedEnvironment(\"exampleWithMultiple\",\n    project=this.project,\n    required_approval_count=2,\n    environment=this.name,\n    deploy_access_levels=[\n        gitlab.ProjectProtectedEnvironmentDeployAccessLevelArgs(\n            access_level=\"developer\",\n        ),\n        gitlab.ProjectProtectedEnvironmentDeployAccessLevelArgs(\n            group_id=456,\n        ),\n        gitlab.ProjectProtectedEnvironmentDeployAccessLevelArgs(\n            user_id=789,\n        ),\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @this = new GitLab.ProjectEnvironment(\"this\", new()\n    {\n        Project = \"123\",\n        ExternalUrl = \"www.example.com\",\n    });\n\n    // Example with access level\n    var exampleWithAccessLevel = new GitLab.ProjectProtectedEnvironment(\"exampleWithAccessLevel\", new()\n    {\n        Project = @this.Project,\n        RequiredApprovalCount = 1,\n        Environment = @this.Name,\n        DeployAccessLevels = new[]\n        {\n            new GitLab.Inputs.ProjectProtectedEnvironmentDeployAccessLevelArgs\n            {\n                AccessLevel = \"developer\",\n            },\n        },\n    });\n\n    // Example with group\n    var exampleWithGroup = new GitLab.ProjectProtectedEnvironment(\"exampleWithGroup\", new()\n    {\n        Project = @this.Project,\n        Environment = @this.Name,\n        DeployAccessLevels = new[]\n        {\n            new GitLab.Inputs.ProjectProtectedEnvironmentDeployAccessLevelArgs\n            {\n                GroupId = 456,\n            },\n        },\n    });\n\n    // Example with user\n    var exampleWithUser = new GitLab.ProjectProtectedEnvironment(\"exampleWithUser\", new()\n    {\n        Project = @this.Project,\n        Environment = @this.Name,\n        DeployAccessLevels = new[]\n        {\n            new GitLab.Inputs.ProjectProtectedEnvironmentDeployAccessLevelArgs\n            {\n                UserId = 789,\n            },\n        },\n    });\n\n    // Example with multiple access levels\n    var exampleWithMultiple = new GitLab.ProjectProtectedEnvironment(\"exampleWithMultiple\", new()\n    {\n        Project = @this.Project,\n        RequiredApprovalCount = 2,\n        Environment = @this.Name,\n        DeployAccessLevels = new[]\n        {\n            new GitLab.Inputs.ProjectProtectedEnvironmentDeployAccessLevelArgs\n            {\n                AccessLevel = \"developer\",\n            },\n            new GitLab.Inputs.ProjectProtectedEnvironmentDeployAccessLevelArgs\n            {\n                GroupId = 456,\n            },\n            new GitLab.Inputs.ProjectProtectedEnvironmentDeployAccessLevelArgs\n            {\n                UserId = 789,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tthis, err := gitlab.NewProjectEnvironment(ctx, \"this\", \u0026gitlab.ProjectEnvironmentArgs{\n\t\t\tProject:     pulumi.String(\"123\"),\n\t\t\tExternalUrl: pulumi.String(\"www.example.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectProtectedEnvironment(ctx, \"exampleWithAccessLevel\", \u0026gitlab.ProjectProtectedEnvironmentArgs{\n\t\t\tProject:               this.Project,\n\t\t\tRequiredApprovalCount: pulumi.Int(1),\n\t\t\tEnvironment:           this.Name,\n\t\t\tDeployAccessLevels: gitlab.ProjectProtectedEnvironmentDeployAccessLevelArray{\n\t\t\t\t\u0026gitlab.ProjectProtectedEnvironmentDeployAccessLevelArgs{\n\t\t\t\t\tAccessLevel: pulumi.String(\"developer\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectProtectedEnvironment(ctx, \"exampleWithGroup\", \u0026gitlab.ProjectProtectedEnvironmentArgs{\n\t\t\tProject:     this.Project,\n\t\t\tEnvironment: this.Name,\n\t\t\tDeployAccessLevels: gitlab.ProjectProtectedEnvironmentDeployAccessLevelArray{\n\t\t\t\t\u0026gitlab.ProjectProtectedEnvironmentDeployAccessLevelArgs{\n\t\t\t\t\tGroupId: pulumi.Int(456),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectProtectedEnvironment(ctx, \"exampleWithUser\", \u0026gitlab.ProjectProtectedEnvironmentArgs{\n\t\t\tProject:     this.Project,\n\t\t\tEnvironment: this.Name,\n\t\t\tDeployAccessLevels: gitlab.ProjectProtectedEnvironmentDeployAccessLevelArray{\n\t\t\t\t\u0026gitlab.ProjectProtectedEnvironmentDeployAccessLevelArgs{\n\t\t\t\t\tUserId: pulumi.Int(789),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectProtectedEnvironment(ctx, \"exampleWithMultiple\", \u0026gitlab.ProjectProtectedEnvironmentArgs{\n\t\t\tProject:               this.Project,\n\t\t\tRequiredApprovalCount: pulumi.Int(2),\n\t\t\tEnvironment:           this.Name,\n\t\t\tDeployAccessLevels: gitlab.ProjectProtectedEnvironmentDeployAccessLevelArray{\n\t\t\t\t\u0026gitlab.ProjectProtectedEnvironmentDeployAccessLevelArgs{\n\t\t\t\t\tAccessLevel: pulumi.String(\"developer\"),\n\t\t\t\t},\n\t\t\t\t\u0026gitlab.ProjectProtectedEnvironmentDeployAccessLevelArgs{\n\t\t\t\t\tGroupId: pulumi.Int(456),\n\t\t\t\t},\n\t\t\t\t\u0026gitlab.ProjectProtectedEnvironmentDeployAccessLevelArgs{\n\t\t\t\t\tUserId: pulumi.Int(789),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ProjectEnvironment;\nimport com.pulumi.gitlab.ProjectEnvironmentArgs;\nimport com.pulumi.gitlab.ProjectProtectedEnvironment;\nimport com.pulumi.gitlab.ProjectProtectedEnvironmentArgs;\nimport com.pulumi.gitlab.inputs.ProjectProtectedEnvironmentDeployAccessLevelArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var this_ = new ProjectEnvironment(\"this\", ProjectEnvironmentArgs.builder()        \n            .project(123)\n            .externalUrl(\"www.example.com\")\n            .build());\n\n        var exampleWithAccessLevel = new ProjectProtectedEnvironment(\"exampleWithAccessLevel\", ProjectProtectedEnvironmentArgs.builder()        \n            .project(this_.project())\n            .requiredApprovalCount(1)\n            .environment(this_.name())\n            .deployAccessLevels(ProjectProtectedEnvironmentDeployAccessLevelArgs.builder()\n                .accessLevel(\"developer\")\n                .build())\n            .build());\n\n        var exampleWithGroup = new ProjectProtectedEnvironment(\"exampleWithGroup\", ProjectProtectedEnvironmentArgs.builder()        \n            .project(this_.project())\n            .environment(this_.name())\n            .deployAccessLevels(ProjectProtectedEnvironmentDeployAccessLevelArgs.builder()\n                .groupId(456)\n                .build())\n            .build());\n\n        var exampleWithUser = new ProjectProtectedEnvironment(\"exampleWithUser\", ProjectProtectedEnvironmentArgs.builder()        \n            .project(this_.project())\n            .environment(this_.name())\n            .deployAccessLevels(ProjectProtectedEnvironmentDeployAccessLevelArgs.builder()\n                .userId(789)\n                .build())\n            .build());\n\n        var exampleWithMultiple = new ProjectProtectedEnvironment(\"exampleWithMultiple\", ProjectProtectedEnvironmentArgs.builder()        \n            .project(this_.project())\n            .requiredApprovalCount(2)\n            .environment(this_.name())\n            .deployAccessLevels(            \n                ProjectProtectedEnvironmentDeployAccessLevelArgs.builder()\n                    .accessLevel(\"developer\")\n                    .build(),\n                ProjectProtectedEnvironmentDeployAccessLevelArgs.builder()\n                    .groupId(456)\n                    .build(),\n                ProjectProtectedEnvironmentDeployAccessLevelArgs.builder()\n                    .userId(789)\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  this:\n    type: gitlab:ProjectEnvironment\n    properties:\n      project: 123\n      externalUrl: www.example.com\n  # Example with access level\n  exampleWithAccessLevel:\n    type: gitlab:ProjectProtectedEnvironment\n    properties:\n      project: ${this.project}\n      requiredApprovalCount: 1\n      environment: ${this.name}\n      deployAccessLevels:\n        - accessLevel: developer\n  # Example with group\n  exampleWithGroup:\n    type: gitlab:ProjectProtectedEnvironment\n    properties:\n      project: ${this.project}\n      environment: ${this.name}\n      deployAccessLevels:\n        - groupId: 456\n  # Example with user\n  exampleWithUser:\n    type: gitlab:ProjectProtectedEnvironment\n    properties:\n      project: ${this.project}\n      environment: ${this.name}\n      deployAccessLevels:\n        - userId: 789\n  # Example with multiple access levels\n  exampleWithMultiple:\n    type: gitlab:ProjectProtectedEnvironment\n    properties:\n      project: ${this.project}\n      requiredApprovalCount: 2\n      environment: ${this.name}\n      deployAccessLevels:\n        - accessLevel: developer\n        - groupId: 456\n        - userId: 789\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitLab protected environments can be imported using an id made up of `projectId:environmentName`, e.g.\n\n```sh\n $ pulumi import gitlab:index/projectProtectedEnvironment:ProjectProtectedEnvironment bar 123:production\n```\n\n ",
            "properties": {
                "deployAccessLevels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/ProjectProtectedEnvironmentDeployAccessLevel:ProjectProtectedEnvironmentDeployAccessLevel"
                    },
                    "description": "Array of access levels allowed to deploy, with each described by a hash.\n"
                },
                "environment": {
                    "type": "string",
                    "description": "The name of the environment.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project which the protected environment is created against.\n"
                },
                "requiredApprovalCount": {
                    "type": "integer",
                    "description": "The number of approvals required to deploy to this environment.\n"
                }
            },
            "required": [
                "environment",
                "project",
                "requiredApprovalCount"
            ],
            "inputProperties": {
                "deployAccessLevels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/ProjectProtectedEnvironmentDeployAccessLevel:ProjectProtectedEnvironmentDeployAccessLevel"
                    },
                    "description": "Array of access levels allowed to deploy, with each described by a hash.\n"
                },
                "environment": {
                    "type": "string",
                    "description": "The name of the environment.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project which the protected environment is created against.\n"
                },
                "requiredApprovalCount": {
                    "type": "integer",
                    "description": "The number of approvals required to deploy to this environment.\n"
                }
            },
            "requiredInputs": [
                "environment",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectProtectedEnvironment resources.\n",
                "properties": {
                    "deployAccessLevels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/ProjectProtectedEnvironmentDeployAccessLevel:ProjectProtectedEnvironmentDeployAccessLevel"
                        },
                        "description": "Array of access levels allowed to deploy, with each described by a hash.\n"
                    },
                    "environment": {
                        "type": "string",
                        "description": "The name of the environment.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or full path of the project which the protected environment is created against.\n"
                    },
                    "requiredApprovalCount": {
                        "type": "integer",
                        "description": "The number of approvals required to deploy to this environment.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectRunnerEnablement:ProjectRunnerEnablement": {
            "description": "The `gitlab.ProjectRunnerEnablement` resource allows to enable a runner in a project.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/runners.html#enable-a-runner-in-project)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = new gitlab.ProjectRunnerEnablement(\"foo\", {\n    project: \"5\",\n    runnerId: 7,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.ProjectRunnerEnablement(\"foo\",\n    project=\"5\",\n    runner_id=7)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = new GitLab.ProjectRunnerEnablement(\"foo\", new()\n    {\n        Project = \"5\",\n        RunnerId = 7,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewProjectRunnerEnablement(ctx, \"foo\", \u0026gitlab.ProjectRunnerEnablementArgs{\n\t\t\tProject:  pulumi.String(\"5\"),\n\t\t\tRunnerId: pulumi.Int(7),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ProjectRunnerEnablement;\nimport com.pulumi.gitlab.ProjectRunnerEnablementArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var foo = new ProjectRunnerEnablement(\"foo\", ProjectRunnerEnablementArgs.builder()        \n            .project(5)\n            .runnerId(7)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  foo:\n    type: gitlab:ProjectRunnerEnablement\n    properties:\n      project: 5\n      runnerId: 7\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitLab project runners can be imported using an id made up of `project:runner_id`, e.g.\n\n```sh\n $ pulumi import gitlab:index/projectRunnerEnablement:ProjectRunnerEnablement foo 5:7\n```\n\n ",
            "properties": {
                "project": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n"
                },
                "runnerId": {
                    "type": "integer",
                    "description": "The ID of a runner to enable for the project.\n"
                }
            },
            "required": [
                "project",
                "runnerId"
            ],
            "inputProperties": {
                "project": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n",
                    "willReplaceOnChanges": true
                },
                "runnerId": {
                    "type": "integer",
                    "description": "The ID of a runner to enable for the project.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "project",
                "runnerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectRunnerEnablement resources.\n",
                "properties": {
                    "project": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n",
                        "willReplaceOnChanges": true
                    },
                    "runnerId": {
                        "type": "integer",
                        "description": "The ID of a runner to enable for the project.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectShareGroup:ProjectShareGroup": {
            "description": "The `gitlab.ProjectShareGroup` resource allows to manage the lifecycle of project shared with a group.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/projects.html#share-project-with-group)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst test = new gitlab.ProjectShareGroup(\"test\", {\n    groupAccess: \"guest\",\n    groupId: 1337,\n    projectId: \"12345\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\ntest = gitlab.ProjectShareGroup(\"test\",\n    group_access=\"guest\",\n    group_id=1337,\n    project_id=\"12345\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new GitLab.ProjectShareGroup(\"test\", new()\n    {\n        GroupAccess = \"guest\",\n        GroupId = 1337,\n        ProjectId = \"12345\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewProjectShareGroup(ctx, \"test\", \u0026gitlab.ProjectShareGroupArgs{\n\t\t\tGroupAccess: pulumi.String(\"guest\"),\n\t\t\tGroupId:     pulumi.Int(1337),\n\t\t\tProjectId:   pulumi.String(\"12345\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ProjectShareGroup;\nimport com.pulumi.gitlab.ProjectShareGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new ProjectShareGroup(\"test\", ProjectShareGroupArgs.builder()        \n            .groupAccess(\"guest\")\n            .groupId(1337)\n            .projectId(\"12345\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: gitlab:ProjectShareGroup\n    properties:\n      groupAccess: guest\n      groupId: 1337\n      projectId: '12345'\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitLab project group shares can be imported using an id made up of `projectid:groupid`, e.g.\n\n```sh\n $ pulumi import gitlab:index/projectShareGroup:ProjectShareGroup test 12345:1337\n```\n\n ",
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "The access level to grant the group for the project. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`, `master`\n",
                    "deprecationMessage": "Use `group_access` instead of the `access_level` attribute."
                },
                "groupAccess": {
                    "type": "string",
                    "description": "The access level to grant the group for the project. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`, `master`\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The id of the group.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The id of the project.\n"
                }
            },
            "required": [
                "groupId",
                "projectId"
            ],
            "inputProperties": {
                "accessLevel": {
                    "type": "string",
                    "description": "The access level to grant the group for the project. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`, `master`\n",
                    "deprecationMessage": "Use `group_access` instead of the `access_level` attribute.",
                    "willReplaceOnChanges": true
                },
                "groupAccess": {
                    "type": "string",
                    "description": "The access level to grant the group for the project. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`, `master`\n",
                    "willReplaceOnChanges": true
                },
                "groupId": {
                    "type": "integer",
                    "description": "The id of the group.\n",
                    "willReplaceOnChanges": true
                },
                "projectId": {
                    "type": "string",
                    "description": "The id of the project.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "groupId",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectShareGroup resources.\n",
                "properties": {
                    "accessLevel": {
                        "type": "string",
                        "description": "The access level to grant the group for the project. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`, `master`\n",
                        "deprecationMessage": "Use `group_access` instead of the `access_level` attribute.",
                        "willReplaceOnChanges": true
                    },
                    "groupAccess": {
                        "type": "string",
                        "description": "The access level to grant the group for the project. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`, `master`\n",
                        "willReplaceOnChanges": true
                    },
                    "groupId": {
                        "type": "integer",
                        "description": "The id of the group.\n",
                        "willReplaceOnChanges": true
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The id of the project.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectTag:ProjectTag": {
            "description": "The `gitlab.ProjectTag` resource allows to manage the lifecycle of a tag in a project.\n\n**Upstream API**: [GitLab API docs](https://docs.gitlab.com/ee/api/tags.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\n// Create a project for the tag to use\nconst exampleProject = new gitlab.Project(\"exampleProject\", {\n    description: \"An example project\",\n    namespaceId: gitlab_group.example.id,\n});\nconst exampleProjectTag = new gitlab.ProjectTag(\"exampleProjectTag\", {\n    ref: \"main\",\n    project: exampleProject.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\n# Create a project for the tag to use\nexample_project = gitlab.Project(\"exampleProject\",\n    description=\"An example project\",\n    namespace_id=gitlab_group[\"example\"][\"id\"])\nexample_project_tag = gitlab.ProjectTag(\"exampleProjectTag\",\n    ref=\"main\",\n    project=example_project.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create a project for the tag to use\n    var exampleProject = new GitLab.Project(\"exampleProject\", new()\n    {\n        Description = \"An example project\",\n        NamespaceId = gitlab_group.Example.Id,\n    });\n\n    var exampleProjectTag = new GitLab.ProjectTag(\"exampleProjectTag\", new()\n    {\n        Ref = \"main\",\n        Project = exampleProject.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleProject, err := gitlab.NewProject(ctx, \"exampleProject\", \u0026gitlab.ProjectArgs{\n\t\t\tDescription: pulumi.String(\"An example project\"),\n\t\t\tNamespaceId: pulumi.Any(gitlab_group.Example.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectTag(ctx, \"exampleProjectTag\", \u0026gitlab.ProjectTagArgs{\n\t\t\tRef:     pulumi.String(\"main\"),\n\t\t\tProject: exampleProject.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ProjectTag;\nimport com.pulumi.gitlab.ProjectTagArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleProject = new Project(\"exampleProject\", ProjectArgs.builder()        \n            .description(\"An example project\")\n            .namespaceId(gitlab_group.example().id())\n            .build());\n\n        var exampleProjectTag = new ProjectTag(\"exampleProjectTag\", ProjectTagArgs.builder()        \n            .ref(\"main\")\n            .project(exampleProject.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a project for the tag to use\n  exampleProject:\n    type: gitlab:Project\n    properties:\n      description: An example project\n      namespaceId: ${gitlab_group.example.id}\n  exampleProjectTag:\n    type: gitlab:ProjectTag\n    properties:\n      ref: main\n      project: ${exampleProject.id}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitlab project tags can be imported with a key composed of `\u003cproject_id\u003e:\u003ctag_name\u003e`, e.g.\n\n```sh\n $ pulumi import gitlab:index/projectTag:ProjectTag example \"12345:develop\"\n```\n\n NOTEthe `ref` attribute won't be available for imported `gitlab_project_tag` resources. ",
            "properties": {
                "commits": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/ProjectTagCommit:ProjectTagCommit"
                    },
                    "description": "The commit associated with the tag.\n"
                },
                "message": {
                    "type": "string",
                    "description": "The message of the annotated tag.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of a tag.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n"
                },
                "protected": {
                    "type": "boolean",
                    "description": "Bool, true if tag has tag protection.\n"
                },
                "ref": {
                    "type": "string",
                    "description": "Create tag using commit SHA, another tag name, or branch name. This attribute is not available for imported resources.\n"
                },
                "releases": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/ProjectTagRelease:ProjectTagRelease"
                    },
                    "description": "The release associated with the tag.\n"
                },
                "target": {
                    "type": "string",
                    "description": "The unique id assigned to the commit by Gitlab.\n"
                }
            },
            "required": [
                "commits",
                "name",
                "project",
                "protected",
                "ref",
                "releases",
                "target"
            ],
            "inputProperties": {
                "message": {
                    "type": "string",
                    "description": "The message of the annotated tag.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of a tag.\n",
                    "willReplaceOnChanges": true
                },
                "project": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n",
                    "willReplaceOnChanges": true
                },
                "ref": {
                    "type": "string",
                    "description": "Create tag using commit SHA, another tag name, or branch name. This attribute is not available for imported resources.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "project",
                "ref"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectTag resources.\n",
                "properties": {
                    "commits": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/ProjectTagCommit:ProjectTagCommit"
                        },
                        "description": "The commit associated with the tag.\n"
                    },
                    "message": {
                        "type": "string",
                        "description": "The message of the annotated tag.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of a tag.\n",
                        "willReplaceOnChanges": true
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n",
                        "willReplaceOnChanges": true
                    },
                    "protected": {
                        "type": "boolean",
                        "description": "Bool, true if tag has tag protection.\n"
                    },
                    "ref": {
                        "type": "string",
                        "description": "Create tag using commit SHA, another tag name, or branch name. This attribute is not available for imported resources.\n",
                        "willReplaceOnChanges": true
                    },
                    "releases": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/ProjectTagRelease:ProjectTagRelease"
                        },
                        "description": "The release associated with the tag.\n"
                    },
                    "target": {
                        "type": "string",
                        "description": "The unique id assigned to the commit by Gitlab.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectVariable:ProjectVariable": {
            "description": "The `gitlab.ProjectVariable` resource allows to manage the lifecycle of a CI/CD variable for a project.\n\n\u003e **Important:** If your GitLab version is older than 13.4, you may see nondeterministic behavior when updating or deleting gitlab.ProjectVariable resources with non-unique keys, for example if there is another variable with the same key and different environment scope. See [this GitLab issue](https://gitlab.com/gitlab-org/gitlab/-/issues/9912).\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/project_level_variables.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = new gitlab.ProjectVariable(\"example\", {\n    key: \"project_variable_key\",\n    project: \"12345\",\n    \"protected\": false,\n    value: \"project_variable_value\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.ProjectVariable(\"example\",\n    key=\"project_variable_key\",\n    project=\"12345\",\n    protected=False,\n    value=\"project_variable_value\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new GitLab.ProjectVariable(\"example\", new()\n    {\n        Key = \"project_variable_key\",\n        Project = \"12345\",\n        Protected = false,\n        Value = \"project_variable_value\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewProjectVariable(ctx, \"example\", \u0026gitlab.ProjectVariableArgs{\n\t\t\tKey:       pulumi.String(\"project_variable_key\"),\n\t\t\tProject:   pulumi.String(\"12345\"),\n\t\t\tProtected: pulumi.Bool(false),\n\t\t\tValue:     pulumi.String(\"project_variable_value\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ProjectVariable;\nimport com.pulumi.gitlab.ProjectVariableArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ProjectVariable(\"example\", ProjectVariableArgs.builder()        \n            .key(\"project_variable_key\")\n            .project(\"12345\")\n            .protected_(false)\n            .value(\"project_variable_value\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: gitlab:ProjectVariable\n    properties:\n      key: project_variable_key\n      project: '12345'\n      protected: false\n      value: project_variable_value\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitLab project variables can be imported using an id made up of `project:key:environment_scope`, e.g.\n\n```sh\n $ pulumi import gitlab:index/projectVariable:ProjectVariable example '12345:project_variable_key:*'\n```\n\n ",
            "properties": {
                "environmentScope": {
                    "type": "string",
                    "description": "The environment scope of the variable. Defaults to all environment (`*`). Note that in Community Editions of Gitlab, values other than `*` will cause inconsistent plans.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The name of the variable.\n"
                },
                "masked": {
                    "type": "boolean",
                    "description": "If set to `true`, the value of the variable will be hidden in job logs. The value must meet the [masking requirements](https://docs.gitlab.com/ee/ci/variables/#masked-variables). Defaults to `false`.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project.\n"
                },
                "protected": {
                    "type": "boolean",
                    "description": "If set to `true`, the variable will be passed only to pipelines running on protected branches and tags. Defaults to `false`.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the variable.\n",
                    "secret": true
                },
                "variableType": {
                    "type": "string",
                    "description": "The type of a variable. Valid values are: `env_var`, `file`. Default is `env_var`.\n"
                }
            },
            "required": [
                "key",
                "project",
                "value"
            ],
            "inputProperties": {
                "environmentScope": {
                    "type": "string",
                    "description": "The environment scope of the variable. Defaults to all environment (`*`). Note that in Community Editions of Gitlab, values other than `*` will cause inconsistent plans.\n",
                    "willReplaceOnChanges": true
                },
                "key": {
                    "type": "string",
                    "description": "The name of the variable.\n",
                    "willReplaceOnChanges": true
                },
                "masked": {
                    "type": "boolean",
                    "description": "If set to `true`, the value of the variable will be hidden in job logs. The value must meet the [masking requirements](https://docs.gitlab.com/ee/ci/variables/#masked-variables). Defaults to `false`.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project.\n",
                    "willReplaceOnChanges": true
                },
                "protected": {
                    "type": "boolean",
                    "description": "If set to `true`, the variable will be passed only to pipelines running on protected branches and tags. Defaults to `false`.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the variable.\n",
                    "secret": true
                },
                "variableType": {
                    "type": "string",
                    "description": "The type of a variable. Valid values are: `env_var`, `file`. Default is `env_var`.\n"
                }
            },
            "requiredInputs": [
                "key",
                "project",
                "value"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectVariable resources.\n",
                "properties": {
                    "environmentScope": {
                        "type": "string",
                        "description": "The environment scope of the variable. Defaults to all environment (`*`). Note that in Community Editions of Gitlab, values other than `*` will cause inconsistent plans.\n",
                        "willReplaceOnChanges": true
                    },
                    "key": {
                        "type": "string",
                        "description": "The name of the variable.\n",
                        "willReplaceOnChanges": true
                    },
                    "masked": {
                        "type": "boolean",
                        "description": "If set to `true`, the value of the variable will be hidden in job logs. The value must meet the [masking requirements](https://docs.gitlab.com/ee/ci/variables/#masked-variables). Defaults to `false`.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project.\n",
                        "willReplaceOnChanges": true
                    },
                    "protected": {
                        "type": "boolean",
                        "description": "If set to `true`, the variable will be passed only to pipelines running on protected branches and tags. Defaults to `false`.\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "The value of the variable.\n",
                        "secret": true
                    },
                    "variableType": {
                        "type": "string",
                        "description": "The type of a variable. Valid values are: `env_var`, `file`. Default is `env_var`.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/releaseLink:ReleaseLink": {
            "description": "The `gitlab.ReleaseLink` resource allows to manage the lifecycle of a release link.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/releases/links.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\n// Create a project\nconst exampleProject = new gitlab.Project(\"exampleProject\", {description: \"An example project\"});\n// Can create release link only to a tag associated with a release\nconst exampleReleaseLink = new gitlab.ReleaseLink(\"exampleReleaseLink\", {\n    project: exampleProject.id,\n    tagName: \"tag_name_associated_with_release\",\n    url: \"https://test/\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\n# Create a project\nexample_project = gitlab.Project(\"exampleProject\", description=\"An example project\")\n# Can create release link only to a tag associated with a release\nexample_release_link = gitlab.ReleaseLink(\"exampleReleaseLink\",\n    project=example_project.id,\n    tag_name=\"tag_name_associated_with_release\",\n    url=\"https://test/\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create a project\n    var exampleProject = new GitLab.Project(\"exampleProject\", new()\n    {\n        Description = \"An example project\",\n    });\n\n    // Can create release link only to a tag associated with a release\n    var exampleReleaseLink = new GitLab.ReleaseLink(\"exampleReleaseLink\", new()\n    {\n        Project = exampleProject.Id,\n        TagName = \"tag_name_associated_with_release\",\n        Url = \"https://test/\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleProject, err := gitlab.NewProject(ctx, \"exampleProject\", \u0026gitlab.ProjectArgs{\n\t\t\tDescription: pulumi.String(\"An example project\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewReleaseLink(ctx, \"exampleReleaseLink\", \u0026gitlab.ReleaseLinkArgs{\n\t\t\tProject: exampleProject.ID(),\n\t\t\tTagName: pulumi.String(\"tag_name_associated_with_release\"),\n\t\t\tUrl:     pulumi.String(\"https://test/\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ReleaseLink;\nimport com.pulumi.gitlab.ReleaseLinkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleProject = new Project(\"exampleProject\", ProjectArgs.builder()        \n            .description(\"An example project\")\n            .build());\n\n        var exampleReleaseLink = new ReleaseLink(\"exampleReleaseLink\", ReleaseLinkArgs.builder()        \n            .project(exampleProject.id())\n            .tagName(\"tag_name_associated_with_release\")\n            .url(\"https://test/\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a project\n  exampleProject:\n    type: gitlab:Project\n    properties:\n      description: An example project\n  # Can create release link only to a tag associated with a release\n  exampleReleaseLink:\n    type: gitlab:ReleaseLink\n    properties:\n      project: ${exampleProject.id}\n      tagName: tag_name_associated_with_release\n      url: https://test/\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGitlab release link can be imported with a key composed of `\u003cproject\u003e:\u003ctag_name\u003e:\u003clink_id\u003e`, e.g.\n\n```sh\n $ pulumi import gitlab:index/releaseLink:ReleaseLink example \"12345:test:2\"\n```\n\n ",
            "properties": {
                "directAssetUrl": {
                    "type": "string",
                    "description": "Full path for a [Direct Asset link](https://docs.gitlab.com/ee/user/project/releases/index.html#permanent-links-to-release-assets).\n"
                },
                "external": {
                    "type": "boolean",
                    "description": "External or internal link.\n"
                },
                "filepath": {
                    "type": "string",
                    "description": "Relative path for a [Direct Asset link](https://docs.gitlab.com/ee/user/project/releases/index.html#permanent-links-to-release-assets).\n"
                },
                "linkId": {
                    "type": "integer",
                    "description": "The ID of the link.\n"
                },
                "linkType": {
                    "type": "string",
                    "description": "The type of the link. Valid values are `other`, `runbook`, `image`, `package`. Defaults to other.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the link. Link names must be unique within the release.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or [URL-encoded path of the project](https://docs.gitlab.com/ee/api/index.html#namespaced-path-encoding).\n"
                },
                "tagName": {
                    "type": "string",
                    "description": "The tag associated with the Release.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL of the link. Link URLs must be unique within the release.\n"
                }
            },
            "required": [
                "directAssetUrl",
                "external",
                "linkId",
                "name",
                "project",
                "tagName",
                "url"
            ],
            "inputProperties": {
                "filepath": {
                    "type": "string",
                    "description": "Relative path for a [Direct Asset link](https://docs.gitlab.com/ee/user/project/releases/index.html#permanent-links-to-release-assets).\n"
                },
                "linkType": {
                    "type": "string",
                    "description": "The type of the link. Valid values are `other`, `runbook`, `image`, `package`. Defaults to other.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the link. Link names must be unique within the release.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or [URL-encoded path of the project](https://docs.gitlab.com/ee/api/index.html#namespaced-path-encoding).\n",
                    "willReplaceOnChanges": true
                },
                "tagName": {
                    "type": "string",
                    "description": "The tag associated with the Release.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL of the link. Link URLs must be unique within the release.\n"
                }
            },
            "requiredInputs": [
                "project",
                "tagName",
                "url"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ReleaseLink resources.\n",
                "properties": {
                    "directAssetUrl": {
                        "type": "string",
                        "description": "Full path for a [Direct Asset link](https://docs.gitlab.com/ee/user/project/releases/index.html#permanent-links-to-release-assets).\n"
                    },
                    "external": {
                        "type": "boolean",
                        "description": "External or internal link.\n"
                    },
                    "filepath": {
                        "type": "string",
                        "description": "Relative path for a [Direct Asset link](https://docs.gitlab.com/ee/user/project/releases/index.html#permanent-links-to-release-assets).\n"
                    },
                    "linkId": {
                        "type": "integer",
                        "description": "The ID of the link.\n"
                    },
                    "linkType": {
                        "type": "string",
                        "description": "The type of the link. Valid values are `other`, `runbook`, `image`, `package`. Defaults to other.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the link. Link names must be unique within the release.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or [URL-encoded path of the project](https://docs.gitlab.com/ee/api/index.html#namespaced-path-encoding).\n",
                        "willReplaceOnChanges": true
                    },
                    "tagName": {
                        "type": "string",
                        "description": "The tag associated with the Release.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "The URL of the link. Link URLs must be unique within the release.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/repositoryFile:RepositoryFile": {
            "description": "\n\n## Import\n\nA Repository File can be imported using an id made up of `\u003cproject-id\u003e:\u003cbranch-name\u003e:\u003cfile-path\u003e`, e.g.\n\n```sh\n $ pulumi import gitlab:index/repositoryFile:RepositoryFile this 1:main:foo/bar.txt\n```\n\n ",
            "properties": {
                "authorEmail": {
                    "type": "string",
                    "description": "Email of the commit author.\n"
                },
                "authorName": {
                    "type": "string",
                    "description": "Name of the commit author.\n"
                },
                "blobId": {
                    "type": "string",
                    "description": "The blob id.\n"
                },
                "branch": {
                    "type": "string",
                    "description": "Name of the branch to which to commit to.\n"
                },
                "commitId": {
                    "type": "string",
                    "description": "The commit id.\n"
                },
                "commitMessage": {
                    "type": "string",
                    "description": "Commit message.\n"
                },
                "content": {
                    "type": "string",
                    "description": "File content. If the content is not yet base64 encoded, it will be encoded automatically. No other encoding is currently supported, because of a [GitLab API bug](https://gitlab.com/gitlab-org/gitlab/-/issues/342430).\n"
                },
                "contentSha256": {
                    "type": "string",
                    "description": "File content sha256 digest.\n"
                },
                "encoding": {
                    "type": "string",
                    "description": "The file content encoding.\n"
                },
                "executeFilemode": {
                    "type": "boolean",
                    "description": "Enables or disables the execute flag on the file. **Note**: requires GitLab 14.10 or newer.\n"
                },
                "fileName": {
                    "type": "string",
                    "description": "The filename.\n"
                },
                "filePath": {
                    "type": "string",
                    "description": "The full path of the file. It must be relative to the root of the project without a leading slash `/` or `./`.\n"
                },
                "lastCommitId": {
                    "type": "string",
                    "description": "The last known commit id.\n"
                },
                "overwriteOnCreate": {
                    "type": "boolean",
                    "description": "Enable overwriting existing files, defaults to `false`. This attribute is only used during `create` and must be use carefully. We suggest to use `imports` whenever possible and limit the use of this attribute for when the project was imported on the same `apply`. This attribute is not supported during a resource import.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or ID of the project.\n"
                },
                "ref": {
                    "type": "string",
                    "description": "The name of branch, tag or commit.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "The file size.\n"
                },
                "startBranch": {
                    "type": "string",
                    "description": "Name of the branch to start the new commit from.\n"
                }
            },
            "required": [
                "blobId",
                "branch",
                "commitId",
                "commitMessage",
                "content",
                "contentSha256",
                "encoding",
                "fileName",
                "filePath",
                "lastCommitId",
                "project",
                "ref",
                "size"
            ],
            "inputProperties": {
                "authorEmail": {
                    "type": "string",
                    "description": "Email of the commit author.\n"
                },
                "authorName": {
                    "type": "string",
                    "description": "Name of the commit author.\n"
                },
                "branch": {
                    "type": "string",
                    "description": "Name of the branch to which to commit to.\n",
                    "willReplaceOnChanges": true
                },
                "commitMessage": {
                    "type": "string",
                    "description": "Commit message.\n"
                },
                "content": {
                    "type": "string",
                    "description": "File content. If the content is not yet base64 encoded, it will be encoded automatically. No other encoding is currently supported, because of a [GitLab API bug](https://gitlab.com/gitlab-org/gitlab/-/issues/342430).\n"
                },
                "executeFilemode": {
                    "type": "boolean",
                    "description": "Enables or disables the execute flag on the file. **Note**: requires GitLab 14.10 or newer.\n"
                },
                "filePath": {
                    "type": "string",
                    "description": "The full path of the file. It must be relative to the root of the project without a leading slash `/` or `./`.\n",
                    "willReplaceOnChanges": true
                },
                "overwriteOnCreate": {
                    "type": "boolean",
                    "description": "Enable overwriting existing files, defaults to `false`. This attribute is only used during `create` and must be use carefully. We suggest to use `imports` whenever possible and limit the use of this attribute for when the project was imported on the same `apply`. This attribute is not supported during a resource import.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or ID of the project.\n",
                    "willReplaceOnChanges": true
                },
                "startBranch": {
                    "type": "string",
                    "description": "Name of the branch to start the new commit from.\n"
                }
            },
            "requiredInputs": [
                "branch",
                "commitMessage",
                "content",
                "filePath",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RepositoryFile resources.\n",
                "properties": {
                    "authorEmail": {
                        "type": "string",
                        "description": "Email of the commit author.\n"
                    },
                    "authorName": {
                        "type": "string",
                        "description": "Name of the commit author.\n"
                    },
                    "blobId": {
                        "type": "string",
                        "description": "The blob id.\n"
                    },
                    "branch": {
                        "type": "string",
                        "description": "Name of the branch to which to commit to.\n",
                        "willReplaceOnChanges": true
                    },
                    "commitId": {
                        "type": "string",
                        "description": "The commit id.\n"
                    },
                    "commitMessage": {
                        "type": "string",
                        "description": "Commit message.\n"
                    },
                    "content": {
                        "type": "string",
                        "description": "File content. If the content is not yet base64 encoded, it will be encoded automatically. No other encoding is currently supported, because of a [GitLab API bug](https://gitlab.com/gitlab-org/gitlab/-/issues/342430).\n"
                    },
                    "contentSha256": {
                        "type": "string",
                        "description": "File content sha256 digest.\n"
                    },
                    "encoding": {
                        "type": "string",
                        "description": "The file content encoding.\n"
                    },
                    "executeFilemode": {
                        "type": "boolean",
                        "description": "Enables or disables the execute flag on the file. **Note**: requires GitLab 14.10 or newer.\n"
                    },
                    "fileName": {
                        "type": "string",
                        "description": "The filename.\n"
                    },
                    "filePath": {
                        "type": "string",
                        "description": "The full path of the file. It must be relative to the root of the project without a leading slash `/` or `./`.\n",
                        "willReplaceOnChanges": true
                    },
                    "lastCommitId": {
                        "type": "string",
                        "description": "The last known commit id.\n"
                    },
                    "overwriteOnCreate": {
                        "type": "boolean",
                        "description": "Enable overwriting existing files, defaults to `false`. This attribute is only used during `create` and must be use carefully. We suggest to use `imports` whenever possible and limit the use of this attribute for when the project was imported on the same `apply`. This attribute is not supported during a resource import.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or ID of the project.\n",
                        "willReplaceOnChanges": true
                    },
                    "ref": {
                        "type": "string",
                        "description": "The name of branch, tag or commit.\n"
                    },
                    "size": {
                        "type": "integer",
                        "description": "The file size.\n"
                    },
                    "startBranch": {
                        "type": "string",
                        "description": "Name of the branch to start the new commit from.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/runner:Runner": {
            "description": "The `gitlab.Runner` resource allows to manage the lifecycle of a runner.\n\nA runner can either be registered at an instance level or group level.\nThe runner will be registered at a group level if the token used is from a group, or at an instance level if the token used is for the instance.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/runners.html#register-a-new-runner)\n\n\n## Import\n\nA GitLab Runner can be imported using the runner's ID, eg\n\n```sh\n $ pulumi import gitlab:index/runner:Runner this 1\n```\n\n ",
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "The access_level of the runner. Valid values are: `not_protected`, `ref_protected`.\n"
                },
                "authenticationToken": {
                    "type": "string",
                    "description": "The authentication token used for building a config.toml file. This value is not present when imported.\n",
                    "secret": true
                },
                "description": {
                    "type": "string",
                    "description": "The runner's description.\n"
                },
                "locked": {
                    "type": "boolean",
                    "description": "Whether the runner should be locked for current project.\n"
                },
                "maximumTimeout": {
                    "type": "integer",
                    "description": "Maximum timeout set when this runner handles the job.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Whether the runner should ignore new jobs.\n"
                },
                "registrationToken": {
                    "type": "string",
                    "description": "The registration token used to register the runner.\n",
                    "secret": true
                },
                "runUntagged": {
                    "type": "boolean",
                    "description": "Whether the runner should handle untagged jobs.\n"
                },
                "status": {
                    "type": "string",
                    "description": "The status of runners to show, one of: online and offline. active and paused are also possible values\n\t\t\t              which were deprecated in GitLab 14.8 and will be removed in GitLab 16.0.\n"
                },
                "tagLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of runner’s tags.\n"
                }
            },
            "required": [
                "accessLevel",
                "authenticationToken",
                "locked",
                "paused",
                "registrationToken",
                "runUntagged",
                "status"
            ],
            "inputProperties": {
                "accessLevel": {
                    "type": "string",
                    "description": "The access_level of the runner. Valid values are: `not_protected`, `ref_protected`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The runner's description.\n"
                },
                "locked": {
                    "type": "boolean",
                    "description": "Whether the runner should be locked for current project.\n"
                },
                "maximumTimeout": {
                    "type": "integer",
                    "description": "Maximum timeout set when this runner handles the job.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Whether the runner should ignore new jobs.\n"
                },
                "registrationToken": {
                    "type": "string",
                    "description": "The registration token used to register the runner.\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                },
                "runUntagged": {
                    "type": "boolean",
                    "description": "Whether the runner should handle untagged jobs.\n"
                },
                "tagLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of runner’s tags.\n"
                }
            },
            "requiredInputs": [
                "registrationToken"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Runner resources.\n",
                "properties": {
                    "accessLevel": {
                        "type": "string",
                        "description": "The access_level of the runner. Valid values are: `not_protected`, `ref_protected`.\n"
                    },
                    "authenticationToken": {
                        "type": "string",
                        "description": "The authentication token used for building a config.toml file. This value is not present when imported.\n",
                        "secret": true
                    },
                    "description": {
                        "type": "string",
                        "description": "The runner's description.\n"
                    },
                    "locked": {
                        "type": "boolean",
                        "description": "Whether the runner should be locked for current project.\n"
                    },
                    "maximumTimeout": {
                        "type": "integer",
                        "description": "Maximum timeout set when this runner handles the job.\n"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "Whether the runner should ignore new jobs.\n"
                    },
                    "registrationToken": {
                        "type": "string",
                        "description": "The registration token used to register the runner.\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "runUntagged": {
                        "type": "boolean",
                        "description": "Whether the runner should handle untagged jobs.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "The status of runners to show, one of: online and offline. active and paused are also possible values\n\t\t\t              which were deprecated in GitLab 14.8 and will be removed in GitLab 16.0.\n"
                    },
                    "tagLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of runner’s tags.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/serviceCustomIssueTracker:ServiceCustomIssueTracker": {
            "description": "The `gitlab.ServiceCustomIssueTracker` resource allows to manage the lifecycle of a project integration with Custom Issue Tracker.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/integrations.html#custom-issue-tracker)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst awesomeProject = new gitlab.Project(\"awesomeProject\", {\n    description: \"My awesome project.\",\n    visibilityLevel: \"public\",\n});\nconst tracker = new gitlab.ServiceCustomIssueTracker(\"tracker\", {\n    project: awesomeProject.id,\n    projectUrl: \"https://customtracker.com/issues\",\n    issuesUrl: \"https://customtracker.com/TEST-:id\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nawesome_project = gitlab.Project(\"awesomeProject\",\n    description=\"My awesome project.\",\n    visibility_level=\"public\")\ntracker = gitlab.ServiceCustomIssueTracker(\"tracker\",\n    project=awesome_project.id,\n    project_url=\"https://customtracker.com/issues\",\n    issues_url=\"https://customtracker.com/TEST-:id\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var awesomeProject = new GitLab.Project(\"awesomeProject\", new()\n    {\n        Description = \"My awesome project.\",\n        VisibilityLevel = \"public\",\n    });\n\n    var tracker = new GitLab.ServiceCustomIssueTracker(\"tracker\", new()\n    {\n        Project = awesomeProject.Id,\n        ProjectUrl = \"https://customtracker.com/issues\",\n        IssuesUrl = \"https://customtracker.com/TEST-:id\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tawesomeProject, err := gitlab.NewProject(ctx, \"awesomeProject\", \u0026gitlab.ProjectArgs{\n\t\t\tDescription:     pulumi.String(\"My awesome project.\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewServiceCustomIssueTracker(ctx, \"tracker\", \u0026gitlab.ServiceCustomIssueTrackerArgs{\n\t\t\tProject:    awesomeProject.ID(),\n\t\t\tProjectUrl: pulumi.String(\"https://customtracker.com/issues\"),\n\t\t\tIssuesUrl:  pulumi.String(\"https://customtracker.com/TEST-:id\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ServiceCustomIssueTracker;\nimport com.pulumi.gitlab.ServiceCustomIssueTrackerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var awesomeProject = new Project(\"awesomeProject\", ProjectArgs.builder()        \n            .description(\"My awesome project.\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var tracker = new ServiceCustomIssueTracker(\"tracker\", ServiceCustomIssueTrackerArgs.builder()        \n            .project(awesomeProject.id())\n            .projectUrl(\"https://customtracker.com/issues\")\n            .issuesUrl(\"https://customtracker.com/TEST-:id\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  awesomeProject:\n    type: gitlab:Project\n    properties:\n      description: My awesome project.\n      visibilityLevel: public\n  tracker:\n    type: gitlab:ServiceCustomIssueTracker\n    properties:\n      project: ${awesomeProject.id}\n      projectUrl: https://customtracker.com/issues\n      issuesUrl: https://customtracker.com/TEST-:id\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nYou can import a gitlab_service_external_wiki state using the project ID, e.g.\n\n```sh\n $ pulumi import gitlab:index/serviceCustomIssueTracker:ServiceCustomIssueTracker tracker 1\n```\n\n ",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "Whether the integration is active.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "The ISO8601 date/time that this integration was activated at in UTC.\n"
                },
                "issuesUrl": {
                    "type": "string",
                    "description": "The URL to view an issue in the external issue tracker. Must contain :id.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project for the custom issue tracker.\n"
                },
                "projectUrl": {
                    "type": "string",
                    "description": "The URL to the project in the external issue tracker.\n"
                },
                "slug": {
                    "type": "string",
                    "description": "The name of the integration in lowercase, shortened to 63 bytes, and with everything except 0-9 and a-z replaced with -. No leading / trailing -. Use in URLs, host names and domain names.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "The ISO8601 date/time that this integration was last updated at in UTC.\n"
                }
            },
            "required": [
                "active",
                "createdAt",
                "issuesUrl",
                "project",
                "projectUrl",
                "slug",
                "updatedAt"
            ],
            "inputProperties": {
                "issuesUrl": {
                    "type": "string",
                    "description": "The URL to view an issue in the external issue tracker. Must contain :id.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project for the custom issue tracker.\n"
                },
                "projectUrl": {
                    "type": "string",
                    "description": "The URL to the project in the external issue tracker.\n"
                }
            },
            "requiredInputs": [
                "issuesUrl",
                "project",
                "projectUrl"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ServiceCustomIssueTracker resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "Whether the integration is active.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "The ISO8601 date/time that this integration was activated at in UTC.\n"
                    },
                    "issuesUrl": {
                        "type": "string",
                        "description": "The URL to view an issue in the external issue tracker. Must contain :id.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or full path of the project for the custom issue tracker.\n"
                    },
                    "projectUrl": {
                        "type": "string",
                        "description": "The URL to the project in the external issue tracker.\n"
                    },
                    "slug": {
                        "type": "string",
                        "description": "The name of the integration in lowercase, shortened to 63 bytes, and with everything except 0-9 and a-z replaced with -. No leading / trailing -. Use in URLs, host names and domain names.\n"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "The ISO8601 date/time that this integration was last updated at in UTC.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/serviceEmailsOnPush:ServiceEmailsOnPush": {
            "description": "The `gitlab.ServiceEmailsOnPush` resource allows to manage the lifecycle of a project integration with Emails on Push Service.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/integrations.html#emails-on-push)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst awesomeProject = new gitlab.Project(\"awesomeProject\", {\n    description: \"My awesome project.\",\n    visibilityLevel: \"public\",\n});\nconst emails = new gitlab.ServiceEmailsOnPush(\"emails\", {\n    project: awesomeProject.id,\n    recipients: \"myrecipient@example.com myotherrecipient@example.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nawesome_project = gitlab.Project(\"awesomeProject\",\n    description=\"My awesome project.\",\n    visibility_level=\"public\")\nemails = gitlab.ServiceEmailsOnPush(\"emails\",\n    project=awesome_project.id,\n    recipients=\"myrecipient@example.com myotherrecipient@example.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var awesomeProject = new GitLab.Project(\"awesomeProject\", new()\n    {\n        Description = \"My awesome project.\",\n        VisibilityLevel = \"public\",\n    });\n\n    var emails = new GitLab.ServiceEmailsOnPush(\"emails\", new()\n    {\n        Project = awesomeProject.Id,\n        Recipients = \"myrecipient@example.com myotherrecipient@example.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tawesomeProject, err := gitlab.NewProject(ctx, \"awesomeProject\", \u0026gitlab.ProjectArgs{\n\t\t\tDescription:     pulumi.String(\"My awesome project.\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewServiceEmailsOnPush(ctx, \"emails\", \u0026gitlab.ServiceEmailsOnPushArgs{\n\t\t\tProject:    awesomeProject.ID(),\n\t\t\tRecipients: pulumi.String(\"myrecipient@example.com myotherrecipient@example.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ServiceEmailsOnPush;\nimport com.pulumi.gitlab.ServiceEmailsOnPushArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var awesomeProject = new Project(\"awesomeProject\", ProjectArgs.builder()        \n            .description(\"My awesome project.\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var emails = new ServiceEmailsOnPush(\"emails\", ServiceEmailsOnPushArgs.builder()        \n            .project(awesomeProject.id())\n            .recipients(\"myrecipient@example.com myotherrecipient@example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  awesomeProject:\n    type: gitlab:Project\n    properties:\n      description: My awesome project.\n      visibilityLevel: public\n  emails:\n    type: gitlab:ServiceEmailsOnPush\n    properties:\n      project: ${awesomeProject.id}\n      recipients: myrecipient@example.com myotherrecipient@example.com\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nYou can import a gitlab_service_emails_on_push state using the project ID, e.g.\n\n```sh\n $ pulumi import gitlab:index/serviceEmailsOnPush:ServiceEmailsOnPush emails 1\n```\n\n ",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "Whether the integration is active.\n"
                },
                "branchesToBeNotified": {
                    "type": "string",
                    "description": "Branches to send notifications for. Valid options are `all`, `default`, `protected`, `default_and_protected`. Notifications are always fired for tag pushes.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "The ISO8601 date/time that this integration was activated at in UTC.\n"
                },
                "disableDiffs": {
                    "type": "boolean",
                    "description": "Disable code diffs.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID or full-path of the project you want to activate integration on.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for push events.\n"
                },
                "recipients": {
                    "type": "string",
                    "description": "Emails separated by whitespace.\n"
                },
                "sendFromCommitterEmail": {
                    "type": "boolean",
                    "description": "Send from committer.\n"
                },
                "slug": {
                    "type": "string",
                    "description": "The name of the integration in lowercase, shortened to 63 bytes, and with everything except 0-9 and a-z replaced with -. No leading / trailing -. Use in URLs, host names and domain names.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for tag push events.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Title of the integration.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "The ISO8601 date/time that this integration was last updated at in UTC.\n"
                }
            },
            "required": [
                "active",
                "createdAt",
                "project",
                "recipients",
                "slug",
                "title",
                "updatedAt"
            ],
            "inputProperties": {
                "branchesToBeNotified": {
                    "type": "string",
                    "description": "Branches to send notifications for. Valid options are `all`, `default`, `protected`, `default_and_protected`. Notifications are always fired for tag pushes.\n"
                },
                "disableDiffs": {
                    "type": "boolean",
                    "description": "Disable code diffs.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID or full-path of the project you want to activate integration on.\n",
                    "willReplaceOnChanges": true
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for push events.\n"
                },
                "recipients": {
                    "type": "string",
                    "description": "Emails separated by whitespace.\n"
                },
                "sendFromCommitterEmail": {
                    "type": "boolean",
                    "description": "Send from committer.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for tag push events.\n"
                }
            },
            "requiredInputs": [
                "project",
                "recipients"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ServiceEmailsOnPush resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "Whether the integration is active.\n"
                    },
                    "branchesToBeNotified": {
                        "type": "string",
                        "description": "Branches to send notifications for. Valid options are `all`, `default`, `protected`, `default_and_protected`. Notifications are always fired for tag pushes.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "The ISO8601 date/time that this integration was activated at in UTC.\n"
                    },
                    "disableDiffs": {
                        "type": "boolean",
                        "description": "Disable code diffs.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "ID or full-path of the project you want to activate integration on.\n",
                        "willReplaceOnChanges": true
                    },
                    "pushEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for push events.\n"
                    },
                    "recipients": {
                        "type": "string",
                        "description": "Emails separated by whitespace.\n"
                    },
                    "sendFromCommitterEmail": {
                        "type": "boolean",
                        "description": "Send from committer.\n"
                    },
                    "slug": {
                        "type": "string",
                        "description": "The name of the integration in lowercase, shortened to 63 bytes, and with everything except 0-9 and a-z replaced with -. No leading / trailing -. Use in URLs, host names and domain names.\n"
                    },
                    "tagPushEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for tag push events.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "Title of the integration.\n"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "The ISO8601 date/time that this integration was last updated at in UTC.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/serviceExternalWiki:ServiceExternalWiki": {
            "description": "The `gitlab.ServiceExternalWiki` resource allows to manage the lifecycle of a project integration with External Wiki Service.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/integrations.html#external-wiki)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst awesomeProject = new gitlab.Project(\"awesomeProject\", {\n    description: \"My awesome project.\",\n    visibilityLevel: \"public\",\n});\nconst wiki = new gitlab.ServiceExternalWiki(\"wiki\", {\n    project: awesomeProject.id,\n    externalWikiUrl: \"https://MyAwesomeExternalWikiURL.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nawesome_project = gitlab.Project(\"awesomeProject\",\n    description=\"My awesome project.\",\n    visibility_level=\"public\")\nwiki = gitlab.ServiceExternalWiki(\"wiki\",\n    project=awesome_project.id,\n    external_wiki_url=\"https://MyAwesomeExternalWikiURL.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var awesomeProject = new GitLab.Project(\"awesomeProject\", new()\n    {\n        Description = \"My awesome project.\",\n        VisibilityLevel = \"public\",\n    });\n\n    var wiki = new GitLab.ServiceExternalWiki(\"wiki\", new()\n    {\n        Project = awesomeProject.Id,\n        ExternalWikiUrl = \"https://MyAwesomeExternalWikiURL.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tawesomeProject, err := gitlab.NewProject(ctx, \"awesomeProject\", \u0026gitlab.ProjectArgs{\n\t\t\tDescription:     pulumi.String(\"My awesome project.\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewServiceExternalWiki(ctx, \"wiki\", \u0026gitlab.ServiceExternalWikiArgs{\n\t\t\tProject:         awesomeProject.ID(),\n\t\t\tExternalWikiUrl: pulumi.String(\"https://MyAwesomeExternalWikiURL.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ServiceExternalWiki;\nimport com.pulumi.gitlab.ServiceExternalWikiArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var awesomeProject = new Project(\"awesomeProject\", ProjectArgs.builder()        \n            .description(\"My awesome project.\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var wiki = new ServiceExternalWiki(\"wiki\", ServiceExternalWikiArgs.builder()        \n            .project(awesomeProject.id())\n            .externalWikiUrl(\"https://MyAwesomeExternalWikiURL.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  awesomeProject:\n    type: gitlab:Project\n    properties:\n      description: My awesome project.\n      visibilityLevel: public\n  wiki:\n    type: gitlab:ServiceExternalWiki\n    properties:\n      project: ${awesomeProject.id}\n      externalWikiUrl: https://MyAwesomeExternalWikiURL.com\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nYou can import a gitlab_service_external_wiki state using the project ID, e.g.\n\n```sh\n $ pulumi import gitlab:index/serviceExternalWiki:ServiceExternalWiki wiki 1\n```\n\n ",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "Whether the integration is active.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "The ISO8601 date/time that this integration was activated at in UTC.\n"
                },
                "externalWikiUrl": {
                    "type": "string",
                    "description": "The URL of the external wiki.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n"
                },
                "slug": {
                    "type": "string",
                    "description": "The name of the integration in lowercase, shortened to 63 bytes, and with everything except 0-9 and a-z replaced with -. No leading / trailing -. Use in URLs, host names and domain names.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Title of the integration.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "The ISO8601 date/time that this integration was last updated at in UTC.\n"
                }
            },
            "required": [
                "active",
                "createdAt",
                "externalWikiUrl",
                "project",
                "slug",
                "title",
                "updatedAt"
            ],
            "inputProperties": {
                "externalWikiUrl": {
                    "type": "string",
                    "description": "The URL of the external wiki.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "externalWikiUrl",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ServiceExternalWiki resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "Whether the integration is active.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "The ISO8601 date/time that this integration was activated at in UTC.\n"
                    },
                    "externalWikiUrl": {
                        "type": "string",
                        "description": "The URL of the external wiki.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "ID of the project you want to activate integration on.\n",
                        "willReplaceOnChanges": true
                    },
                    "slug": {
                        "type": "string",
                        "description": "The name of the integration in lowercase, shortened to 63 bytes, and with everything except 0-9 and a-z replaced with -. No leading / trailing -. Use in URLs, host names and domain names.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "Title of the integration.\n"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "The ISO8601 date/time that this integration was last updated at in UTC.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/serviceGithub:ServiceGithub": {
            "description": "The `gitlab.ServiceGithub` resource allows to manage the lifecycle of a project integration with GitHub.\n\n\u003e This resource requires a GitLab Enterprise instance.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/integrations.html#github)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst awesomeProject = new gitlab.Project(\"awesomeProject\", {\n    description: \"My awesome project.\",\n    visibilityLevel: \"public\",\n});\nconst github = new gitlab.ServiceGithub(\"github\", {\n    project: awesomeProject.id,\n    token: \"REDACTED\",\n    repositoryUrl: \"https://github.com/gitlabhq/terraform-provider-gitlab\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nawesome_project = gitlab.Project(\"awesomeProject\",\n    description=\"My awesome project.\",\n    visibility_level=\"public\")\ngithub = gitlab.ServiceGithub(\"github\",\n    project=awesome_project.id,\n    token=\"REDACTED\",\n    repository_url=\"https://github.com/gitlabhq/terraform-provider-gitlab\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var awesomeProject = new GitLab.Project(\"awesomeProject\", new()\n    {\n        Description = \"My awesome project.\",\n        VisibilityLevel = \"public\",\n    });\n\n    var github = new GitLab.ServiceGithub(\"github\", new()\n    {\n        Project = awesomeProject.Id,\n        Token = \"REDACTED\",\n        RepositoryUrl = \"https://github.com/gitlabhq/terraform-provider-gitlab\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tawesomeProject, err := gitlab.NewProject(ctx, \"awesomeProject\", \u0026gitlab.ProjectArgs{\n\t\t\tDescription:     pulumi.String(\"My awesome project.\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewServiceGithub(ctx, \"github\", \u0026gitlab.ServiceGithubArgs{\n\t\t\tProject:       awesomeProject.ID(),\n\t\t\tToken:         pulumi.String(\"REDACTED\"),\n\t\t\tRepositoryUrl: pulumi.String(\"https://github.com/gitlabhq/terraform-provider-gitlab\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ServiceGithub;\nimport com.pulumi.gitlab.ServiceGithubArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var awesomeProject = new Project(\"awesomeProject\", ProjectArgs.builder()        \n            .description(\"My awesome project.\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var github = new ServiceGithub(\"github\", ServiceGithubArgs.builder()        \n            .project(awesomeProject.id())\n            .token(\"REDACTED\")\n            .repositoryUrl(\"https://github.com/gitlabhq/terraform-provider-gitlab\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  awesomeProject:\n    type: gitlab:Project\n    properties:\n      description: My awesome project.\n      visibilityLevel: public\n  github:\n    type: gitlab:ServiceGithub\n    properties:\n      project: ${awesomeProject.id}\n      token: REDACTED\n      repositoryUrl: https://github.com/gitlabhq/terraform-provider-gitlab\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import gitlab:index/serviceGithub:ServiceGithub You can import a service_github state using `\u003cresource\u003e \u003cproject_id\u003e`\n```\n\n\n\n```sh\n $ pulumi import gitlab:index/serviceGithub:ServiceGithub github 1\n```\n\n ",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "Whether the integration is active.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Create time.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n"
                },
                "repositoryUrl": {
                    "type": "string",
                    "description": "The URL of the GitHub repo to integrate with, e,g, https://github.com/gitlabhq/terraform-provider-gitlab.\n"
                },
                "staticContext": {
                    "type": "boolean",
                    "description": "Append instance name instead of branch to the status. Must enable to set a GitLab status check as *required* in GitHub. See [Static / dynamic status check names] to learn more.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Title.\n"
                },
                "token": {
                    "type": "string",
                    "description": "A GitHub personal access token with at least `repo:status` scope.\n",
                    "secret": true
                },
                "updatedAt": {
                    "type": "string",
                    "description": "Update time.\n"
                }
            },
            "required": [
                "active",
                "createdAt",
                "project",
                "repositoryUrl",
                "title",
                "token",
                "updatedAt"
            ],
            "inputProperties": {
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n",
                    "willReplaceOnChanges": true
                },
                "repositoryUrl": {
                    "type": "string",
                    "description": "The URL of the GitHub repo to integrate with, e,g, https://github.com/gitlabhq/terraform-provider-gitlab.\n"
                },
                "staticContext": {
                    "type": "boolean",
                    "description": "Append instance name instead of branch to the status. Must enable to set a GitLab status check as *required* in GitHub. See [Static / dynamic status check names] to learn more.\n"
                },
                "token": {
                    "type": "string",
                    "description": "A GitHub personal access token with at least `repo:status` scope.\n",
                    "secret": true
                }
            },
            "requiredInputs": [
                "project",
                "repositoryUrl",
                "token"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ServiceGithub resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "Whether the integration is active.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Create time.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "ID of the project you want to activate integration on.\n",
                        "willReplaceOnChanges": true
                    },
                    "repositoryUrl": {
                        "type": "string",
                        "description": "The URL of the GitHub repo to integrate with, e,g, https://github.com/gitlabhq/terraform-provider-gitlab.\n"
                    },
                    "staticContext": {
                        "type": "boolean",
                        "description": "Append instance name instead of branch to the status. Must enable to set a GitLab status check as *required* in GitHub. See [Static / dynamic status check names] to learn more.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "Title.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "A GitHub personal access token with at least `repo:status` scope.\n",
                        "secret": true
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "Update time.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/serviceJira:ServiceJira": {
            "description": "The `gitlab.ServiceJira` resource allows to manage the lifecycle of a project integration with Jira.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/services.html#jira)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst awesomeProject = new gitlab.Project(\"awesomeProject\", {\n    description: \"My awesome project.\",\n    visibilityLevel: \"public\",\n});\nconst jira = new gitlab.ServiceJira(\"jira\", {\n    project: awesomeProject.id,\n    url: \"https://jira.example.com\",\n    username: \"user\",\n    password: \"mypass\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nawesome_project = gitlab.Project(\"awesomeProject\",\n    description=\"My awesome project.\",\n    visibility_level=\"public\")\njira = gitlab.ServiceJira(\"jira\",\n    project=awesome_project.id,\n    url=\"https://jira.example.com\",\n    username=\"user\",\n    password=\"mypass\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var awesomeProject = new GitLab.Project(\"awesomeProject\", new()\n    {\n        Description = \"My awesome project.\",\n        VisibilityLevel = \"public\",\n    });\n\n    var jira = new GitLab.ServiceJira(\"jira\", new()\n    {\n        Project = awesomeProject.Id,\n        Url = \"https://jira.example.com\",\n        Username = \"user\",\n        Password = \"mypass\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tawesomeProject, err := gitlab.NewProject(ctx, \"awesomeProject\", \u0026gitlab.ProjectArgs{\n\t\t\tDescription:     pulumi.String(\"My awesome project.\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewServiceJira(ctx, \"jira\", \u0026gitlab.ServiceJiraArgs{\n\t\t\tProject:  awesomeProject.ID(),\n\t\t\tUrl:      pulumi.String(\"https://jira.example.com\"),\n\t\t\tUsername: pulumi.String(\"user\"),\n\t\t\tPassword: pulumi.String(\"mypass\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ServiceJira;\nimport com.pulumi.gitlab.ServiceJiraArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var awesomeProject = new Project(\"awesomeProject\", ProjectArgs.builder()        \n            .description(\"My awesome project.\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var jira = new ServiceJira(\"jira\", ServiceJiraArgs.builder()        \n            .project(awesomeProject.id())\n            .url(\"https://jira.example.com\")\n            .username(\"user\")\n            .password(\"mypass\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  awesomeProject:\n    type: gitlab:Project\n    properties:\n      description: My awesome project.\n      visibilityLevel: public\n  jira:\n    type: gitlab:ServiceJira\n    properties:\n      project: ${awesomeProject.id}\n      url: https://jira.example.com\n      username: user\n      password: mypass\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nYou can import a service_jira state using the project ID, e.g.\n\n```sh\n $ pulumi import gitlab:index/serviceJira:ServiceJira jira 1\n```\n\n ",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "Whether the integration is active.\n"
                },
                "apiUrl": {
                    "type": "string",
                    "description": "The base URL to the Jira instance API. Web URL value is used if not set. For example, https://jira-api.example.com.\n"
                },
                "commentOnEventEnabled": {
                    "type": "boolean",
                    "description": "Enable comments inside Jira issues on each GitLab event (commit / merge request)\n"
                },
                "commitEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for commit events\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Create time.\n"
                },
                "issuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for issues events.\n"
                },
                "jiraIssueTransitionId": {
                    "type": "string",
                    "description": "The ID of a transition that moves issues to a closed state. You can find this number under the JIRA workflow administration (Administration \u003e Issues \u003e Workflows) by selecting View under Operations of the desired workflow of your project. By default, this ID is set to 2. *Note**: importing this field is only supported since GitLab 15.2.\n"
                },
                "jobEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for job events.\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for merge request events\n"
                },
                "noteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for note events.\n"
                },
                "password": {
                    "type": "string",
                    "description": "The password of the user created to be used with GitLab/JIRA.\n",
                    "secret": true
                },
                "pipelineEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for pipeline events.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n"
                },
                "projectKey": {
                    "type": "string",
                    "description": "The short identifier for your JIRA project, all uppercase, e.g., PROJ.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for push events.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for tag_push events.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Title.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "Update time.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL to the JIRA project which is being linked to this GitLab project. For example, https://jira.example.com.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The username of the user created to be used with GitLab/JIRA.\n"
                }
            },
            "required": [
                "active",
                "apiUrl",
                "commentOnEventEnabled",
                "commitEvents",
                "createdAt",
                "issuesEvents",
                "jobEvents",
                "mergeRequestsEvents",
                "noteEvents",
                "password",
                "pipelineEvents",
                "project",
                "pushEvents",
                "tagPushEvents",
                "title",
                "updatedAt",
                "url",
                "username"
            ],
            "inputProperties": {
                "apiUrl": {
                    "type": "string",
                    "description": "The base URL to the Jira instance API. Web URL value is used if not set. For example, https://jira-api.example.com.\n"
                },
                "commentOnEventEnabled": {
                    "type": "boolean",
                    "description": "Enable comments inside Jira issues on each GitLab event (commit / merge request)\n"
                },
                "commitEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for commit events\n"
                },
                "issuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for issues events.\n"
                },
                "jiraIssueTransitionId": {
                    "type": "string",
                    "description": "The ID of a transition that moves issues to a closed state. You can find this number under the JIRA workflow administration (Administration \u003e Issues \u003e Workflows) by selecting View under Operations of the desired workflow of your project. By default, this ID is set to 2. *Note**: importing this field is only supported since GitLab 15.2.\n"
                },
                "jobEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for job events.\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for merge request events\n"
                },
                "noteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for note events.\n"
                },
                "password": {
                    "type": "string",
                    "description": "The password of the user created to be used with GitLab/JIRA.\n",
                    "secret": true
                },
                "pipelineEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for pipeline events.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n",
                    "willReplaceOnChanges": true
                },
                "projectKey": {
                    "type": "string",
                    "description": "The short identifier for your JIRA project, all uppercase, e.g., PROJ.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for push events.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for tag_push events.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL to the JIRA project which is being linked to this GitLab project. For example, https://jira.example.com.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The username of the user created to be used with GitLab/JIRA.\n"
                }
            },
            "requiredInputs": [
                "password",
                "project",
                "url",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ServiceJira resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "Whether the integration is active.\n"
                    },
                    "apiUrl": {
                        "type": "string",
                        "description": "The base URL to the Jira instance API. Web URL value is used if not set. For example, https://jira-api.example.com.\n"
                    },
                    "commentOnEventEnabled": {
                        "type": "boolean",
                        "description": "Enable comments inside Jira issues on each GitLab event (commit / merge request)\n"
                    },
                    "commitEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for commit events\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Create time.\n"
                    },
                    "issuesEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for issues events.\n"
                    },
                    "jiraIssueTransitionId": {
                        "type": "string",
                        "description": "The ID of a transition that moves issues to a closed state. You can find this number under the JIRA workflow administration (Administration \u003e Issues \u003e Workflows) by selecting View under Operations of the desired workflow of your project. By default, this ID is set to 2. *Note**: importing this field is only supported since GitLab 15.2.\n"
                    },
                    "jobEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for job events.\n"
                    },
                    "mergeRequestsEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for merge request events\n"
                    },
                    "noteEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for note events.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "The password of the user created to be used with GitLab/JIRA.\n",
                        "secret": true
                    },
                    "pipelineEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for pipeline events.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "ID of the project you want to activate integration on.\n",
                        "willReplaceOnChanges": true
                    },
                    "projectKey": {
                        "type": "string",
                        "description": "The short identifier for your JIRA project, all uppercase, e.g., PROJ.\n"
                    },
                    "pushEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for push events.\n"
                    },
                    "tagPushEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for tag_push events.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "Title.\n"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "Update time.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "The URL to the JIRA project which is being linked to this GitLab project. For example, https://jira.example.com.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "The username of the user created to be used with GitLab/JIRA.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/serviceMicrosoftTeams:ServiceMicrosoftTeams": {
            "description": "The `gitlab.ServiceMicrosoftTeams` resource allows to manage the lifecycle of a project integration with Microsoft Teams.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/integrations.html#microsoft-teams)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst awesomeProject = new gitlab.Project(\"awesomeProject\", {\n    description: \"My awesome project.\",\n    visibilityLevel: \"public\",\n});\nconst teams = new gitlab.ServiceMicrosoftTeams(\"teams\", {\n    project: awesomeProject.id,\n    webhook: \"https://testurl.com/?token=XYZ\",\n    pushEvents: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nawesome_project = gitlab.Project(\"awesomeProject\",\n    description=\"My awesome project.\",\n    visibility_level=\"public\")\nteams = gitlab.ServiceMicrosoftTeams(\"teams\",\n    project=awesome_project.id,\n    webhook=\"https://testurl.com/?token=XYZ\",\n    push_events=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var awesomeProject = new GitLab.Project(\"awesomeProject\", new()\n    {\n        Description = \"My awesome project.\",\n        VisibilityLevel = \"public\",\n    });\n\n    var teams = new GitLab.ServiceMicrosoftTeams(\"teams\", new()\n    {\n        Project = awesomeProject.Id,\n        Webhook = \"https://testurl.com/?token=XYZ\",\n        PushEvents = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tawesomeProject, err := gitlab.NewProject(ctx, \"awesomeProject\", \u0026gitlab.ProjectArgs{\n\t\t\tDescription:     pulumi.String(\"My awesome project.\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewServiceMicrosoftTeams(ctx, \"teams\", \u0026gitlab.ServiceMicrosoftTeamsArgs{\n\t\t\tProject:    awesomeProject.ID(),\n\t\t\tWebhook:    pulumi.String(\"https://testurl.com/?token=XYZ\"),\n\t\t\tPushEvents: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ServiceMicrosoftTeams;\nimport com.pulumi.gitlab.ServiceMicrosoftTeamsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var awesomeProject = new Project(\"awesomeProject\", ProjectArgs.builder()        \n            .description(\"My awesome project.\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var teams = new ServiceMicrosoftTeams(\"teams\", ServiceMicrosoftTeamsArgs.builder()        \n            .project(awesomeProject.id())\n            .webhook(\"https://testurl.com/?token=XYZ\")\n            .pushEvents(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  awesomeProject:\n    type: gitlab:Project\n    properties:\n      description: My awesome project.\n      visibilityLevel: public\n  teams:\n    type: gitlab:ServiceMicrosoftTeams\n    properties:\n      project: ${awesomeProject.id}\n      webhook: https://testurl.com/?token=XYZ\n      pushEvents: true\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nYou can import a service_microsoft_teams state using the project ID, e.g.\n\n```sh\n $ pulumi import gitlab:index/serviceMicrosoftTeams:ServiceMicrosoftTeams teams 1\n```\n\n ",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "Whether the integration is active.\n"
                },
                "branchesToBeNotified": {
                    "type": "string",
                    "description": "Branches to send notifications for. Valid options are “all”, “default”, “protected”, and “default*and*protected”. The default value is “default”\n"
                },
                "confidentialIssuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential issue events\n"
                },
                "confidentialNoteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential note events\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Create time.\n"
                },
                "issuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for issue events\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for merge request events\n"
                },
                "noteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for note events\n"
                },
                "notifyOnlyBrokenPipelines": {
                    "type": "boolean",
                    "description": "Send notifications for broken pipelines\n"
                },
                "pipelineEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for pipeline events\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for push events\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for tag push events\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "Update time.\n"
                },
                "webhook": {
                    "type": "string",
                    "description": "The Microsoft Teams webhook (Example, https://outlook.office.com/webhook/...). This value cannot be imported.\n"
                },
                "wikiPageEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for wiki page events\n"
                }
            },
            "required": [
                "active",
                "createdAt",
                "project",
                "updatedAt",
                "webhook"
            ],
            "inputProperties": {
                "branchesToBeNotified": {
                    "type": "string",
                    "description": "Branches to send notifications for. Valid options are “all”, “default”, “protected”, and “default*and*protected”. The default value is “default”\n"
                },
                "confidentialIssuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential issue events\n"
                },
                "confidentialNoteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential note events\n"
                },
                "issuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for issue events\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for merge request events\n"
                },
                "noteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for note events\n"
                },
                "notifyOnlyBrokenPipelines": {
                    "type": "boolean",
                    "description": "Send notifications for broken pipelines\n"
                },
                "pipelineEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for pipeline events\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n",
                    "willReplaceOnChanges": true
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for push events\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for tag push events\n"
                },
                "webhook": {
                    "type": "string",
                    "description": "The Microsoft Teams webhook (Example, https://outlook.office.com/webhook/...). This value cannot be imported.\n"
                },
                "wikiPageEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for wiki page events\n"
                }
            },
            "requiredInputs": [
                "project",
                "webhook"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ServiceMicrosoftTeams resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "Whether the integration is active.\n"
                    },
                    "branchesToBeNotified": {
                        "type": "string",
                        "description": "Branches to send notifications for. Valid options are “all”, “default”, “protected”, and “default*and*protected”. The default value is “default”\n"
                    },
                    "confidentialIssuesEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for confidential issue events\n"
                    },
                    "confidentialNoteEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for confidential note events\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Create time.\n"
                    },
                    "issuesEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for issue events\n"
                    },
                    "mergeRequestsEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for merge request events\n"
                    },
                    "noteEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for note events\n"
                    },
                    "notifyOnlyBrokenPipelines": {
                        "type": "boolean",
                        "description": "Send notifications for broken pipelines\n"
                    },
                    "pipelineEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for pipeline events\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "ID of the project you want to activate integration on.\n",
                        "willReplaceOnChanges": true
                    },
                    "pushEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for push events\n"
                    },
                    "tagPushEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for tag push events\n"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "Update time.\n"
                    },
                    "webhook": {
                        "type": "string",
                        "description": "The Microsoft Teams webhook (Example, https://outlook.office.com/webhook/...). This value cannot be imported.\n"
                    },
                    "wikiPageEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for wiki page events\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/servicePipelinesEmail:ServicePipelinesEmail": {
            "description": "The `gitlab.ServicePipelinesEmail` resource allows to manage the lifecycle of a project integration with Pipeline Emails Service.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/integrations.html#pipeline-emails)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst awesomeProject = new gitlab.Project(\"awesomeProject\", {\n    description: \"My awesome project.\",\n    visibilityLevel: \"public\",\n});\nconst email = new gitlab.ServicePipelinesEmail(\"email\", {\n    project: awesomeProject.id,\n    recipients: [\"gitlab@user.create\"],\n    notifyOnlyBrokenPipelines: true,\n    branchesToBeNotified: \"all\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nawesome_project = gitlab.Project(\"awesomeProject\",\n    description=\"My awesome project.\",\n    visibility_level=\"public\")\nemail = gitlab.ServicePipelinesEmail(\"email\",\n    project=awesome_project.id,\n    recipients=[\"gitlab@user.create\"],\n    notify_only_broken_pipelines=True,\n    branches_to_be_notified=\"all\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var awesomeProject = new GitLab.Project(\"awesomeProject\", new()\n    {\n        Description = \"My awesome project.\",\n        VisibilityLevel = \"public\",\n    });\n\n    var email = new GitLab.ServicePipelinesEmail(\"email\", new()\n    {\n        Project = awesomeProject.Id,\n        Recipients = new[]\n        {\n            \"gitlab@user.create\",\n        },\n        NotifyOnlyBrokenPipelines = true,\n        BranchesToBeNotified = \"all\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tawesomeProject, err := gitlab.NewProject(ctx, \"awesomeProject\", \u0026gitlab.ProjectArgs{\n\t\t\tDescription:     pulumi.String(\"My awesome project.\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewServicePipelinesEmail(ctx, \"email\", \u0026gitlab.ServicePipelinesEmailArgs{\n\t\t\tProject: awesomeProject.ID(),\n\t\t\tRecipients: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"gitlab@user.create\"),\n\t\t\t},\n\t\t\tNotifyOnlyBrokenPipelines: pulumi.Bool(true),\n\t\t\tBranchesToBeNotified:      pulumi.String(\"all\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ServicePipelinesEmail;\nimport com.pulumi.gitlab.ServicePipelinesEmailArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var awesomeProject = new Project(\"awesomeProject\", ProjectArgs.builder()        \n            .description(\"My awesome project.\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var email = new ServicePipelinesEmail(\"email\", ServicePipelinesEmailArgs.builder()        \n            .project(awesomeProject.id())\n            .recipients(\"gitlab@user.create\")\n            .notifyOnlyBrokenPipelines(true)\n            .branchesToBeNotified(\"all\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  awesomeProject:\n    type: gitlab:Project\n    properties:\n      description: My awesome project.\n      visibilityLevel: public\n  email:\n    type: gitlab:ServicePipelinesEmail\n    properties:\n      project: ${awesomeProject.id}\n      recipients:\n        - gitlab@user.create\n      notifyOnlyBrokenPipelines: true\n      branchesToBeNotified: all\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nYou can import a gitlab_service_pipelines_email state using the project ID, e.g.\n\n```sh\n $ pulumi import gitlab:index/servicePipelinesEmail:ServicePipelinesEmail email 1\n```\n\n ",
            "properties": {
                "branchesToBeNotified": {
                    "type": "string",
                    "description": "Branches to send notifications for. Valid options are `all`, `default`, `protected`, and `default_and_protected`. Default is `default`\n"
                },
                "notifyOnlyBrokenPipelines": {
                    "type": "boolean",
                    "description": "Notify only broken pipelines. Default is true.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n"
                },
                "recipients": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ") email addresses where notifications are sent.\n"
                }
            },
            "required": [
                "project",
                "recipients"
            ],
            "inputProperties": {
                "branchesToBeNotified": {
                    "type": "string",
                    "description": "Branches to send notifications for. Valid options are `all`, `default`, `protected`, and `default_and_protected`. Default is `default`\n"
                },
                "notifyOnlyBrokenPipelines": {
                    "type": "boolean",
                    "description": "Notify only broken pipelines. Default is true.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n",
                    "willReplaceOnChanges": true
                },
                "recipients": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ") email addresses where notifications are sent.\n"
                }
            },
            "requiredInputs": [
                "project",
                "recipients"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ServicePipelinesEmail resources.\n",
                "properties": {
                    "branchesToBeNotified": {
                        "type": "string",
                        "description": "Branches to send notifications for. Valid options are `all`, `default`, `protected`, and `default_and_protected`. Default is `default`\n"
                    },
                    "notifyOnlyBrokenPipelines": {
                        "type": "boolean",
                        "description": "Notify only broken pipelines. Default is true.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "ID of the project you want to activate integration on.\n",
                        "willReplaceOnChanges": true
                    },
                    "recipients": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": ") email addresses where notifications are sent.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/serviceSlack:ServiceSlack": {
            "description": "The `gitlab.ServiceSlack` resource allows to manage the lifecycle of a project integration with Slack.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/integrations.html#slack-notifications)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst awesomeProject = new gitlab.Project(\"awesomeProject\", {\n    description: \"My awesome project.\",\n    visibilityLevel: \"public\",\n});\nconst slack = new gitlab.ServiceSlack(\"slack\", {\n    project: awesomeProject.id,\n    webhook: \"https://webhook.com\",\n    username: \"myuser\",\n    pushEvents: true,\n    pushChannel: \"push_chan\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nawesome_project = gitlab.Project(\"awesomeProject\",\n    description=\"My awesome project.\",\n    visibility_level=\"public\")\nslack = gitlab.ServiceSlack(\"slack\",\n    project=awesome_project.id,\n    webhook=\"https://webhook.com\",\n    username=\"myuser\",\n    push_events=True,\n    push_channel=\"push_chan\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var awesomeProject = new GitLab.Project(\"awesomeProject\", new()\n    {\n        Description = \"My awesome project.\",\n        VisibilityLevel = \"public\",\n    });\n\n    var slack = new GitLab.ServiceSlack(\"slack\", new()\n    {\n        Project = awesomeProject.Id,\n        Webhook = \"https://webhook.com\",\n        Username = \"myuser\",\n        PushEvents = true,\n        PushChannel = \"push_chan\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tawesomeProject, err := gitlab.NewProject(ctx, \"awesomeProject\", \u0026gitlab.ProjectArgs{\n\t\t\tDescription:     pulumi.String(\"My awesome project.\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewServiceSlack(ctx, \"slack\", \u0026gitlab.ServiceSlackArgs{\n\t\t\tProject:     awesomeProject.ID(),\n\t\t\tWebhook:     pulumi.String(\"https://webhook.com\"),\n\t\t\tUsername:    pulumi.String(\"myuser\"),\n\t\t\tPushEvents:  pulumi.Bool(true),\n\t\t\tPushChannel: pulumi.String(\"push_chan\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ServiceSlack;\nimport com.pulumi.gitlab.ServiceSlackArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var awesomeProject = new Project(\"awesomeProject\", ProjectArgs.builder()        \n            .description(\"My awesome project.\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var slack = new ServiceSlack(\"slack\", ServiceSlackArgs.builder()        \n            .project(awesomeProject.id())\n            .webhook(\"https://webhook.com\")\n            .username(\"myuser\")\n            .pushEvents(true)\n            .pushChannel(\"push_chan\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  awesomeProject:\n    type: gitlab:Project\n    properties:\n      description: My awesome project.\n      visibilityLevel: public\n  slack:\n    type: gitlab:ServiceSlack\n    properties:\n      project: ${awesomeProject.id}\n      webhook: https://webhook.com\n      username: myuser\n      pushEvents: true\n      pushChannel: push_chan\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nYou can import a gitlab_service_slack.slack state using the project ID, e.g.\n\n```sh\n $ pulumi import gitlab:index/serviceSlack:ServiceSlack email 1\n```\n\n ",
            "properties": {
                "branchesToBeNotified": {
                    "type": "string",
                    "description": "Branches to send notifications for. Valid options are \"all\", \"default\", \"protected\", and \"default*and*protected\".\n"
                },
                "confidentialIssueChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive confidential issue events notifications.\n"
                },
                "confidentialIssuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential issues events.\n"
                },
                "confidentialNoteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential note events.\n"
                },
                "issueChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive issue events notifications.\n"
                },
                "issuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for issues events.\n"
                },
                "jobEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for job events. **ATTENTION**: This attribute is currently not being submitted to the GitLab API, due to https://github.com/xanzy/go-gitlab/issues/1354.\n"
                },
                "mergeRequestChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive merge request events notifications.\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for merge requests events.\n"
                },
                "noteChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive note events notifications.\n"
                },
                "noteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for note events.\n"
                },
                "notifyOnlyBrokenPipelines": {
                    "type": "boolean",
                    "description": "Send notifications for broken pipelines.\n"
                },
                "notifyOnlyDefaultBranch": {
                    "type": "boolean",
                    "description": "This parameter has been replaced with `branches_to_be_notified`.\n",
                    "deprecationMessage": "use 'branches_to_be_notified' argument instead"
                },
                "pipelineChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive pipeline events notifications.\n"
                },
                "pipelineEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for pipeline events.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n"
                },
                "pushChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive push events notifications.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for push events.\n"
                },
                "tagPushChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive tag push events notifications.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for tag push events.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username to use.\n"
                },
                "webhook": {
                    "type": "string",
                    "description": "Webhook URL (Example, https://hooks.slack.com/services/...). This value cannot be imported.\n"
                },
                "wikiPageChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive wiki page events notifications.\n"
                },
                "wikiPageEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for wiki page events.\n"
                }
            },
            "required": [
                "branchesToBeNotified",
                "confidentialIssuesEvents",
                "confidentialNoteEvents",
                "issuesEvents",
                "jobEvents",
                "mergeRequestsEvents",
                "noteEvents",
                "notifyOnlyBrokenPipelines",
                "notifyOnlyDefaultBranch",
                "pipelineEvents",
                "project",
                "pushEvents",
                "tagPushEvents",
                "webhook",
                "wikiPageEvents"
            ],
            "inputProperties": {
                "branchesToBeNotified": {
                    "type": "string",
                    "description": "Branches to send notifications for. Valid options are \"all\", \"default\", \"protected\", and \"default*and*protected\".\n"
                },
                "confidentialIssueChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive confidential issue events notifications.\n"
                },
                "confidentialIssuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential issues events.\n"
                },
                "confidentialNoteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential note events.\n"
                },
                "issueChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive issue events notifications.\n"
                },
                "issuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for issues events.\n"
                },
                "mergeRequestChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive merge request events notifications.\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for merge requests events.\n"
                },
                "noteChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive note events notifications.\n"
                },
                "noteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for note events.\n"
                },
                "notifyOnlyBrokenPipelines": {
                    "type": "boolean",
                    "description": "Send notifications for broken pipelines.\n"
                },
                "notifyOnlyDefaultBranch": {
                    "type": "boolean",
                    "description": "This parameter has been replaced with `branches_to_be_notified`.\n",
                    "deprecationMessage": "use 'branches_to_be_notified' argument instead"
                },
                "pipelineChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive pipeline events notifications.\n"
                },
                "pipelineEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for pipeline events.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n",
                    "willReplaceOnChanges": true
                },
                "pushChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive push events notifications.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for push events.\n"
                },
                "tagPushChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive tag push events notifications.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for tag push events.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username to use.\n"
                },
                "webhook": {
                    "type": "string",
                    "description": "Webhook URL (Example, https://hooks.slack.com/services/...). This value cannot be imported.\n"
                },
                "wikiPageChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive wiki page events notifications.\n"
                },
                "wikiPageEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for wiki page events.\n"
                }
            },
            "requiredInputs": [
                "project",
                "webhook"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ServiceSlack resources.\n",
                "properties": {
                    "branchesToBeNotified": {
                        "type": "string",
                        "description": "Branches to send notifications for. Valid options are \"all\", \"default\", \"protected\", and \"default*and*protected\".\n"
                    },
                    "confidentialIssueChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive confidential issue events notifications.\n"
                    },
                    "confidentialIssuesEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for confidential issues events.\n"
                    },
                    "confidentialNoteEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for confidential note events.\n"
                    },
                    "issueChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive issue events notifications.\n"
                    },
                    "issuesEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for issues events.\n"
                    },
                    "jobEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for job events. **ATTENTION**: This attribute is currently not being submitted to the GitLab API, due to https://github.com/xanzy/go-gitlab/issues/1354.\n"
                    },
                    "mergeRequestChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive merge request events notifications.\n"
                    },
                    "mergeRequestsEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for merge requests events.\n"
                    },
                    "noteChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive note events notifications.\n"
                    },
                    "noteEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for note events.\n"
                    },
                    "notifyOnlyBrokenPipelines": {
                        "type": "boolean",
                        "description": "Send notifications for broken pipelines.\n"
                    },
                    "notifyOnlyDefaultBranch": {
                        "type": "boolean",
                        "description": "This parameter has been replaced with `branches_to_be_notified`.\n",
                        "deprecationMessage": "use 'branches_to_be_notified' argument instead"
                    },
                    "pipelineChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive pipeline events notifications.\n"
                    },
                    "pipelineEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for pipeline events.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "ID of the project you want to activate integration on.\n",
                        "willReplaceOnChanges": true
                    },
                    "pushChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive push events notifications.\n"
                    },
                    "pushEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for push events.\n"
                    },
                    "tagPushChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive tag push events notifications.\n"
                    },
                    "tagPushEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for tag push events.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Username to use.\n"
                    },
                    "webhook": {
                        "type": "string",
                        "description": "Webhook URL (Example, https://hooks.slack.com/services/...). This value cannot be imported.\n"
                    },
                    "wikiPageChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive wiki page events notifications.\n"
                    },
                    "wikiPageEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for wiki page events.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/systemHook:SystemHook": {
            "description": "The `gitlab.SystemHook` resource allows to manage the lifecycle of a system hook.\n\n\u003e This resource requires GitLab 14.9\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/system_hooks.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = new gitlab.SystemHook(\"example\", {\n    enableSslVerification: true,\n    mergeRequestsEvents: true,\n    pushEvents: true,\n    repositoryUpdateEvents: true,\n    tagPushEvents: true,\n    token: \"secret-token\",\n    url: \"https://example.com/hook-%d\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.SystemHook(\"example\",\n    enable_ssl_verification=True,\n    merge_requests_events=True,\n    push_events=True,\n    repository_update_events=True,\n    tag_push_events=True,\n    token=\"secret-token\",\n    url=\"https://example.com/hook-%d\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new GitLab.SystemHook(\"example\", new()\n    {\n        EnableSslVerification = true,\n        MergeRequestsEvents = true,\n        PushEvents = true,\n        RepositoryUpdateEvents = true,\n        TagPushEvents = true,\n        Token = \"secret-token\",\n        Url = \"https://example.com/hook-%d\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewSystemHook(ctx, \"example\", \u0026gitlab.SystemHookArgs{\n\t\t\tEnableSslVerification:  pulumi.Bool(true),\n\t\t\tMergeRequestsEvents:    pulumi.Bool(true),\n\t\t\tPushEvents:             pulumi.Bool(true),\n\t\t\tRepositoryUpdateEvents: pulumi.Bool(true),\n\t\t\tTagPushEvents:          pulumi.Bool(true),\n\t\t\tToken:                  pulumi.String(\"secret-token\"),\n\t\t\tUrl:                    pulumi.String(\"https://example.com/hook-%d\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.SystemHook;\nimport com.pulumi.gitlab.SystemHookArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new SystemHook(\"example\", SystemHookArgs.builder()        \n            .enableSslVerification(true)\n            .mergeRequestsEvents(true)\n            .pushEvents(true)\n            .repositoryUpdateEvents(true)\n            .tagPushEvents(true)\n            .token(\"secret-token\")\n            .url(\"https://example.com/hook-%d\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: gitlab:SystemHook\n    properties:\n      enableSslVerification: true\n      mergeRequestsEvents: true\n      pushEvents: true\n      repositoryUpdateEvents: true\n      tagPushEvents: true\n      token: secret-token\n      url: https://example.com/hook-%d\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nYou can import a system hook using the hook id `{hook-id}`, e.g.\n\n```sh\n $ pulumi import gitlab:index/systemHook:SystemHook example 42\n```\n\n NOTEthe `token` attribute won't be available for imported resources. ",
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "The date and time the hook was created in ISO8601 format.\n"
                },
                "enableSslVerification": {
                    "type": "boolean",
                    "description": "Do SSL verification when triggering the hook.\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Trigger hook on merge requests events.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "When true, the hook fires on push events.\n"
                },
                "repositoryUpdateEvents": {
                    "type": "boolean",
                    "description": "Trigger hook on repository update events.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "When true, the hook fires on new tags being pushed.\n"
                },
                "token": {
                    "type": "string",
                    "description": "Secret token to validate received payloads; this isn’t returned in the response. This attribute is not available for imported resources.\n",
                    "secret": true
                },
                "url": {
                    "type": "string",
                    "description": "The hook URL.\n"
                }
            },
            "required": [
                "createdAt",
                "url"
            ],
            "inputProperties": {
                "enableSslVerification": {
                    "type": "boolean",
                    "description": "Do SSL verification when triggering the hook.\n",
                    "willReplaceOnChanges": true
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Trigger hook on merge requests events.\n",
                    "willReplaceOnChanges": true
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "When true, the hook fires on push events.\n",
                    "willReplaceOnChanges": true
                },
                "repositoryUpdateEvents": {
                    "type": "boolean",
                    "description": "Trigger hook on repository update events.\n",
                    "willReplaceOnChanges": true
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "When true, the hook fires on new tags being pushed.\n",
                    "willReplaceOnChanges": true
                },
                "token": {
                    "type": "string",
                    "description": "Secret token to validate received payloads; this isn’t returned in the response. This attribute is not available for imported resources.\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                },
                "url": {
                    "type": "string",
                    "description": "The hook URL.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "url"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SystemHook resources.\n",
                "properties": {
                    "createdAt": {
                        "type": "string",
                        "description": "The date and time the hook was created in ISO8601 format.\n"
                    },
                    "enableSslVerification": {
                        "type": "boolean",
                        "description": "Do SSL verification when triggering the hook.\n",
                        "willReplaceOnChanges": true
                    },
                    "mergeRequestsEvents": {
                        "type": "boolean",
                        "description": "Trigger hook on merge requests events.\n",
                        "willReplaceOnChanges": true
                    },
                    "pushEvents": {
                        "type": "boolean",
                        "description": "When true, the hook fires on push events.\n",
                        "willReplaceOnChanges": true
                    },
                    "repositoryUpdateEvents": {
                        "type": "boolean",
                        "description": "Trigger hook on repository update events.\n",
                        "willReplaceOnChanges": true
                    },
                    "tagPushEvents": {
                        "type": "boolean",
                        "description": "When true, the hook fires on new tags being pushed.\n",
                        "willReplaceOnChanges": true
                    },
                    "token": {
                        "type": "string",
                        "description": "Secret token to validate received payloads; this isn’t returned in the response. This attribute is not available for imported resources.\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "url": {
                        "type": "string",
                        "description": "The hook URL.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/tagProtection:TagProtection": {
            "description": "The `gitlab.TagProtection` resource allows to manage the lifecycle of a tag protection.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/protected_tags.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst tagProtect = new gitlab.TagProtection(\"tagProtect\", {\n    createAccessLevel: \"developer\",\n    project: \"12345\",\n    tag: \"TagProtected\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\ntag_protect = gitlab.TagProtection(\"tagProtect\",\n    create_access_level=\"developer\",\n    project=\"12345\",\n    tag=\"TagProtected\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var tagProtect = new GitLab.TagProtection(\"tagProtect\", new()\n    {\n        CreateAccessLevel = \"developer\",\n        Project = \"12345\",\n        Tag = \"TagProtected\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewTagProtection(ctx, \"tagProtect\", \u0026gitlab.TagProtectionArgs{\n\t\t\tCreateAccessLevel: pulumi.String(\"developer\"),\n\t\t\tProject:           pulumi.String(\"12345\"),\n\t\t\tTag:               pulumi.String(\"TagProtected\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.TagProtection;\nimport com.pulumi.gitlab.TagProtectionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var tagProtect = new TagProtection(\"tagProtect\", TagProtectionArgs.builder()        \n            .createAccessLevel(\"developer\")\n            .project(\"12345\")\n            .tag(\"TagProtected\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  tagProtect:\n    type: gitlab:TagProtection\n    properties:\n      createAccessLevel: developer\n      project: '12345'\n      tag: TagProtected\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nTag protections can be imported using an id made up of `project_id:tag_name`, e.g.\n\n```sh\n $ pulumi import gitlab:index/tagProtection:TagProtection example 123456789:v1.0.0\n```\n\n ",
            "properties": {
                "createAccessLevel": {
                    "type": "string",
                    "description": "Access levels which are allowed to create. Valid values are: `no one`, `developer`, `maintainer`.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The id of the project.\n"
                },
                "tag": {
                    "type": "string",
                    "description": "Name of the tag or wildcard.\n"
                }
            },
            "required": [
                "createAccessLevel",
                "project",
                "tag"
            ],
            "inputProperties": {
                "createAccessLevel": {
                    "type": "string",
                    "description": "Access levels which are allowed to create. Valid values are: `no one`, `developer`, `maintainer`.\n",
                    "willReplaceOnChanges": true
                },
                "project": {
                    "type": "string",
                    "description": "The id of the project.\n",
                    "willReplaceOnChanges": true
                },
                "tag": {
                    "type": "string",
                    "description": "Name of the tag or wildcard.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "createAccessLevel",
                "project",
                "tag"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TagProtection resources.\n",
                "properties": {
                    "createAccessLevel": {
                        "type": "string",
                        "description": "Access levels which are allowed to create. Valid values are: `no one`, `developer`, `maintainer`.\n",
                        "willReplaceOnChanges": true
                    },
                    "project": {
                        "type": "string",
                        "description": "The id of the project.\n",
                        "willReplaceOnChanges": true
                    },
                    "tag": {
                        "type": "string",
                        "description": "Name of the tag or wildcard.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/topic:Topic": {
            "description": "The `gitlab.Topic` resource allows to manage the lifecycle of topics that are then assignable to projects.\n\n\u003e Topics are the successors for project tags. Aside from avoiding terminology collisions with Git tags, they are more descriptive and better searchable.\n\n\u003e Deleting a topic was implemented in GitLab 14.9. For older versions of GitLab set `soft_destroy = true` to empty out a topic instead of deleting it.\n\n**Upstream API**: [GitLab REST API docs for topics](https://docs.gitlab.com/ee/api/topics.html)\n\n\n## Import\n\n\n\n```sh\n $ pulumi import gitlab:index/topic:Topic You can import a topic to terraform state using `\u003cresource\u003e \u003cid\u003e`.\n```\n\n The `id` must be an integer for the id of the topic you want to import, for example\n\n```sh\n $ pulumi import gitlab:index/topic:Topic functional_programming 1\n```\n\n ",
            "properties": {
                "avatar": {
                    "type": "string",
                    "description": "A local path to the avatar image to upload. **Note**: not available for imported resources.\n"
                },
                "avatarHash": {
                    "type": "string",
                    "description": "The hash of the avatar image. Use `filesha256(\"path/to/avatar.png\")` whenever possible. **Note**: this is used to trigger an update of the avatar. If it's not given, but an avatar is given, the avatar will be updated each time.\n"
                },
                "avatarUrl": {
                    "type": "string",
                    "description": "The URL of the avatar image.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A text describing the topic.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The topic's name.\n"
                },
                "softDestroy": {
                    "type": "boolean",
                    "description": "Empty the topics fields instead of deleting it.\n",
                    "deprecationMessage": "GitLab 14.9 introduced the proper deletion of topics. This field is no longer needed."
                },
                "title": {
                    "type": "string",
                    "description": "The topic's description. Requires at least GitLab 15.0 for which it's a required argument.\n"
                }
            },
            "required": [
                "avatarHash",
                "avatarUrl",
                "name"
            ],
            "inputProperties": {
                "avatar": {
                    "type": "string",
                    "description": "A local path to the avatar image to upload. **Note**: not available for imported resources.\n"
                },
                "avatarHash": {
                    "type": "string",
                    "description": "The hash of the avatar image. Use `filesha256(\"path/to/avatar.png\")` whenever possible. **Note**: this is used to trigger an update of the avatar. If it's not given, but an avatar is given, the avatar will be updated each time.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A text describing the topic.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The topic's name.\n"
                },
                "softDestroy": {
                    "type": "boolean",
                    "description": "Empty the topics fields instead of deleting it.\n",
                    "deprecationMessage": "GitLab 14.9 introduced the proper deletion of topics. This field is no longer needed."
                },
                "title": {
                    "type": "string",
                    "description": "The topic's description. Requires at least GitLab 15.0 for which it's a required argument.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Topic resources.\n",
                "properties": {
                    "avatar": {
                        "type": "string",
                        "description": "A local path to the avatar image to upload. **Note**: not available for imported resources.\n"
                    },
                    "avatarHash": {
                        "type": "string",
                        "description": "The hash of the avatar image. Use `filesha256(\"path/to/avatar.png\")` whenever possible. **Note**: this is used to trigger an update of the avatar. If it's not given, but an avatar is given, the avatar will be updated each time.\n"
                    },
                    "avatarUrl": {
                        "type": "string",
                        "description": "The URL of the avatar image.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A text describing the topic.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The topic's name.\n"
                    },
                    "softDestroy": {
                        "type": "boolean",
                        "description": "Empty the topics fields instead of deleting it.\n",
                        "deprecationMessage": "GitLab 14.9 introduced the proper deletion of topics. This field is no longer needed."
                    },
                    "title": {
                        "type": "string",
                        "description": "The topic's description. Requires at least GitLab 15.0 for which it's a required argument.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/user:User": {
            "description": "The `gitlab.User` resource allows to manage the lifecycle of a user.\n\n\u003e the provider needs to be configured with admin-level access for this resource to work.\n\n\u003e You must specify either password or reset_password.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/users.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = new gitlab.User(\"example\", {\n    canCreateGroup: false,\n    email: \"gitlab@user.create\",\n    isAdmin: true,\n    isExternal: true,\n    password: \"superPassword\",\n    projectsLimit: 4,\n    resetPassword: false,\n    username: \"example\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.User(\"example\",\n    can_create_group=False,\n    email=\"gitlab@user.create\",\n    is_admin=True,\n    is_external=True,\n    password=\"superPassword\",\n    projects_limit=4,\n    reset_password=False,\n    username=\"example\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new GitLab.User(\"example\", new()\n    {\n        CanCreateGroup = false,\n        Email = \"gitlab@user.create\",\n        IsAdmin = true,\n        IsExternal = true,\n        Password = \"superPassword\",\n        ProjectsLimit = 4,\n        ResetPassword = false,\n        Username = \"example\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewUser(ctx, \"example\", \u0026gitlab.UserArgs{\n\t\t\tCanCreateGroup: pulumi.Bool(false),\n\t\t\tEmail:          pulumi.String(\"gitlab@user.create\"),\n\t\t\tIsAdmin:        pulumi.Bool(true),\n\t\t\tIsExternal:     pulumi.Bool(true),\n\t\t\tPassword:       pulumi.String(\"superPassword\"),\n\t\t\tProjectsLimit:  pulumi.Int(4),\n\t\t\tResetPassword:  pulumi.Bool(false),\n\t\t\tUsername:       pulumi.String(\"example\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.User;\nimport com.pulumi.gitlab.UserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new User(\"example\", UserArgs.builder()        \n            .canCreateGroup(false)\n            .email(\"gitlab@user.create\")\n            .isAdmin(true)\n            .isExternal(true)\n            .password(\"superPassword\")\n            .projectsLimit(4)\n            .resetPassword(false)\n            .username(\"example\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: gitlab:User\n    properties:\n      canCreateGroup: false\n      email: gitlab@user.create\n      isAdmin: true\n      isExternal: true\n      password: superPassword\n      projectsLimit: 4\n      resetPassword: false\n      username: example\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import gitlab:index/user:User You can import a user to terraform state using `\u003cresource\u003e \u003cid\u003e`.\n```\n\n The `id` must be an integer for the id of the user you want to import, for example\n\n```sh\n $ pulumi import gitlab:index/user:User example 42\n```\n\n ",
            "properties": {
                "canCreateGroup": {
                    "type": "boolean",
                    "description": "Boolean, defaults to false. Whether to allow the user to create groups.\n"
                },
                "email": {
                    "type": "string",
                    "description": "The e-mail address of the user.\n"
                },
                "isAdmin": {
                    "type": "boolean",
                    "description": "Boolean, defaults to false.  Whether to enable administrative privileges\n"
                },
                "isExternal": {
                    "type": "boolean",
                    "description": "Boolean, defaults to false. Whether a user has access only to some internal or private projects. External users can only access projects to which they are explicitly granted access.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the user.\n"
                },
                "namespaceId": {
                    "type": "integer",
                    "description": "The ID of the user's namespace. Available since GitLab 14.10.\n"
                },
                "note": {
                    "type": "string",
                    "description": "The note associated to the user.\n"
                },
                "password": {
                    "type": "string",
                    "description": "The password of the user.\n",
                    "secret": true
                },
                "projectsLimit": {
                    "type": "integer",
                    "description": "Integer, defaults to 0.  Number of projects user can create.\n"
                },
                "resetPassword": {
                    "type": "boolean",
                    "description": "Boolean, defaults to false. Send user password reset link.\n"
                },
                "skipConfirmation": {
                    "type": "boolean",
                    "description": "Boolean, defaults to true. Whether to skip confirmation.\n"
                },
                "state": {
                    "type": "string",
                    "description": "String, defaults to 'active'. The state of the user account. Valid values are `active`, `deactivated`, `blocked`.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The username of the user.\n"
                }
            },
            "required": [
                "email",
                "name",
                "namespaceId",
                "username"
            ],
            "inputProperties": {
                "canCreateGroup": {
                    "type": "boolean",
                    "description": "Boolean, defaults to false. Whether to allow the user to create groups.\n"
                },
                "email": {
                    "type": "string",
                    "description": "The e-mail address of the user.\n"
                },
                "isAdmin": {
                    "type": "boolean",
                    "description": "Boolean, defaults to false.  Whether to enable administrative privileges\n"
                },
                "isExternal": {
                    "type": "boolean",
                    "description": "Boolean, defaults to false. Whether a user has access only to some internal or private projects. External users can only access projects to which they are explicitly granted access.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the user.\n"
                },
                "namespaceId": {
                    "type": "integer",
                    "description": "The ID of the user's namespace. Available since GitLab 14.10.\n"
                },
                "note": {
                    "type": "string",
                    "description": "The note associated to the user.\n"
                },
                "password": {
                    "type": "string",
                    "description": "The password of the user.\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                },
                "projectsLimit": {
                    "type": "integer",
                    "description": "Integer, defaults to 0.  Number of projects user can create.\n"
                },
                "resetPassword": {
                    "type": "boolean",
                    "description": "Boolean, defaults to false. Send user password reset link.\n",
                    "willReplaceOnChanges": true
                },
                "skipConfirmation": {
                    "type": "boolean",
                    "description": "Boolean, defaults to true. Whether to skip confirmation.\n",
                    "willReplaceOnChanges": true
                },
                "state": {
                    "type": "string",
                    "description": "String, defaults to 'active'. The state of the user account. Valid values are `active`, `deactivated`, `blocked`.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The username of the user.\n"
                }
            },
            "requiredInputs": [
                "email",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering User resources.\n",
                "properties": {
                    "canCreateGroup": {
                        "type": "boolean",
                        "description": "Boolean, defaults to false. Whether to allow the user to create groups.\n"
                    },
                    "email": {
                        "type": "string",
                        "description": "The e-mail address of the user.\n"
                    },
                    "isAdmin": {
                        "type": "boolean",
                        "description": "Boolean, defaults to false.  Whether to enable administrative privileges\n"
                    },
                    "isExternal": {
                        "type": "boolean",
                        "description": "Boolean, defaults to false. Whether a user has access only to some internal or private projects. External users can only access projects to which they are explicitly granted access.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the user.\n"
                    },
                    "namespaceId": {
                        "type": "integer",
                        "description": "The ID of the user's namespace. Available since GitLab 14.10.\n"
                    },
                    "note": {
                        "type": "string",
                        "description": "The note associated to the user.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "The password of the user.\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "projectsLimit": {
                        "type": "integer",
                        "description": "Integer, defaults to 0.  Number of projects user can create.\n"
                    },
                    "resetPassword": {
                        "type": "boolean",
                        "description": "Boolean, defaults to false. Send user password reset link.\n",
                        "willReplaceOnChanges": true
                    },
                    "skipConfirmation": {
                        "type": "boolean",
                        "description": "Boolean, defaults to true. Whether to skip confirmation.\n",
                        "willReplaceOnChanges": true
                    },
                    "state": {
                        "type": "string",
                        "description": "String, defaults to 'active'. The state of the user account. Valid values are `active`, `deactivated`, `blocked`.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "The username of the user.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/userCustomAttribute:UserCustomAttribute": {
            "description": "The `gitlab.UserCustomAttribute` resource allows to manage custom attributes for a user.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/custom_attributes.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst attr = new gitlab.UserCustomAttribute(\"attr\", {\n    key: \"location\",\n    user: 42,\n    value: \"Greenland\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nattr = gitlab.UserCustomAttribute(\"attr\",\n    key=\"location\",\n    user=42,\n    value=\"Greenland\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var attr = new GitLab.UserCustomAttribute(\"attr\", new()\n    {\n        Key = \"location\",\n        User = 42,\n        Value = \"Greenland\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewUserCustomAttribute(ctx, \"attr\", \u0026gitlab.UserCustomAttributeArgs{\n\t\t\tKey:   pulumi.String(\"location\"),\n\t\t\tUser:  pulumi.Int(42),\n\t\t\tValue: pulumi.String(\"Greenland\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.UserCustomAttribute;\nimport com.pulumi.gitlab.UserCustomAttributeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var attr = new UserCustomAttribute(\"attr\", UserCustomAttributeArgs.builder()        \n            .key(\"location\")\n            .user(\"42\")\n            .value(\"Greenland\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  attr:\n    type: gitlab:UserCustomAttribute\n    properties:\n      key: location\n      user: '42'\n      value: Greenland\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nYou can import a user custom attribute using an id made up of `{user-id}:{key}`, e.g.\n\n```sh\n $ pulumi import gitlab:index/userCustomAttribute:UserCustomAttribute attr 42:location\n```\n\n ",
            "properties": {
                "key": {
                    "type": "string",
                    "description": "Key for the Custom Attribute.\n"
                },
                "user": {
                    "type": "integer",
                    "description": "The id of the user.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value for the Custom Attribute.\n"
                }
            },
            "required": [
                "key",
                "user",
                "value"
            ],
            "inputProperties": {
                "key": {
                    "type": "string",
                    "description": "Key for the Custom Attribute.\n"
                },
                "user": {
                    "type": "integer",
                    "description": "The id of the user.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value for the Custom Attribute.\n"
                }
            },
            "requiredInputs": [
                "key",
                "user",
                "value"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserCustomAttribute resources.\n",
                "properties": {
                    "key": {
                        "type": "string",
                        "description": "Key for the Custom Attribute.\n"
                    },
                    "user": {
                        "type": "integer",
                        "description": "The id of the user.\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "Value for the Custom Attribute.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/userGpgKey:UserGpgKey": {
            "description": "The `gitlab.UserGpgKey` resource allows to manage the lifecycle of a GPG key assigned to the current user or a specific user.\n\t\t\n\u003e Managing GPG keys for arbitrary users requires admin privileges.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/users.html#get-a-specific-gpg-key)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst exampleUser = gitlab.getUser({\n    username: \"example-user\",\n});\n// Manages a GPG key for the specified user. An admin token is required if `user_id` is specified.\nconst exampleUserGpgKey = new gitlab.UserGpgKey(\"exampleUserGpgKey\", {\n    userId: exampleUser.then(exampleUser =\u003e exampleUser.id),\n    key: `-----BEGIN PGP PUBLIC KEY BLOCK-----\n...\n-----END PGP PUBLIC KEY BLOCK-----`,\n});\n// Manages a GPG key for the current user\nconst exampleUserUserGpgKey = new gitlab.UserGpgKey(\"exampleUserUserGpgKey\", {key: `-----BEGIN PGP PUBLIC KEY BLOCK-----\n...\n-----END PGP PUBLIC KEY BLOCK-----`});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample_user = gitlab.get_user(username=\"example-user\")\n# Manages a GPG key for the specified user. An admin token is required if `user_id` is specified.\nexample_user_gpg_key = gitlab.UserGpgKey(\"exampleUserGpgKey\",\n    user_id=example_user.id,\n    key=\"\"\"-----BEGIN PGP PUBLIC KEY BLOCK-----\n...\n-----END PGP PUBLIC KEY BLOCK-----\"\"\")\n# Manages a GPG key for the current user\nexample_user_user_gpg_key = gitlab.UserGpgKey(\"exampleUserUserGpgKey\", key=\"\"\"-----BEGIN PGP PUBLIC KEY BLOCK-----\n...\n-----END PGP PUBLIC KEY BLOCK-----\"\"\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleUser = GitLab.GetUser.Invoke(new()\n    {\n        Username = \"example-user\",\n    });\n\n    // Manages a GPG key for the specified user. An admin token is required if `user_id` is specified.\n    var exampleUserGpgKey = new GitLab.UserGpgKey(\"exampleUserGpgKey\", new()\n    {\n        UserId = exampleUser.Apply(getUserResult =\u003e getUserResult.Id),\n        Key = @\"-----BEGIN PGP PUBLIC KEY BLOCK-----\n...\n-----END PGP PUBLIC KEY BLOCK-----\",\n    });\n\n    // Manages a GPG key for the current user\n    var exampleUserUserGpgKey = new GitLab.UserGpgKey(\"exampleUserUserGpgKey\", new()\n    {\n        Key = @\"-----BEGIN PGP PUBLIC KEY BLOCK-----\n...\n-----END PGP PUBLIC KEY BLOCK-----\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleUser, err := gitlab.LookupUser(ctx, \u0026gitlab.LookupUserArgs{\n\t\t\tUsername: pulumi.StringRef(\"example-user\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewUserGpgKey(ctx, \"exampleUserGpgKey\", \u0026gitlab.UserGpgKeyArgs{\n\t\t\tUserId: *pulumi.String(exampleUser.Id),\n\t\t\tKey:    pulumi.String(\"-----BEGIN PGP PUBLIC KEY BLOCK-----\\n...\\n-----END PGP PUBLIC KEY BLOCK-----\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewUserGpgKey(ctx, \"exampleUserUserGpgKey\", \u0026gitlab.UserGpgKeyArgs{\n\t\t\tKey: pulumi.String(\"-----BEGIN PGP PUBLIC KEY BLOCK-----\\n...\\n-----END PGP PUBLIC KEY BLOCK-----\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetUserArgs;\nimport com.pulumi.gitlab.UserGpgKey;\nimport com.pulumi.gitlab.UserGpgKeyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var exampleUser = GitlabFunctions.getUser(GetUserArgs.builder()\n            .username(\"example-user\")\n            .build());\n\n        var exampleUserGpgKey = new UserGpgKey(\"exampleUserGpgKey\", UserGpgKeyArgs.builder()        \n            .userId(exampleUser.applyValue(getUserResult -\u003e getUserResult.id()))\n            .key(\"\"\"\n-----BEGIN PGP PUBLIC KEY BLOCK-----\n...\n-----END PGP PUBLIC KEY BLOCK-----            \"\"\")\n            .build());\n\n        var exampleUserUserGpgKey = new UserGpgKey(\"exampleUserUserGpgKey\", UserGpgKeyArgs.builder()        \n            .key(\"\"\"\n-----BEGIN PGP PUBLIC KEY BLOCK-----\n...\n-----END PGP PUBLIC KEY BLOCK-----            \"\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Manages a GPG key for the specified user. An admin token is required if `user_id` is specified.\n  exampleUserGpgKey:\n    type: gitlab:UserGpgKey\n    properties:\n      userId: ${exampleUser.id}\n      key: |-\n        -----BEGIN PGP PUBLIC KEY BLOCK-----\n        ...\n        -----END PGP PUBLIC KEY BLOCK-----\n  # Manages a GPG key for the current user\n  exampleUserUserGpgKey:\n    type: gitlab:UserGpgKey\n    properties:\n      key: |-\n        -----BEGIN PGP PUBLIC KEY BLOCK-----\n        ...\n        -----END PGP PUBLIC KEY BLOCK-----\nvariables:\n  exampleUser:\n    fn::invoke:\n      Function: gitlab:getUser\n      Arguments:\n        username: example-user\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nYou can import a GPG key for a specific user using an id made up of `{user-id}:{key}`, e.g.\n\n```sh\n $ pulumi import gitlab:index/userGpgKey:UserGpgKey example 42:1\n```\n\n Alternatively, you can import a GPG key for the current user using an id made up of `{key}`, e.g.\n\n```sh\n $ pulumi import gitlab:index/userGpgKey:UserGpgKey example_user 1\n```\n\n ",
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "The time when this key was created in GitLab.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The armored GPG public key.\n"
                },
                "keyId": {
                    "type": "integer",
                    "description": "The ID of the GPG key.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID of the user to add the GPG key to. If this field is omitted, this resource manages a GPG key for the current user. Otherwise, this resource manages a GPG key for the specified user, and an admin token is required.\n"
                }
            },
            "required": [
                "createdAt",
                "key",
                "keyId"
            ],
            "inputProperties": {
                "key": {
                    "type": "string",
                    "description": "The armored GPG public key.\n",
                    "willReplaceOnChanges": true
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID of the user to add the GPG key to. If this field is omitted, this resource manages a GPG key for the current user. Otherwise, this resource manages a GPG key for the specified user, and an admin token is required.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "key"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserGpgKey resources.\n",
                "properties": {
                    "createdAt": {
                        "type": "string",
                        "description": "The time when this key was created in GitLab.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "The armored GPG public key.\n",
                        "willReplaceOnChanges": true
                    },
                    "keyId": {
                        "type": "integer",
                        "description": "The ID of the GPG key.\n"
                    },
                    "userId": {
                        "type": "integer",
                        "description": "The ID of the user to add the GPG key to. If this field is omitted, this resource manages a GPG key for the current user. Otherwise, this resource manages a GPG key for the specified user, and an admin token is required.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/userSshKey:UserSshKey": {
            "description": "The `gitlab.UserSshKey` resource allows to manage the lifecycle of an SSH key assigned to a user.\n\n**Upstream API**: [GitLab API docs](https://docs.gitlab.com/ee/api/users.html#single-ssh-key)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst exampleUser = gitlab.getUser({\n    username: \"example-user\",\n});\nconst exampleUserSshKey = new gitlab.UserSshKey(\"exampleUserSshKey\", {\n    userId: exampleUser.then(exampleUser =\u003e exampleUser.id),\n    title: \"example-key\",\n    key: \"ssh-ed25519 AAAA...\",\n    expiresAt: \"2016-01-21T00:00:00.000Z\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample_user = gitlab.get_user(username=\"example-user\")\nexample_user_ssh_key = gitlab.UserSshKey(\"exampleUserSshKey\",\n    user_id=example_user.id,\n    title=\"example-key\",\n    key=\"ssh-ed25519 AAAA...\",\n    expires_at=\"2016-01-21T00:00:00.000Z\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleUser = GitLab.GetUser.Invoke(new()\n    {\n        Username = \"example-user\",\n    });\n\n    var exampleUserSshKey = new GitLab.UserSshKey(\"exampleUserSshKey\", new()\n    {\n        UserId = exampleUser.Apply(getUserResult =\u003e getUserResult.Id),\n        Title = \"example-key\",\n        Key = \"ssh-ed25519 AAAA...\",\n        ExpiresAt = \"2016-01-21T00:00:00.000Z\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleUser, err := gitlab.LookupUser(ctx, \u0026gitlab.LookupUserArgs{\n\t\t\tUsername: pulumi.StringRef(\"example-user\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewUserSshKey(ctx, \"exampleUserSshKey\", \u0026gitlab.UserSshKeyArgs{\n\t\t\tUserId:    *pulumi.String(exampleUser.Id),\n\t\t\tTitle:     pulumi.String(\"example-key\"),\n\t\t\tKey:       pulumi.String(\"ssh-ed25519 AAAA...\"),\n\t\t\tExpiresAt: pulumi.String(\"2016-01-21T00:00:00.000Z\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetUserArgs;\nimport com.pulumi.gitlab.UserSshKey;\nimport com.pulumi.gitlab.UserSshKeyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var exampleUser = GitlabFunctions.getUser(GetUserArgs.builder()\n            .username(\"example-user\")\n            .build());\n\n        var exampleUserSshKey = new UserSshKey(\"exampleUserSshKey\", UserSshKeyArgs.builder()        \n            .userId(exampleUser.applyValue(getUserResult -\u003e getUserResult.id()))\n            .title(\"example-key\")\n            .key(\"ssh-ed25519 AAAA...\")\n            .expiresAt(\"2016-01-21T00:00:00.000Z\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleUserSshKey:\n    type: gitlab:UserSshKey\n    properties:\n      userId: ${exampleUser.id}\n      title: example-key\n      key: ssh-ed25519 AAAA...\n      expiresAt: 2016-01-21T00:00:00.000Z\nvariables:\n  exampleUser:\n    fn::invoke:\n      Function: gitlab:getUser\n      Arguments:\n        username: example-user\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nYou can import a user ssh key using an id made up of `{user-id}:{key}`, e.g.\n\n```sh\n $ pulumi import gitlab:index/userSshKey:UserSshKey example 42:1\n```\n\n ",
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "The time when this key was created in GitLab.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "The expiration date of the SSH key in ISO 8601 format (YYYY-MM-DDTHH:MM:SSZ)\n"
                },
                "key": {
                    "type": "string",
                    "description": "The ssh key. The SSH key `comment` (trailing part) is optional and ignored for diffing, because GitLab overrides it with the username and GitLab hostname.\n"
                },
                "keyId": {
                    "type": "integer",
                    "description": "The ID of the ssh key.\n"
                },
                "title": {
                    "type": "string",
                    "description": "The title of the ssh key.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID or username of the user.\n"
                }
            },
            "required": [
                "createdAt",
                "key",
                "keyId",
                "title",
                "userId"
            ],
            "inputProperties": {
                "expiresAt": {
                    "type": "string",
                    "description": "The expiration date of the SSH key in ISO 8601 format (YYYY-MM-DDTHH:MM:SSZ)\n",
                    "willReplaceOnChanges": true
                },
                "key": {
                    "type": "string",
                    "description": "The ssh key. The SSH key `comment` (trailing part) is optional and ignored for diffing, because GitLab overrides it with the username and GitLab hostname.\n",
                    "willReplaceOnChanges": true
                },
                "title": {
                    "type": "string",
                    "description": "The title of the ssh key.\n",
                    "willReplaceOnChanges": true
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID or username of the user.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "key",
                "title",
                "userId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserSshKey resources.\n",
                "properties": {
                    "createdAt": {
                        "type": "string",
                        "description": "The time when this key was created in GitLab.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "The expiration date of the SSH key in ISO 8601 format (YYYY-MM-DDTHH:MM:SSZ)\n",
                        "willReplaceOnChanges": true
                    },
                    "key": {
                        "type": "string",
                        "description": "The ssh key. The SSH key `comment` (trailing part) is optional and ignored for diffing, because GitLab overrides it with the username and GitLab hostname.\n",
                        "willReplaceOnChanges": true
                    },
                    "keyId": {
                        "type": "integer",
                        "description": "The ID of the ssh key.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "The title of the ssh key.\n",
                        "willReplaceOnChanges": true
                    },
                    "userId": {
                        "type": "integer",
                        "description": "The ID or username of the user.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "gitlab:index/getApplication:getApplication": {
            "description": "The `gitlab.Application` data source retrieves information about a gitlab application.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/applications.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetApplicationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var oidc = GitlabFunctions.getApplication(GetApplicationArgs.builder()\n            .applicationId(1)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  oidc:\n    fn::invoke:\n      Function: gitlab:getApplication\n      Arguments:\n        applicationId: 1\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getApplication.\n",
                "properties": {
                    "id": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "id"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getApplication.\n",
                "properties": {
                    "applicationId": {
                        "type": "string",
                        "description": "Internal GitLab application id.\n"
                    },
                    "confidential": {
                        "type": "boolean",
                        "description": "Indicates if the application is kept confidential.\n"
                    },
                    "id": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the GitLab application.\n"
                    },
                    "redirectUrl": {
                        "type": "string",
                        "description": "The redirect url of the application.\n"
                    }
                },
                "type": "object",
                "required": [
                    "applicationId",
                    "confidential",
                    "id",
                    "name",
                    "redirectUrl"
                ]
            }
        },
        "gitlab:index/getBranch:getBranch": {
            "description": "The `gitlab.Branch` data source allows details of a repository branch to be retrieved by its name and project.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/branches.html#get-single-repository-branch)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = gitlab.getBranch({\n    name: \"example\",\n    project: \"foo/bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.get_branch(name=\"example\",\n    project=\"foo/bar\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = GitLab.GetBranch.Invoke(new()\n    {\n        Name = \"example\",\n        Project = \"foo/bar\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.LookupBranch(ctx, \u0026gitlab.LookupBranchArgs{\n\t\t\tName:    \"example\",\n\t\t\tProject: \"foo/bar\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetBranchArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var foo = GitlabFunctions.getBranch(GetBranchArgs.builder()\n            .name(\"example\")\n            .project(\"foo/bar\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  foo:\n    fn::invoke:\n      Function: gitlab:getBranch\n      Arguments:\n        name: example\n        project: foo/bar\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getBranch.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the branch.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The full path or id of the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getBranch.\n",
                "properties": {
                    "canPush": {
                        "type": "boolean",
                        "description": "Bool, true if you can push to the branch.\n"
                    },
                    "commits": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getBranchCommit:getBranchCommit"
                        },
                        "description": "The commit associated with the branch ref.\n"
                    },
                    "default": {
                        "type": "boolean",
                        "description": "Bool, true if branch is the default branch for the project.\n"
                    },
                    "developerCanMerge": {
                        "type": "boolean",
                        "description": "Bool, true if developer level access allows to merge branch.\n"
                    },
                    "developerCanPush": {
                        "type": "boolean",
                        "description": "Bool, true if developer level access allows git push.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "merged": {
                        "type": "boolean",
                        "description": "Bool, true if the branch has been merged into it's parent.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the branch.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The full path or id of the project.\n"
                    },
                    "protected": {
                        "type": "boolean",
                        "description": "Bool, true if branch has branch protection.\n"
                    },
                    "webUrl": {
                        "type": "string",
                        "description": "The url of the created branch (https.)\n"
                    }
                },
                "type": "object",
                "required": [
                    "canPush",
                    "commits",
                    "default",
                    "developerCanMerge",
                    "developerCanPush",
                    "merged",
                    "name",
                    "project",
                    "protected",
                    "webUrl",
                    "id"
                ]
            }
        },
        "gitlab:index/getClusterAgent:getClusterAgent": {
            "description": "The `gitlab.ClusterAgent` data source allows to retrieve details about a GitLab Agent for Kubernetes.\n\n\u003e Requires at least GitLab 14.10\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/cluster_agents.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getClusterAgent({\n    agentId: 1,\n    project: \"12345\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_cluster_agent(agent_id=1,\n    project=\"12345\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetClusterAgent.Invoke(new()\n    {\n        AgentId = 1,\n        Project = \"12345\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.LookupClusterAgent(ctx, \u0026gitlab.LookupClusterAgentArgs{\n\t\t\tAgentId: 1,\n\t\t\tProject: \"12345\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetClusterAgentArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getClusterAgent(GetClusterAgentArgs.builder()\n            .agentId(1)\n            .project(\"12345\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getClusterAgent\n      Arguments:\n        agentId: 1\n        project: '12345'\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getClusterAgent.\n",
                "properties": {
                    "agentId": {
                        "type": "integer",
                        "description": "The ID of the agent.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "ID or full path of the project maintained by the authenticated user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "agentId",
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getClusterAgent.\n",
                "properties": {
                    "agentId": {
                        "type": "integer",
                        "description": "The ID of the agent.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "The ISO8601 datetime when the agent was created.\n"
                    },
                    "createdByUserId": {
                        "type": "integer",
                        "description": "The ID of the user who created the agent.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The Name of the agent.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "ID or full path of the project maintained by the authenticated user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "agentId",
                    "createdAt",
                    "createdByUserId",
                    "name",
                    "project",
                    "id"
                ]
            }
        },
        "gitlab:index/getClusterAgents:getClusterAgents": {
            "description": "The `gitlab.getClusterAgents` data source allows details of GitLab Agents for Kubernetes in a project.\n\n\u003e Requires at least GitLab 14.10\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/cluster_agents.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst agents = gitlab.getClusterAgents({\n    project: \"12345\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nagents = gitlab.get_cluster_agents(project=\"12345\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var agents = GitLab.GetClusterAgents.Invoke(new()\n    {\n        Project = \"12345\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.GetClusterAgents(ctx, \u0026gitlab.GetClusterAgentsArgs{\n\t\t\tProject: \"12345\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetClusterAgentsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var agents = GitlabFunctions.getClusterAgents(GetClusterAgentsArgs.builder()\n            .project(\"12345\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  agents:\n    fn::invoke:\n      Function: gitlab:getClusterAgents\n      Arguments:\n        project: '12345'\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getClusterAgents.\n",
                "properties": {
                    "project": {
                        "type": "string",
                        "description": "The ID or full path of the project owned by the authenticated user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getClusterAgents.\n",
                "properties": {
                    "clusterAgents": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getClusterAgentsClusterAgent:getClusterAgentsClusterAgent"
                        },
                        "description": "List of the registered agents.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or full path of the project owned by the authenticated user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterAgents",
                    "project",
                    "id"
                ]
            }
        },
        "gitlab:index/getCurrentUser:getCurrentUser": {
            "description": "The `gitlab.getCurrentUser` data source allows details of the current user (determined by `token` provider attribute) to be retrieved.\n\n**Upstream API**: [GitLab GraphQL API docs](https://docs.gitlab.com/ee/api/graphql/reference/index.html#querycurrentuser)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getCurrentUser({});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_current_user()\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetCurrentUser.Invoke();\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.GetCurrentUser(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getCurrentUser();\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getCurrentUser\n      Arguments: {}\n```\n{{% /example %}}\n{{% /examples %}}",
            "outputs": {
                "description": "A collection of values returned by getCurrentUser.\n",
                "properties": {
                    "bot": {
                        "type": "boolean",
                        "description": "Indicates if the user is a bot.\n"
                    },
                    "globalId": {
                        "type": "string",
                        "description": "Global ID of the user. This is in the form of a GraphQL globally unique ID.\n"
                    },
                    "globalNamespaceId": {
                        "type": "string",
                        "description": "Personal namespace of the user. This is in the form of a GraphQL globally unique ID.\n"
                    },
                    "groupCount": {
                        "type": "integer",
                        "description": "Group count for the user.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "ID of the user.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Human-readable name of the user. Returns **** if the user is a project bot and the requester does not have permission to view the project.\n"
                    },
                    "namespaceId": {
                        "type": "string",
                        "description": "Personal namespace of the user.\n"
                    },
                    "publicEmail": {
                        "type": "string",
                        "description": "User’s public email.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Username of the user. Unique within this instance of GitLab.\n"
                    }
                },
                "type": "object",
                "required": [
                    "bot",
                    "globalId",
                    "globalNamespaceId",
                    "groupCount",
                    "id",
                    "name",
                    "namespaceId",
                    "publicEmail",
                    "username"
                ]
            }
        },
        "gitlab:index/getGroup:getGroup": {
            "description": "The `gitlab.Group` data source allows details of a group to be retrieved by its id or full path.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/groups.html#details-of-a-group)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = gitlab.getGroup({\n    fullPath: \"foo/bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.get_group(full_path=\"foo/bar\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = GitLab.GetGroup.Invoke(new()\n    {\n        FullPath = \"foo/bar\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.LookupGroup(ctx, \u0026gitlab.LookupGroupArgs{\n\t\t\tFullPath: pulumi.StringRef(\"foo/bar\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var foo = GitlabFunctions.getGroup(GetGroupArgs.builder()\n            .fullPath(\"foo/bar\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  foo:\n    fn::invoke:\n      Function: gitlab:getGroup\n      Arguments:\n        fullPath: foo/bar\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getGroup.\n",
                "properties": {
                    "fullPath": {
                        "type": "string",
                        "description": "The full path of the group.\n"
                    },
                    "groupId": {
                        "type": "integer",
                        "description": "The ID of the group.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getGroup.\n",
                "properties": {
                    "defaultBranchProtection": {
                        "type": "integer",
                        "description": "Whether developers and maintainers can push to the applicable default branch.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the group.\n"
                    },
                    "extraSharedRunnersMinutesLimit": {
                        "type": "integer",
                        "description": "Can be set by administrators only. Additional CI/CD minutes for this group.\n"
                    },
                    "fullName": {
                        "type": "string",
                        "description": "The full name of the group.\n"
                    },
                    "fullPath": {
                        "type": "string",
                        "description": "The full path of the group.\n"
                    },
                    "groupId": {
                        "type": "integer",
                        "description": "The ID of the group.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "lfsEnabled": {
                        "type": "boolean",
                        "description": "Boolean, is LFS enabled for projects in this group.\n"
                    },
                    "membershipLock": {
                        "type": "boolean",
                        "description": "Users cannot be added to projects in this group.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of this group.\n"
                    },
                    "parentId": {
                        "type": "integer",
                        "description": "Integer, ID of the parent group.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path of the group.\n"
                    },
                    "preventForkingOutsideGroup": {
                        "type": "boolean",
                        "description": "When enabled, users can not fork projects from this group to external namespaces.\n"
                    },
                    "requestAccessEnabled": {
                        "type": "boolean",
                        "description": "Boolean, is request for access enabled to the group.\n"
                    },
                    "runnersToken": {
                        "type": "string",
                        "description": "The group level registration token to use during runner setup.\n",
                        "secret": true
                    },
                    "sharedRunnersMinutesLimit": {
                        "type": "integer",
                        "description": "Can be set by administrators only. Maximum number of monthly CI/CD minutes for this group. Can be nil (default; inherit system default), 0 (unlimited), or \u003e 0.\n"
                    },
                    "visibilityLevel": {
                        "type": "string",
                        "description": "Visibility level of the group. Possible values are `private`, `internal`, `public`.\n"
                    },
                    "webUrl": {
                        "type": "string",
                        "description": "Web URL of the group.\n"
                    }
                },
                "type": "object",
                "required": [
                    "defaultBranchProtection",
                    "description",
                    "extraSharedRunnersMinutesLimit",
                    "fullName",
                    "fullPath",
                    "groupId",
                    "lfsEnabled",
                    "membershipLock",
                    "name",
                    "parentId",
                    "path",
                    "preventForkingOutsideGroup",
                    "requestAccessEnabled",
                    "runnersToken",
                    "sharedRunnersMinutesLimit",
                    "visibilityLevel",
                    "webUrl",
                    "id"
                ]
            }
        },
        "gitlab:index/getGroupHook:getGroupHook": {
            "description": "The `gitlab.GroupHook` data source allows to retrieve details about a hook in a group.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/groups.html#get-group-hook)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetGroupArgs;\nimport com.pulumi.gitlab.inputs.GetGroupHookArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var exampleGroup = GitlabFunctions.getGroup(GetGroupArgs.builder()\n            .id(\"foo/bar/baz\")\n            .build());\n\n        final var exampleGroupHook = GitlabFunctions.getGroupHook(GetGroupHookArgs.builder()\n            .group(exampleGroup.applyValue(getGroupResult -\u003e getGroupResult.id()))\n            .hookId(1)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  exampleGroup:\n    fn::invoke:\n      Function: gitlab:getGroup\n      Arguments:\n        id: foo/bar/baz\n  exampleGroupHook:\n    fn::invoke:\n      Function: gitlab:getGroupHook\n      Arguments:\n        group: ${exampleGroup.id}\n        hookId: 1\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getGroupHook.\n",
                "properties": {
                    "group": {
                        "type": "string",
                        "description": "The ID or full path of the group.\n"
                    },
                    "hookId": {
                        "type": "integer",
                        "description": "The id of the group hook.\n"
                    }
                },
                "type": "object",
                "required": [
                    "group",
                    "hookId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGroupHook.\n",
                "properties": {
                    "confidentialIssuesEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for confidential issues events.\n"
                    },
                    "confidentialNoteEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for confidential notes events.\n"
                    },
                    "deploymentEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for deployment events.\n"
                    },
                    "enableSslVerification": {
                        "type": "boolean",
                        "description": "Enable ssl verification when invoking the hook.\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "The ID or full path of the group.\n"
                    },
                    "groupId": {
                        "type": "integer",
                        "description": "The id of the group for the hook.\n"
                    },
                    "hookId": {
                        "type": "integer",
                        "description": "The id of the group hook.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "issuesEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for issues events.\n"
                    },
                    "jobEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for job events.\n"
                    },
                    "mergeRequestsEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for merge requests.\n"
                    },
                    "noteEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for notes events.\n"
                    },
                    "pipelineEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for pipeline events.\n"
                    },
                    "pushEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for push events.\n"
                    },
                    "pushEventsBranchFilter": {
                        "type": "string",
                        "description": "Invoke the hook for push events on matching branches only.\n"
                    },
                    "releasesEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for releases events.\n"
                    },
                    "subgroupEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for subgroup events.\n"
                    },
                    "tagPushEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for tag push events.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "A token to present when invoking the hook. The token is not available for imported resources.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "The url of the hook to invoke.\n"
                    },
                    "wikiPageEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for wiki page events.\n"
                    }
                },
                "type": "object",
                "required": [
                    "confidentialIssuesEvents",
                    "confidentialNoteEvents",
                    "deploymentEvents",
                    "enableSslVerification",
                    "group",
                    "groupId",
                    "hookId",
                    "issuesEvents",
                    "jobEvents",
                    "mergeRequestsEvents",
                    "noteEvents",
                    "pipelineEvents",
                    "pushEvents",
                    "pushEventsBranchFilter",
                    "releasesEvents",
                    "subgroupEvents",
                    "tagPushEvents",
                    "token",
                    "url",
                    "wikiPageEvents",
                    "id"
                ]
            }
        },
        "gitlab:index/getGroupHooks:getGroupHooks": {
            "description": "The `gitlab.getGroupHooks` data source allows to retrieve details about hooks in a group.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/groups.html#list-group-hooks)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetGroupArgs;\nimport com.pulumi.gitlab.inputs.GetGroupHooksArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getGroup(GetGroupArgs.builder()\n            .id(\"foo/bar/baz\")\n            .build());\n\n        final var examples = GitlabFunctions.getGroupHooks(GetGroupHooksArgs.builder()\n            .group(example.applyValue(getGroupResult -\u003e getGroupResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getGroup\n      Arguments:\n        id: foo/bar/baz\n  examples:\n    fn::invoke:\n      Function: gitlab:getGroupHooks\n      Arguments:\n        group: ${example.id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getGroupHooks.\n",
                "properties": {
                    "group": {
                        "type": "string",
                        "description": "The ID or full path of the group.\n"
                    }
                },
                "type": "object",
                "required": [
                    "group"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGroupHooks.\n",
                "properties": {
                    "group": {
                        "type": "string",
                        "description": "The ID or full path of the group.\n"
                    },
                    "hooks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getGroupHooksHook:getGroupHooksHook"
                        },
                        "description": "The list of hooks.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "group",
                    "hooks",
                    "id"
                ]
            }
        },
        "gitlab:index/getGroupMembership:getGroupMembership": {
            "description": "The `gitlab.GroupMembership` data source allows to list and filter all members of a group specified by either its id or full path.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/members.html#list-all-members-of-a-group-or-project)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getGroupMembership({\n    fullPath: \"foo/bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_group_membership(full_path=\"foo/bar\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetGroupMembership.Invoke(new()\n    {\n        FullPath = \"foo/bar\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.LookupGroupMembership(ctx, \u0026gitlab.LookupGroupMembershipArgs{\n\t\t\tFullPath: pulumi.StringRef(\"foo/bar\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetGroupMembershipArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getGroupMembership(GetGroupMembershipArgs.builder()\n            .fullPath(\"foo/bar\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getGroupMembership\n      Arguments:\n        fullPath: foo/bar\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getGroupMembership.\n",
                "properties": {
                    "accessLevel": {
                        "type": "string",
                        "description": "Only return members with the desired access level. Acceptable values are: `guest`, `reporter`, `developer`, `maintainer`, `owner`.\n"
                    },
                    "fullPath": {
                        "type": "string",
                        "description": "The full path of the group.\n"
                    },
                    "groupId": {
                        "type": "integer",
                        "description": "The ID of the group.\n"
                    },
                    "inherited": {
                        "type": "boolean",
                        "description": "Return all project members including members through ancestor groups.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getGroupMembership.\n",
                "properties": {
                    "accessLevel": {
                        "type": "string",
                        "description": "Only return members with the desired access level. Acceptable values are: `guest`, `reporter`, `developer`, `maintainer`, `owner`.\n"
                    },
                    "fullPath": {
                        "type": "string",
                        "description": "The full path of the group.\n"
                    },
                    "groupId": {
                        "type": "integer",
                        "description": "The ID of the group.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "inherited": {
                        "type": "boolean",
                        "description": "Return all project members including members through ancestor groups.\n"
                    },
                    "members": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getGroupMembershipMember:getGroupMembershipMember"
                        },
                        "description": "The list of group members.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accessLevel",
                    "fullPath",
                    "groupId",
                    "members",
                    "id"
                ]
            }
        },
        "gitlab:index/getGroupSubgroups:getGroupSubgroups": {
            "description": "The `gitlab.getGroupSubgroups` data source allows to get subgroups of a group.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/groups.html#list-a-groups-subgroups)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst subgroupsGroupSubgroups = gitlab.getGroupSubgroups({\n    groupId: 123456,\n});\nexport const subgroups = subgroupsGroupSubgroups;\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nsubgroups_group_subgroups = gitlab.get_group_subgroups(group_id=123456)\npulumi.export(\"subgroups\", subgroups_group_subgroups)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var subgroupsGroupSubgroups = GitLab.GetGroupSubgroups.Invoke(new()\n    {\n        GroupId = 123456,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"subgroups\"] = subgroupsGroupSubgroups,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tsubgroupsGroupSubgroups, err := gitlab.GetGroupSubgroups(ctx, \u0026gitlab.GetGroupSubgroupsArgs{\n\t\t\tGroupId: 123456,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"subgroups\", subgroupsGroupSubgroups)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetGroupSubgroupsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var subgroupsGroupSubgroups = GitlabFunctions.getGroupSubgroups(GetGroupSubgroupsArgs.builder()\n            .groupId(\"123456\")\n            .build());\n\n        ctx.export(\"subgroups\", subgroupsGroupSubgroups.applyValue(getGroupSubgroupsResult -\u003e getGroupSubgroupsResult));\n    }\n}\n```\n```yaml\nvariables:\n  subgroupsGroupSubgroups:\n    fn::invoke:\n      Function: gitlab:getGroupSubgroups\n      Arguments:\n        groupId: '123456'\noutputs:\n  subgroups: ${subgroupsGroupSubgroups}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getGroupSubgroups.\n",
                "properties": {
                    "allAvailable": {
                        "type": "boolean",
                        "description": "Show all the groups you have access to.\n"
                    },
                    "groupId": {
                        "type": "integer",
                        "description": "The ID of the group.\n"
                    },
                    "minAccessLevel": {
                        "type": "string",
                        "description": "Limit to groups where current user has at least this access level.\n"
                    },
                    "orderBy": {
                        "type": "string",
                        "description": "Order groups by name, path or id.\n"
                    },
                    "owned": {
                        "type": "boolean",
                        "description": "Limit to groups explicitly owned by the current user.\n"
                    },
                    "search": {
                        "type": "string",
                        "description": "Return the list of authorized groups matching the search criteria.\n"
                    },
                    "skipGroups": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "Skip the group IDs passed.\n"
                    },
                    "sort": {
                        "type": "string",
                        "description": "Order groups in asc or desc order.\n"
                    },
                    "statistics": {
                        "type": "boolean",
                        "description": "Include group statistics (administrators only).\n"
                    },
                    "withCustomAttributes": {
                        "type": "boolean",
                        "description": "Include custom attributes in response (administrators only).\n"
                    }
                },
                "type": "object",
                "required": [
                    "groupId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGroupSubgroups.\n",
                "properties": {
                    "allAvailable": {
                        "type": "boolean",
                        "description": "Show all the groups you have access to.\n"
                    },
                    "groupId": {
                        "type": "integer",
                        "description": "The ID of the group.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "minAccessLevel": {
                        "type": "string",
                        "description": "Limit to groups where current user has at least this access level.\n"
                    },
                    "orderBy": {
                        "type": "string",
                        "description": "Order groups by name, path or id.\n"
                    },
                    "owned": {
                        "type": "boolean",
                        "description": "Limit to groups explicitly owned by the current user.\n"
                    },
                    "search": {
                        "type": "string",
                        "description": "Return the list of authorized groups matching the search criteria.\n"
                    },
                    "skipGroups": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "Skip the group IDs passed.\n"
                    },
                    "sort": {
                        "type": "string",
                        "description": "Order groups in asc or desc order.\n"
                    },
                    "statistics": {
                        "type": "boolean",
                        "description": "Include group statistics (administrators only).\n"
                    },
                    "subgroups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getGroupSubgroupsSubgroup:getGroupSubgroupsSubgroup"
                        },
                        "description": "Subgroups of the parent group.\n"
                    },
                    "withCustomAttributes": {
                        "type": "boolean",
                        "description": "Include custom attributes in response (administrators only).\n"
                    }
                },
                "type": "object",
                "required": [
                    "allAvailable",
                    "groupId",
                    "minAccessLevel",
                    "orderBy",
                    "owned",
                    "search",
                    "skipGroups",
                    "sort",
                    "statistics",
                    "subgroups",
                    "withCustomAttributes",
                    "id"
                ]
            }
        },
        "gitlab:index/getGroupVariable:getGroupVariable": {
            "description": "The `gitlab.GroupVariable` data source allows to retrieve details about a group-level CI/CD variable.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/group_level_variables.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = gitlab.getGroupVariable({\n    group: \"my/example/group\",\n    key: \"foo\",\n});\nconst bar = gitlab.getGroupVariable({\n    environmentScope: \"staging/*\",\n    group: \"my/example/group\",\n    key: \"bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.get_group_variable(group=\"my/example/group\",\n    key=\"foo\")\nbar = gitlab.get_group_variable(environment_scope=\"staging/*\",\n    group=\"my/example/group\",\n    key=\"bar\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = GitLab.GetGroupVariable.Invoke(new()\n    {\n        Group = \"my/example/group\",\n        Key = \"foo\",\n    });\n\n    var bar = GitLab.GetGroupVariable.Invoke(new()\n    {\n        EnvironmentScope = \"staging/*\",\n        Group = \"my/example/group\",\n        Key = \"bar\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.LookupGroupVariable(ctx, \u0026gitlab.LookupGroupVariableArgs{\n\t\t\tGroup: \"my/example/group\",\n\t\t\tKey:   \"foo\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.LookupGroupVariable(ctx, \u0026gitlab.LookupGroupVariableArgs{\n\t\t\tEnvironmentScope: pulumi.StringRef(\"staging/*\"),\n\t\t\tGroup:            \"my/example/group\",\n\t\t\tKey:              \"bar\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetGroupVariableArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var foo = GitlabFunctions.getGroupVariable(GetGroupVariableArgs.builder()\n            .group(\"my/example/group\")\n            .key(\"foo\")\n            .build());\n\n        final var bar = GitlabFunctions.getGroupVariable(GetGroupVariableArgs.builder()\n            .environmentScope(\"staging/*\")\n            .group(\"my/example/group\")\n            .key(\"bar\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  foo:\n    fn::invoke:\n      Function: gitlab:getGroupVariable\n      Arguments:\n        group: my/example/group\n        key: foo\n  bar:\n    fn::invoke:\n      Function: gitlab:getGroupVariable\n      Arguments:\n        environmentScope: staging/*\n        group: my/example/group\n        key: bar\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getGroupVariable.\n",
                "properties": {
                    "environmentScope": {
                        "type": "string",
                        "description": "The environment scope of the variable. Defaults to all environment (`*`). Note that in Community Editions of Gitlab, values other than `*` will cause inconsistent plans.\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "The name or id of the group.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "The name of the variable.\n"
                    }
                },
                "type": "object",
                "required": [
                    "group",
                    "key"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGroupVariable.\n",
                "properties": {
                    "environmentScope": {
                        "type": "string",
                        "description": "The environment scope of the variable. Defaults to all environment (`*`). Note that in Community Editions of Gitlab, values other than `*` will cause inconsistent plans.\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "The name or id of the group.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "The name of the variable.\n"
                    },
                    "masked": {
                        "type": "boolean",
                        "description": "If set to `true`, the value of the variable will be hidden in job logs. The value must meet the [masking requirements](https://docs.gitlab.com/ee/ci/variables/#masked-variables). Defaults to `false`.\n"
                    },
                    "protected": {
                        "type": "boolean",
                        "description": "If set to `true`, the variable will be passed only to pipelines running on protected branches and tags. Defaults to `false`.\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "The value of the variable.\n"
                    },
                    "variableType": {
                        "type": "string",
                        "description": "The type of a variable. Valid values are: `env_var`, `file`. Default is `env_var`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "environmentScope",
                    "group",
                    "key",
                    "masked",
                    "protected",
                    "value",
                    "variableType",
                    "id"
                ]
            }
        },
        "gitlab:index/getGroupVariables:getGroupVariables": {
            "description": "The `gitlab.getGroupVariables` data source allows to retrieve all group-level CI/CD variables.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/group_level_variables.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst vars = gitlab.getGroupVariables({\n    group: \"my/example/group\",\n});\nconst stagingVars = gitlab.getGroupVariables({\n    environmentScope: \"staging/*\",\n    group: \"my/example/group\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nvars = gitlab.get_group_variables(group=\"my/example/group\")\nstaging_vars = gitlab.get_group_variables(environment_scope=\"staging/*\",\n    group=\"my/example/group\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var vars = GitLab.GetGroupVariables.Invoke(new()\n    {\n        Group = \"my/example/group\",\n    });\n\n    var stagingVars = GitLab.GetGroupVariables.Invoke(new()\n    {\n        EnvironmentScope = \"staging/*\",\n        Group = \"my/example/group\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.GetGroupVariables(ctx, \u0026gitlab.GetGroupVariablesArgs{\n\t\t\tGroup: \"my/example/group\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.GetGroupVariables(ctx, \u0026gitlab.GetGroupVariablesArgs{\n\t\t\tEnvironmentScope: pulumi.StringRef(\"staging/*\"),\n\t\t\tGroup:            \"my/example/group\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetGroupVariablesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var vars = GitlabFunctions.getGroupVariables(GetGroupVariablesArgs.builder()\n            .group(\"my/example/group\")\n            .build());\n\n        final var stagingVars = GitlabFunctions.getGroupVariables(GetGroupVariablesArgs.builder()\n            .environmentScope(\"staging/*\")\n            .group(\"my/example/group\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  vars:\n    fn::invoke:\n      Function: gitlab:getGroupVariables\n      Arguments:\n        group: my/example/group\n  stagingVars:\n    fn::invoke:\n      Function: gitlab:getGroupVariables\n      Arguments:\n        environmentScope: staging/*\n        group: my/example/group\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getGroupVariables.\n",
                "properties": {
                    "environmentScope": {
                        "type": "string",
                        "description": "The environment scope of the variable. Defaults to all environment (`*`).\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "The name or id of the group.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "group"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGroupVariables.\n",
                "properties": {
                    "environmentScope": {
                        "type": "string",
                        "description": "The environment scope of the variable. Defaults to all environment (`*`).\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "The name or id of the group.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "variables": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getGroupVariablesVariable:getGroupVariablesVariable"
                        },
                        "description": "The list of variables returned by the search\n"
                    }
                },
                "type": "object",
                "required": [
                    "group",
                    "variables",
                    "id"
                ]
            }
        },
        "gitlab:index/getGroups:getGroups": {
            "description": "The `gitlab.getGroups` data source allows details of multiple groups to be retrieved given some optional filter criteria.\n\n\u003e Some attributes might not be returned depending on if you're an admin or not.\n\n\u003e Some available options require administrator privileges.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/groups.html#list-groups)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getGroups({\n    orderBy: \"name\",\n    sort: \"desc\",\n});\nconst example-two = gitlab.getGroups({\n    search: \"GitLab\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_groups(order_by=\"name\",\n    sort=\"desc\")\nexample_two = gitlab.get_groups(search=\"GitLab\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetGroups.Invoke(new()\n    {\n        OrderBy = \"name\",\n        Sort = \"desc\",\n    });\n\n    var example_two = GitLab.GetGroups.Invoke(new()\n    {\n        Search = \"GitLab\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.GetGroups(ctx, \u0026gitlab.GetGroupsArgs{\n\t\t\tOrderBy: pulumi.StringRef(\"name\"),\n\t\t\tSort:    pulumi.StringRef(\"desc\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.GetGroups(ctx, \u0026gitlab.GetGroupsArgs{\n\t\t\tSearch: pulumi.StringRef(\"GitLab\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetGroupsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getGroups(GetGroupsArgs.builder()\n            .orderBy(\"name\")\n            .sort(\"desc\")\n            .build());\n\n        final var example-two = GitlabFunctions.getGroups(GetGroupsArgs.builder()\n            .search(\"GitLab\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getGroups\n      Arguments:\n        orderBy: name\n        sort: desc\n  example-two:\n    fn::invoke:\n      Function: gitlab:getGroups\n      Arguments:\n        search: GitLab\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getGroups.\n",
                "properties": {
                    "orderBy": {
                        "type": "string",
                        "description": "Order the groups' list by `id`, `name`, `path`, or `similarity`. (Requires administrator privileges)\n"
                    },
                    "search": {
                        "type": "string",
                        "description": "Search groups by name or path.\n"
                    },
                    "sort": {
                        "type": "string",
                        "description": "Sort groups' list in asc or desc order. (Requires administrator privileges)\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getGroups.\n",
                "properties": {
                    "groups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getGroupsGroup:getGroupsGroup"
                        },
                        "description": "The list of groups.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "orderBy": {
                        "type": "string",
                        "description": "Order the groups' list by `id`, `name`, `path`, or `similarity`. (Requires administrator privileges)\n"
                    },
                    "search": {
                        "type": "string",
                        "description": "Search groups by name or path.\n"
                    },
                    "sort": {
                        "type": "string",
                        "description": "Sort groups' list in asc or desc order. (Requires administrator privileges)\n"
                    }
                },
                "type": "object",
                "required": [
                    "groups",
                    "id"
                ]
            }
        },
        "gitlab:index/getInstanceDeployKeys:getInstanceDeployKeys": {
            "description": "The `gitlab.getInstanceDeployKeys` data source allows to retrieve a list of deploy keys for a GitLab instance.\n\n\u003e This data source requires administration privileges.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/deploy_keys.html#list-all-deploy-keys)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getInstanceDeployKeys({\n    \"public\": true,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_instance_deploy_keys(public=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetInstanceDeployKeys.Invoke(new()\n    {\n        Public = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.GetInstanceDeployKeys(ctx, \u0026gitlab.GetInstanceDeployKeysArgs{\n\t\t\tPublic: pulumi.BoolRef(true),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetInstanceDeployKeysArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getInstanceDeployKeys(GetInstanceDeployKeysArgs.builder()\n            .public_(true)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getInstanceDeployKeys\n      Arguments:\n        public: true\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getInstanceDeployKeys.\n",
                "properties": {
                    "public": {
                        "type": "boolean",
                        "description": "Only return deploy keys that are public.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getInstanceDeployKeys.\n",
                "properties": {
                    "deployKeys": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getInstanceDeployKeysDeployKey:getInstanceDeployKeysDeployKey"
                        },
                        "description": "The list of all deploy keys across all projects of the GitLab instance.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "public": {
                        "type": "boolean",
                        "description": "Only return deploy keys that are public.\n"
                    }
                },
                "type": "object",
                "required": [
                    "deployKeys",
                    "id"
                ]
            }
        },
        "gitlab:index/getInstanceVariable:getInstanceVariable": {
            "description": "The `gitlab.InstanceVariable` data source allows to retrieve details about an instance-level CI/CD variable.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/instance_level_ci_variables.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = gitlab.getInstanceVariable({\n    key: \"foo\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.get_instance_variable(key=\"foo\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = GitLab.GetInstanceVariable.Invoke(new()\n    {\n        Key = \"foo\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.LookupInstanceVariable(ctx, \u0026gitlab.LookupInstanceVariableArgs{\n\t\t\tKey: \"foo\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetInstanceVariableArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var foo = GitlabFunctions.getInstanceVariable(GetInstanceVariableArgs.builder()\n            .key(\"foo\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  foo:\n    fn::invoke:\n      Function: gitlab:getInstanceVariable\n      Arguments:\n        key: foo\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getInstanceVariable.\n",
                "properties": {
                    "key": {
                        "type": "string",
                        "description": "The name of the variable.\n"
                    }
                },
                "type": "object",
                "required": [
                    "key"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getInstanceVariable.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "The name of the variable.\n"
                    },
                    "masked": {
                        "type": "boolean",
                        "description": "If set to `true`, the value of the variable will be hidden in job logs. The value must meet the [masking requirements](https://docs.gitlab.com/ee/ci/variables/#masked-variables). Defaults to `false`.\n"
                    },
                    "protected": {
                        "type": "boolean",
                        "description": "If set to `true`, the variable will be passed only to pipelines running on protected branches and tags. Defaults to `false`.\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "The value of the variable.\n"
                    },
                    "variableType": {
                        "type": "string",
                        "description": "The type of a variable. Valid values are: `env_var`, `file`. Default is `env_var`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "key",
                    "masked",
                    "protected",
                    "value",
                    "variableType",
                    "id"
                ]
            }
        },
        "gitlab:index/getInstanceVariables:getInstanceVariables": {
            "description": "The `gitlab.getInstanceVariables` data source allows to retrieve all instance-level CI/CD variables.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/instance_level_ci_variables.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst vars = gitlab.getInstanceVariables({});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nvars = gitlab.get_instance_variables()\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var vars = GitLab.GetInstanceVariables.Invoke();\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.GetInstanceVariables(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var vars = GitlabFunctions.getInstanceVariables();\n\n    }\n}\n```\n```yaml\nvariables:\n  vars:\n    fn::invoke:\n      Function: gitlab:getInstanceVariables\n      Arguments: {}\n```\n{{% /example %}}\n{{% /examples %}}",
            "outputs": {
                "description": "A collection of values returned by getInstanceVariables.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "variables": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getInstanceVariablesVariable:getInstanceVariablesVariable"
                        },
                        "description": "The list of variables returned by the search\n"
                    }
                },
                "type": "object",
                "required": [
                    "variables",
                    "id"
                ]
            }
        },
        "gitlab:index/getMetadata:getMetadata": {
            "description": "The `gitlab.getMetadata` data source retrieves the metadata of the GitLab instance.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/metadata.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst this = gitlab.getMetadata({});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nthis = gitlab.get_metadata()\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @this = GitLab.GetMetadata.Invoke();\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.GetMetadata(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var this = GitlabFunctions.getMetadata();\n\n    }\n}\n```\n```yaml\nvariables:\n  this:\n    fn::invoke:\n      Function: gitlab:getMetadata\n      Arguments: {}\n```\n{{% /example %}}\n{{% /examples %}}",
            "outputs": {
                "description": "A collection of values returned by getMetadata.\n",
                "properties": {
                    "enterprise": {
                        "type": "boolean",
                        "description": "If the GitLab instance is an enterprise instance or not. Supported for GitLab 15.6 onwards.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The id of the data source. It will always be `1`\n"
                    },
                    "kas": {
                        "$ref": "#/types/gitlab:index/getMetadataKas:getMetadataKas",
                        "description": "Metadata about the GitLab agent server for Kubernetes (KAS).\n"
                    },
                    "revision": {
                        "type": "string",
                        "description": "Revision of the GitLab instance.\n"
                    },
                    "version": {
                        "type": "string",
                        "description": "Version of the GitLab instance.\n"
                    }
                },
                "type": "object",
                "required": [
                    "enterprise",
                    "id",
                    "kas",
                    "revision",
                    "version"
                ]
            }
        },
        "gitlab:index/getProject:getProject": {
            "description": "The `gitlab.Project` data source allows details of a project to be retrieved by either its ID or its path with namespace.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/projects.html#get-single-project)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getProject({\n    pathWithNamespace: \"foo/bar/baz\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_project(path_with_namespace=\"foo/bar/baz\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetProject.Invoke(new()\n    {\n        PathWithNamespace = \"foo/bar/baz\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.LookupProject(ctx, \u0026gitlab.LookupProjectArgs{\n\t\t\tPathWithNamespace: pulumi.StringRef(\"foo/bar/baz\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetProjectArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getProject(GetProjectArgs.builder()\n            .pathWithNamespace(\"foo/bar/baz\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getProject\n      Arguments:\n        pathWithNamespace: foo/bar/baz\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getProject.\n",
                "properties": {
                    "ciDefaultGitDepth": {
                        "type": "integer",
                        "description": "Default number of revisions for shallow cloning.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The integer that uniquely identifies the project within the gitlab install.\n"
                    },
                    "pathWithNamespace": {
                        "type": "string",
                        "description": "The path of the repository with namespace.\n"
                    },
                    "publicBuilds": {
                        "type": "boolean",
                        "description": "If true, jobs can be viewed by non-project members.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getProject.\n",
                "properties": {
                    "analyticsAccessLevel": {
                        "type": "string",
                        "description": "Set the analytics access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "archived": {
                        "type": "boolean",
                        "description": "Whether the project is in read-only mode (archived).\n"
                    },
                    "autoCancelPendingPipelines": {
                        "type": "string",
                        "description": "Auto-cancel pending pipelines. This isn’t a boolean, but enabled/disabled.\n"
                    },
                    "autoDevopsDeployStrategy": {
                        "type": "string",
                        "description": "Auto Deploy strategy. Valid values are `continuous`, `manual`, `timed_incremental`.\n"
                    },
                    "autoDevopsEnabled": {
                        "type": "boolean",
                        "description": "Enable Auto DevOps for this project.\n"
                    },
                    "autocloseReferencedIssues": {
                        "type": "boolean",
                        "description": "Set whether auto-closing referenced issues on default branch.\n"
                    },
                    "buildGitStrategy": {
                        "type": "string",
                        "description": "The Git strategy. Defaults to fetch.\n"
                    },
                    "buildTimeout": {
                        "type": "integer",
                        "description": "The maximum amount of time, in seconds, that a job can run.\n"
                    },
                    "buildsAccessLevel": {
                        "type": "string",
                        "description": "Set the builds access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "ciConfigPath": {
                        "type": "string",
                        "description": "CI config file path for the project.\n"
                    },
                    "ciDefaultGitDepth": {
                        "type": "integer",
                        "description": "Default number of revisions for shallow cloning.\n"
                    },
                    "ciSeparatedCaches": {
                        "type": "boolean",
                        "description": "Use separate caches for protected branches.\n"
                    },
                    "containerExpirationPolicies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectContainerExpirationPolicy:getProjectContainerExpirationPolicy"
                        },
                        "description": "Set the image cleanup policy for this project. **Note**: this field is sometimes named `container_expiration_policy_attributes` in the GitLab Upstream API.\n"
                    },
                    "containerRegistryAccessLevel": {
                        "type": "string",
                        "description": "Set visibility of container registry, for this project. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "defaultBranch": {
                        "type": "string",
                        "description": "The default branch for the project.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description of the project.\n"
                    },
                    "emailsDisabled": {
                        "type": "boolean",
                        "description": "Disable email notifications.\n"
                    },
                    "environmentsAccessLevel": {
                        "type": "string",
                        "description": "Set the environments access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "externalAuthorizationClassificationLabel": {
                        "type": "string",
                        "description": "The classification label for the project.\n"
                    },
                    "featureFlagsAccessLevel": {
                        "type": "string",
                        "description": "Set the feature flags access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "forkingAccessLevel": {
                        "type": "string",
                        "description": "Set the forking access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "httpUrlToRepo": {
                        "type": "string",
                        "description": "URL that can be provided to `git clone` to clone the\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The integer that uniquely identifies the project within the gitlab install.\n"
                    },
                    "importUrl": {
                        "type": "string",
                        "description": "URL the project was imported from.\n"
                    },
                    "infrastructureAccessLevel": {
                        "type": "string",
                        "description": "Set the infrastructure access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "issuesAccessLevel": {
                        "type": "string",
                        "description": "Set the issues access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "issuesEnabled": {
                        "type": "boolean",
                        "description": "Enable issue tracking for the project.\n"
                    },
                    "keepLatestArtifact": {
                        "type": "boolean",
                        "description": "Disable or enable the ability to keep the latest artifact for this project.\n"
                    },
                    "lfsEnabled": {
                        "type": "boolean",
                        "description": "Enable LFS for the project.\n"
                    },
                    "mergeCommitTemplate": {
                        "type": "string",
                        "description": "Template used to create merge commit message in merge requests. (Introduced in GitLab 14.5.)\n"
                    },
                    "mergePipelinesEnabled": {
                        "type": "boolean",
                        "description": "Enable or disable merge pipelines.\n"
                    },
                    "mergeRequestsAccessLevel": {
                        "type": "string",
                        "description": "Set the merge requests access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "mergeRequestsEnabled": {
                        "type": "boolean",
                        "description": "Enable merge requests for the project.\n"
                    },
                    "mergeTrainsEnabled": {
                        "type": "boolean",
                        "description": "Enable or disable merge trains.\n"
                    },
                    "monitorAccessLevel": {
                        "type": "string",
                        "description": "Set the monitor access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the project.\n"
                    },
                    "namespaceId": {
                        "type": "integer",
                        "description": "The namespace (group or user) of the project. Defaults to your user.\n"
                    },
                    "operationsAccessLevel": {
                        "type": "string",
                        "description": "Set the operations access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path of the repository.\n"
                    },
                    "pathWithNamespace": {
                        "type": "string",
                        "description": "The path of the repository with namespace.\n"
                    },
                    "pipelinesEnabled": {
                        "type": "boolean",
                        "description": "Enable pipelines for the project.\n"
                    },
                    "printingMergeRequestLinkEnabled": {
                        "type": "boolean",
                        "description": "Show link to create/view merge request when pushing from the command line\n"
                    },
                    "publicBuilds": {
                        "type": "boolean",
                        "description": "If true, jobs can be viewed by non-project members.\n"
                    },
                    "pushRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectPushRule:getProjectPushRule"
                        },
                        "description": "Push rules for the project. Push rules are only available on Enterprise plans and if the authenticated has permissions to read them.\n"
                    },
                    "releasesAccessLevel": {
                        "type": "string",
                        "description": "Set the releases access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "removeSourceBranchAfterMerge": {
                        "type": "boolean",
                        "description": "Enable `Delete source branch` option by default for all new merge requests\n"
                    },
                    "repositoryAccessLevel": {
                        "type": "string",
                        "description": "Set the repository access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "repositoryStorage": {
                        "type": "string",
                        "description": "Which storage shard the repository is on. (administrator only)\n"
                    },
                    "requestAccessEnabled": {
                        "type": "boolean",
                        "description": "Allow users to request member access.\n"
                    },
                    "requirementsAccessLevel": {
                        "type": "string",
                        "description": "Set the requirements access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "resolveOutdatedDiffDiscussions": {
                        "type": "boolean",
                        "description": "Automatically resolve merge request diffs discussions on lines changed with a push.\n"
                    },
                    "restrictUserDefinedVariables": {
                        "type": "boolean",
                        "description": "Allow only users with the Maintainer role to pass user-defined variables when triggering a pipeline.\n"
                    },
                    "runnersToken": {
                        "type": "string",
                        "description": "Registration token to use during runner setup.\n",
                        "secret": true
                    },
                    "securityAndComplianceAccessLevel": {
                        "type": "string",
                        "description": "Set the security and compliance access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "snippetsAccessLevel": {
                        "type": "string",
                        "description": "Set the snippets access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "snippetsEnabled": {
                        "type": "boolean",
                        "description": "Enable snippets for the project.\n"
                    },
                    "squashCommitTemplate": {
                        "type": "string",
                        "description": "Template used to create squash commit message in merge requests. (Introduced in GitLab 14.6.)\n"
                    },
                    "sshUrlToRepo": {
                        "type": "string",
                        "description": "URL that can be provided to `git clone` to clone the\n"
                    },
                    "suggestionCommitMessage": {
                        "type": "string",
                        "description": "The commit message used to apply merge request suggestions.\n"
                    },
                    "topics": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of topics for the project.\n"
                    },
                    "visibilityLevel": {
                        "type": "string",
                        "description": "Repositories are created as private by default.\n"
                    },
                    "webUrl": {
                        "type": "string",
                        "description": "URL that can be used to find the project in a browser.\n"
                    },
                    "wikiAccessLevel": {
                        "type": "string",
                        "description": "Set the wiki access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "wikiEnabled": {
                        "type": "boolean",
                        "description": "Enable wiki for the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "analyticsAccessLevel",
                    "archived",
                    "autoCancelPendingPipelines",
                    "autoDevopsDeployStrategy",
                    "autoDevopsEnabled",
                    "autocloseReferencedIssues",
                    "buildGitStrategy",
                    "buildTimeout",
                    "buildsAccessLevel",
                    "ciConfigPath",
                    "ciDefaultGitDepth",
                    "ciSeparatedCaches",
                    "containerExpirationPolicies",
                    "containerRegistryAccessLevel",
                    "defaultBranch",
                    "description",
                    "emailsDisabled",
                    "environmentsAccessLevel",
                    "externalAuthorizationClassificationLabel",
                    "featureFlagsAccessLevel",
                    "forkingAccessLevel",
                    "httpUrlToRepo",
                    "id",
                    "importUrl",
                    "infrastructureAccessLevel",
                    "issuesAccessLevel",
                    "issuesEnabled",
                    "keepLatestArtifact",
                    "lfsEnabled",
                    "mergeCommitTemplate",
                    "mergePipelinesEnabled",
                    "mergeRequestsAccessLevel",
                    "mergeRequestsEnabled",
                    "mergeTrainsEnabled",
                    "monitorAccessLevel",
                    "name",
                    "namespaceId",
                    "operationsAccessLevel",
                    "path",
                    "pathWithNamespace",
                    "pipelinesEnabled",
                    "printingMergeRequestLinkEnabled",
                    "pushRules",
                    "releasesAccessLevel",
                    "removeSourceBranchAfterMerge",
                    "repositoryAccessLevel",
                    "repositoryStorage",
                    "requestAccessEnabled",
                    "requirementsAccessLevel",
                    "resolveOutdatedDiffDiscussions",
                    "restrictUserDefinedVariables",
                    "runnersToken",
                    "securityAndComplianceAccessLevel",
                    "snippetsAccessLevel",
                    "snippetsEnabled",
                    "squashCommitTemplate",
                    "sshUrlToRepo",
                    "suggestionCommitMessage",
                    "topics",
                    "visibilityLevel",
                    "webUrl",
                    "wikiAccessLevel",
                    "wikiEnabled"
                ]
            }
        },
        "gitlab:index/getProjectBranches:getProjectBranches": {
            "description": "The `gitlab.getProjectBranches` data source allows details of the branches of a given project to be retrieved.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/branches.html#list-repository-branches)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getProjectBranches({\n    project: \"foo/bar/baz\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_project_branches(project=\"foo/bar/baz\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetProjectBranches.Invoke(new()\n    {\n        Project = \"foo/bar/baz\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.GetProjectBranches(ctx, \u0026gitlab.GetProjectBranchesArgs{\n\t\t\tProject: \"foo/bar/baz\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetProjectBranchesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getProjectBranches(GetProjectBranchesArgs.builder()\n            .project(\"foo/bar/baz\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getProjectBranches\n      Arguments:\n        project: foo/bar/baz\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectBranches.\n",
                "properties": {
                    "project": {
                        "type": "string",
                        "description": "ID or URL-encoded path of the project owned by the authenticated user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectBranches.\n",
                "properties": {
                    "branches": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectBranchesBranch:getProjectBranchesBranch"
                        },
                        "description": "The list of branches of the project, as defined below.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "ID or URL-encoded path of the project owned by the authenticated user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "branches",
                    "project",
                    "id"
                ]
            }
        },
        "gitlab:index/getProjectHook:getProjectHook": {
            "description": "The `gitlab.ProjectHook` data source allows to retrieve details about a hook in a project.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/projects.html#get-project-hook)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst exampleProject = gitlab.getProject({\n    id: \"foo/bar/baz\",\n});\nconst exampleProjectHook = exampleProject.then(exampleProject =\u003e gitlab.getProjectHook({\n    project: exampleProject.id,\n    hookId: 1,\n}));\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample_project = gitlab.get_project(id=\"foo/bar/baz\")\nexample_project_hook = gitlab.get_project_hook(project=example_project.id,\n    hook_id=1)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleProject = GitLab.GetProject.Invoke(new()\n    {\n        Id = \"foo/bar/baz\",\n    });\n\n    var exampleProjectHook = GitLab.GetProjectHook.Invoke(new()\n    {\n        Project = exampleProject.Apply(getProjectResult =\u003e getProjectResult.Id),\n        HookId = 1,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleProject, err := gitlab.LookupProject(ctx, \u0026gitlab.LookupProjectArgs{\n\t\t\tId: pulumi.StringRef(\"foo/bar/baz\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.LookupProjectHook(ctx, \u0026gitlab.LookupProjectHookArgs{\n\t\t\tProject: exampleProject.Id,\n\t\t\tHookId:  1,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetProjectArgs;\nimport com.pulumi.gitlab.inputs.GetProjectHookArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var exampleProject = GitlabFunctions.getProject(GetProjectArgs.builder()\n            .id(\"foo/bar/baz\")\n            .build());\n\n        final var exampleProjectHook = GitlabFunctions.getProjectHook(GetProjectHookArgs.builder()\n            .project(exampleProject.applyValue(getProjectResult -\u003e getProjectResult.id()))\n            .hookId(1)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  exampleProject:\n    fn::invoke:\n      Function: gitlab:getProject\n      Arguments:\n        id: foo/bar/baz\n  exampleProjectHook:\n    fn::invoke:\n      Function: gitlab:getProjectHook\n      Arguments:\n        project: ${exampleProject.id}\n        hookId: 1\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectHook.\n",
                "properties": {
                    "hookId": {
                        "type": "integer",
                        "description": "The id of the project hook.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project to add the hook to.\n"
                    }
                },
                "type": "object",
                "required": [
                    "hookId",
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectHook.\n",
                "properties": {
                    "confidentialIssuesEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for confidential issues events.\n"
                    },
                    "confidentialNoteEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for confidential notes events.\n"
                    },
                    "deploymentEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for deployment events.\n"
                    },
                    "enableSslVerification": {
                        "type": "boolean",
                        "description": "Enable ssl verification when invoking the hook.\n"
                    },
                    "hookId": {
                        "type": "integer",
                        "description": "The id of the project hook.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "issuesEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for issues events.\n"
                    },
                    "jobEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for job events.\n"
                    },
                    "mergeRequestsEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for merge requests.\n"
                    },
                    "noteEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for notes events.\n"
                    },
                    "pipelineEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for pipeline events.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project to add the hook to.\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "The id of the project for the hook.\n"
                    },
                    "pushEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for push events.\n"
                    },
                    "pushEventsBranchFilter": {
                        "type": "string",
                        "description": "Invoke the hook for push events on matching branches only.\n"
                    },
                    "releasesEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for releases events.\n"
                    },
                    "tagPushEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for tag push events.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "A token to present when invoking the hook. The token is not available for imported resources.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "The url of the hook to invoke.\n"
                    },
                    "wikiPageEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for wiki page events.\n"
                    }
                },
                "type": "object",
                "required": [
                    "confidentialIssuesEvents",
                    "confidentialNoteEvents",
                    "deploymentEvents",
                    "enableSslVerification",
                    "hookId",
                    "issuesEvents",
                    "jobEvents",
                    "mergeRequestsEvents",
                    "noteEvents",
                    "pipelineEvents",
                    "project",
                    "projectId",
                    "pushEvents",
                    "pushEventsBranchFilter",
                    "releasesEvents",
                    "tagPushEvents",
                    "token",
                    "url",
                    "wikiPageEvents",
                    "id"
                ]
            }
        },
        "gitlab:index/getProjectHooks:getProjectHooks": {
            "description": "The `gitlab.getProjectHooks` data source allows to retrieve details about hooks in a project.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/projects.html#list-project-hooks)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getProject({\n    id: \"foo/bar/baz\",\n});\nconst examples = example.then(example =\u003e gitlab.getProjectHooks({\n    project: example.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_project(id=\"foo/bar/baz\")\nexamples = gitlab.get_project_hooks(project=example.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetProject.Invoke(new()\n    {\n        Id = \"foo/bar/baz\",\n    });\n\n    var examples = GitLab.GetProjectHooks.Invoke(new()\n    {\n        Project = example.Apply(getProjectResult =\u003e getProjectResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := gitlab.LookupProject(ctx, \u0026gitlab.LookupProjectArgs{\n\t\t\tId: pulumi.StringRef(\"foo/bar/baz\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.GetProjectHooks(ctx, \u0026gitlab.GetProjectHooksArgs{\n\t\t\tProject: example.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetProjectArgs;\nimport com.pulumi.gitlab.inputs.GetProjectHooksArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getProject(GetProjectArgs.builder()\n            .id(\"foo/bar/baz\")\n            .build());\n\n        final var examples = GitlabFunctions.getProjectHooks(GetProjectHooksArgs.builder()\n            .project(example.applyValue(getProjectResult -\u003e getProjectResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getProject\n      Arguments:\n        id: foo/bar/baz\n  examples:\n    fn::invoke:\n      Function: gitlab:getProjectHooks\n      Arguments:\n        project: ${example.id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectHooks.\n",
                "properties": {
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectHooks.\n",
                "properties": {
                    "hooks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectHooksHook:getProjectHooksHook"
                        },
                        "description": "The list of hooks.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "hooks",
                    "project",
                    "id"
                ]
            }
        },
        "gitlab:index/getProjectIssue:getProjectIssue": {
            "description": "The `gitlab.ProjectIssue` data source allows to retrieve details about an issue in a project.\n\n**Upstream API**: [GitLab API docs](https://docs.gitlab.com/ee/api/issues.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = gitlab.getProject({\n    id: \"foo/bar/baz\",\n});\nconst welcomeIssue = foo.then(foo =\u003e gitlab.getProjectIssue({\n    project: foo.id,\n    iid: 1,\n}));\nexport const welcomeIssueWebUrl = data.gitlab_project_issue.web_url;\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.get_project(id=\"foo/bar/baz\")\nwelcome_issue = gitlab.get_project_issue(project=foo.id,\n    iid=1)\npulumi.export(\"welcomeIssueWebUrl\", data[\"gitlab_project_issue\"][\"web_url\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = GitLab.GetProject.Invoke(new()\n    {\n        Id = \"foo/bar/baz\",\n    });\n\n    var welcomeIssue = GitLab.GetProjectIssue.Invoke(new()\n    {\n        Project = foo.Apply(getProjectResult =\u003e getProjectResult.Id),\n        Iid = 1,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"welcomeIssueWebUrl\"] = data.Gitlab_project_issue.Web_url,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfoo, err := gitlab.LookupProject(ctx, \u0026gitlab.LookupProjectArgs{\n\t\t\tId: pulumi.StringRef(\"foo/bar/baz\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.LookupProjectIssue(ctx, \u0026gitlab.LookupProjectIssueArgs{\n\t\t\tProject: foo.Id,\n\t\t\tIid:     1,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"welcomeIssueWebUrl\", data.Gitlab_project_issue.Web_url)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetProjectArgs;\nimport com.pulumi.gitlab.inputs.GetProjectIssueArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var foo = GitlabFunctions.getProject(GetProjectArgs.builder()\n            .id(\"foo/bar/baz\")\n            .build());\n\n        final var welcomeIssue = GitlabFunctions.getProjectIssue(GetProjectIssueArgs.builder()\n            .project(foo.applyValue(getProjectResult -\u003e getProjectResult.id()))\n            .iid(1)\n            .build());\n\n        ctx.export(\"welcomeIssueWebUrl\", data.gitlab_project_issue().web_url());\n    }\n}\n```\n```yaml\nvariables:\n  foo:\n    fn::invoke:\n      Function: gitlab:getProject\n      Arguments:\n        id: foo/bar/baz\n  welcomeIssue:\n    fn::invoke:\n      Function: gitlab:getProjectIssue\n      Arguments:\n        project: ${foo.id}\n        iid: 1\noutputs:\n  welcomeIssueWebUrl: ${data.gitlab_project_issue.web_url}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectIssue.\n",
                "properties": {
                    "iid": {
                        "type": "integer",
                        "description": "The internal ID of the project's issue.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or ID of the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "iid",
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectIssue.\n",
                "properties": {
                    "assigneeIds": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "The IDs of the users to assign the issue to.\n"
                    },
                    "authorId": {
                        "type": "integer",
                        "description": "The ID of the author of the issue. Use `gitlab.User` data source to get more information about the user.\n"
                    },
                    "closedAt": {
                        "type": "string",
                        "description": "When the issue was closed. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n"
                    },
                    "closedByUserId": {
                        "type": "integer",
                        "description": "The ID of the user that closed the issue. Use `gitlab.User` data source to get more information about the user.\n"
                    },
                    "confidential": {
                        "type": "boolean",
                        "description": "Set an issue to be confidential.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "When the issue was created. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z. Requires administrator or project/group owner rights.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of an issue. Limited to 1,048,576 characters.\n"
                    },
                    "discussionLocked": {
                        "type": "boolean",
                        "description": "Whether the issue is locked for discussions or not.\n"
                    },
                    "discussionToResolve": {
                        "type": "string",
                        "description": "The ID of a discussion to resolve. This fills out the issue with a default description and mark the discussion as resolved. Use in combination with merge*request*to*resolve*discussions_of.\n"
                    },
                    "downvotes": {
                        "type": "integer",
                        "description": "The number of downvotes the issue has received.\n"
                    },
                    "dueDate": {
                        "type": "string",
                        "description": "The due date. Date time string in the format YYYY-MM-DD, for example 2016-03-11.\n"
                    },
                    "epicId": {
                        "type": "integer",
                        "description": "ID of the epic to add the issue to. Valid values are greater than or equal to 0.\n"
                    },
                    "epicIssueId": {
                        "type": "integer",
                        "description": "The ID of the epic issue.\n"
                    },
                    "externalId": {
                        "type": "string",
                        "description": "The external ID of the issue.\n"
                    },
                    "humanTimeEstimate": {
                        "type": "string",
                        "description": "The human-readable time estimate of the issue.\n"
                    },
                    "humanTotalTimeSpent": {
                        "type": "string",
                        "description": "The human-readable total time spent of the issue.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "iid": {
                        "type": "integer",
                        "description": "The internal ID of the project's issue.\n"
                    },
                    "issueId": {
                        "type": "integer",
                        "description": "The instance-wide ID of the issue.\n"
                    },
                    "issueLinkId": {
                        "type": "integer",
                        "description": "The ID of the issue link.\n"
                    },
                    "issueType": {
                        "type": "string",
                        "description": "The type of issue. Valid values are: `issue`, `incident`, `test_case`.\n"
                    },
                    "labels": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The labels of an issue.\n"
                    },
                    "links": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "The links of the issue.\n"
                    },
                    "mergeRequestToResolveDiscussionsOf": {
                        "type": "integer",
                        "description": "The IID of a merge request in which to resolve all issues. This fills out the issue with a default description and mark all discussions as resolved. When passing a description or title, these values take precedence over the default values.\n"
                    },
                    "mergeRequestsCount": {
                        "type": "integer",
                        "description": "The number of merge requests associated with the issue.\n"
                    },
                    "milestoneId": {
                        "type": "integer",
                        "description": "The global ID of a milestone to assign issue. To find the milestone_id associated with a milestone, view an issue with the milestone assigned and use the API to retrieve the issue's details.\n"
                    },
                    "movedToId": {
                        "type": "integer",
                        "description": "The ID of the issue that was moved to.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or ID of the project.\n"
                    },
                    "references": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "The references of the issue.\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "The state of the issue. Valid values are: `opened`, `closed`.\n"
                    },
                    "subscribed": {
                        "type": "boolean",
                        "description": "Whether the authenticated user is subscribed to the issue or not.\n"
                    },
                    "taskCompletionStatuses": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectIssueTaskCompletionStatus:getProjectIssueTaskCompletionStatus"
                        },
                        "description": "The task completion status. It's always a one element list.\n"
                    },
                    "timeEstimate": {
                        "type": "integer",
                        "description": "The time estimate of the issue.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "The title of the issue.\n"
                    },
                    "totalTimeSpent": {
                        "type": "integer",
                        "description": "The total time spent of the issue.\n"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "When the issue was updated. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n"
                    },
                    "upvotes": {
                        "type": "integer",
                        "description": "The number of upvotes the issue has received.\n"
                    },
                    "userNotesCount": {
                        "type": "integer",
                        "description": "The number of user notes on the issue.\n"
                    },
                    "webUrl": {
                        "type": "string",
                        "description": "The web URL of the issue.\n"
                    },
                    "weight": {
                        "type": "integer",
                        "description": "The weight of the issue. Valid values are greater than or equal to 0.\n"
                    }
                },
                "type": "object",
                "required": [
                    "assigneeIds",
                    "authorId",
                    "closedAt",
                    "closedByUserId",
                    "confidential",
                    "createdAt",
                    "description",
                    "discussionLocked",
                    "discussionToResolve",
                    "downvotes",
                    "dueDate",
                    "epicId",
                    "epicIssueId",
                    "externalId",
                    "humanTimeEstimate",
                    "humanTotalTimeSpent",
                    "iid",
                    "issueId",
                    "issueLinkId",
                    "issueType",
                    "labels",
                    "links",
                    "mergeRequestToResolveDiscussionsOf",
                    "mergeRequestsCount",
                    "milestoneId",
                    "movedToId",
                    "project",
                    "references",
                    "state",
                    "subscribed",
                    "taskCompletionStatuses",
                    "timeEstimate",
                    "title",
                    "totalTimeSpent",
                    "updatedAt",
                    "upvotes",
                    "userNotesCount",
                    "webUrl",
                    "weight",
                    "id"
                ]
            }
        },
        "gitlab:index/getProjectIssues:getProjectIssues": {
            "description": "The `gitlab.getProjectIssues` data source allows to retrieve details about issues in a project.\n\n**Upstream API**: [GitLab API docs](https://docs.gitlab.com/ee/api/issues.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = gitlab.getProject({\n    id: \"foo/bar/baz\",\n});\nconst allWithFoo = foo.then(foo =\u003e gitlab.getProjectIssues({\n    project: foo.id,\n    search: \"foo\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.get_project(id=\"foo/bar/baz\")\nall_with_foo = gitlab.get_project_issues(project=foo.id,\n    search=\"foo\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = GitLab.GetProject.Invoke(new()\n    {\n        Id = \"foo/bar/baz\",\n    });\n\n    var allWithFoo = GitLab.GetProjectIssues.Invoke(new()\n    {\n        Project = foo.Apply(getProjectResult =\u003e getProjectResult.Id),\n        Search = \"foo\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfoo, err := gitlab.LookupProject(ctx, \u0026gitlab.LookupProjectArgs{\n\t\t\tId: pulumi.StringRef(\"foo/bar/baz\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.GetProjectIssues(ctx, \u0026gitlab.GetProjectIssuesArgs{\n\t\t\tProject: foo.Id,\n\t\t\tSearch:  pulumi.StringRef(\"foo\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetProjectArgs;\nimport com.pulumi.gitlab.inputs.GetProjectIssuesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var foo = GitlabFunctions.getProject(GetProjectArgs.builder()\n            .id(\"foo/bar/baz\")\n            .build());\n\n        final var allWithFoo = GitlabFunctions.getProjectIssues(GetProjectIssuesArgs.builder()\n            .project(foo.applyValue(getProjectResult -\u003e getProjectResult.id()))\n            .search(\"foo\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  foo:\n    fn::invoke:\n      Function: gitlab:getProject\n      Arguments:\n        id: foo/bar/baz\n  allWithFoo:\n    fn::invoke:\n      Function: gitlab:getProjectIssues\n      Arguments:\n        project: ${foo.id}\n        search: foo\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectIssues.\n",
                "properties": {
                    "assigneeId": {
                        "type": "integer",
                        "description": "Return issues assigned to the given user id. Mutually exclusive with assignee_username. None returns unassigned issues. Any returns issues with an assignee.\n"
                    },
                    "assigneeUsername": {
                        "type": "string",
                        "description": "Return issues assigned to the given username. Similar to assignee*id and mutually exclusive with assignee*id. In GitLab CE, the assignee_username array should only contain a single value. Otherwise, an invalid parameter error is returned.\n"
                    },
                    "authorId": {
                        "type": "integer",
                        "description": "Return issues created by the given user id. Combine with scope=all or scope=assigned*to*me.\n"
                    },
                    "confidential": {
                        "type": "boolean",
                        "description": "Filter confidential or public issues.\n"
                    },
                    "createdAfter": {
                        "type": "string",
                        "description": "Return issues created on or after the given time. Expected in ISO 8601 format (2019-03-15T08:00:00Z)\n"
                    },
                    "createdBefore": {
                        "type": "string",
                        "description": "Return issues created on or before the given time. Expected in ISO 8601 format (2019-03-15T08:00:00Z)\n"
                    },
                    "dueDate": {
                        "type": "string",
                        "description": "Return issues that have no due date, are overdue, or whose due date is this week, this month, or between two weeks ago and next month. Accepts: 0 (no due date), any, today, tomorrow, overdue, week, month, next*month*and*previous*two_weeks.\n"
                    },
                    "iids": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "Return only the issues having the given iid\n"
                    },
                    "issueType": {
                        "type": "string",
                        "description": "Filter to a given type of issue. Valid values are [issue incident test_case]. (Introduced in GitLab 13.12)\n"
                    },
                    "labels": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Return issues with labels. Issues must have all labels to be returned. None lists all issues with no labels. Any lists all issues with at least one label. No+Label (Deprecated) lists all issues with no labels. Predefined names are case-insensitive.\n"
                    },
                    "milestone": {
                        "type": "string",
                        "description": "The milestone title. None lists all issues with no milestone. Any lists all issues that have an assigned milestone.\n"
                    },
                    "myReactionEmoji": {
                        "type": "string",
                        "description": "Return issues reacted by the authenticated user by the given emoji. None returns issues not given a reaction. Any returns issues given at least one reaction.\n"
                    },
                    "notAssigneeIds": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "Return issues that do not match the assignee id.\n"
                    },
                    "notAuthorIds": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "Return issues that do not match the author id.\n"
                    },
                    "notLabels": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Return issues that do not match the labels.\n"
                    },
                    "notMilestone": {
                        "type": "string",
                        "description": "Return issues that do not match the milestone.\n"
                    },
                    "notMyReactionEmojis": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Return issues not reacted by the authenticated user by the given emoji.\n"
                    },
                    "orderBy": {
                        "type": "string",
                        "description": "Return issues ordered by. Valid values are `created_at`, `updated_at`, `priority`, `due_date`, `relative_position`, `label_priority`, `milestone_due`, `popularity`, `weight`. Default is created_at\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project.\n"
                    },
                    "scope": {
                        "type": "string",
                        "description": "Return issues for the given scope. Valid values are `created_by_me`, `assigned_to_me`, `all`. Defaults to all.\n"
                    },
                    "search": {
                        "type": "string",
                        "description": "Search project issues against their title and description\n"
                    },
                    "sort": {
                        "type": "string",
                        "description": "Return issues sorted in asc or desc order. Default is desc\n"
                    },
                    "updatedAfter": {
                        "type": "string",
                        "description": "Return issues updated on or after the given time. Expected in ISO 8601 format (2019-03-15T08:00:00Z)\n"
                    },
                    "updatedBefore": {
                        "type": "string",
                        "description": "Return issues updated on or before the given time. Expected in ISO 8601 format (2019-03-15T08:00:00Z)\n"
                    },
                    "weight": {
                        "type": "integer",
                        "description": "Return issues with the specified weight. None returns issues with no weight assigned. Any returns issues with a weight assigned.\n"
                    },
                    "withLabelsDetails": {
                        "type": "boolean",
                        "description": "If true, the response returns more details for each label in labels field: :name, :color, :description, :description*html, :text*color. Default is false. description_html was introduced in GitLab 12.7\n"
                    }
                },
                "type": "object",
                "required": [
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectIssues.\n",
                "properties": {
                    "assigneeId": {
                        "type": "integer",
                        "description": "Return issues assigned to the given user id. Mutually exclusive with assignee_username. None returns unassigned issues. Any returns issues with an assignee.\n"
                    },
                    "assigneeUsername": {
                        "type": "string",
                        "description": "Return issues assigned to the given username. Similar to assignee*id and mutually exclusive with assignee*id. In GitLab CE, the assignee_username array should only contain a single value. Otherwise, an invalid parameter error is returned.\n"
                    },
                    "authorId": {
                        "type": "integer",
                        "description": "Return issues created by the given user id. Combine with scope=all or scope=assigned*to*me.\n"
                    },
                    "confidential": {
                        "type": "boolean",
                        "description": "Filter confidential or public issues.\n"
                    },
                    "createdAfter": {
                        "type": "string",
                        "description": "Return issues created on or after the given time. Expected in ISO 8601 format (2019-03-15T08:00:00Z)\n"
                    },
                    "createdBefore": {
                        "type": "string",
                        "description": "Return issues created on or before the given time. Expected in ISO 8601 format (2019-03-15T08:00:00Z)\n"
                    },
                    "dueDate": {
                        "type": "string",
                        "description": "Return issues that have no due date, are overdue, or whose due date is this week, this month, or between two weeks ago and next month. Accepts: 0 (no due date), any, today, tomorrow, overdue, week, month, next*month*and*previous*two_weeks.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "iids": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "Return only the issues having the given iid\n"
                    },
                    "issueType": {
                        "type": "string",
                        "description": "Filter to a given type of issue. Valid values are [issue incident test_case]. (Introduced in GitLab 13.12)\n"
                    },
                    "issues": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectIssuesIssue:getProjectIssuesIssue"
                        },
                        "description": "The list of issues returned by the search.\n"
                    },
                    "labels": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Return issues with labels. Issues must have all labels to be returned. None lists all issues with no labels. Any lists all issues with at least one label. No+Label (Deprecated) lists all issues with no labels. Predefined names are case-insensitive.\n"
                    },
                    "milestone": {
                        "type": "string",
                        "description": "The milestone title. None lists all issues with no milestone. Any lists all issues that have an assigned milestone.\n"
                    },
                    "myReactionEmoji": {
                        "type": "string",
                        "description": "Return issues reacted by the authenticated user by the given emoji. None returns issues not given a reaction. Any returns issues given at least one reaction.\n"
                    },
                    "notAssigneeIds": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "Return issues that do not match the assignee id.\n"
                    },
                    "notAuthorIds": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "Return issues that do not match the author id.\n"
                    },
                    "notLabels": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Return issues that do not match the labels.\n"
                    },
                    "notMilestone": {
                        "type": "string",
                        "description": "Return issues that do not match the milestone.\n"
                    },
                    "notMyReactionEmojis": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Return issues not reacted by the authenticated user by the given emoji.\n"
                    },
                    "orderBy": {
                        "type": "string",
                        "description": "Return issues ordered by. Valid values are `created_at`, `updated_at`, `priority`, `due_date`, `relative_position`, `label_priority`, `milestone_due`, `popularity`, `weight`. Default is created_at\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project.\n"
                    },
                    "scope": {
                        "type": "string",
                        "description": "Return issues for the given scope. Valid values are `created_by_me`, `assigned_to_me`, `all`. Defaults to all.\n"
                    },
                    "search": {
                        "type": "string",
                        "description": "Search project issues against their title and description\n"
                    },
                    "sort": {
                        "type": "string",
                        "description": "Return issues sorted in asc or desc order. Default is desc\n"
                    },
                    "updatedAfter": {
                        "type": "string",
                        "description": "Return issues updated on or after the given time. Expected in ISO 8601 format (2019-03-15T08:00:00Z)\n"
                    },
                    "updatedBefore": {
                        "type": "string",
                        "description": "Return issues updated on or before the given time. Expected in ISO 8601 format (2019-03-15T08:00:00Z)\n"
                    },
                    "weight": {
                        "type": "integer",
                        "description": "Return issues with the specified weight. None returns issues with no weight assigned. Any returns issues with a weight assigned.\n"
                    },
                    "withLabelsDetails": {
                        "type": "boolean",
                        "description": "If true, the response returns more details for each label in labels field: :name, :color, :description, :description*html, :text*color. Default is false. description_html was introduced in GitLab 12.7\n"
                    }
                },
                "type": "object",
                "required": [
                    "issues",
                    "project",
                    "id"
                ]
            }
        },
        "gitlab:index/getProjectMembership:getProjectMembership": {
            "description": "The `gitlab.ProjectMembership` data source allows to list and filter all members of a project specified by either its id or full path.\n\n\u003e **Note** exactly one of project_id or full_path must be provided.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/members.html#list-all-members-of-a-group-or-project)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getProjectMembership({\n    inherited: true,\n    projectId: 123,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_project_membership(inherited=True,\n    project_id=123)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetProjectMembership.Invoke(new()\n    {\n        Inherited = true,\n        ProjectId = 123,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.LookupProjectMembership(ctx, \u0026gitlab.LookupProjectMembershipArgs{\n\t\t\tInherited: pulumi.BoolRef(true),\n\t\t\tProjectId: pulumi.IntRef(123),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetProjectMembershipArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getProjectMembership(GetProjectMembershipArgs.builder()\n            .inherited(true)\n            .projectId(123)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getProjectMembership\n      Arguments:\n        inherited: true\n        projectId: 123\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectMembership.\n",
                "properties": {
                    "fullPath": {
                        "type": "string",
                        "description": "The full path of the project.\n"
                    },
                    "inherited": {
                        "type": "boolean",
                        "description": "Return all project members including members through ancestor groups\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "The ID of the project.\n"
                    },
                    "query": {
                        "type": "string",
                        "description": "A query string to search for members\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getProjectMembership.\n",
                "properties": {
                    "fullPath": {
                        "type": "string",
                        "description": "The full path of the project.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "inherited": {
                        "type": "boolean",
                        "description": "Return all project members including members through ancestor groups\n"
                    },
                    "members": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectMembershipMember:getProjectMembershipMember"
                        },
                        "description": "The list of project members.\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "The ID of the project.\n"
                    },
                    "query": {
                        "type": "string",
                        "description": "A query string to search for members\n"
                    }
                },
                "type": "object",
                "required": [
                    "fullPath",
                    "members",
                    "projectId",
                    "id"
                ]
            }
        },
        "gitlab:index/getProjectMilestone:getProjectMilestone": {
            "description": "The `gitlab.ProjectMilestone` data source allows get details of a project milestone.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/milestones.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getProjectMilestone({\n    milestoneId: 10,\n    project: \"foo/bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_project_milestone(milestone_id=10,\n    project=\"foo/bar\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetProjectMilestone.Invoke(new()\n    {\n        MilestoneId = 10,\n        Project = \"foo/bar\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.LookupProjectMilestone(ctx, \u0026gitlab.LookupProjectMilestoneArgs{\n\t\t\tMilestoneId: 10,\n\t\t\tProject:     \"foo/bar\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetProjectMilestoneArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getProjectMilestone(GetProjectMilestoneArgs.builder()\n            .milestoneId(10)\n            .project(\"foo/bar\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getProjectMilestone\n      Arguments:\n        milestoneId: 10\n        project: foo/bar\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectMilestone.\n",
                "properties": {
                    "milestoneId": {
                        "type": "integer",
                        "description": "The instance-wide ID of the project’s milestone.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "milestoneId",
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectMilestone.\n",
                "properties": {
                    "createdAt": {
                        "type": "string",
                        "description": "The time of creation of the milestone. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the milestone.\n"
                    },
                    "dueDate": {
                        "type": "string",
                        "description": "The due date of the milestone. Date time string in the format YYYY-MM-DD, for example 2016-03-11.\n"
                    },
                    "expired": {
                        "type": "boolean",
                        "description": "Bool, true if milestone expired.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "iid": {
                        "type": "integer",
                        "description": "The ID of the project's milestone.\n"
                    },
                    "milestoneId": {
                        "type": "integer",
                        "description": "The instance-wide ID of the project’s milestone.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "The project ID of milestone.\n"
                    },
                    "startDate": {
                        "type": "string",
                        "description": "The start date of the milestone. Date time string in the format YYYY-MM-DD, for example 2016-03-11.\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "The state of the milestone. Valid values are: `active`, `closed`.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "The title of a milestone.\n"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "The last update time of the milestone. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n"
                    },
                    "webUrl": {
                        "type": "string",
                        "description": "The web URL of the milestone.\n"
                    }
                },
                "type": "object",
                "required": [
                    "createdAt",
                    "description",
                    "dueDate",
                    "expired",
                    "iid",
                    "milestoneId",
                    "project",
                    "projectId",
                    "startDate",
                    "state",
                    "title",
                    "updatedAt",
                    "webUrl",
                    "id"
                ]
            }
        },
        "gitlab:index/getProjectMilestones:getProjectMilestones": {
            "description": "The `gitlab.getProjectMilestones` data source allows get details of a project milestones.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/milestones.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getProjectMilestones({\n    project: \"foo/bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_project_milestones(project=\"foo/bar\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetProjectMilestones.Invoke(new()\n    {\n        Project = \"foo/bar\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.GetProjectMilestones(ctx, \u0026gitlab.GetProjectMilestonesArgs{\n\t\t\tProject: \"foo/bar\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetProjectMilestonesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getProjectMilestones(GetProjectMilestonesArgs.builder()\n            .project(\"foo/bar\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getProjectMilestones\n      Arguments:\n        project: foo/bar\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectMilestones.\n",
                "properties": {
                    "iids": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "Return only the milestones having the given `iid` (Note: ignored if `include_parent_milestones` is set as `true`).\n"
                    },
                    "includeParentMilestones": {
                        "type": "boolean",
                        "description": "Include group milestones from parent group and its ancestors. Introduced in GitLab 13.4.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n",
                        "willReplaceOnChanges": true
                    },
                    "search": {
                        "type": "string",
                        "description": "Return only milestones with a title or description matching the provided string.\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "Return only `active` or `closed` milestones.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "Return only the milestones having the given `title`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectMilestones.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "iids": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "Return only the milestones having the given `iid` (Note: ignored if `include_parent_milestones` is set as `true`).\n"
                    },
                    "includeParentMilestones": {
                        "type": "boolean",
                        "description": "Include group milestones from parent group and its ancestors. Introduced in GitLab 13.4.\n"
                    },
                    "milestones": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectMilestonesMilestone:getProjectMilestonesMilestone"
                        },
                        "description": "List of milestones from a project.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n"
                    },
                    "search": {
                        "type": "string",
                        "description": "Return only milestones with a title or description matching the provided string.\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "Return only `active` or `closed` milestones.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "Return only the milestones having the given `title`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "milestones",
                    "project",
                    "id"
                ]
            }
        },
        "gitlab:index/getProjectProtectedBranch:getProjectProtectedBranch": {
            "description": "The `gitlab_protected_branch` data source allows details of a protected branch to be retrieved by its name and the project it belongs to.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/protected_branches.html#get-a-single-protected-branch-or-wildcard-protected-branch)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getProjectProtectedBranch({\n    name: \"main\",\n    projectId: \"foo/bar/baz\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_project_protected_branch(name=\"main\",\n    project_id=\"foo/bar/baz\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetProjectProtectedBranch.Invoke(new()\n    {\n        Name = \"main\",\n        ProjectId = \"foo/bar/baz\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.GetProjectProtectedBranch(ctx, \u0026gitlab.GetProjectProtectedBranchArgs{\n\t\t\tName:      \"main\",\n\t\t\tProjectId: \"foo/bar/baz\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetProjectProtectedBranchArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getProjectProtectedBranch(GetProjectProtectedBranchArgs.builder()\n            .name(\"main\")\n            .projectId(\"foo/bar/baz\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getProjectProtectedBranch\n      Arguments:\n        name: main\n        projectId: foo/bar/baz\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectProtectedBranch.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the protected branch.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The integer or path with namespace that uniquely identifies the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectProtectedBranch.\n",
                "properties": {
                    "allowForcePush": {
                        "type": "boolean",
                        "description": "Whether force push is allowed.\n"
                    },
                    "codeOwnerApprovalRequired": {
                        "type": "boolean",
                        "description": "Reject code pushes that change files listed in the CODEOWNERS file.\n"
                    },
                    "id": {
                        "type": "integer",
                        "description": "The ID of this resource.\n"
                    },
                    "mergeAccessLevels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectProtectedBranchMergeAccessLevel:getProjectProtectedBranchMergeAccessLevel"
                        },
                        "description": "Describes which access levels, users, or groups are allowed to perform the action.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the protected branch.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The integer or path with namespace that uniquely identifies the project.\n"
                    },
                    "pushAccessLevels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectProtectedBranchPushAccessLevel:getProjectProtectedBranchPushAccessLevel"
                        },
                        "description": "Describes which access levels, users, or groups are allowed to perform the action.\n"
                    }
                },
                "type": "object",
                "required": [
                    "allowForcePush",
                    "codeOwnerApprovalRequired",
                    "id",
                    "mergeAccessLevels",
                    "name",
                    "projectId",
                    "pushAccessLevels"
                ]
            }
        },
        "gitlab:index/getProjectProtectedBranches:getProjectProtectedBranches": {
            "description": "The `gitlab.getProjectProtectedBranches` data source allows details of the protected branches of a given project.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/protected_branches.html#list-protected-branches)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getProjectProtectedBranches({\n    projectId: \"foo/bar/baz\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_project_protected_branches(project_id=\"foo/bar/baz\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetProjectProtectedBranches.Invoke(new()\n    {\n        ProjectId = \"foo/bar/baz\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.GetProjectProtectedBranches(ctx, \u0026gitlab.GetProjectProtectedBranchesArgs{\n\t\t\tProjectId: \"foo/bar/baz\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetProjectProtectedBranchesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getProjectProtectedBranches(GetProjectProtectedBranchesArgs.builder()\n            .projectId(\"foo/bar/baz\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getProjectProtectedBranches\n      Arguments:\n        projectId: foo/bar/baz\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectProtectedBranches.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "The integer or path with namespace that uniquely identifies the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectProtectedBranches.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The integer or path with namespace that uniquely identifies the project.\n"
                    },
                    "protectedBranches": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectProtectedBranchesProtectedBranch:getProjectProtectedBranchesProtectedBranch"
                        },
                        "description": "A list of protected branches, as defined below.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId",
                    "protectedBranches",
                    "id"
                ]
            }
        },
        "gitlab:index/getProjectTag:getProjectTag": {
            "description": "The `gitlab.ProjectTag` data source allows details of a project tag to be retrieved by its name.\n\n**Upstream API**: [GitLab API docs](https://docs.gitlab.com/ee/api/tags.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = gitlab.getProjectTag({\n    name: \"example\",\n    project: \"foo/bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.get_project_tag(name=\"example\",\n    project=\"foo/bar\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = GitLab.GetProjectTag.Invoke(new()\n    {\n        Name = \"example\",\n        Project = \"foo/bar\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.LookupProjectTag(ctx, \u0026gitlab.LookupProjectTagArgs{\n\t\t\tName:    \"example\",\n\t\t\tProject: \"foo/bar\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetProjectTagArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var foo = GitlabFunctions.getProjectTag(GetProjectTagArgs.builder()\n            .name(\"example\")\n            .project(\"foo/bar\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  foo:\n    fn::invoke:\n      Function: gitlab:getProjectTag\n      Arguments:\n        name: example\n        project: foo/bar\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectTag.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of a tag.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectTag.\n",
                "properties": {
                    "commits": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectTagCommit:getProjectTagCommit"
                        },
                        "description": "The commit associated with the tag.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "message": {
                        "type": "string",
                        "description": "The message of the annotated tag.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of a tag.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n"
                    },
                    "protected": {
                        "type": "boolean",
                        "description": "Bool, true if tag has tag protection.\n"
                    },
                    "releases": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectTagRelease:getProjectTagRelease"
                        },
                        "description": "The release associated with the tag.\n"
                    },
                    "target": {
                        "type": "string",
                        "description": "The unique id assigned to the commit by Gitlab.\n"
                    }
                },
                "type": "object",
                "required": [
                    "commits",
                    "message",
                    "name",
                    "project",
                    "protected",
                    "releases",
                    "target",
                    "id"
                ]
            }
        },
        "gitlab:index/getProjectTags:getProjectTags": {
            "description": "The `gitlab.getProjectTags` data source allows details of project tags to be retrieved by some search criteria.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/tags.html#list-project-repository-tags)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getProjectTags({\n    project: \"foo/bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_project_tags(project=\"foo/bar\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetProjectTags.Invoke(new()\n    {\n        Project = \"foo/bar\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.GetProjectTags(ctx, \u0026gitlab.GetProjectTagsArgs{\n\t\t\tProject: \"foo/bar\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetProjectTagsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getProjectTags(GetProjectTagsArgs.builder()\n            .project(\"foo/bar\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getProjectTags\n      Arguments:\n        project: foo/bar\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectTags.\n",
                "properties": {
                    "orderBy": {
                        "type": "string",
                        "description": "Return tags ordered by `name` or `updated` fields. Default is `updated`.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n"
                    },
                    "search": {
                        "type": "string",
                        "description": "Return list of tags matching the search criteria. You can use `^term` and `term$` to find tags that begin and end with `term` respectively. No other regular expressions are supported.\n"
                    },
                    "sort": {
                        "type": "string",
                        "description": "Return tags sorted in `asc` or `desc` order. Default is `desc`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectTags.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "orderBy": {
                        "type": "string",
                        "description": "Return tags ordered by `name` or `updated` fields. Default is `updated`.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n"
                    },
                    "search": {
                        "type": "string",
                        "description": "Return list of tags matching the search criteria. You can use `^term` and `term$` to find tags that begin and end with `term` respectively. No other regular expressions are supported.\n"
                    },
                    "sort": {
                        "type": "string",
                        "description": "Return tags sorted in `asc` or `desc` order. Default is `desc`.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectTagsTag:getProjectTagsTag"
                        },
                        "description": "List of repository tags from a project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "project",
                    "tags",
                    "id"
                ]
            }
        },
        "gitlab:index/getProjectVariable:getProjectVariable": {
            "description": "The `gitlab.ProjectVariable` data source allows to retrieve details about a project-level CI/CD variable.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/project_level_variables.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = gitlab.getProjectVariable({\n    key: \"foo\",\n    project: \"my/example/project\",\n});\nconst bar = gitlab.getProjectVariable({\n    environmentScope: \"staging/*\",\n    key: \"bar\",\n    project: \"my/example/project\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.get_project_variable(key=\"foo\",\n    project=\"my/example/project\")\nbar = gitlab.get_project_variable(environment_scope=\"staging/*\",\n    key=\"bar\",\n    project=\"my/example/project\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = GitLab.GetProjectVariable.Invoke(new()\n    {\n        Key = \"foo\",\n        Project = \"my/example/project\",\n    });\n\n    var bar = GitLab.GetProjectVariable.Invoke(new()\n    {\n        EnvironmentScope = \"staging/*\",\n        Key = \"bar\",\n        Project = \"my/example/project\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.LookupProjectVariable(ctx, \u0026gitlab.LookupProjectVariableArgs{\n\t\t\tKey:     \"foo\",\n\t\t\tProject: \"my/example/project\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.LookupProjectVariable(ctx, \u0026gitlab.LookupProjectVariableArgs{\n\t\t\tEnvironmentScope: pulumi.StringRef(\"staging/*\"),\n\t\t\tKey:              \"bar\",\n\t\t\tProject:          \"my/example/project\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetProjectVariableArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var foo = GitlabFunctions.getProjectVariable(GetProjectVariableArgs.builder()\n            .key(\"foo\")\n            .project(\"my/example/project\")\n            .build());\n\n        final var bar = GitlabFunctions.getProjectVariable(GetProjectVariableArgs.builder()\n            .environmentScope(\"staging/*\")\n            .key(\"bar\")\n            .project(\"my/example/project\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  foo:\n    fn::invoke:\n      Function: gitlab:getProjectVariable\n      Arguments:\n        key: foo\n        project: my/example/project\n  bar:\n    fn::invoke:\n      Function: gitlab:getProjectVariable\n      Arguments:\n        environmentScope: staging/*\n        key: bar\n        project: my/example/project\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectVariable.\n",
                "properties": {
                    "environmentScope": {
                        "type": "string",
                        "description": "The environment scope of the variable. Defaults to all environment (`*`). Note that in Community Editions of Gitlab, values other than `*` will cause inconsistent plans.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "The name of the variable.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "key",
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectVariable.\n",
                "properties": {
                    "environmentScope": {
                        "type": "string",
                        "description": "The environment scope of the variable. Defaults to all environment (`*`). Note that in Community Editions of Gitlab, values other than `*` will cause inconsistent plans.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "The name of the variable.\n"
                    },
                    "masked": {
                        "type": "boolean",
                        "description": "If set to `true`, the value of the variable will be hidden in job logs. The value must meet the [masking requirements](https://docs.gitlab.com/ee/ci/variables/#masked-variables). Defaults to `false`.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project.\n"
                    },
                    "protected": {
                        "type": "boolean",
                        "description": "If set to `true`, the variable will be passed only to pipelines running on protected branches and tags. Defaults to `false`.\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "The value of the variable.\n"
                    },
                    "variableType": {
                        "type": "string",
                        "description": "The type of a variable. Valid values are: `env_var`, `file`. Default is `env_var`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "environmentScope",
                    "key",
                    "masked",
                    "project",
                    "protected",
                    "value",
                    "variableType",
                    "id"
                ]
            }
        },
        "gitlab:index/getProjectVariables:getProjectVariables": {
            "description": "The `gitlab.getProjectVariables` data source allows to retrieve all project-level CI/CD variables.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/project_level_variables.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst vars = gitlab.getProjectVariables({\n    project: \"my/example/project\",\n});\nconst stagingVars = gitlab.getProjectVariables({\n    environmentScope: \"staging/*\",\n    project: \"my/example/project\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nvars = gitlab.get_project_variables(project=\"my/example/project\")\nstaging_vars = gitlab.get_project_variables(environment_scope=\"staging/*\",\n    project=\"my/example/project\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var vars = GitLab.GetProjectVariables.Invoke(new()\n    {\n        Project = \"my/example/project\",\n    });\n\n    var stagingVars = GitLab.GetProjectVariables.Invoke(new()\n    {\n        EnvironmentScope = \"staging/*\",\n        Project = \"my/example/project\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.GetProjectVariables(ctx, \u0026gitlab.GetProjectVariablesArgs{\n\t\t\tProject: \"my/example/project\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.GetProjectVariables(ctx, \u0026gitlab.GetProjectVariablesArgs{\n\t\t\tEnvironmentScope: pulumi.StringRef(\"staging/*\"),\n\t\t\tProject:          \"my/example/project\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetProjectVariablesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var vars = GitlabFunctions.getProjectVariables(GetProjectVariablesArgs.builder()\n            .project(\"my/example/project\")\n            .build());\n\n        final var stagingVars = GitlabFunctions.getProjectVariables(GetProjectVariablesArgs.builder()\n            .environmentScope(\"staging/*\")\n            .project(\"my/example/project\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  vars:\n    fn::invoke:\n      Function: gitlab:getProjectVariables\n      Arguments:\n        project: my/example/project\n  stagingVars:\n    fn::invoke:\n      Function: gitlab:getProjectVariables\n      Arguments:\n        environmentScope: staging/*\n        project: my/example/project\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectVariables.\n",
                "properties": {
                    "environmentScope": {
                        "type": "string",
                        "description": "The environment scope of the variable. Defaults to all environment (`*`).\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectVariables.\n",
                "properties": {
                    "environmentScope": {
                        "type": "string",
                        "description": "The environment scope of the variable. Defaults to all environment (`*`).\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project.\n"
                    },
                    "variables": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectVariablesVariable:getProjectVariablesVariable"
                        },
                        "description": "The list of variables returned by the search\n"
                    }
                },
                "type": "object",
                "required": [
                    "project",
                    "variables",
                    "id"
                ]
            }
        },
        "gitlab:index/getProjects:getProjects": {
            "description": "The `gitlab.getProjects` data source allows details of multiple projects to be retrieved. Optionally filtered by the set attributes.\n\n\u003e This data source supports all available filters exposed by the xanzy/go-gitlab package, which might not expose all available filters exposed by the Gitlab APIs.\n\n\u003e The owner sub-attributes are only populated if the Gitlab token used has an administrator scope.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/projects.html#list-all-projects)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst mygroup = gitlab.getGroup({\n    fullPath: \"mygroup\",\n});\nconst groupProjects = mygroup.then(mygroup =\u003e gitlab.getProjects({\n    groupId: mygroup.id,\n    orderBy: \"name\",\n    includeSubgroups: true,\n    withShared: false,\n}));\nconst projects = gitlab.getProjects({\n    search: \"postgresql\",\n    visibility: \"private\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nmygroup = gitlab.get_group(full_path=\"mygroup\")\ngroup_projects = gitlab.get_projects(group_id=mygroup.id,\n    order_by=\"name\",\n    include_subgroups=True,\n    with_shared=False)\nprojects = gitlab.get_projects(search=\"postgresql\",\n    visibility=\"private\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var mygroup = GitLab.GetGroup.Invoke(new()\n    {\n        FullPath = \"mygroup\",\n    });\n\n    var groupProjects = GitLab.GetProjects.Invoke(new()\n    {\n        GroupId = mygroup.Apply(getGroupResult =\u003e getGroupResult.Id),\n        OrderBy = \"name\",\n        IncludeSubgroups = true,\n        WithShared = false,\n    });\n\n    var projects = GitLab.GetProjects.Invoke(new()\n    {\n        Search = \"postgresql\",\n        Visibility = \"private\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmygroup, err := gitlab.LookupGroup(ctx, \u0026gitlab.LookupGroupArgs{\n\t\t\tFullPath: pulumi.StringRef(\"mygroup\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.GetProjects(ctx, \u0026gitlab.GetProjectsArgs{\n\t\t\tGroupId:          pulumi.IntRef(mygroup.Id),\n\t\t\tOrderBy:          pulumi.StringRef(\"name\"),\n\t\t\tIncludeSubgroups: pulumi.BoolRef(true),\n\t\t\tWithShared:       pulumi.BoolRef(false),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.GetProjects(ctx, \u0026gitlab.GetProjectsArgs{\n\t\t\tSearch:     pulumi.StringRef(\"postgresql\"),\n\t\t\tVisibility: pulumi.StringRef(\"private\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetGroupArgs;\nimport com.pulumi.gitlab.inputs.GetProjectsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var mygroup = GitlabFunctions.getGroup(GetGroupArgs.builder()\n            .fullPath(\"mygroup\")\n            .build());\n\n        final var groupProjects = GitlabFunctions.getProjects(GetProjectsArgs.builder()\n            .groupId(mygroup.applyValue(getGroupResult -\u003e getGroupResult.id()))\n            .orderBy(\"name\")\n            .includeSubgroups(true)\n            .withShared(false)\n            .build());\n\n        final var projects = GitlabFunctions.getProjects(GetProjectsArgs.builder()\n            .search(\"postgresql\")\n            .visibility(\"private\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  mygroup:\n    fn::invoke:\n      Function: gitlab:getGroup\n      Arguments:\n        fullPath: mygroup\n  groupProjects:\n    fn::invoke:\n      Function: gitlab:getProjects\n      Arguments:\n        groupId: ${mygroup.id}\n        orderBy: name\n        includeSubgroups: true\n        withShared: false\n  projects:\n    fn::invoke:\n      Function: gitlab:getProjects\n      Arguments:\n        search: postgresql\n        visibility: private\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getProjects.\n",
                "properties": {
                    "archived": {
                        "type": "boolean",
                        "description": "Limit by archived status.\n"
                    },
                    "groupId": {
                        "type": "integer",
                        "description": "The ID of the group owned by the authenticated user to look projects for within. Cannot be used with `min_access_level`, `with_programming_language` or `statistics`.\n"
                    },
                    "includeSubgroups": {
                        "type": "boolean",
                        "description": "Include projects in subgroups of this group. Default is `false`. Needs `group_id`.\n"
                    },
                    "maxQueryablePages": {
                        "type": "integer",
                        "description": "The maximum number of project results pages that may be queried. Prevents overloading your Gitlab instance in case of a misconfiguration.\n"
                    },
                    "membership": {
                        "type": "boolean",
                        "description": "Limit by projects that the current user is a member of.\n"
                    },
                    "minAccessLevel": {
                        "type": "integer",
                        "description": "Limit to projects where current user has at least this access level, refer to the [official documentation](https://docs.gitlab.com/ee/api/members.html) for values. Cannot be used with `group_id`.\n"
                    },
                    "orderBy": {
                        "type": "string",
                        "description": "Return projects ordered ordered by: `id`, `name`, `path`, `created_at`, `updated_at`, `last_activity_at`, `similarity`, `repository_size`, `storage_size`, `packages_size`, `wiki_size`. Some values or only available in certain circumstances. See [upstream docs](https://docs.gitlab.com/ee/api/projects.html#list-all-projects) for details.\n"
                    },
                    "owned": {
                        "type": "boolean",
                        "description": "Limit by projects owned by the current user.\n"
                    },
                    "page": {
                        "type": "integer",
                        "description": "The first page to begin the query on.\n"
                    },
                    "perPage": {
                        "type": "integer",
                        "description": "The number of results to return per page.\n"
                    },
                    "search": {
                        "type": "string",
                        "description": "Return list of authorized projects matching the search criteria.\n"
                    },
                    "simple": {
                        "type": "boolean",
                        "description": "Return only the ID, URL, name, and path of each project.\n"
                    },
                    "sort": {
                        "type": "string",
                        "description": "Return projects sorted in `asc` or `desc` order. Default is `desc`.\n"
                    },
                    "starred": {
                        "type": "boolean",
                        "description": "Limit by projects starred by the current user.\n"
                    },
                    "statistics": {
                        "type": "boolean",
                        "description": "Include project statistics. Cannot be used with `group_id`.\n"
                    },
                    "visibility": {
                        "type": "string",
                        "description": "Limit by visibility `public`, `internal`, or `private`.\n"
                    },
                    "withCustomAttributes": {
                        "type": "boolean",
                        "description": "Include custom attributes in response *(admins only)*.\n"
                    },
                    "withIssuesEnabled": {
                        "type": "boolean",
                        "description": "Limit by projects with issues feature enabled. Default is `false`.\n"
                    },
                    "withMergeRequestsEnabled": {
                        "type": "boolean",
                        "description": "Limit by projects with merge requests feature enabled. Default is `false`.\n"
                    },
                    "withProgrammingLanguage": {
                        "type": "string",
                        "description": "Limit by projects which use the given programming language. Cannot be used with `group_id`.\n"
                    },
                    "withShared": {
                        "type": "boolean",
                        "description": "Include projects shared to this group. Default is `true`. Needs `group_id`.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getProjects.\n",
                "properties": {
                    "archived": {
                        "type": "boolean",
                        "description": "Limit by archived status.\n"
                    },
                    "groupId": {
                        "type": "integer",
                        "description": "The ID of the group owned by the authenticated user to look projects for within. Cannot be used with `min_access_level`, `with_programming_language` or `statistics`.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "includeSubgroups": {
                        "type": "boolean",
                        "description": "Include projects in subgroups of this group. Default is `false`. Needs `group_id`.\n"
                    },
                    "maxQueryablePages": {
                        "type": "integer",
                        "description": "The maximum number of project results pages that may be queried. Prevents overloading your Gitlab instance in case of a misconfiguration.\n"
                    },
                    "membership": {
                        "type": "boolean",
                        "description": "Limit by projects that the current user is a member of.\n"
                    },
                    "minAccessLevel": {
                        "type": "integer",
                        "description": "Limit to projects where current user has at least this access level, refer to the [official documentation](https://docs.gitlab.com/ee/api/members.html) for values. Cannot be used with `group_id`.\n"
                    },
                    "orderBy": {
                        "type": "string",
                        "description": "Return projects ordered ordered by: `id`, `name`, `path`, `created_at`, `updated_at`, `last_activity_at`, `similarity`, `repository_size`, `storage_size`, `packages_size`, `wiki_size`. Some values or only available in certain circumstances. See [upstream docs](https://docs.gitlab.com/ee/api/projects.html#list-all-projects) for details.\n"
                    },
                    "owned": {
                        "type": "boolean",
                        "description": "Limit by projects owned by the current user.\n"
                    },
                    "page": {
                        "type": "integer",
                        "description": "The first page to begin the query on.\n"
                    },
                    "perPage": {
                        "type": "integer",
                        "description": "The number of results to return per page.\n"
                    },
                    "projects": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectsProject:getProjectsProject"
                        },
                        "description": "A list containing the projects matching the supplied arguments\n"
                    },
                    "search": {
                        "type": "string",
                        "description": "Return list of authorized projects matching the search criteria.\n"
                    },
                    "simple": {
                        "type": "boolean",
                        "description": "Return only the ID, URL, name, and path of each project.\n"
                    },
                    "sort": {
                        "type": "string",
                        "description": "Return projects sorted in `asc` or `desc` order. Default is `desc`.\n"
                    },
                    "starred": {
                        "type": "boolean",
                        "description": "Limit by projects starred by the current user.\n"
                    },
                    "statistics": {
                        "type": "boolean",
                        "description": "Include project statistics. Cannot be used with `group_id`.\n"
                    },
                    "visibility": {
                        "type": "string",
                        "description": "Limit by visibility `public`, `internal`, or `private`.\n"
                    },
                    "withCustomAttributes": {
                        "type": "boolean",
                        "description": "Include custom attributes in response *(admins only)*.\n"
                    },
                    "withIssuesEnabled": {
                        "type": "boolean",
                        "description": "Limit by projects with issues feature enabled. Default is `false`.\n"
                    },
                    "withMergeRequestsEnabled": {
                        "type": "boolean",
                        "description": "Limit by projects with merge requests feature enabled. Default is `false`.\n"
                    },
                    "withProgrammingLanguage": {
                        "type": "string",
                        "description": "Limit by projects which use the given programming language. Cannot be used with `group_id`.\n"
                    },
                    "withShared": {
                        "type": "boolean",
                        "description": "Include projects shared to this group. Default is `true`. Needs `group_id`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projects",
                    "id"
                ]
            }
        },
        "gitlab:index/getReleaseLink:getReleaseLink": {
            "description": "The `gitlab.ReleaseLink` data source allows get details of a release link.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/releases/links.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getReleaseLink({\n    linkId: 11,\n    project: \"foo/bar\",\n    tagName: \"v1.0.1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_release_link(link_id=11,\n    project=\"foo/bar\",\n    tag_name=\"v1.0.1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetReleaseLink.Invoke(new()\n    {\n        LinkId = 11,\n        Project = \"foo/bar\",\n        TagName = \"v1.0.1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.LookupReleaseLink(ctx, \u0026gitlab.LookupReleaseLinkArgs{\n\t\t\tLinkId:  11,\n\t\t\tProject: \"foo/bar\",\n\t\t\tTagName: \"v1.0.1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetReleaseLinkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getReleaseLink(GetReleaseLinkArgs.builder()\n            .linkId(\"11\")\n            .project(\"foo/bar\")\n            .tagName(\"v1.0.1\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getReleaseLink\n      Arguments:\n        linkId: '11'\n        project: foo/bar\n        tagName: v1.0.1\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getReleaseLink.\n",
                "properties": {
                    "linkId": {
                        "type": "integer",
                        "description": "The ID of the link.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or [URL-encoded path of the project](https://docs.gitlab.com/ee/api/index.html#namespaced-path-encoding).\n"
                    },
                    "tagName": {
                        "type": "string",
                        "description": "The tag associated with the Release.\n"
                    }
                },
                "type": "object",
                "required": [
                    "linkId",
                    "project",
                    "tagName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getReleaseLink.\n",
                "properties": {
                    "directAssetUrl": {
                        "type": "string",
                        "description": "Full path for a [Direct Asset link](https://docs.gitlab.com/ee/user/project/releases/index.html#permanent-links-to-release-assets).\n"
                    },
                    "external": {
                        "type": "boolean",
                        "description": "External or internal link.\n"
                    },
                    "filepath": {
                        "type": "string",
                        "description": "Relative path for a [Direct Asset link](https://docs.gitlab.com/ee/user/project/releases/index.html#permanent-links-to-release-assets).\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "linkId": {
                        "type": "integer",
                        "description": "The ID of the link.\n"
                    },
                    "linkType": {
                        "type": "string",
                        "description": "The type of the link. Valid values are `other`, `runbook`, `image`, `package`. Defaults to other.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the link. Link names must be unique within the release.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or [URL-encoded path of the project](https://docs.gitlab.com/ee/api/index.html#namespaced-path-encoding).\n"
                    },
                    "tagName": {
                        "type": "string",
                        "description": "The tag associated with the Release.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "The URL of the link. Link URLs must be unique within the release.\n"
                    }
                },
                "type": "object",
                "required": [
                    "directAssetUrl",
                    "external",
                    "filepath",
                    "linkId",
                    "linkType",
                    "name",
                    "project",
                    "tagName",
                    "url",
                    "id"
                ]
            }
        },
        "gitlab:index/getReleaseLinks:getReleaseLinks": {
            "description": "The `gitlab.getReleaseLinks` data source allows get details of release links.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/releases/links.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getReleaseLinks({\n    project: \"foo/bar\",\n    tagName: \"v1.0.1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_release_links(project=\"foo/bar\",\n    tag_name=\"v1.0.1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetReleaseLinks.Invoke(new()\n    {\n        Project = \"foo/bar\",\n        TagName = \"v1.0.1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.GetReleaseLinks(ctx, \u0026gitlab.GetReleaseLinksArgs{\n\t\t\tProject: \"foo/bar\",\n\t\t\tTagName: \"v1.0.1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetReleaseLinksArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getReleaseLinks(GetReleaseLinksArgs.builder()\n            .project(\"foo/bar\")\n            .tagName(\"v1.0.1\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getReleaseLinks\n      Arguments:\n        project: foo/bar\n        tagName: v1.0.1\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getReleaseLinks.\n",
                "properties": {
                    "project": {
                        "type": "string",
                        "description": "The ID or full path to the project.\n",
                        "willReplaceOnChanges": true
                    },
                    "tagName": {
                        "type": "string",
                        "description": "The tag associated with the Release.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "project",
                    "tagName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getReleaseLinks.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or full path to the project.\n"
                    },
                    "releaseLinks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getReleaseLinksReleaseLink:getReleaseLinksReleaseLink"
                        },
                        "description": "List of release links\n"
                    },
                    "tagName": {
                        "type": "string",
                        "description": "The tag associated with the Release.\n"
                    }
                },
                "type": "object",
                "required": [
                    "project",
                    "releaseLinks",
                    "tagName",
                    "id"
                ]
            }
        },
        "gitlab:index/getRepositoryFile:getRepositoryFile": {
            "description": "The `gitlab.RepositoryFile` data source allows details of a file in a repository to be retrieved.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/repository_files.html)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getRepositoryFile({\n    filePath: \"README.md\",\n    project: \"example\",\n    ref: \"main\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_repository_file(file_path=\"README.md\",\n    project=\"example\",\n    ref=\"main\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetRepositoryFile.Invoke(new()\n    {\n        FilePath = \"README.md\",\n        Project = \"example\",\n        Ref = \"main\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.LookupRepositoryFile(ctx, \u0026gitlab.LookupRepositoryFileArgs{\n\t\t\tFilePath: \"README.md\",\n\t\t\tProject:  \"example\",\n\t\t\tRef:      \"main\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetRepositoryFileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getRepositoryFile(GetRepositoryFileArgs.builder()\n            .filePath(\"README.md\")\n            .project(\"example\")\n            .ref(\"main\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getRepositoryFile\n      Arguments:\n        filePath: README.md\n        project: example\n        ref: main\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getRepositoryFile.\n",
                "properties": {
                    "filePath": {
                        "type": "string",
                        "description": "The full path of the file. It must be relative to the root of the project without a leading slash `/` or `./`.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or ID of the project.\n"
                    },
                    "ref": {
                        "type": "string",
                        "description": "The name of branch, tag or commit.\n"
                    }
                },
                "type": "object",
                "required": [
                    "filePath",
                    "project",
                    "ref"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRepositoryFile.\n",
                "properties": {
                    "blobId": {
                        "type": "string",
                        "description": "The blob id.\n"
                    },
                    "commitId": {
                        "type": "string",
                        "description": "The commit id.\n"
                    },
                    "content": {
                        "type": "string",
                        "description": "File content. If the content is not yet base64 encoded, it will be encoded automatically. No other encoding is currently supported, because of a [GitLab API bug](https://gitlab.com/gitlab-org/gitlab/-/issues/342430).\n"
                    },
                    "contentSha256": {
                        "type": "string",
                        "description": "File content sha256 digest.\n"
                    },
                    "encoding": {
                        "type": "string",
                        "description": "The file content encoding.\n"
                    },
                    "executeFilemode": {
                        "type": "boolean",
                        "description": "Enables or disables the execute flag on the file. **Note**: requires GitLab 14.10 or newer.\n"
                    },
                    "fileName": {
                        "type": "string",
                        "description": "The filename.\n"
                    },
                    "filePath": {
                        "type": "string",
                        "description": "The full path of the file. It must be relative to the root of the project without a leading slash `/` or `./`.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "lastCommitId": {
                        "type": "string",
                        "description": "The last known commit id.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or ID of the project.\n"
                    },
                    "ref": {
                        "type": "string",
                        "description": "The name of branch, tag or commit.\n"
                    },
                    "size": {
                        "type": "integer",
                        "description": "The file size.\n"
                    }
                },
                "type": "object",
                "required": [
                    "blobId",
                    "commitId",
                    "content",
                    "contentSha256",
                    "encoding",
                    "executeFilemode",
                    "fileName",
                    "filePath",
                    "lastCommitId",
                    "project",
                    "ref",
                    "size",
                    "id"
                ]
            }
        },
        "gitlab:index/getRepositoryTree:getRepositoryTree": {
            "description": "The `gitlab.getRepositoryTree` data source allows details of directories and files in a repository to be retrieved.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/repositories.html#list-repository-tree)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst this = gitlab.getRepositoryTree({\n    path: \"ExampleSubFolder\",\n    project: \"example\",\n    recursive: true,\n    ref: \"main\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nthis = gitlab.get_repository_tree(path=\"ExampleSubFolder\",\n    project=\"example\",\n    recursive=True,\n    ref=\"main\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @this = GitLab.GetRepositoryTree.Invoke(new()\n    {\n        Path = \"ExampleSubFolder\",\n        Project = \"example\",\n        Recursive = true,\n        Ref = \"main\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.GetRepositoryTree(ctx, \u0026gitlab.GetRepositoryTreeArgs{\n\t\t\tPath:      pulumi.StringRef(\"ExampleSubFolder\"),\n\t\t\tProject:   \"example\",\n\t\t\tRecursive: pulumi.BoolRef(true),\n\t\t\tRef:       \"main\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetRepositoryTreeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var this = GitlabFunctions.getRepositoryTree(GetRepositoryTreeArgs.builder()\n            .path(\"ExampleSubFolder\")\n            .project(\"example\")\n            .recursive(true)\n            .ref(\"main\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  this:\n    fn::invoke:\n      Function: gitlab:getRepositoryTree\n      Arguments:\n        path: ExampleSubFolder\n        project: example\n        recursive: true\n        ref: main\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getRepositoryTree.\n",
                "properties": {
                    "path": {
                        "type": "string",
                        "description": "The path inside repository. Used to get content of subdirectories.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or full path of the project owned by the authenticated user.\n"
                    },
                    "recursive": {
                        "type": "boolean",
                        "description": "Boolean value used to get a recursive tree (false by default).\n"
                    },
                    "ref": {
                        "type": "string",
                        "description": "The name of a repository branch or tag.\n"
                    }
                },
                "type": "object",
                "required": [
                    "project",
                    "ref"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRepositoryTree.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path inside repository. Used to get content of subdirectories.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or full path of the project owned by the authenticated user.\n"
                    },
                    "recursive": {
                        "type": "boolean",
                        "description": "Boolean value used to get a recursive tree (false by default).\n"
                    },
                    "ref": {
                        "type": "string",
                        "description": "The name of a repository branch or tag.\n"
                    },
                    "trees": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getRepositoryTreeTree:getRepositoryTreeTree"
                        },
                        "description": "The list of files/directories returned by the search\n"
                    }
                },
                "type": "object",
                "required": [
                    "project",
                    "ref",
                    "trees",
                    "id"
                ]
            }
        },
        "gitlab:index/getUser:getUser": {
            "description": "The `gitlab.User` data source allows details of a user to be retrieved by either the user ID, username or email address.\n\n\u003e Some attributes might not be returned depending on if you're an admin or not.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/users.html#single-user)\n",
            "inputs": {
                "description": "A collection of arguments for invoking getUser.\n",
                "properties": {
                    "email": {
                        "type": "string",
                        "description": "The public email address of the user. **Note**: before GitLab 14.8 the lookup was based on the users primary email address.\n"
                    },
                    "namespaceId": {
                        "type": "integer",
                        "description": "The ID of the user's namespace. Requires admin token to access this field. Available since GitLab 14.10.\n"
                    },
                    "userId": {
                        "type": "integer",
                        "description": "The ID of the user.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "The username of the user.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getUser.\n",
                "properties": {
                    "avatarUrl": {
                        "type": "string",
                        "description": "The avatar URL of the user.\n"
                    },
                    "bio": {
                        "type": "string",
                        "description": "The bio of the user.\n"
                    },
                    "canCreateGroup": {
                        "type": "boolean",
                        "description": "Whether the user can create groups.\n"
                    },
                    "canCreateProject": {
                        "type": "boolean",
                        "description": "Whether the user can create projects.\n"
                    },
                    "colorSchemeId": {
                        "type": "integer",
                        "description": "User's color scheme ID.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Date the user was created at.\n"
                    },
                    "currentSignInAt": {
                        "type": "string",
                        "description": "Current user's sign-in date.\n"
                    },
                    "email": {
                        "type": "string",
                        "description": "The public email address of the user. **Note**: before GitLab 14.8 the lookup was based on the users primary email address.\n"
                    },
                    "externUid": {
                        "type": "string",
                        "description": "The external UID of the user.\n"
                    },
                    "external": {
                        "type": "boolean",
                        "description": "Whether the user is external.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "isAdmin": {
                        "type": "boolean",
                        "description": "Whether the user is an admin.\n"
                    },
                    "lastSignInAt": {
                        "type": "string",
                        "description": "Last user's sign-in date.\n"
                    },
                    "linkedin": {
                        "type": "string",
                        "description": "LinkedIn profile of the user.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "The location of the user.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the user.\n"
                    },
                    "namespaceId": {
                        "type": "integer",
                        "description": "The ID of the user's namespace. Requires admin token to access this field. Available since GitLab 14.10.\n"
                    },
                    "note": {
                        "type": "string",
                        "description": "Admin notes for this user.\n"
                    },
                    "organization": {
                        "type": "string",
                        "description": "The organization of the user.\n"
                    },
                    "projectsLimit": {
                        "type": "integer",
                        "description": "Number of projects the user can create.\n"
                    },
                    "skype": {
                        "type": "string",
                        "description": "Skype username of the user.\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "Whether the user is active or blocked.\n"
                    },
                    "themeId": {
                        "type": "integer",
                        "description": "User's theme ID.\n"
                    },
                    "twitter": {
                        "type": "string",
                        "description": "Twitter username of the user.\n"
                    },
                    "twoFactorEnabled": {
                        "type": "boolean",
                        "description": "Whether user's two-factor auth is enabled.\n"
                    },
                    "userId": {
                        "type": "integer",
                        "description": "The ID of the user.\n"
                    },
                    "userProvider": {
                        "type": "string",
                        "description": "The UID provider of the user.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "The username of the user.\n"
                    },
                    "websiteUrl": {
                        "type": "string",
                        "description": "User's website URL.\n"
                    }
                },
                "type": "object",
                "required": [
                    "avatarUrl",
                    "bio",
                    "canCreateGroup",
                    "canCreateProject",
                    "colorSchemeId",
                    "createdAt",
                    "currentSignInAt",
                    "email",
                    "externUid",
                    "external",
                    "isAdmin",
                    "lastSignInAt",
                    "linkedin",
                    "location",
                    "name",
                    "namespaceId",
                    "note",
                    "organization",
                    "projectsLimit",
                    "skype",
                    "state",
                    "themeId",
                    "twitter",
                    "twoFactorEnabled",
                    "userId",
                    "userProvider",
                    "username",
                    "websiteUrl",
                    "id"
                ]
            }
        },
        "gitlab:index/getUserSshkeys:getUserSshkeys": {
            "description": "The `gitlab.getUserSshkeys` data source allows a list of SSH keys to be retrieved by either the user ID or username.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/users.html#list-ssh-keys-for-user)\n",
            "inputs": {
                "description": "A collection of arguments for invoking getUserSshkeys.\n",
                "properties": {
                    "userId": {
                        "type": "integer",
                        "description": "ID of the user to get the SSH keys for.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Username of the user to get the SSH keys for.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getUserSshkeys.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "keys": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getUserSshkeysKey:getUserSshkeysKey"
                        },
                        "description": "The user's keys.\n"
                    },
                    "userId": {
                        "type": "integer",
                        "description": "ID of the user to get the SSH keys for.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Username of the user to get the SSH keys for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "keys",
                    "userId",
                    "username",
                    "id"
                ]
            }
        },
        "gitlab:index/getUsers:getUsers": {
            "description": "The `gitlab.getUsers` data source allows details of multiple users to be retrieved given some optional filter criteria.\n\n\u003e Some attributes might not be returned depending on if you're an admin or not.\n\n\u003e Some available options require administrator privileges.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ce/api/users.html#list-users)\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getUsers({\n    createdBefore: \"2019-01-01\",\n    orderBy: \"name\",\n    sort: \"desc\",\n});\nconst example-two = gitlab.getUsers({\n    search: \"username\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_users(created_before=\"2019-01-01\",\n    order_by=\"name\",\n    sort=\"desc\")\nexample_two = gitlab.get_users(search=\"username\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetUsers.Invoke(new()\n    {\n        CreatedBefore = \"2019-01-01\",\n        OrderBy = \"name\",\n        Sort = \"desc\",\n    });\n\n    var example_two = GitLab.GetUsers.Invoke(new()\n    {\n        Search = \"username\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v5/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.GetUsers(ctx, \u0026gitlab.GetUsersArgs{\n\t\t\tCreatedBefore: pulumi.StringRef(\"2019-01-01\"),\n\t\t\tOrderBy:       pulumi.StringRef(\"name\"),\n\t\t\tSort:          pulumi.StringRef(\"desc\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.GetUsers(ctx, \u0026gitlab.GetUsersArgs{\n\t\t\tSearch: pulumi.StringRef(\"username\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetUsersArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getUsers(GetUsersArgs.builder()\n            .createdBefore(\"2019-01-01\")\n            .orderBy(\"name\")\n            .sort(\"desc\")\n            .build());\n\n        final var example-two = GitlabFunctions.getUsers(GetUsersArgs.builder()\n            .search(\"username\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getUsers\n      Arguments:\n        createdBefore: 2019-01-01\n        orderBy: name\n        sort: desc\n  example-two:\n    fn::invoke:\n      Function: gitlab:getUsers\n      Arguments:\n        search: username\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getUsers.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "Filter users that are active.\n"
                    },
                    "blocked": {
                        "type": "boolean",
                        "description": "Filter users that are blocked.\n"
                    },
                    "createdAfter": {
                        "type": "string",
                        "description": "Search for users created after a specific date. (Requires administrator privileges)\n"
                    },
                    "createdBefore": {
                        "type": "string",
                        "description": "Search for users created before a specific date. (Requires administrator privileges)\n"
                    },
                    "externProvider": {
                        "type": "string",
                        "description": "Lookup users by external provider. (Requires administrator privileges)\n"
                    },
                    "externUid": {
                        "type": "string",
                        "description": "Lookup users by external UID. (Requires administrator privileges)\n"
                    },
                    "orderBy": {
                        "type": "string",
                        "description": "Order the users' list by `id`, `name`, `username`, `created_at` or `updated_at`. (Requires administrator privileges)\n"
                    },
                    "search": {
                        "type": "string",
                        "description": "Search users by username, name or email.\n"
                    },
                    "sort": {
                        "type": "string",
                        "description": "Sort users' list in asc or desc order. (Requires administrator privileges)\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getUsers.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "Filter users that are active.\n"
                    },
                    "blocked": {
                        "type": "boolean",
                        "description": "Filter users that are blocked.\n"
                    },
                    "createdAfter": {
                        "type": "string",
                        "description": "Search for users created after a specific date. (Requires administrator privileges)\n"
                    },
                    "createdBefore": {
                        "type": "string",
                        "description": "Search for users created before a specific date. (Requires administrator privileges)\n"
                    },
                    "externProvider": {
                        "type": "string",
                        "description": "Lookup users by external provider. (Requires administrator privileges)\n"
                    },
                    "externUid": {
                        "type": "string",
                        "description": "Lookup users by external UID. (Requires administrator privileges)\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "orderBy": {
                        "type": "string",
                        "description": "Order the users' list by `id`, `name`, `username`, `created_at` or `updated_at`. (Requires administrator privileges)\n"
                    },
                    "search": {
                        "type": "string",
                        "description": "Search users by username, name or email.\n"
                    },
                    "sort": {
                        "type": "string",
                        "description": "Sort users' list in asc or desc order. (Requires administrator privileges)\n"
                    },
                    "users": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getUsersUser:getUsersUser"
                        },
                        "description": "The list of users.\n"
                    }
                },
                "type": "object",
                "required": [
                    "users",
                    "id"
                ]
            }
        }
    }
}