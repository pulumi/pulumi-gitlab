{
    "name": "gitlab",
    "description": "A Pulumi package for creating and managing GitLab resources.",
    "keywords": [
        "pulumi",
        "gitlab"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`gitlab` Terraform Provider](https://github.com/gitlabhq/terraform-provider-gitlab).",
    "repository": "https://github.com/pulumi/pulumi-gitlab",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "packageReferences": {
                "Pulumi": "3.*"
            },
            "namespaces": {
                "gitlab": "GitLab"
            },
            "compatibility": "tfbridge20",
            "respectSchemaVersion": true
        },
        "go": {
            "importBasePath": "github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab",
            "generateResourceContainerTypes": true,
            "generateExtraInputTypes": true,
            "respectSchemaVersion": true
        },
        "nodejs": {
            "packageDescription": "A Pulumi package for creating and managing GitLab resources.",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/gitlabhq/terraform-provider-gitlab)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-gitlab` repo](https://github.com/pulumi/pulumi-gitlab/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-gitlab` repo](https://github.com/gitlabhq/terraform-provider-gitlab/issues).",
            "dependencies": {
                "builtin-modules": "3.0.0",
                "read-package-tree": "^5.2.1",
                "resolve": "^1.7.1"
            },
            "devDependencies": {
                "@types/node": "^10.0.0"
            },
            "compatibility": "tfbridge20",
            "disableUnionOutputTypes": true,
            "respectSchemaVersion": true
        },
        "python": {
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/gitlabhq/terraform-provider-gitlab)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-gitlab` repo](https://github.com/pulumi/pulumi-gitlab/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-gitlab` repo](https://github.com/gitlabhq/terraform-provider-gitlab/issues).",
            "compatibility": "tfbridge20",
            "respectSchemaVersion": true,
            "pyproject": {
                "enabled": true
            }
        }
    },
    "config": {
        "variables": {
            "baseUrl": {
                "type": "string",
                "description": "This is the target GitLab base API endpoint. Providing a value is a requirement when working with GitLab CE or GitLab\nEnterprise e.g. `https://my.gitlab.server/api/v4/`. It is optional to provide this value and it can also be sourced from\nthe `GITLAB_BASE_URL` environment variable. The value must end with a slash.\n"
            },
            "cacertFile": {
                "type": "string",
                "description": "This is a file containing the ca cert to verify the gitlab instance. This is available for use when working with GitLab\nCE or Gitlab Enterprise with a locally-issued or self-signed certificate chain.\n"
            },
            "clientCert": {
                "type": "string",
                "description": "File path to client certificate when GitLab instance is behind company proxy. File must contain PEM encoded data.\n"
            },
            "clientKey": {
                "type": "string",
                "description": "File path to client key when GitLab instance is behind company proxy. File must contain PEM encoded data. Required when\n`client_cert` is set.\n"
            },
            "earlyAuthCheck": {
                "type": "boolean"
            },
            "headers": {
                "type": "object",
                "additionalProperties": {
                    "type": "string"
                },
                "description": "A map of headers to append to all API request to the GitLab instance.\n"
            },
            "insecure": {
                "type": "boolean",
                "description": "When set to true this disables SSL verification of the connection to the GitLab instance.\n"
            },
            "retries": {
                "type": "integer",
                "description": "The number of retries to execute when receiving a 429 Rate Limit error. Each retry will exponentially back off.\n"
            },
            "token": {
                "type": "string",
                "description": "The OAuth2 Token, Project, Group, Personal Access Token or CI Job Token used to connect to GitLab. The OAuth method is\nused in this provider for authentication (using Bearer authorization token). See\nhttps://docs.gitlab.com/ee/api/#authentication for details. It may be sourced from the `GITLAB_TOKEN` environment\nvariable.\n",
                "secret": true
            }
        }
    },
    "types": {
        "gitlab:index/ApplicationSettingsDefaultBranchProtectionDefaults:ApplicationSettingsDefaultBranchProtectionDefaults": {
            "properties": {
                "allowForcePush": {
                    "type": "boolean",
                    "description": "Allow force push for all users with push access.\n"
                },
                "allowedToMerges": {
                    "type": "array",
                    "items": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "An array of access levels allowed to merge. Supports Developer (30) or Maintainer (40).\n"
                },
                "allowedToPushes": {
                    "type": "array",
                    "items": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "An array of access levels allowed to push. Supports Developer (30) or Maintainer (40).\n"
                },
                "developerCanInitialPush": {
                    "type": "boolean",
                    "description": "Allow developers to initial push.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "allowForcePush",
                        "allowedToMerges",
                        "allowedToPushes",
                        "developerCanInitialPush"
                    ]
                }
            }
        },
        "gitlab:index/BranchCommit:BranchCommit": {
            "properties": {
                "authorEmail": {
                    "type": "string",
                    "description": "The email of the author.\n"
                },
                "authorName": {
                    "type": "string",
                    "description": "The name of the author.\n"
                },
                "authoredDate": {
                    "type": "string",
                    "description": "The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).\n"
                },
                "committedDate": {
                    "type": "string",
                    "description": "The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).\n"
                },
                "committerEmail": {
                    "type": "string",
                    "description": "The email of the user that committed.\n"
                },
                "committerName": {
                    "type": "string",
                    "description": "The name of the user that committed.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The unique id assigned to the commit by Gitlab.\n"
                },
                "message": {
                    "type": "string",
                    "description": "The commit message\n"
                },
                "parentIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The id of the parents of the commit\n"
                },
                "shortId": {
                    "type": "string",
                    "description": "The short id assigned to the commit by Gitlab.\n"
                },
                "title": {
                    "type": "string",
                    "description": "The title of the commit\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "authorEmail",
                        "authorName",
                        "authoredDate",
                        "committedDate",
                        "committerEmail",
                        "committerName",
                        "id",
                        "message",
                        "parentIds",
                        "shortId",
                        "title"
                    ]
                }
            }
        },
        "gitlab:index/BranchProtectionAllowedToMerge:BranchProtectionAllowedToMerge": {
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`.\n"
                },
                "accessLevelDescription": {
                    "type": "string",
                    "description": "Readable description of access level.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "accessLevel",
                        "accessLevelDescription"
                    ]
                }
            }
        },
        "gitlab:index/BranchProtectionAllowedToPush:BranchProtectionAllowedToPush": {
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`.\n"
                },
                "accessLevelDescription": {
                    "type": "string",
                    "description": "Readable description of access level.\n"
                },
                "deployKeyId": {
                    "type": "integer",
                    "description": "The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `group_id` and `user_id`. This field is read-only until Gitlab 17.5.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `user_id`.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `group_id`.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "accessLevel",
                        "accessLevelDescription"
                    ]
                }
            }
        },
        "gitlab:index/BranchProtectionAllowedToUnprotect:BranchProtectionAllowedToUnprotect": {
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Access levels allowed to unprotect push to protected branch. Valid values are: `developer`, `maintainer`, `admin`.\n"
                },
                "accessLevelDescription": {
                    "type": "string",
                    "description": "Readable description of access level.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "accessLevel",
                        "accessLevelDescription"
                    ]
                }
            }
        },
        "gitlab:index/GroupAccessTokenRotationConfiguration:GroupAccessTokenRotationConfiguration": {
            "properties": {
                "expirationDays": {
                    "type": "integer",
                    "description": "The duration (in days) the new token should be valid for.\n"
                },
                "rotateBeforeDays": {
                    "type": "integer",
                    "description": "The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.\n"
                }
            },
            "type": "object",
            "required": [
                "expirationDays",
                "rotateBeforeDays"
            ]
        },
        "gitlab:index/GroupDefaultBranchProtectionDefaults:GroupDefaultBranchProtectionDefaults": {
            "properties": {
                "allowForcePush": {
                    "type": "boolean",
                    "description": "Allow force push for all users with push access.\n"
                },
                "allowedToMerges": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of access levels allowed to merge. Valid values are: `developer`, `maintainer`, `no one`.\n"
                },
                "allowedToPushes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of access levels allowed to push. Valid values are: `developer`, `maintainer`, `no one`.\n"
                },
                "developerCanInitialPush": {
                    "type": "boolean",
                    "description": "Allow developers to initial push.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "allowForcePush",
                        "allowedToMerges",
                        "allowedToPushes",
                        "developerCanInitialPush"
                    ]
                }
            }
        },
        "gitlab:index/GroupEpicBoardList:GroupEpicBoardList": {
            "properties": {
                "id": {
                    "type": "integer",
                    "description": "The ID of the list.\n"
                },
                "labelId": {
                    "type": "integer",
                    "description": "The ID of the label the list should be scoped to.\n"
                },
                "position": {
                    "type": "integer",
                    "description": "The position of the list within the board. The position for the list is sed on the its position in the `lists` array.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "position"
                    ]
                }
            }
        },
        "gitlab:index/GroupHookCustomHeader:GroupHookCustomHeader": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "Key of the custom header.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of the custom header. This value cannot be imported.\n",
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ]
        },
        "gitlab:index/GroupIssueBoardList:GroupIssueBoardList": {
            "properties": {
                "id": {
                    "type": "integer",
                    "description": "The ID of the list.\n"
                },
                "labelId": {
                    "type": "integer",
                    "description": "The ID of the label the list should be scoped to.\n"
                },
                "position": {
                    "type": "integer",
                    "description": "The explicit position of the list within the board, zero based.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "position"
                    ]
                }
            }
        },
        "gitlab:index/GroupProtectedEnvironmentApprovalRule:GroupProtectedEnvironmentApprovalRule": {
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Levels of access allowed to approve a deployment to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.\n"
                },
                "accessLevelDescription": {
                    "type": "string",
                    "description": "Readable description of level of access.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of the group allowed to approve a deployment to this protected environment. TThe group must be a sub-group under the given group. Mutually exclusive with `access_level` and `user_id`.\n"
                },
                "groupInheritanceType": {
                    "type": "integer",
                    "description": "Group inheritance allows access rules to take inherited group membership into account. Valid values are `0`, `1`. `0` =\u003e Direct group membership only, `1` =\u003e All inherited groups. Default: `0`\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The unique ID of the Approval Rules object.\n"
                },
                "requiredApprovals": {
                    "type": "integer",
                    "description": "The number of approval required to allow deployment to this protected environment. This is mutually exclusive with user_id.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID of the user allowed to approve a deployment to this protected environment. The user must be a member of the group with Maintainer role or higher. Mutually exclusive with `access_level` and `group_id`.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "accessLevelDescription",
                        "groupInheritanceType",
                        "id",
                        "requiredApprovals"
                    ]
                }
            }
        },
        "gitlab:index/GroupProtectedEnvironmentDeployAccessLevel:GroupProtectedEnvironmentDeployAccessLevel": {
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Levels of access required to deploy to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.\n"
                },
                "accessLevelDescription": {
                    "type": "string",
                    "description": "Readable description of level of access.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of the group allowed to deploy to this protected environment. The group must be a sub-group under the given group. Mutually exclusive with `access_level` and `user_id`.\n"
                },
                "groupInheritanceType": {
                    "type": "integer",
                    "description": "Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` =\u003e Direct group membership only, `1` =\u003e All inherited groups. Default: `0`\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The unique ID of the Deploy Access Level object.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID of the user allowed to deploy to this protected environment. The user must be a member of the group with Maintainer role or higher. Mutually exclusive with `access_level` and `group_id`.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "accessLevelDescription",
                        "groupInheritanceType",
                        "id"
                    ]
                }
            }
        },
        "gitlab:index/GroupPushRules:GroupPushRules": {
            "properties": {
                "authorEmailRegex": {
                    "type": "string",
                    "description": "All commit author emails must match this regex, e.g. `@my-company.com$`.\n"
                },
                "branchNameRegex": {
                    "type": "string",
                    "description": "All branch names must match this regex, e.g. `(feature|hotfix)\\/*`.\n"
                },
                "commitCommitterCheck": {
                    "type": "boolean",
                    "description": "Only commits pushed using verified emails are allowed.  **Note** This attribute is only supported in GitLab versions \u003e= 16.4.\n"
                },
                "commitCommitterNameCheck": {
                    "type": "boolean",
                    "description": "Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.\n"
                },
                "commitMessageNegativeRegex": {
                    "type": "string",
                    "description": "No commit message is allowed to match this regex, for example `ssh\\:\\/\\/`.\n"
                },
                "commitMessageRegex": {
                    "type": "string",
                    "description": "All commit messages must match this regex, e.g. `Fixed \\d+\\..*`.\n"
                },
                "denyDeleteTag": {
                    "type": "boolean",
                    "description": "Deny deleting a tag.\n"
                },
                "fileNameRegex": {
                    "type": "string",
                    "description": "Filenames matching the regular expression provided in this attribute are not allowed, for example, `(jar|exe)$`.\n"
                },
                "maxFileSize": {
                    "type": "integer",
                    "description": "Maximum file size (MB) allowed.\n"
                },
                "memberCheck": {
                    "type": "boolean",
                    "description": "Allows only GitLab users to author commits.\n"
                },
                "preventSecrets": {
                    "type": "boolean",
                    "description": "GitLab will reject any files that are likely to contain secrets.\n"
                },
                "rejectNonDcoCommits": {
                    "type": "boolean",
                    "description": "Reject commit when it’s not DCO certified.\n"
                },
                "rejectUnsignedCommits": {
                    "type": "boolean",
                    "description": "Only commits signed through GPG are allowed.  **Note** This attribute is only supported in GitLab versions \u003e= 16.4.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "authorEmailRegex",
                        "branchNameRegex",
                        "commitCommitterCheck",
                        "commitCommitterNameCheck",
                        "commitMessageNegativeRegex",
                        "commitMessageRegex",
                        "denyDeleteTag",
                        "fileNameRegex",
                        "maxFileSize",
                        "memberCheck",
                        "preventSecrets",
                        "rejectNonDcoCommits",
                        "rejectUnsignedCommits"
                    ]
                }
            }
        },
        "gitlab:index/PersonalAccessTokenRotationConfiguration:PersonalAccessTokenRotationConfiguration": {
            "properties": {
                "expirationDays": {
                    "type": "integer",
                    "description": "The duration (in days) the new token should be valid for.\n"
                },
                "rotateBeforeDays": {
                    "type": "integer",
                    "description": "The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.\n"
                }
            },
            "type": "object",
            "required": [
                "expirationDays",
                "rotateBeforeDays"
            ]
        },
        "gitlab:index/ProjectAccessTokenRotationConfiguration:ProjectAccessTokenRotationConfiguration": {
            "properties": {
                "expirationDays": {
                    "type": "integer",
                    "description": "The duration (in days) the new token should be valid for.\n"
                },
                "rotateBeforeDays": {
                    "type": "integer",
                    "description": "The duration (in days) before the expiration when the token should be rotated. As an example, if set to 7 days, the token will rotate 7 days before the expiration date, but only when `pulumi up` is run in that timeframe.\n"
                }
            },
            "type": "object",
            "required": [
                "expirationDays",
                "rotateBeforeDays"
            ]
        },
        "gitlab:index/ProjectContainerExpirationPolicy:ProjectContainerExpirationPolicy": {
            "properties": {
                "cadence": {
                    "type": "string",
                    "description": "The cadence of the policy. Valid values are: `1d`, `7d`, `14d`, `1month`, `3month`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "If true, the policy is enabled.\n"
                },
                "keepN": {
                    "type": "integer",
                    "description": "The number of images to keep.\n"
                },
                "nameRegex": {
                    "type": "string",
                    "description": "The regular expression to match image names to delete.\n",
                    "deprecationMessage": "`name_regex` has been deprecated. Use `name_regex_delete` instead."
                },
                "nameRegexDelete": {
                    "type": "string",
                    "description": "The regular expression to match image names to delete.\n"
                },
                "nameRegexKeep": {
                    "type": "string",
                    "description": "The regular expression to match image names to keep.\n"
                },
                "nextRunAt": {
                    "type": "string",
                    "description": "The next time the policy will run.\n"
                },
                "olderThan": {
                    "type": "string",
                    "description": "The number of days to keep images.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "cadence",
                        "enabled",
                        "keepN",
                        "nameRegex",
                        "nameRegexDelete",
                        "nameRegexKeep",
                        "nextRunAt",
                        "olderThan"
                    ]
                }
            }
        },
        "gitlab:index/ProjectHookCustomHeader:ProjectHookCustomHeader": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "Key of the custom header.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of the custom header. This value cannot be imported.\n",
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ]
        },
        "gitlab:index/ProjectIssueBoardList:ProjectIssueBoardList": {
            "properties": {
                "assigneeId": {
                    "type": "integer",
                    "description": "The ID of the assignee the list should be scoped to. Requires a GitLab EE license.\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The ID of the list\n"
                },
                "iterationId": {
                    "type": "integer",
                    "description": "The ID of the iteration the list should be scoped to. Requires a GitLab EE license.\n"
                },
                "labelId": {
                    "type": "integer",
                    "description": "The ID of the label the list should be scoped to. Requires a GitLab EE license.\n"
                },
                "milestoneId": {
                    "type": "integer",
                    "description": "The ID of the milestone the list should be scoped to. Requires a GitLab EE license.\n"
                },
                "position": {
                    "type": "integer",
                    "description": "The position of the list within the board. The position for the list is based on the its position in the `lists` array.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "position"
                    ]
                }
            }
        },
        "gitlab:index/ProjectIssueTaskCompletionStatus:ProjectIssueTaskCompletionStatus": {
            "properties": {
                "completedCount": {
                    "type": "integer",
                    "description": "The number of tasks that are completed.\n"
                },
                "count": {
                    "type": "integer",
                    "description": "The number of tasks.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "completedCount",
                        "count"
                    ]
                }
            }
        },
        "gitlab:index/ProjectProtectedEnvironmentApprovalRule:ProjectProtectedEnvironmentApprovalRule": {
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Levels of access allowed to approve a deployment to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.\n"
                },
                "accessLevelDescription": {
                    "type": "string",
                    "description": "Readable description of level of access.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of the group allowed to approve a deployment to this protected environment. The project must be shared with the group. Mutually exclusive with `access_level` and `user_id`.\n"
                },
                "groupInheritanceType": {
                    "type": "integer",
                    "description": "Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` =\u003e Direct group membership only, `1` =\u003e All inherited groups. Default: `0`\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The unique ID of the Approval Rules object.\n"
                },
                "requiredApprovals": {
                    "type": "integer",
                    "description": "The number of approval required to allow deployment to this protected environment. This is mutually exclusive with user_id.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID of the user allowed to approve a deployment to this protected environment. The user must be a member of the project. Mutually exclusive with `access_level` and `group_id`.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "accessLevelDescription",
                        "groupInheritanceType",
                        "id",
                        "requiredApprovals"
                    ]
                }
            }
        },
        "gitlab:index/ProjectProtectedEnvironmentDeployAccessLevel:ProjectProtectedEnvironmentDeployAccessLevel": {
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Levels of access required to deploy to this protected environment. Mutually exclusive with `user_id` and `group_id`. Valid values are `developer`, `maintainer`.\n"
                },
                "accessLevelDescription": {
                    "type": "string",
                    "description": "Readable description of level of access.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of the group allowed to deploy to this protected environment. The project must be shared with the group. Mutually exclusive with `access_level` and `user_id`.\n"
                },
                "groupInheritanceType": {
                    "type": "integer",
                    "description": "Group inheritance allows deploy access levels to take inherited group membership into account. Valid values are `0`, `1`. `0` =\u003e Direct group membership only, `1` =\u003e All inherited groups. Default: `0`\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The unique ID of the Deploy Access Level object.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID of the user allowed to deploy to this protected environment. The user must be a member of the project. Mutually exclusive with `access_level` and `group_id`.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "accessLevelDescription",
                        "groupInheritanceType",
                        "id"
                    ]
                }
            }
        },
        "gitlab:index/ProjectPushRules:ProjectPushRules": {
            "properties": {
                "authorEmailRegex": {
                    "type": "string",
                    "description": "All commit author emails must match this regex, e.g. `@my-company.com$`.\n"
                },
                "branchNameRegex": {
                    "type": "string",
                    "description": "All branch names must match this regex, e.g. `(feature|hotfix)\\/*`.\n"
                },
                "commitCommitterCheck": {
                    "type": "boolean",
                    "description": "Users can only push commits to this repository that were committed with one of their own verified emails.\n"
                },
                "commitCommitterNameCheck": {
                    "type": "boolean",
                    "description": "Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.\n"
                },
                "commitMessageNegativeRegex": {
                    "type": "string",
                    "description": "No commit message is allowed to match this regex, e.g. `ssh\\:\\/\\/`.\n"
                },
                "commitMessageRegex": {
                    "type": "string",
                    "description": "All commit messages must match this regex, e.g. `Fixed \\d+\\..*`.\n"
                },
                "denyDeleteTag": {
                    "type": "boolean",
                    "description": "Deny deleting a tag.\n"
                },
                "fileNameRegex": {
                    "type": "string",
                    "description": "All committed filenames must not match this regex, e.g. `(jar|exe)$`.\n"
                },
                "maxFileSize": {
                    "type": "integer",
                    "description": "Maximum file size (MB).\n"
                },
                "memberCheck": {
                    "type": "boolean",
                    "description": "Restrict commits by author (email) to existing GitLab users.\n"
                },
                "preventSecrets": {
                    "type": "boolean",
                    "description": "GitLab will reject any files that are likely to contain secrets.\n"
                },
                "rejectNonDcoCommits": {
                    "type": "boolean",
                    "description": "Reject commit when it’s not DCO certified.\n"
                },
                "rejectUnsignedCommits": {
                    "type": "boolean",
                    "description": "Reject commit when it’s not signed through GPG.\n"
                }
            },
            "type": "object"
        },
        "gitlab:index/ProjectTagCommit:ProjectTagCommit": {
            "properties": {
                "authorEmail": {
                    "type": "string",
                    "description": "The email of the author.\n"
                },
                "authorName": {
                    "type": "string",
                    "description": "The name of the author.\n"
                },
                "authoredDate": {
                    "type": "string",
                    "description": "The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).\n"
                },
                "committedDate": {
                    "type": "string",
                    "description": "The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).\n"
                },
                "committerEmail": {
                    "type": "string",
                    "description": "The email of the user that committed.\n"
                },
                "committerName": {
                    "type": "string",
                    "description": "The name of the user that committed.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The unique id assigned to the commit by Gitlab.\n"
                },
                "message": {
                    "type": "string",
                    "description": "The commit message\n"
                },
                "parentIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The id of the parents of the commit\n"
                },
                "shortId": {
                    "type": "string",
                    "description": "The short id assigned to the commit by Gitlab.\n"
                },
                "title": {
                    "type": "string",
                    "description": "The title of the commit\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "authorEmail",
                        "authorName",
                        "authoredDate",
                        "committedDate",
                        "committerEmail",
                        "committerName",
                        "id",
                        "message",
                        "parentIds",
                        "shortId",
                        "title"
                    ]
                }
            }
        },
        "gitlab:index/ProjectTagRelease:ProjectTagRelease": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "The description of release.\n"
                },
                "tagName": {
                    "type": "string",
                    "description": "The name of the tag.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "description",
                        "tagName"
                    ]
                }
            }
        },
        "gitlab:index/TagProtectionAllowedToCreate:TagProtectionAllowedToCreate": {
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Access levels allowed to create protected tags. Valid values are: `no one`, `developer`, `maintainer`.\n"
                },
                "accessLevelDescription": {
                    "type": "string",
                    "description": "Readable description of access level.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "accessLevel",
                        "accessLevelDescription"
                    ]
                }
            }
        },
        "gitlab:index/getBranchCommit:getBranchCommit": {
            "properties": {
                "authorEmail": {
                    "type": "string",
                    "description": "The email of the author.\n"
                },
                "authorName": {
                    "type": "string",
                    "description": "The name of the author.\n"
                },
                "authoredDate": {
                    "type": "string",
                    "description": "The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).\n"
                },
                "committedDate": {
                    "type": "string",
                    "description": "The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).\n"
                },
                "committerEmail": {
                    "type": "string",
                    "description": "The email of the user that committed.\n"
                },
                "committerName": {
                    "type": "string",
                    "description": "The name of the user that committed.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The unique id assigned to the commit by Gitlab.\n"
                },
                "message": {
                    "type": "string",
                    "description": "The commit message\n"
                },
                "parentIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The id of the parents of the commit\n"
                },
                "shortId": {
                    "type": "string",
                    "description": "The short id assigned to the commit by Gitlab.\n"
                },
                "title": {
                    "type": "string",
                    "description": "The title of the commit\n"
                }
            },
            "type": "object",
            "required": [
                "authorEmail",
                "authorName",
                "authoredDate",
                "committedDate",
                "committerEmail",
                "committerName",
                "id",
                "message",
                "parentIds",
                "shortId",
                "title"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getClusterAgentsClusterAgent:getClusterAgentsClusterAgent": {
            "properties": {
                "agentId": {
                    "type": "integer",
                    "description": "The ID of the agent.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "The ISO8601 datetime when the agent was created.\n"
                },
                "createdByUserId": {
                    "type": "integer",
                    "description": "The ID of the user who created the agent.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The Name of the agent.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID or full path of the project maintained by the authenticated user.\n"
                }
            },
            "type": "object",
            "required": [
                "agentId",
                "createdAt",
                "createdByUserId",
                "name",
                "project"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getGroupBillableMemberMembershipsMembership:getGroupBillableMemberMembershipsMembership": {
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Access-level of the member. For details see: https://docs.gitlab.com/ee/api/access_requests.html#valid-access-levels\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Datetime when the membership was first added.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "Date when the membership will end.\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The id of the membership.\n"
                },
                "sourceFullName": {
                    "type": "string",
                    "description": "Breadcrumb-style, full display-name of the group or project.\n"
                },
                "sourceId": {
                    "type": "integer",
                    "description": "The id of the group or project, the user is a (direct) member of.\n"
                },
                "sourceMembersUrl": {
                    "type": "string",
                    "description": "URL to the members-page of the group or project.\n"
                }
            },
            "type": "object",
            "required": [
                "accessLevel",
                "createdAt",
                "expiresAt",
                "id",
                "sourceFullName",
                "sourceId",
                "sourceMembersUrl"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getGroupHooksHook:getGroupHooksHook": {
            "properties": {
                "confidentialIssuesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for confidential issues events.\n"
                },
                "confidentialNoteEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for confidential notes events.\n"
                },
                "customWebhookTemplate": {
                    "type": "string",
                    "description": "Set a custom webhook template.\n"
                },
                "deploymentEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for deployment events.\n"
                },
                "enableSslVerification": {
                    "type": "boolean",
                    "description": "Enable ssl verification when invoking the hook.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The ID or full path of the group.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The id of the group for the hook.\n"
                },
                "hookId": {
                    "type": "integer",
                    "description": "The id of the group hook.\n"
                },
                "issuesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for issues events.\n"
                },
                "jobEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for job events.\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for merge requests.\n"
                },
                "noteEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for notes events.\n"
                },
                "pipelineEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for pipeline events.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for push events.\n"
                },
                "pushEventsBranchFilter": {
                    "type": "string",
                    "description": "Invoke the hook for push events on matching branches only.\n"
                },
                "releasesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for releases events.\n"
                },
                "subgroupEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for subgroup events.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for tag push events.\n"
                },
                "token": {
                    "type": "string",
                    "description": "A token to present when invoking the hook. The token is not available for imported resources.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The url of the hook to invoke.\n"
                },
                "wikiPageEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for wiki page events.\n"
                }
            },
            "type": "object",
            "required": [
                "confidentialIssuesEvents",
                "confidentialNoteEvents",
                "customWebhookTemplate",
                "deploymentEvents",
                "enableSslVerification",
                "group",
                "groupId",
                "hookId",
                "issuesEvents",
                "jobEvents",
                "mergeRequestsEvents",
                "noteEvents",
                "pipelineEvents",
                "pushEvents",
                "pushEventsBranchFilter",
                "releasesEvents",
                "subgroupEvents",
                "tagPushEvents",
                "token",
                "url",
                "wikiPageEvents"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getGroupMembershipMember:getGroupMembershipMember": {
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "The level of access to the group.\n"
                },
                "avatarUrl": {
                    "type": "string",
                    "description": "The avatar URL of the user.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "Expiration date for the group membership.\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The unique id assigned to the user by the gitlab server.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the user.\n"
                },
                "state": {
                    "type": "string",
                    "description": "Whether the user is active or blocked.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The username of the user.\n"
                },
                "webUrl": {
                    "type": "string",
                    "description": "User's website URL.\n"
                }
            },
            "type": "object",
            "required": [
                "accessLevel",
                "avatarUrl",
                "expiresAt",
                "id",
                "name",
                "state",
                "username",
                "webUrl"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getGroupProvisionedUsersProvisionedUser:getGroupProvisionedUsersProvisionedUser": {
            "properties": {
                "avatarUrl": {
                    "type": "string",
                    "description": "The avatar URL of the provisioned user.\n"
                },
                "bio": {
                    "type": "string",
                    "description": "The bio of the provisioned user.\n"
                },
                "bot": {
                    "type": "boolean",
                    "description": "Whether the provisioned user is a bot.\n"
                },
                "confirmedAt": {
                    "type": "string",
                    "description": "The confirmation date of the provisioned user.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "The creation date of the provisioned user.\n"
                },
                "email": {
                    "type": "string",
                    "description": "The email of the provisioned user.\n"
                },
                "external": {
                    "type": "boolean",
                    "description": "Whether the provisioned user is external.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of the provisioned user.\n"
                },
                "jobTitle": {
                    "type": "string",
                    "description": "The job title of the provisioned user.\n"
                },
                "lastActivityOn": {
                    "type": "string",
                    "description": "The last activity date of the provisioned user.\n"
                },
                "lastSignInAt": {
                    "type": "string",
                    "description": "The last sign-in date of the provisioned user.\n"
                },
                "linkedin": {
                    "type": "string",
                    "description": "The LinkedIn ID of the provisioned user.\n"
                },
                "location": {
                    "type": "string",
                    "description": "The location of the provisioned user.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the provisioned user.\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization of the provisioned user.\n"
                },
                "privateProfile": {
                    "type": "boolean",
                    "description": "Whether the provisioned user has a private profile.\n"
                },
                "pronouns": {
                    "type": "string",
                    "description": "The pronouns of the provisioned user.\n"
                },
                "publicEmail": {
                    "type": "string",
                    "description": "The public email of the provisioned user.\n"
                },
                "skype": {
                    "type": "string",
                    "description": "The Skype ID of the provisioned user.\n"
                },
                "state": {
                    "type": "string",
                    "description": "The state of the provisioned user.\n"
                },
                "twitter": {
                    "type": "string",
                    "description": "The Twitter ID of the provisioned user.\n"
                },
                "twoFactorEnabled": {
                    "type": "boolean",
                    "description": "Whether two-factor authentication is enabled for the provisioned user.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The username of the provisioned user.\n"
                },
                "webUrl": {
                    "type": "string",
                    "description": "The web URL of the provisioned user.\n"
                },
                "websiteUrl": {
                    "type": "string",
                    "description": "The website URL of the provisioned user.\n"
                }
            },
            "type": "object",
            "required": [
                "avatarUrl",
                "bio",
                "bot",
                "confirmedAt",
                "createdAt",
                "email",
                "external",
                "id",
                "jobTitle",
                "lastActivityOn",
                "lastSignInAt",
                "linkedin",
                "location",
                "name",
                "organization",
                "privateProfile",
                "pronouns",
                "publicEmail",
                "skype",
                "state",
                "twitter",
                "twoFactorEnabled",
                "username",
                "webUrl",
                "websiteUrl"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getGroupSharedWithGroup:getGroupSharedWithGroup": {
            "properties": {
                "expiresAt": {
                    "type": "string",
                    "description": "Share with group expiration date.\n"
                },
                "groupAccessLevel": {
                    "type": "integer",
                    "description": "The access_level permission level of the shared group.\n"
                },
                "groupFullPath": {
                    "type": "string",
                    "description": "The full path of the group shared with.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of the group shared with.\n"
                },
                "groupName": {
                    "type": "string",
                    "description": "The name of the group shared with.\n"
                }
            },
            "type": "object",
            "required": [
                "expiresAt",
                "groupAccessLevel",
                "groupFullPath",
                "groupId",
                "groupName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getGroupSubgroupsSubgroup:getGroupSubgroupsSubgroup": {
            "properties": {
                "allowedEmailDomainsList": {
                    "type": "string"
                },
                "autoDevopsEnabled": {
                    "type": "boolean"
                },
                "avatarUrl": {
                    "type": "string"
                },
                "createdAt": {
                    "type": "string"
                },
                "defaultBranchProtection": {
                    "type": "integer"
                },
                "description": {
                    "type": "string"
                },
                "emailsEnabled": {
                    "type": "boolean"
                },
                "fileTemplateProjectId": {
                    "type": "integer"
                },
                "fullName": {
                    "type": "string"
                },
                "fullPath": {
                    "type": "string"
                },
                "groupId": {
                    "type": "integer"
                },
                "ipRestrictionRanges": {
                    "type": "string"
                },
                "lfsEnabled": {
                    "type": "boolean"
                },
                "mentionsDisabled": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string"
                },
                "parentId": {
                    "type": "integer"
                },
                "path": {
                    "type": "string"
                },
                "projectCreationLevel": {
                    "type": "string"
                },
                "requestAccessEnabled": {
                    "type": "boolean"
                },
                "requireTwoFactorAuthentication": {
                    "type": "boolean"
                },
                "shareWithGroupLock": {
                    "type": "boolean"
                },
                "sharedRunnersSetting": {
                    "type": "string"
                },
                "statistics": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "subgroupCreationLevel": {
                    "type": "string"
                },
                "twoFactorGracePeriod": {
                    "type": "integer"
                },
                "visibility": {
                    "type": "string"
                },
                "webUrl": {
                    "type": "string"
                },
                "wikiAccessLevel": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "allowedEmailDomainsList",
                "autoDevopsEnabled",
                "avatarUrl",
                "createdAt",
                "defaultBranchProtection",
                "description",
                "emailsEnabled",
                "fileTemplateProjectId",
                "fullName",
                "fullPath",
                "groupId",
                "ipRestrictionRanges",
                "lfsEnabled",
                "mentionsDisabled",
                "name",
                "parentId",
                "path",
                "projectCreationLevel",
                "requestAccessEnabled",
                "requireTwoFactorAuthentication",
                "shareWithGroupLock",
                "sharedRunnersSetting",
                "statistics",
                "subgroupCreationLevel",
                "twoFactorGracePeriod",
                "visibility",
                "webUrl",
                "wikiAccessLevel"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getGroupVariablesVariable:getGroupVariablesVariable": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "The description of the variable.\n"
                },
                "environmentScope": {
                    "type": "string",
                    "description": "The environment scope of the variable. Defaults to all environment (`*`). Note that in Community Editions of Gitlab, values other than `*` will cause inconsistent plans.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The name or id of the group.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The name of the variable.\n"
                },
                "masked": {
                    "type": "boolean",
                    "description": "If set to `true`, the value of the variable will be hidden in job logs. The value must meet the [masking requirements](https://docs.gitlab.com/ee/ci/variables/#masked-variables). Defaults to `false`.\n"
                },
                "protected": {
                    "type": "boolean",
                    "description": "If set to `true`, the variable will be passed only to pipelines running on protected branches and tags. Defaults to `false`.\n"
                },
                "raw": {
                    "type": "boolean",
                    "description": "Whether the variable is treated as a raw string. Default: false. When true, variables in the value are not expanded.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the variable.\n"
                },
                "variableType": {
                    "type": "string",
                    "description": "The type of a variable. Valid values are: `env_var`, `file`. Default is `env_var`.\n"
                }
            },
            "type": "object",
            "required": [
                "description",
                "environmentScope",
                "group",
                "key",
                "masked",
                "protected",
                "raw",
                "value",
                "variableType"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getGroupsGroup:getGroupsGroup": {
            "properties": {
                "defaultBranchProtection": {
                    "type": "integer",
                    "description": "Whether developers and maintainers can push to the applicable default branch.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the group.\n"
                },
                "fullName": {
                    "type": "string",
                    "description": "The full name of the group.\n"
                },
                "fullPath": {
                    "type": "string",
                    "description": "The full path of the group.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of the group.\n"
                },
                "lfsEnabled": {
                    "type": "boolean",
                    "description": "Boolean, is LFS enabled for projects in this group.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of this group.\n"
                },
                "parentId": {
                    "type": "integer",
                    "description": "Integer, ID of the parent group.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path of the group.\n"
                },
                "preventForkingOutsideGroup": {
                    "type": "boolean",
                    "description": "When enabled, users can not fork projects from this group to external namespaces.\n"
                },
                "requestAccessEnabled": {
                    "type": "boolean",
                    "description": "Boolean, is request for access enabled to the group.\n"
                },
                "runnersToken": {
                    "type": "string",
                    "description": "The group level registration token to use during runner setup.\n",
                    "secret": true
                },
                "sharedRunnersSetting": {
                    "type": "string",
                    "description": "Enable or disable shared runners for a group’s subgroups and projects. Valid values are: `enabled`, `disabled_and_overridable`, `disabled_and_unoverridable`, `disabled_with_override`.\n"
                },
                "visibilityLevel": {
                    "type": "string",
                    "description": "Visibility level of the group. Possible values are `private`, `internal`, `public`.\n"
                },
                "webUrl": {
                    "type": "string",
                    "description": "Web URL of the group.\n"
                },
                "wikiAccessLevel": {
                    "type": "string",
                    "description": "The group's wiki access level. Only available on Premium and Ultimate plans. Valid values are `disabled`, `private`, `enabled`.\n"
                }
            },
            "type": "object",
            "required": [
                "defaultBranchProtection",
                "description",
                "fullName",
                "fullPath",
                "groupId",
                "lfsEnabled",
                "name",
                "parentId",
                "path",
                "preventForkingOutsideGroup",
                "requestAccessEnabled",
                "runnersToken",
                "sharedRunnersSetting",
                "visibilityLevel",
                "webUrl",
                "wikiAccessLevel"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getInstanceDeployKeysDeployKey:getInstanceDeployKeysDeployKey": {
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "The creation date of the deploy key. In RFC3339 format.\n"
                },
                "fingerprint": {
                    "type": "string",
                    "description": "The fingerprint of the deploy key.\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The ID of the deploy key.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The deploy key.\n"
                },
                "projectsWithWriteAccesses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getInstanceDeployKeysDeployKeyProjectsWithWriteAccess:getInstanceDeployKeysDeployKeyProjectsWithWriteAccess"
                    },
                    "description": "The list of projects that the deploy key has write access to.\n"
                },
                "title": {
                    "type": "string",
                    "description": "The title of the deploy key.\n"
                }
            },
            "type": "object",
            "required": [
                "createdAt",
                "fingerprint",
                "id",
                "key",
                "projectsWithWriteAccesses",
                "title"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getInstanceDeployKeysDeployKeyProjectsWithWriteAccess:getInstanceDeployKeysDeployKeyProjectsWithWriteAccess": {
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "The creation date of the project. In RFC3339 format.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the project.\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The ID of the project.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the project.\n"
                },
                "nameWithNamespace": {
                    "type": "string",
                    "description": "The name of the project with namespace.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path of the project.\n"
                },
                "pathWithNamespace": {
                    "type": "string",
                    "description": "The path of the project with namespace.\n"
                }
            },
            "type": "object",
            "required": [
                "createdAt",
                "description",
                "id",
                "name",
                "nameWithNamespace",
                "path",
                "pathWithNamespace"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getInstanceVariablesVariable:getInstanceVariablesVariable": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "The description of the variable. Maximum of 255 characters.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The name of the variable.\n"
                },
                "masked": {
                    "type": "boolean",
                    "description": "If set to `true`, the value of the variable will be hidden in job logs. The value must meet the [masking requirements](https://docs.gitlab.com/ee/ci/variables/#masked-variables). Defaults to `false`.\n"
                },
                "protected": {
                    "type": "boolean",
                    "description": "If set to `true`, the variable will be passed only to pipelines running on protected branches and tags. Defaults to `false`.\n"
                },
                "raw": {
                    "type": "boolean",
                    "description": "Whether the variable is treated as a raw string. Default: false. When true, variables in the value are not expanded.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the variable.\n"
                },
                "variableType": {
                    "type": "string",
                    "description": "The type of a variable. Valid values are: `env_var`, `file`. Default is `env_var`.\n"
                }
            },
            "type": "object",
            "required": [
                "description",
                "key",
                "masked",
                "protected",
                "raw",
                "value",
                "variableType"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getMetadataKas:getMetadataKas": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Indicates whether KAS is enabled.\n"
                },
                "externalK8sProxyUrl": {
                    "type": "string",
                    "description": "URL used by the Kubernetes tooling to communicate with the KAS Kubernetes API proxy. It’s null if kas.enabled is false.\n"
                },
                "externalUrl": {
                    "type": "string",
                    "description": "URL used by the agents to communicate with KAS. It’s null if kas.enabled is false.\n"
                },
                "version": {
                    "type": "string",
                    "description": "Version of KAS. It’s null if kas.enabled is false.\n"
                }
            },
            "type": "object",
            "required": [
                "enabled",
                "externalK8sProxyUrl",
                "externalUrl",
                "version"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getPipelineScheduleLastPipeline:getPipelineScheduleLastPipeline": {
            "properties": {
                "id": {
                    "type": "integer",
                    "description": "The pipeline ID.\n"
                },
                "ref": {
                    "type": "string",
                    "description": "The ref of the pipeline.\n"
                },
                "sha": {
                    "type": "string",
                    "description": "The SHA of the pipeline.\n"
                },
                "status": {
                    "type": "string",
                    "description": "The status of pipelines, one of: created, waiting*for*resource, preparing, pending, running, success, failed, canceled, skipped, manual, scheduled.\n"
                }
            },
            "type": "object",
            "required": [
                "id",
                "ref",
                "sha",
                "status"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getPipelineScheduleOwner:getPipelineScheduleOwner": {
            "properties": {
                "avatarUrl": {
                    "type": "string",
                    "description": "Image URL for the user's avatar.\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The user ID.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name.\n"
                },
                "state": {
                    "type": "string",
                    "description": "User's state, one of: active, blocked.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username.\n"
                },
                "webUrl": {
                    "type": "string",
                    "description": "URL to the user's profile.\n"
                }
            },
            "type": "object",
            "required": [
                "avatarUrl",
                "id",
                "name",
                "state",
                "username",
                "webUrl"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getPipelineScheduleVariable:getPipelineScheduleVariable": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key of a variable.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value of a variable.\n"
                },
                "variableType": {
                    "type": "string",
                    "description": "The type of a variable, one of: env_var and file.\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value",
                "variableType"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getPipelineSchedulesPipelineSchedule:getPipelineSchedulesPipelineSchedule": {
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "The activation status of pipeline schedule.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "The datetime of when the schedule was created.\n"
                },
                "cron": {
                    "type": "string",
                    "description": "The cron (e.g. `0 1 * * *`).\n"
                },
                "cronTimezone": {
                    "type": "string",
                    "description": "The timezone.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the pipeline schedule.\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The pipeline schedule id.\n"
                },
                "nextRunAt": {
                    "type": "string",
                    "description": "The datetime of when the schedule will next run.\n"
                },
                "owner": {
                    "$ref": "#/types/gitlab:index/getPipelineSchedulesPipelineScheduleOwner:getPipelineSchedulesPipelineScheduleOwner",
                    "description": "The details of the pipeline schedule owner.\n"
                },
                "ref": {
                    "type": "string",
                    "description": "The branch/tag name to be triggered. This will be the full branch reference, for example: `refs/heads/main`, not `main`.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "The datetime of when the schedule was last updated.\n"
                }
            },
            "type": "object",
            "required": [
                "active",
                "createdAt",
                "cron",
                "cronTimezone",
                "description",
                "id",
                "nextRunAt",
                "owner",
                "ref",
                "updatedAt"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getPipelineSchedulesPipelineScheduleOwner:getPipelineSchedulesPipelineScheduleOwner": {
            "properties": {
                "avatarUrl": {
                    "type": "string",
                    "description": "Image URL for the user's avatar.\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The user ID.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name.\n"
                },
                "state": {
                    "type": "string",
                    "description": "User's state, one of: active, blocked.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username.\n"
                },
                "webUrl": {
                    "type": "string",
                    "description": "URL to the user's profile.\n"
                }
            },
            "type": "object",
            "required": [
                "avatarUrl",
                "id",
                "name",
                "state",
                "username",
                "webUrl"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectBranchesBranch:getProjectBranchesBranch": {
            "properties": {
                "canPush": {
                    "type": "boolean",
                    "description": "Bool, true if you can push to the branch.\n"
                },
                "commits": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getProjectBranchesBranchCommit:getProjectBranchesBranchCommit"
                    },
                    "description": "The commit associated with this branch.\n"
                },
                "default": {
                    "type": "boolean",
                    "description": "Bool, true if branch is the default branch for the project.\n"
                },
                "developersCanMerge": {
                    "type": "boolean",
                    "description": "Bool, true if developer level access allows to merge branch.\n"
                },
                "developersCanPush": {
                    "type": "boolean",
                    "description": "Bool, true if developer level access allows git push.\n"
                },
                "merged": {
                    "type": "boolean",
                    "description": "Bool, true if the branch has been merged into it's parent.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the branch.\n"
                },
                "protected": {
                    "type": "boolean",
                    "description": "Bool, true if branch has branch protection.\n"
                },
                "webUrl": {
                    "type": "string",
                    "description": "URL that can be used to find the branch in a browser.\n"
                }
            },
            "type": "object",
            "required": [
                "canPush",
                "commits",
                "default",
                "developersCanMerge",
                "developersCanPush",
                "merged",
                "name",
                "protected",
                "webUrl"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectBranchesBranchCommit:getProjectBranchesBranchCommit": {
            "properties": {
                "authorEmail": {
                    "type": "string",
                    "description": "The email of the author.\n"
                },
                "authorName": {
                    "type": "string",
                    "description": "The name of the author.\n"
                },
                "authoredDate": {
                    "type": "string",
                    "description": "The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).\n"
                },
                "committedDate": {
                    "type": "string",
                    "description": "The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).\n"
                },
                "committerEmail": {
                    "type": "string",
                    "description": "The email of the user that committed.\n"
                },
                "committerName": {
                    "type": "string",
                    "description": "The name of the user that committed.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The unique id assigned to the commit by Gitlab.\n"
                },
                "message": {
                    "type": "string",
                    "description": "The commit message\n"
                },
                "parentIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The id of the parents of the commit\n"
                },
                "shortId": {
                    "type": "string",
                    "description": "The short id assigned to the commit by Gitlab.\n"
                },
                "title": {
                    "type": "string",
                    "description": "The title of the commit\n"
                }
            },
            "type": "object",
            "required": [
                "authorEmail",
                "authorName",
                "authoredDate",
                "committedDate",
                "committerEmail",
                "committerName",
                "id",
                "message",
                "parentIds",
                "shortId",
                "title"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectContainerExpirationPolicy:getProjectContainerExpirationPolicy": {
            "properties": {
                "cadence": {
                    "type": "string",
                    "description": "The cadence of the policy. Valid values are: `1d`, `7d`, `14d`, `1month`, `3month`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "If true, the policy is enabled.\n"
                },
                "keepN": {
                    "type": "integer",
                    "description": "The number of images to keep.\n"
                },
                "nameRegex": {
                    "type": "string",
                    "description": "The regular expression to match image names to delete.\n",
                    "deprecationMessage": "`name_regex` has been deprecated. Use `name_regex_delete` instead."
                },
                "nameRegexDelete": {
                    "type": "string",
                    "description": "The regular expression to match image names to delete.\n"
                },
                "nameRegexKeep": {
                    "type": "string",
                    "description": "The regular expression to match image names to keep.\n"
                },
                "nextRunAt": {
                    "type": "string",
                    "description": "The next time the policy will run.\n"
                },
                "olderThan": {
                    "type": "string",
                    "description": "The number of days to keep images.\n"
                }
            },
            "type": "object",
            "required": [
                "cadence",
                "enabled",
                "keepN",
                "nameRegex",
                "nameRegexDelete",
                "nameRegexKeep",
                "nextRunAt",
                "olderThan"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectEnvironmentsEnvironment:getProjectEnvironmentsEnvironment": {
            "properties": {
                "clusterAgentId": {
                    "type": "integer",
                    "description": "The ID of the environments cluster agent or `null` if none is assigned.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Timestamp of the environment creation, RFC3339 format.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the environment.\n"
                },
                "externalUrl": {
                    "type": "string",
                    "description": "Place to link to for this environment.\n"
                },
                "fluxResourcePath": {
                    "type": "string",
                    "description": "The Flux resource path to associate with this environment.\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The ID of the environment.\n"
                },
                "kubernetesNamespace": {
                    "type": "string",
                    "description": "The Kubernetes namespace to associate with this environment.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the environment.\n"
                },
                "slug": {
                    "type": "string",
                    "description": "The simplified version of the environment name, suitable for inclusion in DNS, URLs, Kubernetes labels, and so on. The slug is truncated to 24 characters. A random suffix is automatically added to uppercase environment names.\n"
                },
                "state": {
                    "type": "string",
                    "description": "The state of the environment. Value can be one of `available`, `stopping`, `stopped`. Returns all environments if not set.\n"
                },
                "tier": {
                    "type": "string",
                    "description": "The tier of the environment. Value can be one of `production`, `staging`, `testing`, `development`, `other`. Returns all environments if not set.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "Timestamp of the last environment update, RFC3339 format.\n"
                }
            },
            "type": "object",
            "required": [
                "clusterAgentId",
                "createdAt",
                "description",
                "externalUrl",
                "fluxResourcePath",
                "id",
                "kubernetesNamespace",
                "name",
                "slug",
                "state",
                "tier",
                "updatedAt"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectHooksHook:getProjectHooksHook": {
            "properties": {
                "confidentialIssuesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for confidential issues events.\n"
                },
                "confidentialNoteEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for confidential notes events.\n"
                },
                "customWebhookTemplate": {
                    "type": "string",
                    "description": "Set a custom webhook template.\n"
                },
                "deploymentEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for deployment events.\n"
                },
                "enableSslVerification": {
                    "type": "boolean",
                    "description": "Enable ssl verification when invoking the hook.\n"
                },
                "hookId": {
                    "type": "integer",
                    "description": "The id of the project hook.\n"
                },
                "issuesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for issues events.\n"
                },
                "jobEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for job events.\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for merge requests.\n"
                },
                "noteEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for notes events.\n"
                },
                "pipelineEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for pipeline events.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the hook to.\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "The id of the project for the hook.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for push events.\n"
                },
                "pushEventsBranchFilter": {
                    "type": "string",
                    "description": "Invoke the hook for push events on matching branches only.\n"
                },
                "releasesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for releases events.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for tag push events.\n"
                },
                "token": {
                    "type": "string",
                    "description": "A token to present when invoking the hook. The token is not available for imported resources.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The url of the hook to invoke.\n"
                },
                "wikiPageEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for wiki page events.\n"
                }
            },
            "type": "object",
            "required": [
                "confidentialIssuesEvents",
                "confidentialNoteEvents",
                "customWebhookTemplate",
                "deploymentEvents",
                "enableSslVerification",
                "hookId",
                "issuesEvents",
                "jobEvents",
                "mergeRequestsEvents",
                "noteEvents",
                "pipelineEvents",
                "project",
                "projectId",
                "pushEvents",
                "pushEventsBranchFilter",
                "releasesEvents",
                "tagPushEvents",
                "token",
                "url",
                "wikiPageEvents"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectIssueTaskCompletionStatus:getProjectIssueTaskCompletionStatus": {
            "properties": {
                "completedCount": {
                    "type": "integer",
                    "description": "The number of tasks that are completed.\n"
                },
                "count": {
                    "type": "integer",
                    "description": "The number of tasks.\n"
                }
            },
            "type": "object",
            "required": [
                "completedCount",
                "count"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectIssuesIssue:getProjectIssuesIssue": {
            "properties": {
                "assigneeIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "The IDs of the users to assign the issue to.\n"
                },
                "authorId": {
                    "type": "integer",
                    "description": "The ID of the author of the issue. Use `gitlab.User` data source to get more information about the user.\n"
                },
                "closedAt": {
                    "type": "string",
                    "description": "When the issue was closed. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n"
                },
                "closedByUserId": {
                    "type": "integer",
                    "description": "The ID of the user that closed the issue. Use `gitlab.User` data source to get more information about the user.\n"
                },
                "confidential": {
                    "type": "boolean",
                    "description": "Set an issue to be confidential.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "When the issue was created. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z. Requires administrator or project/group owner rights.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of an issue. Limited to 1,048,576 characters.\n"
                },
                "discussionLocked": {
                    "type": "boolean",
                    "description": "Whether the issue is locked for discussions or not.\n"
                },
                "discussionToResolve": {
                    "type": "string",
                    "description": "The ID of a discussion to resolve. This fills out the issue with a default description and mark the discussion as resolved. Use in combination with merge_request_to_resolve_discussions_of.\n"
                },
                "downvotes": {
                    "type": "integer",
                    "description": "The number of downvotes the issue has received.\n"
                },
                "dueDate": {
                    "type": "string",
                    "description": "The due date. Date time string in the format YYYY-MM-DD, for example 2016-03-11.\n"
                },
                "epicId": {
                    "type": "integer",
                    "description": "ID of the epic to add the issue to. Valid values are greater than or equal to 0.\n"
                },
                "epicIssueId": {
                    "type": "integer",
                    "description": "The ID of the epic issue.\n"
                },
                "externalId": {
                    "type": "string",
                    "description": "The external ID of the issue.\n"
                },
                "humanTimeEstimate": {
                    "type": "string",
                    "description": "The human-readable time estimate of the issue.\n"
                },
                "humanTotalTimeSpent": {
                    "type": "string",
                    "description": "The human-readable total time spent of the issue.\n"
                },
                "iid": {
                    "type": "integer",
                    "description": "The internal ID of the project's issue.\n"
                },
                "issueId": {
                    "type": "integer",
                    "description": "The instance-wide ID of the issue.\n"
                },
                "issueLinkId": {
                    "type": "integer",
                    "description": "The ID of the issue link.\n"
                },
                "issueType": {
                    "type": "string",
                    "description": "The type of issue. Valid values are: `issue`, `incident`, `test_case`.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The labels of an issue.\n"
                },
                "links": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The links of the issue.\n"
                },
                "mergeRequestToResolveDiscussionsOf": {
                    "type": "integer",
                    "description": "The IID of a merge request in which to resolve all issues. This fills out the issue with a default description and mark all discussions as resolved. When passing a description or title, these values take precedence over the default values.\n"
                },
                "mergeRequestsCount": {
                    "type": "integer",
                    "description": "The number of merge requests associated with the issue.\n"
                },
                "milestoneId": {
                    "type": "integer",
                    "description": "The global ID of a milestone to assign issue. To find the milestone_id associated with a milestone, view an issue with the milestone assigned and use the API to retrieve the issue's details.\n"
                },
                "movedToId": {
                    "type": "integer",
                    "description": "The ID of the issue that was moved to.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or ID of the project.\n"
                },
                "references": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The references of the issue.\n"
                },
                "state": {
                    "type": "string",
                    "description": "The state of the issue. Valid values are: `opened`, `closed`.\n"
                },
                "subscribed": {
                    "type": "boolean",
                    "description": "Whether the authenticated user is subscribed to the issue or not.\n"
                },
                "taskCompletionStatuses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getProjectIssuesIssueTaskCompletionStatus:getProjectIssuesIssueTaskCompletionStatus"
                    },
                    "description": "The task completion status. It's always a one element list.\n"
                },
                "timeEstimate": {
                    "type": "integer",
                    "description": "The time estimate of the issue.\n"
                },
                "title": {
                    "type": "string",
                    "description": "The title of the issue.\n"
                },
                "totalTimeSpent": {
                    "type": "integer",
                    "description": "The total time spent of the issue.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "When the issue was updated. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n"
                },
                "upvotes": {
                    "type": "integer",
                    "description": "The number of upvotes the issue has received.\n"
                },
                "userNotesCount": {
                    "type": "integer",
                    "description": "The number of user notes on the issue.\n"
                },
                "webUrl": {
                    "type": "string",
                    "description": "The web URL of the issue.\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "The weight of the issue. Valid values are greater than or equal to 0.\n"
                }
            },
            "type": "object",
            "required": [
                "assigneeIds",
                "authorId",
                "closedAt",
                "closedByUserId",
                "confidential",
                "createdAt",
                "description",
                "discussionLocked",
                "discussionToResolve",
                "downvotes",
                "dueDate",
                "epicId",
                "epicIssueId",
                "externalId",
                "humanTimeEstimate",
                "humanTotalTimeSpent",
                "iid",
                "issueId",
                "issueLinkId",
                "issueType",
                "labels",
                "links",
                "mergeRequestToResolveDiscussionsOf",
                "mergeRequestsCount",
                "milestoneId",
                "movedToId",
                "project",
                "references",
                "state",
                "subscribed",
                "taskCompletionStatuses",
                "timeEstimate",
                "title",
                "totalTimeSpent",
                "updatedAt",
                "upvotes",
                "userNotesCount",
                "webUrl",
                "weight"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectIssuesIssueTaskCompletionStatus:getProjectIssuesIssueTaskCompletionStatus": {
            "properties": {
                "completedCount": {
                    "type": "integer",
                    "description": "The number of tasks that are completed.\n"
                },
                "count": {
                    "type": "integer",
                    "description": "The number of tasks.\n"
                }
            },
            "type": "object",
            "required": [
                "completedCount",
                "count"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectMembershipMember:getProjectMembershipMember": {
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "The level of access to the group.\n"
                },
                "avatarUrl": {
                    "type": "string",
                    "description": "The avatar URL of the user.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "Expiration date for the group membership.\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The unique id assigned to the user by the gitlab server.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the user.\n"
                },
                "state": {
                    "type": "string",
                    "description": "Whether the user is active or blocked.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The username of the user.\n"
                },
                "webUrl": {
                    "type": "string",
                    "description": "User's website URL.\n"
                }
            },
            "type": "object",
            "required": [
                "accessLevel",
                "avatarUrl",
                "expiresAt",
                "id",
                "name",
                "state",
                "username",
                "webUrl"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectMergeRequestAssignee:getProjectMergeRequestAssignee": {
            "properties": {
                "avatarUrl": {
                    "type": "string",
                    "description": "A link to the user's avatar image.\n"
                },
                "id": {
                    "type": "number",
                    "description": "The internal ID number of the user.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the user.\n"
                },
                "state": {
                    "type": "string",
                    "description": "The state of the user account.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The username of the user.\n"
                },
                "webUrl": {
                    "type": "string",
                    "description": "A link to the user's profile page.\n"
                }
            },
            "type": "object",
            "required": [
                "avatarUrl",
                "id",
                "name",
                "state",
                "username",
                "webUrl"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectMergeRequestAuthor:getProjectMergeRequestAuthor": {
            "properties": {
                "avatarUrl": {
                    "type": "string",
                    "description": "A link to the user's avatar image.\n"
                },
                "id": {
                    "type": "number",
                    "description": "The internal ID number of the user.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the user.\n"
                },
                "state": {
                    "type": "string",
                    "description": "The state of the user account.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The username of the user.\n"
                },
                "webUrl": {
                    "type": "string",
                    "description": "A link to the user's profile page.\n"
                }
            },
            "type": "object",
            "required": [
                "avatarUrl",
                "id",
                "name",
                "state",
                "username",
                "webUrl"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectMergeRequestClosedBy:getProjectMergeRequestClosedBy": {
            "properties": {
                "avatarUrl": {
                    "type": "string",
                    "description": "A link to the user's avatar image.\n"
                },
                "id": {
                    "type": "number",
                    "description": "The internal ID number of the user.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the user.\n"
                },
                "state": {
                    "type": "string",
                    "description": "The state of the user account.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The username of the user.\n"
                },
                "webUrl": {
                    "type": "string",
                    "description": "A link to the user's profile page.\n"
                }
            },
            "type": "object",
            "required": [
                "avatarUrl",
                "id",
                "name",
                "state",
                "username",
                "webUrl"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectMilestonesMilestone:getProjectMilestonesMilestone": {
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "The time of creation of the milestone. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the milestone.\n"
                },
                "dueDate": {
                    "type": "string",
                    "description": "The due date of the milestone. Date time string in the format YYYY-MM-DD, for example 2016-03-11.\n"
                },
                "expired": {
                    "type": "boolean",
                    "description": "Bool, true if milestone expired.\n"
                },
                "iid": {
                    "type": "integer",
                    "description": "The ID of the project's milestone.\n"
                },
                "milestoneId": {
                    "type": "integer",
                    "description": "The instance-wide ID of the project’s milestone.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "The project ID of milestone.\n"
                },
                "startDate": {
                    "type": "string",
                    "description": "The start date of the milestone. Date time string in the format YYYY-MM-DD, for example 2016-03-11.\n"
                },
                "state": {
                    "type": "string",
                    "description": "The state of the milestone. Valid values are: `active`, `closed`.\n"
                },
                "title": {
                    "type": "string",
                    "description": "The title of a milestone.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "The last update time of the milestone. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n"
                },
                "webUrl": {
                    "type": "string",
                    "description": "The web URL of the milestone.\n"
                }
            },
            "type": "object",
            "required": [
                "createdAt",
                "description",
                "dueDate",
                "expired",
                "iid",
                "milestoneId",
                "project",
                "projectId",
                "startDate",
                "state",
                "title",
                "updatedAt",
                "webUrl"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectProtectedBranchMergeAccessLevel:getProjectProtectedBranchMergeAccessLevel": {
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`.\n"
                },
                "accessLevelDescription": {
                    "type": "string",
                    "description": "Readable description of access level.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.\n"
                }
            },
            "type": "object",
            "required": [
                "accessLevel",
                "accessLevelDescription"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectProtectedBranchPushAccessLevel:getProjectProtectedBranchPushAccessLevel": {
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`.\n"
                },
                "accessLevelDescription": {
                    "type": "string",
                    "description": "Readable description of access level.\n"
                },
                "deployKeyId": {
                    "type": "integer",
                    "description": "The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `group_id` and `user_id`. This field is read-only until Gitlab 17.5.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `user_id`.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `group_id`.\n"
                }
            },
            "type": "object",
            "required": [
                "accessLevel",
                "accessLevelDescription"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectProtectedBranchesProtectedBranch:getProjectProtectedBranchesProtectedBranch": {
            "properties": {
                "allowForcePush": {
                    "type": "boolean",
                    "description": "Whether force push is allowed.\n"
                },
                "codeOwnerApprovalRequired": {
                    "type": "boolean",
                    "description": "Reject code pushes that change files listed in the CODEOWNERS file.\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The ID of this resource.\n"
                },
                "mergeAccessLevels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getProjectProtectedBranchesProtectedBranchMergeAccessLevel:getProjectProtectedBranchesProtectedBranchMergeAccessLevel"
                    },
                    "description": "Array of access levels and user(s)/group(s) allowed to merge to protected branch.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the protected branch.\n"
                },
                "pushAccessLevels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getProjectProtectedBranchesProtectedBranchPushAccessLevel:getProjectProtectedBranchesProtectedBranchPushAccessLevel"
                    },
                    "description": "Array of access levels and user(s)/group(s) allowed to push to protected branch.\n"
                }
            },
            "type": "object",
            "required": [
                "allowForcePush",
                "codeOwnerApprovalRequired",
                "id",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectProtectedBranchesProtectedBranchMergeAccessLevel:getProjectProtectedBranchesProtectedBranchMergeAccessLevel": {
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Access levels allowed to merge to protected branch. Valid values are: `no one`, `developer`, `maintainer`.\n"
                },
                "accessLevelDescription": {
                    "type": "string",
                    "description": "Readable description of access level.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `user_id`.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `group_id`.\n"
                }
            },
            "type": "object",
            "required": [
                "accessLevel",
                "accessLevelDescription"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectProtectedBranchesProtectedBranchPushAccessLevel:getProjectProtectedBranchesProtectedBranchPushAccessLevel": {
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Access levels allowed to push to protected branch. Valid values are: `no one`, `developer`, `maintainer`.\n"
                },
                "accessLevelDescription": {
                    "type": "string",
                    "description": "Readable description of access level.\n"
                },
                "deployKeyId": {
                    "type": "integer",
                    "description": "The ID of a GitLab deploy key allowed to perform the relevant action. Mutually exclusive with `group_id` and `user_id`. This field is read-only until Gitlab 17.5.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of a GitLab group allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `user_id`.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID of a GitLab user allowed to perform the relevant action. Mutually exclusive with `deploy_key_id` and `group_id`.\n"
                }
            },
            "type": "object",
            "required": [
                "accessLevel",
                "accessLevelDescription"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectProtectedTagCreateAccessLevel:getProjectProtectedTagCreateAccessLevel": {
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Access level allowed to create protected tags.\n"
                },
                "accessLevelDescription": {
                    "type": "string",
                    "description": "Readable description of access level.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of a GitLab group allowed to perform the relevant action.\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The ID of the create access level.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID of a GitLab user allowed to perform the relevant action.\n"
                }
            },
            "type": "object",
            "required": [
                "accessLevel",
                "accessLevelDescription",
                "id"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectProtectedTagsProtectedTag:getProjectProtectedTagsProtectedTag": {
            "properties": {
                "createAccessLevels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getProjectProtectedTagsProtectedTagCreateAccessLevel:getProjectProtectedTagsProtectedTagCreateAccessLevel"
                    },
                    "description": "Array of access levels/user(s)/group(s) allowed to create protected tags.\n"
                },
                "tag": {
                    "type": "string",
                    "description": "The name of the protected tag.\n"
                }
            },
            "type": "object",
            "required": [
                "createAccessLevels",
                "tag"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectProtectedTagsProtectedTagCreateAccessLevel:getProjectProtectedTagsProtectedTagCreateAccessLevel": {
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Access level allowed to create protected tags.\n"
                },
                "accessLevelDescription": {
                    "type": "string",
                    "description": "Readable description of access level.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of a GitLab group allowed to perform the relevant action.\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The ID of the create access level.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID of a GitLab user allowed to perform the relevant action.\n"
                }
            },
            "type": "object",
            "required": [
                "accessLevel",
                "accessLevelDescription",
                "id"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectPushRule:getProjectPushRule": {
            "properties": {
                "authorEmailRegex": {
                    "type": "string",
                    "description": "All commit author emails must match this regex, e.g. `@my-company.com$`.\n"
                },
                "branchNameRegex": {
                    "type": "string",
                    "description": "All branch names must match this regex, e.g. `(feature|hotfix)\\/*`.\n"
                },
                "commitCommitterCheck": {
                    "type": "boolean",
                    "description": "Users can only push commits to this repository that were committed with one of their own verified emails.\n"
                },
                "commitCommitterNameCheck": {
                    "type": "boolean",
                    "description": "Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.\n"
                },
                "commitMessageNegativeRegex": {
                    "type": "string",
                    "description": "No commit message is allowed to match this regex, for example `ssh\\:\\/\\/`.\n"
                },
                "commitMessageRegex": {
                    "type": "string",
                    "description": "All commit messages must match this regex, e.g. `Fixed \\d+\\..*`.\n"
                },
                "denyDeleteTag": {
                    "type": "boolean",
                    "description": "Deny deleting a tag.\n"
                },
                "fileNameRegex": {
                    "type": "string",
                    "description": "All committed filenames must not match this regex, e.g. `(jar|exe)$`.\n"
                },
                "maxFileSize": {
                    "type": "integer",
                    "description": "Maximum file size (MB).\n"
                },
                "memberCheck": {
                    "type": "boolean",
                    "description": "Restrict commits by author (email) to existing GitLab users.\n"
                },
                "preventSecrets": {
                    "type": "boolean",
                    "description": "GitLab will reject any files that are likely to contain secrets.\n"
                },
                "rejectNonDcoCommits": {
                    "type": "boolean",
                    "description": "Reject commit when it’s not DCO certified.\n"
                },
                "rejectUnsignedCommits": {
                    "type": "boolean",
                    "description": "Reject commit when it’s not signed through GPG.\n"
                }
            },
            "type": "object",
            "required": [
                "authorEmailRegex",
                "branchNameRegex",
                "commitCommitterCheck",
                "commitCommitterNameCheck",
                "commitMessageNegativeRegex",
                "commitMessageRegex",
                "denyDeleteTag",
                "fileNameRegex",
                "maxFileSize",
                "memberCheck",
                "preventSecrets",
                "rejectNonDcoCommits",
                "rejectUnsignedCommits"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectSharedWithGroup:getProjectSharedWithGroup": {
            "properties": {
                "groupAccessLevel": {
                    "type": "integer",
                    "description": "The access_level permission level of the shared group.\n"
                },
                "groupFullPath": {
                    "type": "string",
                    "description": "The full path of the group shared with.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of the group shared with.\n"
                },
                "groupName": {
                    "type": "string",
                    "description": "The name of the group shared with.\n"
                }
            },
            "type": "object",
            "required": [
                "groupAccessLevel",
                "groupFullPath",
                "groupId",
                "groupName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectTagCommit:getProjectTagCommit": {
            "properties": {
                "authorEmail": {
                    "type": "string",
                    "description": "The email of the author.\n"
                },
                "authorName": {
                    "type": "string",
                    "description": "The name of the author.\n"
                },
                "authoredDate": {
                    "type": "string",
                    "description": "The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).\n"
                },
                "committedDate": {
                    "type": "string",
                    "description": "The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).\n"
                },
                "committerEmail": {
                    "type": "string",
                    "description": "The email of the user that committed.\n"
                },
                "committerName": {
                    "type": "string",
                    "description": "The name of the user that committed.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The unique id assigned to the commit by Gitlab.\n"
                },
                "message": {
                    "type": "string",
                    "description": "The commit message\n"
                },
                "parentIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The id of the parents of the commit\n"
                },
                "shortId": {
                    "type": "string",
                    "description": "The short id assigned to the commit by Gitlab.\n"
                },
                "title": {
                    "type": "string",
                    "description": "The title of the commit\n"
                }
            },
            "type": "object",
            "required": [
                "authorEmail",
                "authorName",
                "authoredDate",
                "committedDate",
                "committerEmail",
                "committerName",
                "id",
                "message",
                "parentIds",
                "shortId",
                "title"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectTagRelease:getProjectTagRelease": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "The description of release.\n"
                },
                "tagName": {
                    "type": "string",
                    "description": "The name of the tag.\n"
                }
            },
            "type": "object",
            "required": [
                "description",
                "tagName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectTagsTag:getProjectTagsTag": {
            "properties": {
                "commits": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getProjectTagsTagCommit:getProjectTagsTagCommit"
                    },
                    "description": "The commit associated with the tag.\n"
                },
                "message": {
                    "type": "string",
                    "description": "The message of the annotated tag.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of a tag.\n"
                },
                "protected": {
                    "type": "boolean",
                    "description": "Bool, true if tag has tag protection.\n"
                },
                "releases": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getProjectTagsTagRelease:getProjectTagsTagRelease"
                    },
                    "description": "The release associated with the tag.\n"
                },
                "target": {
                    "type": "string",
                    "description": "The unique id assigned to the commit by Gitlab.\n"
                }
            },
            "type": "object",
            "required": [
                "commits",
                "message",
                "name",
                "protected",
                "releases",
                "target"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectTagsTagCommit:getProjectTagsTagCommit": {
            "properties": {
                "authorEmail": {
                    "type": "string",
                    "description": "The email of the author.\n"
                },
                "authorName": {
                    "type": "string",
                    "description": "The name of the author.\n"
                },
                "authoredDate": {
                    "type": "string",
                    "description": "The date which the commit was authored (format: yyyy-MM-ddTHH:mm:ssZ).\n"
                },
                "committedDate": {
                    "type": "string",
                    "description": "The date at which the commit was pushed (format: yyyy-MM-ddTHH:mm:ssZ).\n"
                },
                "committerEmail": {
                    "type": "string",
                    "description": "The email of the user that committed.\n"
                },
                "committerName": {
                    "type": "string",
                    "description": "The name of the user that committed.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The unique id assigned to the commit by Gitlab.\n"
                },
                "message": {
                    "type": "string",
                    "description": "The commit message\n"
                },
                "parentIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The id of the parents of the commit\n"
                },
                "shortId": {
                    "type": "string",
                    "description": "The short id assigned to the commit by Gitlab.\n"
                },
                "title": {
                    "type": "string",
                    "description": "The title of the commit\n"
                }
            },
            "type": "object",
            "required": [
                "authorEmail",
                "authorName",
                "authoredDate",
                "committedDate",
                "committerEmail",
                "committerName",
                "id",
                "message",
                "parentIds",
                "shortId",
                "title"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectTagsTagRelease:getProjectTagsTagRelease": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "The description of release.\n"
                },
                "tagName": {
                    "type": "string",
                    "description": "The name of the tag.\n"
                }
            },
            "type": "object",
            "required": [
                "description",
                "tagName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectVariablesVariable:getProjectVariablesVariable": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "The description of the variable.\n"
                },
                "environmentScope": {
                    "type": "string",
                    "description": "The environment scope of the variable. Defaults to all environment (`*`). Note that in Community Editions of Gitlab, values other than `*` will cause inconsistent plans.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The name of the variable.\n"
                },
                "masked": {
                    "type": "boolean",
                    "description": "If set to `true`, the value of the variable will be hidden in job logs. The value must meet the [masking requirements](https://docs.gitlab.com/ee/ci/variables/#masked-variables). Defaults to `false`.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project.\n"
                },
                "protected": {
                    "type": "boolean",
                    "description": "If set to `true`, the variable will be passed only to pipelines running on protected branches and tags. Defaults to `false`.\n"
                },
                "raw": {
                    "type": "boolean",
                    "description": "Whether the variable is treated as a raw string. Default: false. When true, variables in the value are not expanded.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the variable.\n"
                },
                "variableType": {
                    "type": "string",
                    "description": "The type of a variable. Valid values are: `env_var`, `file`. Default is `env_var`.\n"
                }
            },
            "type": "object",
            "required": [
                "description",
                "environmentScope",
                "key",
                "masked",
                "project",
                "protected",
                "raw",
                "value",
                "variableType"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectsProject:getProjectsProject": {
            "properties": {
                "_links": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Links for the project.\n"
                },
                "allowMergeOnSkippedPipeline": {
                    "type": "boolean",
                    "description": "Whether allow_merge_on_skipped_pipeline is enabled for the project.\n"
                },
                "allowPipelineTriggerApproveDeployment": {
                    "type": "boolean",
                    "description": "Set whether or not a pipeline triggerer is allowed to approve deployments. Premium and Ultimate only.\n"
                },
                "analyticsAccessLevel": {
                    "type": "string",
                    "description": "Set the analytics access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "approvalsBeforeMerge": {
                    "type": "integer",
                    "description": "The numbers of approvals needed in a merge requests.\n"
                },
                "archived": {
                    "type": "boolean",
                    "description": "Whether the project is archived.\n"
                },
                "autoCancelPendingPipelines": {
                    "type": "string",
                    "description": "Auto-cancel pending pipelines. This isn’t a boolean, but enabled/disabled.\n"
                },
                "autoDevopsDeployStrategy": {
                    "type": "string",
                    "description": "Auto Deploy strategy. Valid values are `continuous`, `manual`, `timed_incremental`.\n"
                },
                "autoDevopsEnabled": {
                    "type": "boolean",
                    "description": "Enable Auto DevOps for this project.\n"
                },
                "autocloseReferencedIssues": {
                    "type": "boolean",
                    "description": "Set whether auto-closing referenced issues on default branch.\n"
                },
                "avatarUrl": {
                    "type": "string",
                    "description": "The avatar url of the project.\n"
                },
                "buildCoverageRegex": {
                    "type": "string",
                    "description": "Build coverage regex for the project.\n"
                },
                "buildGitStrategy": {
                    "type": "string",
                    "description": "The Git strategy. Defaults to fetch.\n"
                },
                "buildTimeout": {
                    "type": "integer",
                    "description": "The maximum amount of time, in seconds, that a job can run.\n"
                },
                "buildsAccessLevel": {
                    "type": "string",
                    "description": "Set the builds access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "ciConfigPath": {
                    "type": "string",
                    "description": "CI config file path for the project.\n"
                },
                "ciDefaultGitDepth": {
                    "type": "integer",
                    "description": "Default number of revisions for shallow cloning.\n"
                },
                "ciForwardDeploymentEnabled": {
                    "type": "boolean",
                    "description": "When a new deployment job starts, skip older deployment jobs that are still pending.\n"
                },
                "ciPipelineVariablesMinimumOverrideRole": {
                    "type": "string",
                    "description": "The minimum role required to set variables when running pipelines and jobs. Introduced in GitLab 17.1. Valid values are `developer`, `maintainer`, `owner`, `no_one_allowed`\n"
                },
                "ciRestrictPipelineCancellationRole": {
                    "type": "string",
                    "description": "The role required to cancel a pipeline or job. Introduced in GitLab 16.8. Premium and Ultimate only. Valid values are `developer`, `maintainer`, `no one`\n"
                },
                "containerExpirationPolicies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getProjectsProjectContainerExpirationPolicy:getProjectsProjectContainerExpirationPolicy"
                    },
                    "description": "Set the image cleanup policy for this project. **Note**: this field is sometimes named `container_expiration_policy_attributes` in the GitLab Upstream API.\n"
                },
                "containerRegistryAccessLevel": {
                    "type": "string",
                    "description": "Set visibility of container registry, for this project. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "containerRegistryEnabled": {
                    "type": "boolean",
                    "description": "Whether the container registry is enabled for the project.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Creation time for the project.\n"
                },
                "creatorId": {
                    "type": "integer",
                    "description": "Creator ID for the project.\n"
                },
                "customAttributes": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    },
                    "description": "Custom attributes for the project.\n"
                },
                "defaultBranch": {
                    "type": "string",
                    "description": "The default branch name of the project.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the project.\n"
                },
                "emailsEnabled": {
                    "type": "boolean",
                    "description": "Enable email notifications.\n"
                },
                "emptyRepo": {
                    "type": "boolean",
                    "description": "Whether the project is empty.\n"
                },
                "environmentsAccessLevel": {
                    "type": "string",
                    "description": "Set the environments access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "externalAuthorizationClassificationLabel": {
                    "type": "string",
                    "description": "The classification label for the project.\n"
                },
                "featureFlagsAccessLevel": {
                    "type": "string",
                    "description": "Set the feature flags access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "forkedFromProjects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getProjectsProjectForkedFromProject:getProjectsProjectForkedFromProject"
                    },
                    "description": "Present if the project is a fork. Contains information about the upstream project.\n"
                },
                "forkingAccessLevel": {
                    "type": "string",
                    "description": "Set the forking access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "forksCount": {
                    "type": "integer",
                    "description": "The number of forks of the project.\n"
                },
                "groupRunnersEnabled": {
                    "type": "boolean",
                    "description": "Whether group runners are enabled for the project.\n"
                },
                "httpUrlToRepo": {
                    "type": "string",
                    "description": "The HTTP clone URL of the project.\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The ID of the project.\n"
                },
                "importError": {
                    "type": "string",
                    "description": "The import error, if it exists, for the project.\n"
                },
                "importStatus": {
                    "type": "string",
                    "description": "The import status of the project.\n"
                },
                "importUrl": {
                    "type": "string",
                    "description": "URL the project was imported from.\n"
                },
                "infrastructureAccessLevel": {
                    "type": "string",
                    "description": "Set the infrastructure access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "issuesAccessLevel": {
                    "type": "string",
                    "description": "Set the issues access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "issuesEnabled": {
                    "type": "boolean",
                    "description": "Whether issues are enabled for the project.\n"
                },
                "jobsEnabled": {
                    "type": "boolean",
                    "description": "Whether pipelines are enabled for the project.\n"
                },
                "keepLatestArtifact": {
                    "type": "boolean",
                    "description": "Disable or enable the ability to keep the latest artifact for this project.\n"
                },
                "lastActivityAt": {
                    "type": "string",
                    "description": "Last activirty time for the project.\n"
                },
                "lfsEnabled": {
                    "type": "boolean",
                    "description": "Whether LFS (large file storage) is enabled for the project.\n"
                },
                "mergeCommitTemplate": {
                    "type": "string",
                    "description": "Template used to create merge commit message in merge requests. (Introduced in GitLab 14.5.)\n"
                },
                "mergeMethod": {
                    "type": "string",
                    "description": "Merge method for the project.\n"
                },
                "mergePipelinesEnabled": {
                    "type": "boolean",
                    "description": "Enable or disable merge pipelines.\n"
                },
                "mergeRequestsAccessLevel": {
                    "type": "string",
                    "description": "Set the merge requests access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "mergeRequestsEnabled": {
                    "type": "boolean",
                    "description": "Whether merge requests are enabled for the project.\n"
                },
                "mergeTrainsEnabled": {
                    "type": "boolean",
                    "description": "Enable or disable merge trains.\n"
                },
                "mirror": {
                    "type": "boolean",
                    "description": "Whether the pull mirroring is enabled for the project.\n"
                },
                "mirrorOverwritesDivergedBranches": {
                    "type": "boolean",
                    "description": "Whether mirror_overwrites_diverged_branches is enabled for the project.\n"
                },
                "mirrorTriggerBuilds": {
                    "type": "boolean",
                    "description": "Whether pull mirroring triggers builds for the project.\n"
                },
                "mirrorUserId": {
                    "type": "integer",
                    "description": "The mirror user ID for the project.\n"
                },
                "modelExperimentsAccessLevel": {
                    "type": "string",
                    "description": "The visibility of machine learning model experiments.\n"
                },
                "modelRegistryAccessLevel": {
                    "type": "string",
                    "description": "The visibility of machine learning model registry.\n"
                },
                "monitorAccessLevel": {
                    "type": "string",
                    "description": "Set the monitor access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the project.\n"
                },
                "nameWithNamespace": {
                    "type": "string",
                    "description": "In `group / subgroup / project` or `user / project` format.\n"
                },
                "namespaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getProjectsProjectNamespace:getProjectsProjectNamespace"
                    },
                    "description": "Namespace of the project (parent group/s).\n"
                },
                "onlyAllowMergeIfAllDiscussionsAreResolved": {
                    "type": "boolean",
                    "description": "Whether only_allow_merge_if_all_discussions_are_resolved is enabled for the project.\n"
                },
                "onlyAllowMergeIfPipelineSucceeds": {
                    "type": "boolean",
                    "description": "Whether only_allow_merge_if_pipeline_succeeds is enabled for the project.\n"
                },
                "onlyMirrorProtectedBranches": {
                    "type": "boolean",
                    "description": "Whether only_mirror_protected_branches is enabled for the project.\n"
                },
                "openIssuesCount": {
                    "type": "integer",
                    "description": "The number of open issies for the project.\n"
                },
                "owners": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getProjectsProjectOwner:getProjectsProjectOwner"
                    }
                },
                "packagesEnabled": {
                    "type": "boolean",
                    "description": "Whether packages are enabled for the project.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path of the project.\n"
                },
                "pathWithNamespace": {
                    "type": "string",
                    "description": "In `group/subgroup/project` or `user/project` format.\n"
                },
                "permissions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getProjectsProjectPermission:getProjectsProjectPermission"
                    },
                    "description": "Permissions for the project.\n"
                },
                "publicBuilds": {
                    "type": "boolean",
                    "description": "Whether public builds are enabled for the project.\n"
                },
                "readmeUrl": {
                    "type": "string",
                    "description": "The remote url of the project.\n"
                },
                "releasesAccessLevel": {
                    "type": "string",
                    "description": "Set the releases access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "repositoryAccessLevel": {
                    "type": "string",
                    "description": "Set the repository access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "repositoryStorage": {
                    "type": "string",
                    "description": "Which storage shard the repository is on. (administrator only)\n"
                },
                "requestAccessEnabled": {
                    "type": "boolean",
                    "description": "Whether requesting access is enabled for the project.\n"
                },
                "requirementsAccessLevel": {
                    "type": "string",
                    "description": "Set the requirements access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "resolveOutdatedDiffDiscussions": {
                    "type": "boolean",
                    "description": "Whether resolve_outdated_diff_discussions is enabled for the project\n"
                },
                "restrictUserDefinedVariables": {
                    "type": "boolean",
                    "description": "Allow only users with the Maintainer role to pass user-defined variables when triggering a pipeline.\n"
                },
                "runnersToken": {
                    "type": "string",
                    "description": "The runners token for the project.\n",
                    "secret": true
                },
                "securityAndComplianceAccessLevel": {
                    "type": "string",
                    "description": "Set the security and compliance access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "sharedRunnersEnabled": {
                    "type": "boolean",
                    "description": "Whether shared runners are enabled for the project.\n"
                },
                "sharedWithGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getProjectsProjectSharedWithGroup:getProjectsProjectSharedWithGroup"
                    },
                    "description": "Groups the the project is shared with.\n"
                },
                "snippetsAccessLevel": {
                    "type": "string",
                    "description": "Set the snippets access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "snippetsEnabled": {
                    "type": "boolean",
                    "description": "Whether snippets are enabled for the project.\n"
                },
                "squashCommitTemplate": {
                    "type": "string",
                    "description": "Template used to create squash commit message in merge requests. (Introduced in GitLab 14.6.)\n"
                },
                "sshUrlToRepo": {
                    "type": "string",
                    "description": "The SSH clone URL of the project.\n"
                },
                "starCount": {
                    "type": "integer",
                    "description": "The number of stars on the project.\n"
                },
                "statistics": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "integer"
                    },
                    "description": "Statistics for the project.\n"
                },
                "suggestionCommitMessage": {
                    "type": "string",
                    "description": "The commit message used to apply merge request suggestions.\n"
                },
                "tagLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of the project topics (formerly called \"project tags\").\n"
                },
                "topics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of topics for the project.\n"
                },
                "visibility": {
                    "type": "string",
                    "description": "The visibility of the project.\n"
                },
                "webUrl": {
                    "type": "string",
                    "description": "The web url of the project.\n"
                },
                "wikiAccessLevel": {
                    "type": "string",
                    "description": "Set the wiki access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "wikiEnabled": {
                    "type": "boolean",
                    "description": "Whether wiki is enabled for the project.\n"
                }
            },
            "type": "object",
            "required": [
                "_links",
                "allowMergeOnSkippedPipeline",
                "allowPipelineTriggerApproveDeployment",
                "analyticsAccessLevel",
                "approvalsBeforeMerge",
                "archived",
                "autoCancelPendingPipelines",
                "autoDevopsDeployStrategy",
                "autoDevopsEnabled",
                "autocloseReferencedIssues",
                "avatarUrl",
                "buildCoverageRegex",
                "buildGitStrategy",
                "buildTimeout",
                "buildsAccessLevel",
                "ciConfigPath",
                "ciDefaultGitDepth",
                "ciForwardDeploymentEnabled",
                "ciPipelineVariablesMinimumOverrideRole",
                "ciRestrictPipelineCancellationRole",
                "containerExpirationPolicies",
                "containerRegistryAccessLevel",
                "containerRegistryEnabled",
                "createdAt",
                "creatorId",
                "customAttributes",
                "defaultBranch",
                "description",
                "emailsEnabled",
                "emptyRepo",
                "environmentsAccessLevel",
                "externalAuthorizationClassificationLabel",
                "featureFlagsAccessLevel",
                "forkedFromProjects",
                "forkingAccessLevel",
                "forksCount",
                "groupRunnersEnabled",
                "httpUrlToRepo",
                "id",
                "importError",
                "importStatus",
                "importUrl",
                "infrastructureAccessLevel",
                "issuesAccessLevel",
                "issuesEnabled",
                "jobsEnabled",
                "keepLatestArtifact",
                "lastActivityAt",
                "lfsEnabled",
                "mergeCommitTemplate",
                "mergeMethod",
                "mergePipelinesEnabled",
                "mergeRequestsAccessLevel",
                "mergeRequestsEnabled",
                "mergeTrainsEnabled",
                "mirror",
                "mirrorOverwritesDivergedBranches",
                "mirrorTriggerBuilds",
                "mirrorUserId",
                "modelExperimentsAccessLevel",
                "modelRegistryAccessLevel",
                "monitorAccessLevel",
                "name",
                "nameWithNamespace",
                "namespaces",
                "onlyAllowMergeIfAllDiscussionsAreResolved",
                "onlyAllowMergeIfPipelineSucceeds",
                "onlyMirrorProtectedBranches",
                "openIssuesCount",
                "owners",
                "packagesEnabled",
                "path",
                "pathWithNamespace",
                "permissions",
                "publicBuilds",
                "readmeUrl",
                "releasesAccessLevel",
                "repositoryAccessLevel",
                "repositoryStorage",
                "requestAccessEnabled",
                "requirementsAccessLevel",
                "resolveOutdatedDiffDiscussions",
                "restrictUserDefinedVariables",
                "runnersToken",
                "securityAndComplianceAccessLevel",
                "sharedRunnersEnabled",
                "sharedWithGroups",
                "snippetsAccessLevel",
                "snippetsEnabled",
                "squashCommitTemplate",
                "sshUrlToRepo",
                "starCount",
                "statistics",
                "suggestionCommitMessage",
                "tagLists",
                "topics",
                "visibility",
                "webUrl",
                "wikiAccessLevel",
                "wikiEnabled"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectsProjectContainerExpirationPolicy:getProjectsProjectContainerExpirationPolicy": {
            "properties": {
                "cadence": {
                    "type": "string",
                    "description": "The cadence of the policy. Valid values are: `1d`, `7d`, `14d`, `1month`, `3month`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "If true, the policy is enabled.\n"
                },
                "keepN": {
                    "type": "integer",
                    "description": "The number of images to keep.\n"
                },
                "nameRegex": {
                    "type": "string",
                    "description": "The regular expression to match image names to delete.\n",
                    "deprecationMessage": "`name_regex` has been deprecated. Use `name_regex_delete` instead."
                },
                "nameRegexDelete": {
                    "type": "string",
                    "description": "The regular expression to match image names to delete.\n"
                },
                "nameRegexKeep": {
                    "type": "string",
                    "description": "The regular expression to match image names to keep.\n"
                },
                "nextRunAt": {
                    "type": "string",
                    "description": "The next time the policy will run.\n"
                },
                "olderThan": {
                    "type": "string",
                    "description": "The number of days to keep images.\n"
                }
            },
            "type": "object",
            "required": [
                "cadence",
                "enabled",
                "keepN",
                "nameRegex",
                "nameRegexDelete",
                "nameRegexKeep",
                "nextRunAt",
                "olderThan"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectsProjectForkedFromProject:getProjectsProjectForkedFromProject": {
            "properties": {
                "httpUrlToRepo": {
                    "type": "string",
                    "description": "The HTTP clone URL of the upstream project.\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The ID of the upstream project.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the upstream project.\n"
                },
                "nameWithNamespace": {
                    "type": "string",
                    "description": "In `group / subgroup / project` or `user / project` format.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path of the upstream project.\n"
                },
                "pathWithNamespace": {
                    "type": "string",
                    "description": "In `group/subgroup/project` or `user/project` format.\n"
                },
                "webUrl": {
                    "type": "string",
                    "description": "The web url of the upstream project.\n"
                }
            },
            "type": "object",
            "required": [
                "httpUrlToRepo",
                "id",
                "name",
                "nameWithNamespace",
                "path",
                "pathWithNamespace",
                "webUrl"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectsProjectNamespace:getProjectsProjectNamespace": {
            "properties": {
                "fullPath": {
                    "type": "string",
                    "description": "The full path of the namespace.\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The ID of the namespace.\n"
                },
                "kind": {
                    "type": "string",
                    "description": "The kind of the namespace.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the namespace.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path of the namespace.\n"
                }
            },
            "type": "object",
            "required": [
                "fullPath",
                "id",
                "kind",
                "name",
                "path"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectsProjectOwner:getProjectsProjectOwner": {
            "properties": {
                "avatarUrl": {
                    "type": "string",
                    "description": "The avatar url of the owner.\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The ID of the owner.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the owner.\n"
                },
                "state": {
                    "type": "string",
                    "description": "The state of the owner.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The username of the owner.\n"
                },
                "websiteUrl": {
                    "type": "string",
                    "description": "The website url of the owner.\n"
                }
            },
            "type": "object",
            "required": [
                "avatarUrl",
                "id",
                "name",
                "state",
                "username",
                "websiteUrl"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectsProjectPermission:getProjectsProjectPermission": {
            "properties": {
                "groupAccess": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "integer"
                    },
                    "description": "Group access level.\n"
                },
                "projectAccess": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "integer"
                    },
                    "description": "Project access level.\n"
                }
            },
            "type": "object",
            "required": [
                "groupAccess",
                "projectAccess"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getProjectsProjectSharedWithGroup:getProjectsProjectSharedWithGroup": {
            "properties": {
                "groupAccessLevel": {
                    "type": "string",
                    "description": "The group access level.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The group ID.\n"
                },
                "groupName": {
                    "type": "string",
                    "description": "The group name.\n"
                }
            },
            "type": "object",
            "required": [
                "groupAccessLevel",
                "groupId",
                "groupName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getReleaseAssets:getReleaseAssets": {
            "properties": {
                "count": {
                    "type": "integer",
                    "description": "The number of assets for a release\n"
                },
                "links": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getReleaseAssetsLink:getReleaseAssetsLink"
                    },
                    "description": "The links for a release\n"
                },
                "sources": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/getReleaseAssetsSource:getReleaseAssetsSource"
                    },
                    "description": "The sources for a release\n"
                }
            },
            "type": "object",
            "required": [
                "count"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getReleaseAssetsLink:getReleaseAssetsLink": {
            "properties": {
                "id": {
                    "type": "integer",
                    "description": "The ID of the link\n"
                },
                "linkType": {
                    "type": "string",
                    "description": "The type of the link\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the link\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL of the link\n"
                }
            },
            "type": "object",
            "required": [
                "id",
                "linkType",
                "name",
                "url"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getReleaseAssetsSource:getReleaseAssetsSource": {
            "properties": {
                "format": {
                    "type": "string",
                    "description": "The format of the source\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL of the source\n"
                }
            },
            "type": "object",
            "required": [
                "format",
                "url"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getReleaseLinksReleaseLink:getReleaseLinksReleaseLink": {
            "properties": {
                "directAssetUrl": {
                    "type": "string",
                    "description": "Full path for a [Direct Asset link](https://docs.gitlab.com/ee/user/project/releases/index.html#permanent-links-to-release-assets).\n"
                },
                "external": {
                    "type": "boolean",
                    "description": "External or internal link.\n"
                },
                "filepath": {
                    "type": "string",
                    "description": "Relative path for a [Direct Asset link](https://docs.gitlab.com/ee/user/project/releases/index.html#permanent-links-to-release-assets).\n"
                },
                "linkId": {
                    "type": "integer",
                    "description": "The ID of the link.\n"
                },
                "linkType": {
                    "type": "string",
                    "description": "The type of the link. Valid values are `other`, `runbook`, `image`, `package`. Defaults to other.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the link. Link names must be unique within the release.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or [URL-encoded path of the project](https://docs.gitlab.com/ee/api/index.html#namespaced-path-encoding).\n"
                },
                "tagName": {
                    "type": "string",
                    "description": "The tag associated with the Release.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL of the link. Link URLs must be unique within the release.\n"
                }
            },
            "type": "object",
            "required": [
                "directAssetUrl",
                "external",
                "filepath",
                "linkId",
                "linkType",
                "name",
                "project",
                "tagName",
                "url"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getRepositoryTreeTree:getRepositoryTreeTree": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "The SHA-1 hash of the tree or blob in the repository.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "Unix access mode of the file in the repository.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the blob or tree in the repository\n"
                },
                "path": {
                    "type": "string",
                    "description": "Path of the object inside of the repository.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of object in the repository. Can be either type tree or of type blob\n"
                }
            },
            "type": "object",
            "required": [
                "id",
                "mode",
                "name",
                "path",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getRunnersRunner:getRunnersRunner": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "The description of the runner.\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The runner id.\n"
                },
                "isShared": {
                    "type": "boolean",
                    "description": "Indicates if this is a shared runner\n"
                },
                "online": {
                    "type": "boolean",
                    "description": "The connectivity status of the runner.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Indicates if the runner is accepting or ignoring new jobs.\n"
                },
                "runnerType": {
                    "type": "string",
                    "description": "The runner type. Values are `instance_type`, `group_type` and `project_type`.\n"
                },
                "status": {
                    "type": "string",
                    "description": "The status of the runner. Values can be `online`, `offline`, `stale`, and `never_contacted`.\n"
                }
            },
            "type": "object",
            "required": [
                "description",
                "id",
                "isShared",
                "online",
                "paused",
                "runnerType",
                "status"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getUserSshkeysKey:getUserSshkeysKey": {
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "The time when this key was created in GitLab.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "The expiration date of the SSH key in ISO 8601 format (YYYY-MM-DDTHH:MM:SSZ)\n"
                },
                "key": {
                    "type": "string",
                    "description": "The ssh key. The SSH key `comment` (trailing part) is optional and ignored for diffing, because GitLab overrides it with the username and GitLab hostname.\n"
                },
                "keyId": {
                    "type": "integer",
                    "description": "The ID of the ssh key.\n"
                },
                "title": {
                    "type": "string",
                    "description": "The title of the ssh key.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID or username of the user. If this field is omitted, this resource manages a SSH key for the current user. Otherwise, this resource manages a SSH key for the specified user, and an admin token is required.\n"
                }
            },
            "type": "object",
            "required": [
                "createdAt",
                "expiresAt",
                "key",
                "keyId",
                "title",
                "userId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "gitlab:index/getUsersUser:getUsersUser": {
            "properties": {
                "avatarUrl": {
                    "type": "string",
                    "description": "The avatar URL of the user.\n"
                },
                "bio": {
                    "type": "string",
                    "description": "The bio of the user.\n"
                },
                "canCreateGroup": {
                    "type": "boolean",
                    "description": "Whether the user can create groups.\n"
                },
                "canCreateProject": {
                    "type": "boolean",
                    "description": "Whether the user can create projects.\n"
                },
                "colorSchemeId": {
                    "type": "integer",
                    "description": "User's color scheme ID.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Date the user was created at.\n"
                },
                "currentSignInAt": {
                    "type": "string",
                    "description": "Current user's sign-in date.\n"
                },
                "email": {
                    "type": "string",
                    "description": "The public email address of the user. **Note**: before GitLab 14.8 the lookup was based on the users primary email address.\n"
                },
                "externUid": {
                    "type": "string",
                    "description": "The external UID of the user.\n"
                },
                "external": {
                    "type": "boolean",
                    "description": "Whether the user is external.\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The unique id assigned to the user by the gitlab server.\n"
                },
                "isAdmin": {
                    "type": "boolean",
                    "description": "Whether the user is an admin.\n"
                },
                "isBot": {
                    "type": "boolean",
                    "description": "Whether the user is a bot.\n"
                },
                "lastSignInAt": {
                    "type": "string",
                    "description": "Last user's sign-in date.\n"
                },
                "linkedin": {
                    "type": "string",
                    "description": "LinkedIn profile of the user.\n"
                },
                "location": {
                    "type": "string",
                    "description": "The location of the user.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the user.\n"
                },
                "namespaceId": {
                    "type": "integer",
                    "description": "The ID of the user's namespace. Requires admin token to access this field. Available since GitLab 14.10.\n"
                },
                "organization": {
                    "type": "string",
                    "description": "The organization of the user.\n"
                },
                "projectsLimit": {
                    "type": "integer",
                    "description": "Number of projects the user can create.\n"
                },
                "provider": {
                    "type": "string",
                    "description": "The UID provider of the user.\n"
                },
                "skype": {
                    "type": "string",
                    "description": "Skype username of the user.\n"
                },
                "state": {
                    "type": "string",
                    "description": "Whether the user is active or blocked.\n"
                },
                "themeId": {
                    "type": "integer",
                    "description": "User's theme ID.\n"
                },
                "twitter": {
                    "type": "string",
                    "description": "Twitter username of the user.\n"
                },
                "twoFactorEnabled": {
                    "type": "boolean",
                    "description": "Whether user's two-factor auth is enabled.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The username of the user.\n"
                },
                "websiteUrl": {
                    "type": "string",
                    "description": "User's website URL.\n"
                }
            },
            "type": "object",
            "required": [
                "avatarUrl",
                "bio",
                "canCreateGroup",
                "canCreateProject",
                "colorSchemeId",
                "createdAt",
                "currentSignInAt",
                "email",
                "externUid",
                "external",
                "id",
                "isAdmin",
                "isBot",
                "lastSignInAt",
                "linkedin",
                "location",
                "name",
                "namespaceId",
                "organization",
                "projectsLimit",
                "provider",
                "skype",
                "state",
                "themeId",
                "twitter",
                "twoFactorEnabled",
                "username",
                "websiteUrl"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        }
    },
    "provider": {
        "description": "The provider type for the gitlab package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "baseUrl": {
                "type": "string",
                "description": "This is the target GitLab base API endpoint. Providing a value is a requirement when working with GitLab CE or GitLab\nEnterprise e.g. `https://my.gitlab.server/api/v4/`. It is optional to provide this value and it can also be sourced from\nthe `GITLAB_BASE_URL` environment variable. The value must end with a slash.\n"
            },
            "cacertFile": {
                "type": "string",
                "description": "This is a file containing the ca cert to verify the gitlab instance. This is available for use when working with GitLab\nCE or Gitlab Enterprise with a locally-issued or self-signed certificate chain.\n"
            },
            "clientCert": {
                "type": "string",
                "description": "File path to client certificate when GitLab instance is behind company proxy. File must contain PEM encoded data.\n"
            },
            "clientKey": {
                "type": "string",
                "description": "File path to client key when GitLab instance is behind company proxy. File must contain PEM encoded data. Required when\n`client_cert` is set.\n"
            },
            "earlyAuthCheck": {
                "type": "boolean"
            },
            "headers": {
                "type": "object",
                "additionalProperties": {
                    "type": "string"
                },
                "description": "A map of headers to append to all API request to the GitLab instance.\n"
            },
            "insecure": {
                "type": "boolean",
                "description": "When set to true this disables SSL verification of the connection to the GitLab instance.\n"
            },
            "retries": {
                "type": "integer",
                "description": "The number of retries to execute when receiving a 429 Rate Limit error. Each retry will exponentially back off.\n"
            },
            "token": {
                "type": "string",
                "description": "The OAuth2 Token, Project, Group, Personal Access Token or CI Job Token used to connect to GitLab. The OAuth method is\nused in this provider for authentication (using Bearer authorization token). See\nhttps://docs.gitlab.com/ee/api/#authentication for details. It may be sourced from the `GITLAB_TOKEN` environment\nvariable.\n",
                "secret": true
            }
        },
        "inputProperties": {
            "baseUrl": {
                "type": "string",
                "description": "This is the target GitLab base API endpoint. Providing a value is a requirement when working with GitLab CE or GitLab\nEnterprise e.g. `https://my.gitlab.server/api/v4/`. It is optional to provide this value and it can also be sourced from\nthe `GITLAB_BASE_URL` environment variable. The value must end with a slash.\n"
            },
            "cacertFile": {
                "type": "string",
                "description": "This is a file containing the ca cert to verify the gitlab instance. This is available for use when working with GitLab\nCE or Gitlab Enterprise with a locally-issued or self-signed certificate chain.\n"
            },
            "clientCert": {
                "type": "string",
                "description": "File path to client certificate when GitLab instance is behind company proxy. File must contain PEM encoded data.\n"
            },
            "clientKey": {
                "type": "string",
                "description": "File path to client key when GitLab instance is behind company proxy. File must contain PEM encoded data. Required when\n`client_cert` is set.\n"
            },
            "earlyAuthCheck": {
                "type": "boolean"
            },
            "headers": {
                "type": "object",
                "additionalProperties": {
                    "type": "string"
                },
                "description": "A map of headers to append to all API request to the GitLab instance.\n"
            },
            "insecure": {
                "type": "boolean",
                "description": "When set to true this disables SSL verification of the connection to the GitLab instance.\n"
            },
            "retries": {
                "type": "integer",
                "description": "The number of retries to execute when receiving a 429 Rate Limit error. Each retry will exponentially back off.\n"
            },
            "token": {
                "type": "string",
                "description": "The OAuth2 Token, Project, Group, Personal Access Token or CI Job Token used to connect to GitLab. The OAuth method is\nused in this provider for authentication (using Bearer authorization token). See\nhttps://docs.gitlab.com/ee/api/#authentication for details. It may be sourced from the `GITLAB_TOKEN` environment\nvariable.\n",
                "secret": true
            }
        }
    },
    "resources": {
        "gitlab:index/application:Application": {
            "description": "The `gitlab.Application` resource allows to manage the lifecycle of applications in gitlab.\n\n\u003e In order to use a user for a user to create an application, they must have admin privileges at the instance level.\nTo create an OIDC application, a scope of \"openid\".\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/applications.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst oidc = new gitlab.Application(\"oidc\", {\n    confidential: true,\n    scopes: [\"openid\"],\n    name: \"company_oidc\",\n    redirectUrl: \"https://mycompany.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\noidc = gitlab.Application(\"oidc\",\n    confidential=True,\n    scopes=[\"openid\"],\n    name=\"company_oidc\",\n    redirect_url=\"https://mycompany.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var oidc = new GitLab.Application(\"oidc\", new()\n    {\n        Confidential = true,\n        Scopes = new[]\n        {\n            \"openid\",\n        },\n        Name = \"company_oidc\",\n        RedirectUrl = \"https://mycompany.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewApplication(ctx, \"oidc\", \u0026gitlab.ApplicationArgs{\n\t\t\tConfidential: pulumi.Bool(true),\n\t\t\tScopes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"openid\"),\n\t\t\t},\n\t\t\tName:        pulumi.String(\"company_oidc\"),\n\t\t\tRedirectUrl: pulumi.String(\"https://mycompany.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Application;\nimport com.pulumi.gitlab.ApplicationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var oidc = new Application(\"oidc\", ApplicationArgs.builder()\n            .confidential(true)\n            .scopes(\"openid\")\n            .name(\"company_oidc\")\n            .redirectUrl(\"https://mycompany.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  oidc:\n    type: gitlab:Application\n    properties:\n      confidential: true\n      scopes:\n        - openid\n      name: company_oidc\n      redirectUrl: https://mycompany.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_application`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_application.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitlab applications can be imported with their id, e.g.\n\n```sh\n$ pulumi import gitlab:index/application:Application example \"1\"\n```\n\nNOTE: the secret and scopes cannot be imported\n\n",
            "properties": {
                "applicationId": {
                    "type": "string",
                    "description": "Internal name of the application.\n"
                },
                "confidential": {
                    "type": "boolean",
                    "description": "The application is used where the client secret can be kept confidential. Native mobile apps and Single Page Apps are considered non-confidential. Defaults to true if not supplied\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the application.\n"
                },
                "redirectUrl": {
                    "type": "string",
                    "description": "The URL gitlab should send the user to after authentication.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Scopes of the application. Use \"openid\" if you plan to use this as an oidc authentication application. Valid options are: `api`, `read_api`, `read_user`, `read_repository`, `write_repository`, `read_registry`, `write_registry`, `sudo`, `admin_mode`, `openid`, `profile`, `email`.\nThis is only populated when creating a new application. This attribute is not available for imported resources\n"
                },
                "secret": {
                    "type": "string",
                    "description": "Application secret. Sensitive and must be kept secret. This is only populated when creating a new application. This attribute is not available for imported resources.\n",
                    "secret": true
                }
            },
            "required": [
                "applicationId",
                "confidential",
                "name",
                "redirectUrl",
                "scopes",
                "secret"
            ],
            "inputProperties": {
                "confidential": {
                    "type": "boolean",
                    "description": "The application is used where the client secret can be kept confidential. Native mobile apps and Single Page Apps are considered non-confidential. Defaults to true if not supplied\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the application.\n"
                },
                "redirectUrl": {
                    "type": "string",
                    "description": "The URL gitlab should send the user to after authentication.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Scopes of the application. Use \"openid\" if you plan to use this as an oidc authentication application. Valid options are: `api`, `read_api`, `read_user`, `read_repository`, `write_repository`, `read_registry`, `write_registry`, `sudo`, `admin_mode`, `openid`, `profile`, `email`.\nThis is only populated when creating a new application. This attribute is not available for imported resources\n"
                }
            },
            "requiredInputs": [
                "redirectUrl",
                "scopes"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Application resources.\n",
                "properties": {
                    "applicationId": {
                        "type": "string",
                        "description": "Internal name of the application.\n"
                    },
                    "confidential": {
                        "type": "boolean",
                        "description": "The application is used where the client secret can be kept confidential. Native mobile apps and Single Page Apps are considered non-confidential. Defaults to true if not supplied\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the application.\n"
                    },
                    "redirectUrl": {
                        "type": "string",
                        "description": "The URL gitlab should send the user to after authentication.\n"
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Scopes of the application. Use \"openid\" if you plan to use this as an oidc authentication application. Valid options are: `api`, `read_api`, `read_user`, `read_repository`, `write_repository`, `read_registry`, `write_registry`, `sudo`, `admin_mode`, `openid`, `profile`, `email`.\nThis is only populated when creating a new application. This attribute is not available for imported resources\n"
                    },
                    "secret": {
                        "type": "string",
                        "description": "Application secret. Sensitive and must be kept secret. This is only populated when creating a new application. This attribute is not available for imported resources.\n",
                        "secret": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/applicationSettings:ApplicationSettings": {
            "description": "## Example Usage\n\n",
            "properties": {
                "abuseNotificationEmail": {
                    "type": "string",
                    "description": "If set, abuse reports are sent to this address. Abuse reports are always available in the Admin Area.\n"
                },
                "adminMode": {
                    "type": "boolean",
                    "description": "Require administrators to enable Admin Mode by re-authenticating for administrative tasks.\n"
                },
                "afterSignOutPath": {
                    "type": "string",
                    "description": "Where to redirect users after logout.\n"
                },
                "afterSignUpText": {
                    "type": "string",
                    "description": "Text shown to the user after signing up.\n"
                },
                "akismetApiKey": {
                    "type": "string",
                    "description": "API key for Akismet spam protection.\n",
                    "secret": true
                },
                "akismetEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: akismet*api*key) Enable or disable Akismet spam protection.\n"
                },
                "allowAccountDeletion": {
                    "type": "boolean",
                    "description": "Set to true to allow users to delete their accounts. Premium and Ultimate only.\n"
                },
                "allowGroupOwnersToManageLdap": {
                    "type": "boolean",
                    "description": "Set to true to allow group owners to manage LDAP.\n"
                },
                "allowLocalRequestsFromSystemHooks": {
                    "type": "boolean",
                    "description": "Allow requests to the local network from system hooks.\n"
                },
                "allowLocalRequestsFromWebHooksAndServices": {
                    "type": "boolean",
                    "description": "Allow requests to the local network from web hooks and services.\n"
                },
                "allowProjectCreationForGuestAndBelow": {
                    "type": "boolean",
                    "description": "Indicates whether users assigned up to the Guest role can create groups and personal projects.\n"
                },
                "allowRunnerRegistrationToken": {
                    "type": "boolean",
                    "description": "Allow using a registration token to create a runner.\n"
                },
                "archiveBuildsInHumanReadable": {
                    "type": "string",
                    "description": "Set the duration for which the jobs are considered as old and expired. After that time passes, the jobs are archived and no longer able to be retried. Make it empty to never expire jobs. It has to be no less than 1 day, for example: 15 days, 1 month, 2 years.\n"
                },
                "asciidocMaxIncludes": {
                    "type": "integer",
                    "description": "Maximum limit of AsciiDoc include directives being processed in any one document. Maximum: 64.\n"
                },
                "assetProxyAllowlists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Assets that match these domains are not proxied. Wildcards allowed. Your GitLab installation URL is automatically allowlisted. GitLab restart is required to apply changes.\n"
                },
                "assetProxyEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: asset*proxy*url) Enable proxying of assets. GitLab restart is required to apply changes.\n"
                },
                "assetProxySecretKey": {
                    "type": "string",
                    "description": "Shared secret with the asset proxy server. GitLab restart is required to apply changes.\n",
                    "secret": true
                },
                "assetProxyUrl": {
                    "type": "string",
                    "description": "URL of the asset proxy server. GitLab restart is required to apply changes.\n"
                },
                "authorizedKeysEnabled": {
                    "type": "boolean",
                    "description": "By default, we write to the authorized_keys file to support Git over SSH without additional configuration. GitLab can be optimized to authenticate SSH keys via the database file. Only disable this if you have configured your OpenSSH server to use the AuthorizedKeysCommand.\n"
                },
                "autoBanUserOnExcessiveProjectsDownload": {
                    "type": "boolean",
                    "description": "When enabled, users will get automatically banned from the application when they download more than the maximum number of unique projects in the time period specified by max*number*of*repository*downloads and max*number*of*repository*downloads*within*time_period respectively. Introduced in GitLab 15.4. Self-managed, Ultimate only.\n"
                },
                "autoDevopsDomain": {
                    "type": "string",
                    "description": "Specify a domain to use by default for every project’s Auto Review Apps and Auto Deploy stages.\n"
                },
                "autoDevopsEnabled": {
                    "type": "boolean",
                    "description": "Enable Auto DevOps for projects by default. It automatically builds, tests, and deploys applications based on a predefined CI/CD configuration.\n"
                },
                "automaticPurchasedStorageAllocation": {
                    "type": "boolean",
                    "description": "Enabling this permits automatic allocation of purchased storage in a namespace.\n"
                },
                "bulkImportConcurrentPipelineBatchLimit": {
                    "type": "integer",
                    "description": "Maximum simultaneous Direct Transfer batches to process.\n"
                },
                "bulkImportEnabled": {
                    "type": "boolean",
                    "description": "Enable migrating GitLab groups by direct transfer. Introduced in GitLab 15.8.\n"
                },
                "bulkImportMaxDownloadFileSize": {
                    "type": "integer",
                    "description": "Maximum download file size when importing from source GitLab instances by direct transfer. Introduced in GitLab 16.3.\n"
                },
                "canCreateGroup": {
                    "type": "boolean",
                    "description": "Indicates whether users can create top-level groups. Introduced in GitLab 15.5.\n"
                },
                "checkNamespacePlan": {
                    "type": "boolean",
                    "description": "Enabling this makes only licensed EE features available to projects if the project namespace’s plan includes the feature or if the project is public.\n"
                },
                "ciMaxIncludes": {
                    "type": "integer",
                    "description": "The maximum number of includes per pipeline.\n"
                },
                "ciMaxTotalYamlSizeBytes": {
                    "type": "integer",
                    "description": "The maximum amount of memory, in bytes, that can be allocated for the pipeline configuration, with all included YAML configuration files.\n"
                },
                "commitEmailHostname": {
                    "type": "string",
                    "description": "Custom hostname (for private commit emails).\n"
                },
                "concurrentBitbucketImportJobsLimit": {
                    "type": "integer",
                    "description": "Maximum number of simultaneous import jobs for the Bitbucket Cloud importer. Introduced in GitLab 16.11.\n"
                },
                "concurrentBitbucketServerImportJobsLimit": {
                    "type": "integer",
                    "description": "Maximum number of simultaneous import jobs for the Bitbucket Server importer. Introduced in GitLab 16.11.\n"
                },
                "concurrentGithubImportJobsLimit": {
                    "type": "integer",
                    "description": "Maximum number of simultaneous import jobs for the GitHub importer. Introduced in GitLab 16.11.\n"
                },
                "containerExpirationPoliciesEnableHistoricEntries": {
                    "type": "boolean",
                    "description": "Enable cleanup policies for all projects.\n"
                },
                "containerRegistryCleanupTagsServiceMaxListSize": {
                    "type": "integer",
                    "description": "The maximum number of tags that can be deleted in a single execution of cleanup policies.\n"
                },
                "containerRegistryDeleteTagsServiceTimeout": {
                    "type": "integer",
                    "description": "The maximum time, in seconds, that the cleanup process can take to delete a batch of tags for cleanup policies.\n"
                },
                "containerRegistryExpirationPoliciesCaching": {
                    "type": "boolean",
                    "description": "Caching during the execution of cleanup policies.\n"
                },
                "containerRegistryExpirationPoliciesWorkerCapacity": {
                    "type": "integer",
                    "description": "Number of workers for cleanup policies.\n"
                },
                "containerRegistryTokenExpireDelay": {
                    "type": "integer",
                    "description": "Container Registry token duration in minutes.\n"
                },
                "deactivateDormantUsers": {
                    "type": "boolean",
                    "description": "Enable automatic deactivation of dormant users.\n"
                },
                "deactivateDormantUsersPeriod": {
                    "type": "integer",
                    "description": "Length of time (in days) after which a user is considered dormant. Introduced in GitLab 15.3.\n"
                },
                "decompressArchiveFileTimeout": {
                    "type": "integer",
                    "description": "Default timeout for decompressing archived files, in seconds. Set to 0 to disable timeouts. Introduced in GitLab 16.4.\n"
                },
                "defaultArtifactsExpireIn": {
                    "type": "string",
                    "description": "Set the default expiration time for each job’s artifacts.\n"
                },
                "defaultBranchName": {
                    "type": "string",
                    "description": "Instance-level custom initial branch name (introduced in GitLab 13.2).\n"
                },
                "defaultBranchProtection": {
                    "type": "integer",
                    "description": "Determine if developers can push to the default branch. Can take: 0 (not protected, both users with the Developer role or Maintainer role can push new commits and force push), 1 (partially protected, users with the Developer role or Maintainer role can push new commits, but cannot force push) or 2 (fully protected, users with the Developer or Maintainer role cannot push new commits, but users with the Developer or Maintainer role can; no one can force push) as a parameter. Default is 2.\n"
                },
                "defaultBranchProtectionDefaults": {
                    "$ref": "#/types/gitlab:index/ApplicationSettingsDefaultBranchProtectionDefaults:ApplicationSettingsDefaultBranchProtectionDefaults",
                    "description": "The default*branch*protection*defaults attribute describes the default branch protection defaults. All parameters are optional.\n"
                },
                "defaultCiConfigPath": {
                    "type": "string",
                    "description": "Default CI/CD configuration file and path for new projects (.gitlab-ci.yml if not set).\n"
                },
                "defaultGroupVisibility": {
                    "type": "string",
                    "description": "What visibility level new groups receive. Can take private, internal and public as a parameter.\n"
                },
                "defaultPreferredLanguage": {
                    "type": "string",
                    "description": "Default preferred language for users who are not logged in.\n"
                },
                "defaultProjectCreation": {
                    "type": "integer",
                    "description": "Default project creation protection. Can take: 0 (No one), 1 (Maintainers) or 2 (Developers + Maintainers).\n"
                },
                "defaultProjectVisibility": {
                    "type": "string",
                    "description": "What visibility level new projects receive. Can take private, internal and public as a parameter.\n"
                },
                "defaultProjectsLimit": {
                    "type": "integer",
                    "description": "Project limit per user.\n"
                },
                "defaultSnippetVisibility": {
                    "type": "string",
                    "description": "What visibility level new snippets receive. Can take private, internal and public as a parameter.\n"
                },
                "defaultSyntaxHighlightingTheme": {
                    "type": "integer",
                    "description": "Default syntax highlighting theme for users who are new or not signed in. See IDs of available themes (https://gitlab.com/gitlab-org/gitlab/blob/master/lib/gitlab/themes.rb#L16)\n"
                },
                "deleteInactiveProjects": {
                    "type": "boolean",
                    "description": "Enable inactive project deletion feature. Introduced in GitLab 14.10. Became operational in GitLab 15.0 (with feature flag inactive*projects*deletion).\n"
                },
                "deleteUnconfirmedUsers": {
                    "type": "boolean",
                    "description": "Specifies whether users who have not confirmed their email should be deleted. When set to true, unconfirmed users are deleted after unconfirmed*users*delete*after*days days. Introduced in GitLab 16.1. Self-managed, Premium and Ultimate only.\n"
                },
                "deletionAdjournedPeriod": {
                    "type": "integer",
                    "description": "The number of days to wait before deleting a project or group that is marked for deletion. Value must be between 1 and 90.\n"
                },
                "diagramsnetEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires diagramsnet_url) Enable Diagrams.net integration.\n"
                },
                "diagramsnetUrl": {
                    "type": "string",
                    "description": "The Diagrams.net instance URL for integration.\n"
                },
                "diffMaxFiles": {
                    "type": "integer",
                    "description": "Maximum files in a diff.\n"
                },
                "diffMaxLines": {
                    "type": "integer",
                    "description": "Maximum lines in a diff.\n"
                },
                "diffMaxPatchBytes": {
                    "type": "integer",
                    "description": "Maximum diff patch size, in bytes.\n"
                },
                "disableAdminOauthScopes": {
                    "type": "boolean",
                    "description": "Stops administrators from connecting their GitLab accounts to non-trusted OAuth 2.0 applications that have the api, read*api, read*repository, write*repository, read*registry, write_registry, or sudo scopes. Introduced in GitLab 15.6.\n"
                },
                "disableFeedToken": {
                    "type": "boolean",
                    "description": "Disable display of RSS/Atom and calendar feed tokens (introduced in GitLab 13.7).\n"
                },
                "disablePersonalAccessTokens": {
                    "type": "boolean",
                    "description": "Disable personal access tokens. Introduced in GitLab 15.7. Self-managed, Premium and Ultimate only. There is no method available to enable a personal access token that’s been disabled through the API. This is a known issue.\n"
                },
                "disabledOauthSignInSources": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Disabled OAuth sign-in sources.\n"
                },
                "dnsRebindingProtectionEnabled": {
                    "type": "boolean",
                    "description": "Enforce DNS rebinding attack protection.\n"
                },
                "domainAllowlists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Force people to use only corporate emails for sign-up. Null means there is no restriction.\n"
                },
                "domainDenylistEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: domain_denylist) Allows blocking sign-ups from emails from specific domains.\n"
                },
                "domainDenylists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Users with email addresses that match these domains cannot sign up. Wildcards allowed. Use separate lines for multiple entries. Ex: domain.com, *.domain.com.\n"
                },
                "downstreamPipelineTriggerLimitPerProjectUserSha": {
                    "type": "integer",
                    "description": "Maximum downstream pipeline trigger rate. Introduced in GitLab 16.10.\n"
                },
                "dsaKeyRestriction": {
                    "type": "integer",
                    "description": "The minimum allowed bit length of an uploaded DSA key. 0 means no restriction. -1 disables DSA keys.\n"
                },
                "duoFeaturesEnabled": {
                    "type": "boolean",
                    "description": "Indicates whether GitLab Duo features are enabled for this instance. Introduced in GitLab 16.10. Self-managed, Premium and Ultimate only.\n"
                },
                "ecdsaKeyRestriction": {
                    "type": "integer",
                    "description": "The minimum allowed curve size (in bits) of an uploaded ECDSA key. 0 means no restriction. -1 disables ECDSA keys.\n"
                },
                "ecdsaSkKeyRestriction": {
                    "type": "integer",
                    "description": "The minimum allowed curve size (in bits) of an uploaded ECDSA*SK key. 0 means no restriction. -1 disables ECDSA*SK keys.\n"
                },
                "ed25519KeyRestriction": {
                    "type": "integer",
                    "description": "The minimum allowed curve size (in bits) of an uploaded ED25519 key. 0 means no restriction. -1 disables ED25519 keys.\n"
                },
                "ed25519SkKeyRestriction": {
                    "type": "integer",
                    "description": "The minimum allowed curve size (in bits) of an uploaded ED25519*SK key. 0 means no restriction. -1 disables ED25519*SK keys.\n"
                },
                "eksAccessKeyId": {
                    "type": "string",
                    "description": "AWS IAM access key ID.\n",
                    "secret": true
                },
                "eksAccountId": {
                    "type": "string",
                    "description": "Amazon account ID.\n"
                },
                "eksIntegrationEnabled": {
                    "type": "boolean",
                    "description": "Enable integration with Amazon EKS.\n"
                },
                "eksSecretAccessKey": {
                    "type": "string",
                    "description": "AWS IAM secret access key.\n",
                    "secret": true
                },
                "elasticsearchAws": {
                    "type": "boolean",
                    "description": "Enable the use of AWS hosted Elasticsearch.\n"
                },
                "elasticsearchAwsAccessKey": {
                    "type": "string",
                    "description": "AWS IAM access key.\n",
                    "secret": true
                },
                "elasticsearchAwsRegion": {
                    "type": "string",
                    "description": "The AWS region the Elasticsearch domain is configured.\n"
                },
                "elasticsearchAwsSecretAccessKey": {
                    "type": "string",
                    "description": "AWS IAM secret access key.\n",
                    "secret": true
                },
                "elasticsearchIndexedFieldLengthLimit": {
                    "type": "integer",
                    "description": "Maximum size of text fields to index by Elasticsearch. 0 value means no limit. This does not apply to repository and wiki indexing.\n"
                },
                "elasticsearchIndexedFileSizeLimitKb": {
                    "type": "integer",
                    "description": "Maximum size of repository and wiki files that are indexed by Elasticsearch.\n"
                },
                "elasticsearchIndexing": {
                    "type": "boolean",
                    "description": "Enable Elasticsearch indexing.\n"
                },
                "elasticsearchLimitIndexing": {
                    "type": "boolean",
                    "description": "Limit Elasticsearch to index certain namespaces and projects.\n"
                },
                "elasticsearchMaxBulkConcurrency": {
                    "type": "integer",
                    "description": "Maximum concurrency of Elasticsearch bulk requests per indexing operation. This only applies to repository indexing operations.\n"
                },
                "elasticsearchMaxBulkSizeMb": {
                    "type": "integer",
                    "description": "Maximum size of Elasticsearch bulk indexing requests in MB. This only applies to repository indexing operations.\n"
                },
                "elasticsearchMaxCodeIndexingConcurrency": {
                    "type": "integer",
                    "description": "Maximum concurrency of Elasticsearch code indexing background jobs. This only applies to repository indexing operations. Premium and Ultimate only.\n"
                },
                "elasticsearchNamespaceIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "The namespaces to index via Elasticsearch if elasticsearch*limit*indexing is enabled.\n"
                },
                "elasticsearchPassword": {
                    "type": "string",
                    "description": "The password of your Elasticsearch instance.\n",
                    "secret": true
                },
                "elasticsearchProjectIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "The projects to index via Elasticsearch if elasticsearch*limit*indexing is enabled.\n"
                },
                "elasticsearchRequeueWorkers": {
                    "type": "boolean",
                    "description": "Enable automatic requeuing of indexing workers. This improves non-code indexing throughput by enqueuing Sidekiq jobs until all documents are processed. Premium and Ultimate only.\n"
                },
                "elasticsearchSearch": {
                    "type": "boolean",
                    "description": "Enable Elasticsearch search.\n"
                },
                "elasticsearchUrls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The URL to use for connecting to Elasticsearch. Use a comma-separated list to support cluster (for example, http://localhost:9200, http://localhost:9201).\n"
                },
                "elasticsearchUsername": {
                    "type": "string",
                    "description": "The username of your Elasticsearch instance.\n"
                },
                "elasticsearchWorkerNumberOfShards": {
                    "type": "integer",
                    "description": "Number of indexing worker shards. This improves non-code indexing throughput by enqueuing more parallel Sidekiq jobs. Premium and Ultimate only.\n"
                },
                "emailAdditionalText": {
                    "type": "string",
                    "description": "Additional text added to the bottom of every email for legal/auditing/compliance reasons.\n"
                },
                "emailAuthorInBody": {
                    "type": "boolean",
                    "description": "Some email servers do not support overriding the email sender name. Enable this option to include the name of the author of the issue, merge request or comment in the email body instead.\n"
                },
                "emailConfirmationSetting": {
                    "type": "string",
                    "description": "Specifies whether users must confirm their email before sign in. Possible values are off, soft, and hard.\n"
                },
                "enableArtifactExternalRedirectWarningPage": {
                    "type": "boolean",
                    "description": "Show the external redirect page that warns you about user-generated content in GitLab Pages.\n"
                },
                "enabledGitAccessProtocol": {
                    "type": "string",
                    "description": "Enabled protocols for Git access. Allowed values are: ssh, http, and nil to allow both protocols.\n"
                },
                "enforceNamespaceStorageLimit": {
                    "type": "boolean",
                    "description": "Enabling this permits enforcement of namespace storage limits.\n"
                },
                "enforceTerms": {
                    "type": "boolean",
                    "description": "(If enabled, requires: terms) Enforce application ToS to all users.\n"
                },
                "externalAuthClientCert": {
                    "type": "string",
                    "description": "(If enabled, requires: external*auth*client_key) The certificate to use to authenticate with the external authorization service.\n"
                },
                "externalAuthClientKey": {
                    "type": "string",
                    "description": "Private key for the certificate when authentication is required for the external authorization service, this is encrypted when stored.\n",
                    "secret": true
                },
                "externalAuthClientKeyPass": {
                    "type": "string",
                    "description": "Passphrase to use for the private key when authenticating with the external service this is encrypted when stored.\n",
                    "secret": true
                },
                "externalAuthorizationServiceDefaultLabel": {
                    "type": "string",
                    "description": "The default classification label to use when requesting authorization and no classification label has been specified on the project.\n"
                },
                "externalAuthorizationServiceEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: external*authorization*service*default*label, external*authorization*service*timeout and external*authorization*service*url) Enable using an external authorization service for accessing projects.\n"
                },
                "externalAuthorizationServiceTimeout": {
                    "type": "number",
                    "description": "The timeout after which an authorization request is aborted, in seconds. When a request times out, access is denied to the user. (min: 0.001, max: 10, step: 0.001).\n"
                },
                "externalAuthorizationServiceUrl": {
                    "type": "string",
                    "description": "URL to which authorization requests are directed.\n"
                },
                "externalPipelineValidationServiceTimeout": {
                    "type": "integer",
                    "description": "How long to wait for a response from the pipeline validation service. Assumes OK if it times out.\n"
                },
                "externalPipelineValidationServiceToken": {
                    "type": "string",
                    "description": "Optional. Token to include as the X-Gitlab-Token header in requests to the URL in external*pipeline*validation*service*url.\n"
                },
                "externalPipelineValidationServiceUrl": {
                    "type": "string",
                    "description": "URL to use for pipeline validation requests.\n"
                },
                "failedLoginAttemptsUnlockPeriodInMinutes": {
                    "type": "integer",
                    "description": "Time period in minutes after which the user is unlocked when maximum number of failed sign-in attempts reached.\n"
                },
                "fileTemplateProjectId": {
                    "type": "integer",
                    "description": "The ID of a project to load custom file templates from.\n"
                },
                "firstDayOfWeek": {
                    "type": "integer",
                    "description": "Start day of the week for calendar views and date pickers. Valid values are 0 for Sunday, 1 for Monday, and 6 for Saturday.\n"
                },
                "geoNodeAllowedIps": {
                    "type": "string",
                    "description": "Comma-separated list of IPs and CIDRs of allowed secondary nodes. For example, 1.1.1.1, 2.2.2.0/24.\n"
                },
                "geoStatusTimeout": {
                    "type": "integer",
                    "description": "The amount of seconds after which a request to get a secondary node status times out.\n"
                },
                "gitRateLimitUsersAlertlists": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "List of user IDs that are emailed when the Git abuse rate limit is exceeded. Maximum: 100 user IDs. Introduced in GitLab 15.9. Self-managed, Ultimate only.\n"
                },
                "gitRateLimitUsersAllowlists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of usernames excluded from Git anti-abuse rate limits. Maximum: 100 usernames. Introduced in GitLab 15.2. Self-managed, Ultimate only.\n"
                },
                "gitTwoFactorSessionExpiry": {
                    "type": "integer",
                    "description": "Maximum duration (in minutes) of a session for Git operations when 2FA is enabled.\n"
                },
                "gitalyTimeoutDefault": {
                    "type": "integer",
                    "description": "Default Gitaly timeout, in seconds. This timeout is not enforced for Git fetch/push operations or Sidekiq jobs. Set to 0 to disable timeouts.\n"
                },
                "gitalyTimeoutFast": {
                    "type": "integer",
                    "description": "Gitaly fast operation timeout, in seconds. Some Gitaly operations are expected to be fast. If they exceed this threshold, there may be a problem with a storage shard and ‘failing fast’ can help maintain the stability of the GitLab instance. Set to 0 to disable timeouts.\n"
                },
                "gitalyTimeoutMedium": {
                    "type": "integer",
                    "description": "Medium Gitaly timeout, in seconds. This should be a value between the Fast and the Default timeout. Set to 0 to disable timeouts.\n"
                },
                "gitlabDedicatedInstance": {
                    "type": "boolean",
                    "description": "Indicates whether the instance was provisioned for GitLab Dedicated.\n"
                },
                "gitlabEnvironmentToolkitInstance": {
                    "type": "boolean",
                    "description": "Indicates whether the instance was provisioned with the GitLab Environment Toolkit for Service Ping reporting.\n"
                },
                "gitlabShellOperationLimit": {
                    "type": "integer",
                    "description": "Maximum number of Git operations per minute a user can perform. Introduced in GitLab 16.2.\n"
                },
                "gitpodEnabled": {
                    "type": "boolean",
                    "description": "Enable Gitpod integration.\n"
                },
                "gitpodUrl": {
                    "type": "string",
                    "description": "The Gitpod instance URL for integration.\n"
                },
                "globallyAllowedIps": {
                    "type": "string",
                    "description": "Comma-separated list of IP addresses and CIDRs always allowed for inbound traffic. For example, 1.1.1.1, 2.2.2.0/24.\n"
                },
                "grafanaEnabled": {
                    "type": "boolean",
                    "description": "Enable Grafana.\n"
                },
                "grafanaUrl": {
                    "type": "string",
                    "description": "Grafana URL.\n"
                },
                "gravatarEnabled": {
                    "type": "boolean",
                    "description": "Enable Gravatar.\n"
                },
                "groupOwnersCanManageDefaultBranchProtection": {
                    "type": "boolean",
                    "description": "Prevent overrides of default branch protection.\n"
                },
                "hashedStorageEnabled": {
                    "type": "boolean",
                    "description": "Create new projects using hashed storage paths: Enable immutable, hash-based paths and repository names to store repositories on disk. This prevents repositories from having to be moved or renamed when the Project URL changes and may improve disk I/O performance. (Always enabled in GitLab versions 13.0 and later, configuration is scheduled for removal in 14.0).\n"
                },
                "helpPageHideCommercialContent": {
                    "type": "boolean",
                    "description": "Hide marketing-related entries from help.\n"
                },
                "helpPageSupportUrl": {
                    "type": "string",
                    "description": "Alternate support URL for help page and help dropdown.\n"
                },
                "helpPageText": {
                    "type": "string",
                    "description": "Custom text displayed on the help page.\n"
                },
                "helpText": {
                    "type": "string",
                    "description": "GitLab server administrator information.\n"
                },
                "hideThirdPartyOffers": {
                    "type": "boolean",
                    "description": "Do not display offers from third parties in GitLab.\n"
                },
                "homePageUrl": {
                    "type": "string",
                    "description": "Redirect to this URL when not logged in.\n"
                },
                "housekeepingEnabled": {
                    "type": "boolean",
                    "description": "Enable or disable Git housekeeping.\n\t\t\tIf enabled, requires either housekeeping*optimize*repository*period OR housekeeping*bitmaps*enabled, housekeeping*full*repack*period, housekeeping*gc*period, and housekeeping*incremental*repack*period.\n\t\t\tOptions housekeeping*bitmaps*enabled, housekeeping*full*repack*period, housekeeping*gc*period, and housekeeping*incremental*repack*period are deprecated. Use housekeeping*optimize*repository*period instead.\n"
                },
                "housekeepingFullRepackPeriod": {
                    "type": "integer",
                    "description": "Number of Git pushes after which an incremental git repack is run.\n",
                    "deprecationMessage": "housekeeping_full_repack_period is deprecated. Use housekeeping_optimize_repository_period instead."
                },
                "housekeepingGcPeriod": {
                    "type": "integer",
                    "description": "Number of Git pushes after which git gc is run.\n",
                    "deprecationMessage": "housekeeping_gc_period is deprecated. Use housekeeping_optimize_repository_period instead."
                },
                "housekeepingIncrementalRepackPeriod": {
                    "type": "integer",
                    "description": "Number of Git pushes after which an incremental git repack is run.\n",
                    "deprecationMessage": "housekeeping_incremental_repack_period is deprecated. Use housekeeping_optimize_repository_period instead."
                },
                "housekeepingOptimizeRepositoryPeriod": {
                    "type": "integer",
                    "description": "Number of Git pushes after which an incremental git repack is run.\n"
                },
                "htmlEmailsEnabled": {
                    "type": "boolean",
                    "description": "Enable HTML emails.\n"
                },
                "importSources": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Sources to allow project import from. Valid values are: `github`, `bitbucket`, `bitbucket_server`, `fogbugz`, `git`, `gitlab.Project`, `gitea`, `manifest`\n"
                },
                "inProductMarketingEmailsEnabled": {
                    "type": "boolean",
                    "description": "Enable in-product marketing emails.\n"
                },
                "inactiveProjectsDeleteAfterMonths": {
                    "type": "integer",
                    "description": "If delete*inactive*projects is true, the time (in months) to wait before deleting inactive projects. Introduced in GitLab 14.10. Became operational in GitLab 15.0.\n"
                },
                "inactiveProjectsMinSizeMb": {
                    "type": "integer",
                    "description": "If delete*inactive*projects is true, the minimum repository size for projects to be checked for inactivity. Introduced in GitLab 14.10. Became operational in GitLab 15.0.\n"
                },
                "inactiveProjectsSendWarningEmailAfterMonths": {
                    "type": "integer",
                    "description": "If delete*inactive*projects is true, sets the time (in months) to wait before emailing maintainers that the project is scheduled be deleted because it is inactive. Introduced in GitLab 14.10. Became operational in GitLab 15.0.\n"
                },
                "includeOptionalMetricsInServicePing": {
                    "type": "boolean",
                    "description": "Whether or not optional metrics are enabled in Service Ping. Introduced in GitLab 16.10.\n"
                },
                "invisibleCaptchaEnabled": {
                    "type": "boolean",
                    "description": "Enable Invisible CAPTCHA spam detection during sign-up.\n"
                },
                "issuesCreateLimit": {
                    "type": "integer",
                    "description": "Max number of issue creation requests per minute per user.\n"
                },
                "jiraConnectApplicationKey": {
                    "type": "string",
                    "description": "ID of the OAuth application used to authenticate with the GitLab for Jira Cloud app.\n"
                },
                "jiraConnectProxyUrl": {
                    "type": "string",
                    "description": "URL of the GitLab instance used as a proxy for the GitLab for Jira Cloud app.\n"
                },
                "jiraConnectPublicKeyStorageEnabled": {
                    "type": "boolean",
                    "description": "Enable public key storage for the GitLab for Jira Cloud app.\n"
                },
                "keepLatestArtifact": {
                    "type": "boolean",
                    "description": "Prevent the deletion of the artifacts from the most recent successful jobs, regardless of the expiry time.\n"
                },
                "localMarkdownVersion": {
                    "type": "integer",
                    "description": "Increase this value when any cached Markdown should be invalidated.\n"
                },
                "lockDuoFeaturesEnabled": {
                    "type": "boolean",
                    "description": "Indicates whether the GitLab Duo features enabled setting is enforced for all subgroups. Introduced in GitLab 16.10. Self-managed, Premium and Ultimate only.\n"
                },
                "mailgunEventsEnabled": {
                    "type": "boolean",
                    "description": "Enable Mailgun event receiver.\n"
                },
                "mailgunSigningKey": {
                    "type": "string",
                    "description": "The Mailgun HTTP webhook signing key for receiving events from webhook.\n",
                    "secret": true
                },
                "maintenanceMode": {
                    "type": "boolean",
                    "description": "When instance is in maintenance mode, non-administrative users can sign in with read-only access and make read-only API requests.\n"
                },
                "maintenanceModeMessage": {
                    "type": "string",
                    "description": "Message displayed when instance is in maintenance mode.\n"
                },
                "mavenPackageRequestsForwarding": {
                    "type": "boolean",
                    "description": "Use repo.maven.apache.org as a default remote repository when the package is not found in the GitLab Package Registry for Maven. Premium and Ultimate only.\n"
                },
                "maxArtifactsSize": {
                    "type": "integer",
                    "description": "Maximum artifacts size in MB.\n"
                },
                "maxAttachmentSize": {
                    "type": "integer",
                    "description": "Limit attachment size in MB.\n"
                },
                "maxDecompressedArchiveSize": {
                    "type": "integer",
                    "description": "Maximum decompressed archive size in bytes.\n"
                },
                "maxExportSize": {
                    "type": "integer",
                    "description": "Maximum export size in MB. 0 for unlimited.\n"
                },
                "maxImportRemoteFileSize": {
                    "type": "integer",
                    "description": "Maximum remote file size for imports from external object storages. Introduced in GitLab 16.3.\n"
                },
                "maxImportSize": {
                    "type": "integer",
                    "description": "Maximum import size in MB. 0 for unlimited.\n"
                },
                "maxLoginAttempts": {
                    "type": "integer",
                    "description": "Maximum number of sign-in attempts before locking out the user.\n"
                },
                "maxNumberOfRepositoryDownloads": {
                    "type": "integer",
                    "description": "Maximum number of unique repositories a user can download in the specified time period before they are banned. Maximum: 10,000 repositories. Introduced in GitLab 15.1.\n"
                },
                "maxNumberOfRepositoryDownloadsWithinTimePeriod": {
                    "type": "integer",
                    "description": "Reporting time period (in seconds). Maximum: 864000 seconds (10 days). Introduced in GitLab 15.1.\n"
                },
                "maxPagesSize": {
                    "type": "integer",
                    "description": "Maximum size of pages repositories in MB.\n"
                },
                "maxPersonalAccessTokenLifetime": {
                    "type": "integer",
                    "description": "Maximum allowable lifetime for access tokens in days.\n"
                },
                "maxSshKeyLifetime": {
                    "type": "integer",
                    "description": "Maximum allowable lifetime for SSH keys in days. Introduced in GitLab 14.6.\n"
                },
                "maxTerraformStateSizeBytes": {
                    "type": "integer"
                },
                "metricsMethodCallThreshold": {
                    "type": "integer",
                    "description": "A method call is only tracked when it takes longer than the given amount of milliseconds.\n"
                },
                "minimumPasswordLength": {
                    "type": "integer",
                    "description": "Indicates whether passwords require a minimum length. Introduced in GitLab 15.1. Premium and Ultimate only.\n"
                },
                "mirrorAvailable": {
                    "type": "boolean",
                    "description": "Allow repository mirroring to configured by project Maintainers. If disabled, only Administrators can configure repository mirroring.\n"
                },
                "mirrorCapacityThreshold": {
                    "type": "integer",
                    "description": "Minimum capacity to be available before scheduling more mirrors preemptively.\n"
                },
                "mirrorMaxCapacity": {
                    "type": "integer",
                    "description": "Maximum number of mirrors that can be synchronizing at the same time.\n"
                },
                "mirrorMaxDelay": {
                    "type": "integer",
                    "description": "Maximum time (in minutes) between updates that a mirror can have when scheduled to synchronize.\n"
                },
                "npmPackageRequestsForwarding": {
                    "type": "boolean",
                    "description": "Use npmjs.org as a default remote repository when the package is not found in the GitLab Package Registry for npm.\n"
                },
                "nugetSkipMetadataUrlValidation": {
                    "type": "boolean",
                    "description": "Indicates whether to skip metadata URL validation for the NuGet package. Introduced in GitLab 17.0.\n"
                },
                "outboundLocalRequestsWhitelists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Define a list of trusted domains or IP addresses to which local requests are allowed when local requests for hooks and services are disabled.\n"
                },
                "packageMetadataPurlTypes": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "List of package registry metadata to sync. See the list of the available values (https://gitlab.com/gitlab-org/gitlab/-/blob/ace16c20d5da7c4928dd03fb139692638b557fe3/app/models/concerns/enums/package_metadata.rb#L5). Self-managed, Ultimate only.\n"
                },
                "packageRegistryAllowAnyoneToPullOption": {
                    "type": "boolean",
                    "description": "Enable to allow anyone to pull from Package Registry visible and changeable.\n"
                },
                "packageRegistryCleanupPoliciesWorkerCapacity": {
                    "type": "integer",
                    "description": "Number of workers assigned to the packages cleanup policies.\n"
                },
                "pagesDomainVerificationEnabled": {
                    "type": "boolean",
                    "description": "Require users to prove ownership of custom domains. Domain verification is an essential security measure for public GitLab sites. Users are required to demonstrate they control a domain before it is enabled.\n"
                },
                "passwordAuthenticationEnabledForGit": {
                    "type": "boolean",
                    "description": "Enable authentication for Git over HTTP(S) via a GitLab account password.\n"
                },
                "passwordAuthenticationEnabledForWeb": {
                    "type": "boolean",
                    "description": "Enable authentication for the web interface via a GitLab account password.\n"
                },
                "passwordLowercaseRequired": {
                    "type": "boolean",
                    "description": "Indicates whether passwords require at least one lowercase letter. Introduced in GitLab 15.1.\n"
                },
                "passwordNumberRequired": {
                    "type": "boolean",
                    "description": "Indicates whether passwords require at least one number. Introduced in GitLab 15.1.\n"
                },
                "passwordSymbolRequired": {
                    "type": "boolean",
                    "description": "Indicates whether passwords require at least one symbol character. Introduced in GitLab 15.1.\n"
                },
                "passwordUppercaseRequired": {
                    "type": "boolean",
                    "description": "Indicates whether passwords require at least one uppercase letter. Introduced in GitLab 15.1.\n"
                },
                "performanceBarAllowedGroupPath": {
                    "type": "string",
                    "description": "Path of the group that is allowed to toggle the performance bar.\n"
                },
                "personalAccessTokenPrefix": {
                    "type": "string",
                    "description": "Prefix for all generated personal access tokens.\n"
                },
                "pipelineLimitPerProjectUserSha": {
                    "type": "integer",
                    "description": "Maximum number of pipeline creation requests per minute per user and commit.\n"
                },
                "plantumlEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: plantuml_url) Enable PlantUML integration.\n"
                },
                "plantumlUrl": {
                    "type": "string",
                    "description": "The PlantUML instance URL for integration.\n"
                },
                "pollingIntervalMultiplier": {
                    "type": "number",
                    "description": "Interval multiplier used by endpoints that perform polling. Set to 0 to disable polling.\n"
                },
                "projectExportEnabled": {
                    "type": "boolean",
                    "description": "Enable project export.\n"
                },
                "projectJobsApiRateLimit": {
                    "type": "integer",
                    "description": "Maximum authenticated requests to /project/:id/jobs per minute. Introduced in GitLab 16.5.\n"
                },
                "projectsApiRateLimitUnauthenticated": {
                    "type": "integer",
                    "description": "Introduced in GitLab 15.10. Max number of requests per 10 minutes per IP address for unauthenticated requests to the list all projects API. To disable throttling set to 0.\n"
                },
                "prometheusMetricsEnabled": {
                    "type": "boolean",
                    "description": "Enable Prometheus metrics.\n"
                },
                "protectedCiVariables": {
                    "type": "boolean",
                    "description": "CI/CD variables are protected by default.\n"
                },
                "pushEventActivitiesLimit": {
                    "type": "integer",
                    "description": "Number of changes (branches or tags) in a single push to determine whether individual push events or bulk push events are created. Bulk push events are created if it surpasses that value.\n"
                },
                "pushEventHooksLimit": {
                    "type": "integer",
                    "description": "Number of changes (branches or tags) in a single push to determine whether webhooks and services fire or not. Webhooks and services aren’t submitted if it surpasses that value.\n"
                },
                "pypiPackageRequestsForwarding": {
                    "type": "boolean",
                    "description": "Use pypi.org as a default remote repository when the package is not found in the GitLab Package Registry for PyPI.\n"
                },
                "rateLimitingResponseText": {
                    "type": "string",
                    "description": "When rate limiting is enabled via the throttle_* settings, send this plain text response when a rate limit is exceeded. ‘Retry later’ is sent if this is blank.\n"
                },
                "rawBlobRequestLimit": {
                    "type": "integer",
                    "description": "Max number of requests per minute for each raw path. To disable throttling set to 0.\n"
                },
                "recaptchaEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: recaptcha*private*key and recaptcha*site*key) Enable reCAPTCHA.\n"
                },
                "recaptchaPrivateKey": {
                    "type": "string",
                    "description": "Private key for reCAPTCHA.\n",
                    "secret": true
                },
                "recaptchaSiteKey": {
                    "type": "string",
                    "description": "Site key for reCAPTCHA.\n",
                    "secret": true
                },
                "receiveMaxInputSize": {
                    "type": "integer",
                    "description": "Maximum push size (MB).\n"
                },
                "receptiveClusterAgentsEnabled": {
                    "type": "boolean",
                    "description": "Enable receptive mode for GitLab Agents for Kubernetes.\n"
                },
                "rememberMeEnabled": {
                    "type": "boolean",
                    "description": "Enable Remember me setting. Introduced in GitLab 16.0.\n"
                },
                "repositoryChecksEnabled": {
                    "type": "boolean",
                    "description": "GitLab periodically runs git fsck in all project and wiki repositories to look for silent disk corruption issues.\n"
                },
                "repositorySizeLimit": {
                    "type": "integer",
                    "description": "Size limit per repository (MB).\n"
                },
                "repositoryStorages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(GitLab 13.0 and earlier) List of names of enabled storage paths, taken from gitlab.yml. New projects are created in one of these stores, chosen at random.\n"
                },
                "repositoryStoragesWeighted": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "integer"
                    },
                    "description": "(GitLab 13.1 and later) Hash of names of taken from gitlab.yml to weights. New projects are created in one of these stores, chosen by a weighted random selection.\n"
                },
                "requireAdminApprovalAfterUserSignup": {
                    "type": "boolean",
                    "description": "When enabled, any user that signs up for an account using the registration form is placed under a Pending approval state and has to be explicitly approved by an administrator.\n"
                },
                "requireAdminTwoFactorAuthentication": {
                    "type": "boolean",
                    "description": "Allow administrators to require 2FA for all administrators on the instance.\n"
                },
                "requirePersonalAccessTokenExpiry": {
                    "type": "boolean",
                    "description": "When enabled, users must set an expiration date when creating a group or project access token, or a personal access token owned by a non-service account.\n"
                },
                "requireTwoFactorAuthentication": {
                    "type": "boolean",
                    "description": "(If enabled, requires: two*factor*grace_period) Require all users to set up Two-factor authentication.\n"
                },
                "restrictedVisibilityLevels": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Selected levels cannot be used by non-Administrator users for groups, projects or snippets. Can take private, internal and public as a parameter. Null means there is no restriction.\n"
                },
                "rsaKeyRestriction": {
                    "type": "integer",
                    "description": "The minimum allowed bit length of an uploaded RSA key. 0 means no restriction. -1 disables RSA keys.\n"
                },
                "searchRateLimit": {
                    "type": "integer",
                    "description": "Max number of requests per minute for performing a search while authenticated. To disable throttling set to 0.\n"
                },
                "searchRateLimitUnauthenticated": {
                    "type": "integer",
                    "description": "Max number of requests per minute for performing a search while unauthenticated. To disable throttling set to 0.\n"
                },
                "securityApprovalPoliciesLimit": {
                    "type": "integer",
                    "description": "Maximum number of active merge request approval policies per security policy project. Maximum: 20\n"
                },
                "securityPolicyGlobalGroupApproversEnabled": {
                    "type": "boolean",
                    "description": "Whether to look up merge request approval policy approval groups globally or within project hierarchies.\n"
                },
                "securityTxtContent": {
                    "type": "string",
                    "description": "Public security contact information. Introduced in GitLab 16.7.\n"
                },
                "sendUserConfirmationEmail": {
                    "type": "boolean",
                    "description": "Send confirmation email on sign-up.\n"
                },
                "serviceAccessTokensExpirationEnforced": {
                    "type": "boolean",
                    "description": "Flag to indicate if token expiry date can be optional for service account users\n"
                },
                "sessionExpireDelay": {
                    "type": "integer",
                    "description": "Session duration in minutes. GitLab restart is required to apply changes.\n"
                },
                "sharedRunnersEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: shared*runners*text and shared*runners*minutes) Enable shared runners for new projects.\n"
                },
                "sharedRunnersMinutes": {
                    "type": "integer",
                    "description": "Set the maximum number of CI/CD minutes that a group can use on shared runners per month.\n"
                },
                "sharedRunnersText": {
                    "type": "string",
                    "description": "Shared runners text.\n"
                },
                "sidekiqJobLimiterCompressionThresholdBytes": {
                    "type": "integer",
                    "description": "The threshold in bytes at which Sidekiq jobs are compressed before being stored in Redis.\n"
                },
                "sidekiqJobLimiterLimitBytes": {
                    "type": "integer",
                    "description": "The threshold in bytes at which Sidekiq jobs are rejected. 0 means do not reject any job.\n"
                },
                "sidekiqJobLimiterMode": {
                    "type": "string",
                    "description": "track or compress. Sets the behavior for Sidekiq job size limits.\n"
                },
                "signInText": {
                    "type": "string",
                    "description": "Text on the login page.\n"
                },
                "signupEnabled": {
                    "type": "boolean",
                    "description": "Enable registration.\n"
                },
                "silentAdminExportsEnabled": {
                    "type": "boolean",
                    "description": "Enable Silent admin exports.\n"
                },
                "silentModeEnabled": {
                    "type": "boolean",
                    "description": "Enable Silent mode.\n"
                },
                "slackAppEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: slack*app*id, slack*app*secret and slack*app*secret) Enable Slack app.\n"
                },
                "slackAppId": {
                    "type": "string",
                    "description": "The app ID of the Slack-app.\n"
                },
                "slackAppSecret": {
                    "type": "string",
                    "description": "The app secret of the Slack-app.\n",
                    "secret": true
                },
                "slackAppSigningSecret": {
                    "type": "string",
                    "description": "The signing secret of the Slack-app.\n",
                    "secret": true
                },
                "slackAppVerificationToken": {
                    "type": "string",
                    "description": "The verification token of the Slack-app.\n"
                },
                "snippetSizeLimit": {
                    "type": "integer",
                    "description": "Max snippet content size in bytes.\n"
                },
                "snowplowAppId": {
                    "type": "string",
                    "description": "The Snowplow site name / application ID. (for example, gitlab)\n"
                },
                "snowplowCollectorHostname": {
                    "type": "string",
                    "description": "The Snowplow collector hostname. (for example, snowplow.trx.gitlab.net)\n"
                },
                "snowplowCookieDomain": {
                    "type": "string",
                    "description": "The Snowplow cookie domain. (for example, .gitlab.com)\n"
                },
                "snowplowDatabaseCollectorHostname": {
                    "type": "string",
                    "description": "The Snowplow collector for database events hostname. (for example, db-snowplow.trx.gitlab.net)\n"
                },
                "snowplowEnabled": {
                    "type": "boolean",
                    "description": "Enable snowplow tracking.\n"
                },
                "sourcegraphEnabled": {
                    "type": "boolean",
                    "description": "Enables Sourcegraph integration. If enabled, requires sourcegraph_url.\n"
                },
                "sourcegraphPublicOnly": {
                    "type": "boolean",
                    "description": "Blocks Sourcegraph from being loaded on private and internal projects.\n"
                },
                "sourcegraphUrl": {
                    "type": "string",
                    "description": "The Sourcegraph instance URL for integration.\n"
                },
                "spamCheckApiKey": {
                    "type": "string",
                    "description": "API key used by GitLab for accessing the Spam Check service endpoint.\n",
                    "secret": true
                },
                "spamCheckEndpointEnabled": {
                    "type": "boolean",
                    "description": "Enables spam checking using external Spam Check API endpoint.\n"
                },
                "spamCheckEndpointUrl": {
                    "type": "string",
                    "description": "URL of the external Spamcheck service endpoint. Valid URI schemes are grpc or tls. Specifying tls forces communication to be encrypted.\n"
                },
                "staticObjectsExternalStorageAuthToken": {
                    "type": "string",
                    "description": "Authentication token for the external storage linked in static*objects*external*storage*url.\n",
                    "secret": true
                },
                "staticObjectsExternalStorageUrl": {
                    "type": "string",
                    "description": "URL to an external storage for repository static objects.\n",
                    "secret": true
                },
                "suggestPipelineEnabled": {
                    "type": "boolean",
                    "description": "Enable pipeline suggestion banner.\n"
                },
                "terminalMaxSessionTime": {
                    "type": "integer",
                    "description": "Maximum time for web terminal websocket connection (in seconds). Set to 0 for unlimited time.\n"
                },
                "terms": {
                    "type": "string",
                    "description": "(Required by: enforce_terms) Markdown content for the ToS.\n"
                },
                "throttleAuthenticatedApiEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: throttle*authenticated*api*period*in*seconds and throttle*authenticated*api*requests*per*period) Enable authenticated API request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots).\n"
                },
                "throttleAuthenticatedApiPeriodInSeconds": {
                    "type": "integer",
                    "description": "Rate limit period (in seconds).\n"
                },
                "throttleAuthenticatedApiRequestsPerPeriod": {
                    "type": "integer",
                    "description": "Maximum requests per period per user.\n"
                },
                "throttleAuthenticatedPackagesApiEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: throttle*authenticated*packages*api*period*in*seconds and throttle*authenticated*packages*api*requests*per*period) Enable authenticated API request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots). View Package Registry rate limits for more details.\n"
                },
                "throttleAuthenticatedPackagesApiPeriodInSeconds": {
                    "type": "integer",
                    "description": "Rate limit period (in seconds). View Package Registry rate limits for more details.\n"
                },
                "throttleAuthenticatedPackagesApiRequestsPerPeriod": {
                    "type": "integer",
                    "description": "Maximum requests per period per user. View Package Registry rate limits for more details.\n"
                },
                "throttleAuthenticatedWebEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: throttle*authenticated*web*period*in*seconds and throttle*authenticated*web*requests*per*period) Enable authenticated web request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots).\n"
                },
                "throttleAuthenticatedWebPeriodInSeconds": {
                    "type": "integer",
                    "description": "Rate limit period (in seconds).\n"
                },
                "throttleAuthenticatedWebRequestsPerPeriod": {
                    "type": "integer",
                    "description": "Maximum requests per period per user.\n"
                },
                "throttleUnauthenticatedApiEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: throttle*unauthenticated*api*period*in*seconds and throttle*unauthenticated*api*requests*per*period) Enable unauthenticated API request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots).\n"
                },
                "throttleUnauthenticatedApiPeriodInSeconds": {
                    "type": "integer",
                    "description": "Rate limit period in seconds.\n"
                },
                "throttleUnauthenticatedApiRequestsPerPeriod": {
                    "type": "integer",
                    "description": "Max requests per period per IP.\n"
                },
                "throttleUnauthenticatedPackagesApiEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: throttle*unauthenticated*packages*api*period*in*seconds and throttle*unauthenticated*packages*api*requests*per*period) Enable authenticated API request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots). View Package Registry rate limits for more details.\n"
                },
                "throttleUnauthenticatedPackagesApiPeriodInSeconds": {
                    "type": "integer",
                    "description": "Rate limit period (in seconds). View Package Registry rate limits for more details.\n"
                },
                "throttleUnauthenticatedPackagesApiRequestsPerPeriod": {
                    "type": "integer",
                    "description": "Maximum requests per period per user. View Package Registry rate limits for more details.\n"
                },
                "throttleUnauthenticatedWebEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: throttle*unauthenticated*web*period*in*seconds and throttle*unauthenticated*web*requests*per*period) Enable unauthenticated web request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots).\n"
                },
                "throttleUnauthenticatedWebPeriodInSeconds": {
                    "type": "integer",
                    "description": "Rate limit period in seconds.\n"
                },
                "throttleUnauthenticatedWebRequestsPerPeriod": {
                    "type": "integer",
                    "description": "Max requests per period per IP.\n"
                },
                "timeTrackingLimitToHours": {
                    "type": "boolean",
                    "description": "Limit display of time tracking units to hours.\n"
                },
                "twoFactorGracePeriod": {
                    "type": "integer",
                    "description": "Amount of time (in hours) that users are allowed to skip forced configuration of two-factor authentication.\n"
                },
                "unconfirmedUsersDeleteAfterDays": {
                    "type": "integer",
                    "description": "Specifies how many days after sign-up to delete users who have not confirmed their email. Only applicable if delete*unconfirmed*users is set to true. Must be 1 or greater. Introduced in GitLab 16.1. Self-managed, Premium and Ultimate only.\n"
                },
                "uniqueIpsLimitEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: unique*ips*limit*per*user and unique*ips*limit*time*window) Limit sign in from multiple IPs.\n"
                },
                "uniqueIpsLimitPerUser": {
                    "type": "integer",
                    "description": "Maximum number of IPs per user.\n"
                },
                "uniqueIpsLimitTimeWindow": {
                    "type": "integer",
                    "description": "How many seconds an IP is counted towards the limit.\n"
                },
                "updateRunnerVersionsEnabled": {
                    "type": "boolean",
                    "description": "Fetch GitLab Runner release version data from GitLab.com.\n"
                },
                "usagePingEnabled": {
                    "type": "boolean",
                    "description": "Every week GitLab reports license usage back to GitLab, Inc.\n"
                },
                "useClickhouseForAnalytics": {
                    "type": "boolean",
                    "description": "Enables ClickHouse as a data source for analytics reports. ClickHouse must be configured for this setting to take effect. Available on Premium and Ultimate only.\n"
                },
                "userDeactivationEmailsEnabled": {
                    "type": "boolean",
                    "description": "Send an email to users upon account deactivation.\n"
                },
                "userDefaultExternal": {
                    "type": "boolean",
                    "description": "Newly registered users are external by default.\n"
                },
                "userDefaultInternalRegex": {
                    "type": "string",
                    "description": "Specify an email address regex pattern to identify default internal users.\n"
                },
                "userDefaultsToPrivateProfile": {
                    "type": "boolean",
                    "description": "Newly created users have private profile by default. Introduced in GitLab 15.8.\n"
                },
                "userOauthApplications": {
                    "type": "boolean",
                    "description": "Allow users to register any application to use GitLab as an OAuth provider.\n"
                },
                "userShowAddSshKeyMessage": {
                    "type": "boolean",
                    "description": "When set to false disable the You won't be able to pull or push project code via SSH warning shown to users with no uploaded SSH key.\n"
                },
                "validRunnerRegistrars": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of types which are allowed to register a GitLab Runner. Can be [], ['group'], ['project'] or ['group', 'project'].\n"
                },
                "versionCheckEnabled": {
                    "type": "boolean",
                    "description": "Let GitLab inform you when an update is available.\n"
                },
                "webIdeClientsidePreviewEnabled": {
                    "type": "boolean",
                    "description": "Live Preview (allow live previews of JavaScript projects in the Web IDE using CodeSandbox Live Preview).\n"
                },
                "whatsNewVariant": {
                    "type": "string",
                    "description": "What's new variant, possible values: all*tiers, current*tier, and disabled.\n"
                },
                "wikiPageMaxContentBytes": {
                    "type": "integer",
                    "description": "Maximum wiki page content size in bytes. The minimum value is 1024 bytes.\n"
                }
            },
            "required": [
                "abuseNotificationEmail",
                "adminMode",
                "afterSignOutPath",
                "afterSignUpText",
                "akismetApiKey",
                "akismetEnabled",
                "allowAccountDeletion",
                "allowGroupOwnersToManageLdap",
                "allowLocalRequestsFromSystemHooks",
                "allowLocalRequestsFromWebHooksAndServices",
                "allowProjectCreationForGuestAndBelow",
                "allowRunnerRegistrationToken",
                "archiveBuildsInHumanReadable",
                "asciidocMaxIncludes",
                "assetProxyAllowlists",
                "assetProxyEnabled",
                "assetProxySecretKey",
                "assetProxyUrl",
                "authorizedKeysEnabled",
                "autoBanUserOnExcessiveProjectsDownload",
                "autoDevopsDomain",
                "autoDevopsEnabled",
                "automaticPurchasedStorageAllocation",
                "bulkImportConcurrentPipelineBatchLimit",
                "bulkImportEnabled",
                "bulkImportMaxDownloadFileSize",
                "canCreateGroup",
                "checkNamespacePlan",
                "ciMaxIncludes",
                "ciMaxTotalYamlSizeBytes",
                "commitEmailHostname",
                "concurrentBitbucketImportJobsLimit",
                "concurrentBitbucketServerImportJobsLimit",
                "concurrentGithubImportJobsLimit",
                "containerExpirationPoliciesEnableHistoricEntries",
                "containerRegistryCleanupTagsServiceMaxListSize",
                "containerRegistryDeleteTagsServiceTimeout",
                "containerRegistryExpirationPoliciesCaching",
                "containerRegistryExpirationPoliciesWorkerCapacity",
                "containerRegistryTokenExpireDelay",
                "deactivateDormantUsers",
                "deactivateDormantUsersPeriod",
                "decompressArchiveFileTimeout",
                "defaultArtifactsExpireIn",
                "defaultBranchName",
                "defaultBranchProtection",
                "defaultBranchProtectionDefaults",
                "defaultCiConfigPath",
                "defaultGroupVisibility",
                "defaultPreferredLanguage",
                "defaultProjectCreation",
                "defaultProjectVisibility",
                "defaultProjectsLimit",
                "defaultSnippetVisibility",
                "defaultSyntaxHighlightingTheme",
                "deleteInactiveProjects",
                "deleteUnconfirmedUsers",
                "deletionAdjournedPeriod",
                "diagramsnetEnabled",
                "diagramsnetUrl",
                "diffMaxFiles",
                "diffMaxLines",
                "diffMaxPatchBytes",
                "disableAdminOauthScopes",
                "disableFeedToken",
                "disablePersonalAccessTokens",
                "disabledOauthSignInSources",
                "dnsRebindingProtectionEnabled",
                "domainAllowlists",
                "domainDenylists",
                "domainDenylistEnabled",
                "downstreamPipelineTriggerLimitPerProjectUserSha",
                "dsaKeyRestriction",
                "duoFeaturesEnabled",
                "ecdsaKeyRestriction",
                "ecdsaSkKeyRestriction",
                "ed25519KeyRestriction",
                "ed25519SkKeyRestriction",
                "eksAccessKeyId",
                "eksAccountId",
                "eksIntegrationEnabled",
                "eksSecretAccessKey",
                "elasticsearchAws",
                "elasticsearchAwsAccessKey",
                "elasticsearchAwsRegion",
                "elasticsearchAwsSecretAccessKey",
                "elasticsearchIndexedFieldLengthLimit",
                "elasticsearchIndexedFileSizeLimitKb",
                "elasticsearchIndexing",
                "elasticsearchLimitIndexing",
                "elasticsearchMaxBulkConcurrency",
                "elasticsearchMaxBulkSizeMb",
                "elasticsearchMaxCodeIndexingConcurrency",
                "elasticsearchNamespaceIds",
                "elasticsearchPassword",
                "elasticsearchProjectIds",
                "elasticsearchRequeueWorkers",
                "elasticsearchSearch",
                "elasticsearchUrls",
                "elasticsearchUsername",
                "elasticsearchWorkerNumberOfShards",
                "emailAdditionalText",
                "emailAuthorInBody",
                "emailConfirmationSetting",
                "enableArtifactExternalRedirectWarningPage",
                "enabledGitAccessProtocol",
                "enforceNamespaceStorageLimit",
                "enforceTerms",
                "externalAuthClientCert",
                "externalAuthClientKey",
                "externalAuthClientKeyPass",
                "externalAuthorizationServiceDefaultLabel",
                "externalAuthorizationServiceEnabled",
                "externalAuthorizationServiceTimeout",
                "externalAuthorizationServiceUrl",
                "externalPipelineValidationServiceTimeout",
                "externalPipelineValidationServiceToken",
                "externalPipelineValidationServiceUrl",
                "failedLoginAttemptsUnlockPeriodInMinutes",
                "fileTemplateProjectId",
                "firstDayOfWeek",
                "geoNodeAllowedIps",
                "geoStatusTimeout",
                "gitRateLimitUsersAlertlists",
                "gitRateLimitUsersAllowlists",
                "gitTwoFactorSessionExpiry",
                "gitalyTimeoutDefault",
                "gitalyTimeoutFast",
                "gitalyTimeoutMedium",
                "gitlabDedicatedInstance",
                "gitlabEnvironmentToolkitInstance",
                "gitlabShellOperationLimit",
                "gitpodEnabled",
                "gitpodUrl",
                "globallyAllowedIps",
                "grafanaEnabled",
                "grafanaUrl",
                "gravatarEnabled",
                "groupOwnersCanManageDefaultBranchProtection",
                "hashedStorageEnabled",
                "helpPageHideCommercialContent",
                "helpPageSupportUrl",
                "helpPageText",
                "helpText",
                "hideThirdPartyOffers",
                "homePageUrl",
                "housekeepingEnabled",
                "housekeepingFullRepackPeriod",
                "housekeepingGcPeriod",
                "housekeepingIncrementalRepackPeriod",
                "housekeepingOptimizeRepositoryPeriod",
                "htmlEmailsEnabled",
                "importSources",
                "inProductMarketingEmailsEnabled",
                "inactiveProjectsDeleteAfterMonths",
                "inactiveProjectsMinSizeMb",
                "inactiveProjectsSendWarningEmailAfterMonths",
                "includeOptionalMetricsInServicePing",
                "invisibleCaptchaEnabled",
                "issuesCreateLimit",
                "jiraConnectApplicationKey",
                "jiraConnectProxyUrl",
                "jiraConnectPublicKeyStorageEnabled",
                "keepLatestArtifact",
                "localMarkdownVersion",
                "lockDuoFeaturesEnabled",
                "mailgunEventsEnabled",
                "mailgunSigningKey",
                "maintenanceMode",
                "maintenanceModeMessage",
                "mavenPackageRequestsForwarding",
                "maxArtifactsSize",
                "maxAttachmentSize",
                "maxDecompressedArchiveSize",
                "maxExportSize",
                "maxImportRemoteFileSize",
                "maxImportSize",
                "maxLoginAttempts",
                "maxNumberOfRepositoryDownloads",
                "maxNumberOfRepositoryDownloadsWithinTimePeriod",
                "maxPagesSize",
                "maxPersonalAccessTokenLifetime",
                "maxSshKeyLifetime",
                "maxTerraformStateSizeBytes",
                "metricsMethodCallThreshold",
                "minimumPasswordLength",
                "mirrorAvailable",
                "mirrorCapacityThreshold",
                "mirrorMaxCapacity",
                "mirrorMaxDelay",
                "npmPackageRequestsForwarding",
                "nugetSkipMetadataUrlValidation",
                "outboundLocalRequestsWhitelists",
                "packageMetadataPurlTypes",
                "packageRegistryAllowAnyoneToPullOption",
                "packageRegistryCleanupPoliciesWorkerCapacity",
                "pagesDomainVerificationEnabled",
                "passwordAuthenticationEnabledForGit",
                "passwordAuthenticationEnabledForWeb",
                "passwordLowercaseRequired",
                "passwordNumberRequired",
                "passwordSymbolRequired",
                "passwordUppercaseRequired",
                "performanceBarAllowedGroupPath",
                "personalAccessTokenPrefix",
                "pipelineLimitPerProjectUserSha",
                "plantumlEnabled",
                "plantumlUrl",
                "pollingIntervalMultiplier",
                "projectExportEnabled",
                "projectJobsApiRateLimit",
                "projectsApiRateLimitUnauthenticated",
                "prometheusMetricsEnabled",
                "protectedCiVariables",
                "pushEventActivitiesLimit",
                "pushEventHooksLimit",
                "pypiPackageRequestsForwarding",
                "rateLimitingResponseText",
                "rawBlobRequestLimit",
                "recaptchaEnabled",
                "recaptchaPrivateKey",
                "recaptchaSiteKey",
                "receiveMaxInputSize",
                "receptiveClusterAgentsEnabled",
                "rememberMeEnabled",
                "repositoryChecksEnabled",
                "repositorySizeLimit",
                "repositoryStorages",
                "repositoryStoragesWeighted",
                "requireAdminApprovalAfterUserSignup",
                "requireAdminTwoFactorAuthentication",
                "requirePersonalAccessTokenExpiry",
                "requireTwoFactorAuthentication",
                "restrictedVisibilityLevels",
                "rsaKeyRestriction",
                "searchRateLimit",
                "searchRateLimitUnauthenticated",
                "securityApprovalPoliciesLimit",
                "securityPolicyGlobalGroupApproversEnabled",
                "securityTxtContent",
                "sendUserConfirmationEmail",
                "serviceAccessTokensExpirationEnforced",
                "sessionExpireDelay",
                "sharedRunnersEnabled",
                "sharedRunnersMinutes",
                "sharedRunnersText",
                "sidekiqJobLimiterCompressionThresholdBytes",
                "sidekiqJobLimiterLimitBytes",
                "sidekiqJobLimiterMode",
                "signInText",
                "signupEnabled",
                "silentAdminExportsEnabled",
                "silentModeEnabled",
                "slackAppEnabled",
                "slackAppId",
                "slackAppSecret",
                "slackAppSigningSecret",
                "slackAppVerificationToken",
                "snippetSizeLimit",
                "snowplowAppId",
                "snowplowCollectorHostname",
                "snowplowCookieDomain",
                "snowplowDatabaseCollectorHostname",
                "snowplowEnabled",
                "sourcegraphEnabled",
                "sourcegraphPublicOnly",
                "sourcegraphUrl",
                "spamCheckApiKey",
                "spamCheckEndpointEnabled",
                "spamCheckEndpointUrl",
                "suggestPipelineEnabled",
                "terminalMaxSessionTime",
                "terms",
                "throttleAuthenticatedApiEnabled",
                "throttleAuthenticatedApiPeriodInSeconds",
                "throttleAuthenticatedApiRequestsPerPeriod",
                "throttleAuthenticatedPackagesApiEnabled",
                "throttleAuthenticatedPackagesApiPeriodInSeconds",
                "throttleAuthenticatedPackagesApiRequestsPerPeriod",
                "throttleAuthenticatedWebEnabled",
                "throttleAuthenticatedWebPeriodInSeconds",
                "throttleAuthenticatedWebRequestsPerPeriod",
                "throttleUnauthenticatedApiEnabled",
                "throttleUnauthenticatedApiPeriodInSeconds",
                "throttleUnauthenticatedApiRequestsPerPeriod",
                "throttleUnauthenticatedPackagesApiEnabled",
                "throttleUnauthenticatedPackagesApiPeriodInSeconds",
                "throttleUnauthenticatedPackagesApiRequestsPerPeriod",
                "throttleUnauthenticatedWebEnabled",
                "throttleUnauthenticatedWebPeriodInSeconds",
                "throttleUnauthenticatedWebRequestsPerPeriod",
                "timeTrackingLimitToHours",
                "twoFactorGracePeriod",
                "unconfirmedUsersDeleteAfterDays",
                "uniqueIpsLimitEnabled",
                "uniqueIpsLimitPerUser",
                "uniqueIpsLimitTimeWindow",
                "updateRunnerVersionsEnabled",
                "usagePingEnabled",
                "useClickhouseForAnalytics",
                "userDeactivationEmailsEnabled",
                "userDefaultExternal",
                "userDefaultInternalRegex",
                "userDefaultsToPrivateProfile",
                "userOauthApplications",
                "userShowAddSshKeyMessage",
                "validRunnerRegistrars",
                "versionCheckEnabled",
                "webIdeClientsidePreviewEnabled",
                "whatsNewVariant",
                "wikiPageMaxContentBytes"
            ],
            "inputProperties": {
                "abuseNotificationEmail": {
                    "type": "string",
                    "description": "If set, abuse reports are sent to this address. Abuse reports are always available in the Admin Area.\n"
                },
                "adminMode": {
                    "type": "boolean",
                    "description": "Require administrators to enable Admin Mode by re-authenticating for administrative tasks.\n"
                },
                "afterSignOutPath": {
                    "type": "string",
                    "description": "Where to redirect users after logout.\n"
                },
                "afterSignUpText": {
                    "type": "string",
                    "description": "Text shown to the user after signing up.\n"
                },
                "akismetApiKey": {
                    "type": "string",
                    "description": "API key for Akismet spam protection.\n",
                    "secret": true
                },
                "akismetEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: akismet*api*key) Enable or disable Akismet spam protection.\n"
                },
                "allowAccountDeletion": {
                    "type": "boolean",
                    "description": "Set to true to allow users to delete their accounts. Premium and Ultimate only.\n"
                },
                "allowGroupOwnersToManageLdap": {
                    "type": "boolean",
                    "description": "Set to true to allow group owners to manage LDAP.\n"
                },
                "allowLocalRequestsFromSystemHooks": {
                    "type": "boolean",
                    "description": "Allow requests to the local network from system hooks.\n"
                },
                "allowLocalRequestsFromWebHooksAndServices": {
                    "type": "boolean",
                    "description": "Allow requests to the local network from web hooks and services.\n"
                },
                "allowProjectCreationForGuestAndBelow": {
                    "type": "boolean",
                    "description": "Indicates whether users assigned up to the Guest role can create groups and personal projects.\n"
                },
                "allowRunnerRegistrationToken": {
                    "type": "boolean",
                    "description": "Allow using a registration token to create a runner.\n"
                },
                "archiveBuildsInHumanReadable": {
                    "type": "string",
                    "description": "Set the duration for which the jobs are considered as old and expired. After that time passes, the jobs are archived and no longer able to be retried. Make it empty to never expire jobs. It has to be no less than 1 day, for example: 15 days, 1 month, 2 years.\n"
                },
                "asciidocMaxIncludes": {
                    "type": "integer",
                    "description": "Maximum limit of AsciiDoc include directives being processed in any one document. Maximum: 64.\n"
                },
                "assetProxyAllowlists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Assets that match these domains are not proxied. Wildcards allowed. Your GitLab installation URL is automatically allowlisted. GitLab restart is required to apply changes.\n"
                },
                "assetProxyEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: asset*proxy*url) Enable proxying of assets. GitLab restart is required to apply changes.\n"
                },
                "assetProxySecretKey": {
                    "type": "string",
                    "description": "Shared secret with the asset proxy server. GitLab restart is required to apply changes.\n",
                    "secret": true
                },
                "assetProxyUrl": {
                    "type": "string",
                    "description": "URL of the asset proxy server. GitLab restart is required to apply changes.\n"
                },
                "authorizedKeysEnabled": {
                    "type": "boolean",
                    "description": "By default, we write to the authorized_keys file to support Git over SSH without additional configuration. GitLab can be optimized to authenticate SSH keys via the database file. Only disable this if you have configured your OpenSSH server to use the AuthorizedKeysCommand.\n"
                },
                "autoBanUserOnExcessiveProjectsDownload": {
                    "type": "boolean",
                    "description": "When enabled, users will get automatically banned from the application when they download more than the maximum number of unique projects in the time period specified by max*number*of*repository*downloads and max*number*of*repository*downloads*within*time_period respectively. Introduced in GitLab 15.4. Self-managed, Ultimate only.\n"
                },
                "autoDevopsDomain": {
                    "type": "string",
                    "description": "Specify a domain to use by default for every project’s Auto Review Apps and Auto Deploy stages.\n"
                },
                "autoDevopsEnabled": {
                    "type": "boolean",
                    "description": "Enable Auto DevOps for projects by default. It automatically builds, tests, and deploys applications based on a predefined CI/CD configuration.\n"
                },
                "automaticPurchasedStorageAllocation": {
                    "type": "boolean",
                    "description": "Enabling this permits automatic allocation of purchased storage in a namespace.\n"
                },
                "bulkImportConcurrentPipelineBatchLimit": {
                    "type": "integer",
                    "description": "Maximum simultaneous Direct Transfer batches to process.\n"
                },
                "bulkImportEnabled": {
                    "type": "boolean",
                    "description": "Enable migrating GitLab groups by direct transfer. Introduced in GitLab 15.8.\n"
                },
                "bulkImportMaxDownloadFileSize": {
                    "type": "integer",
                    "description": "Maximum download file size when importing from source GitLab instances by direct transfer. Introduced in GitLab 16.3.\n"
                },
                "canCreateGroup": {
                    "type": "boolean",
                    "description": "Indicates whether users can create top-level groups. Introduced in GitLab 15.5.\n"
                },
                "checkNamespacePlan": {
                    "type": "boolean",
                    "description": "Enabling this makes only licensed EE features available to projects if the project namespace’s plan includes the feature or if the project is public.\n"
                },
                "ciMaxIncludes": {
                    "type": "integer",
                    "description": "The maximum number of includes per pipeline.\n"
                },
                "ciMaxTotalYamlSizeBytes": {
                    "type": "integer",
                    "description": "The maximum amount of memory, in bytes, that can be allocated for the pipeline configuration, with all included YAML configuration files.\n"
                },
                "commitEmailHostname": {
                    "type": "string",
                    "description": "Custom hostname (for private commit emails).\n"
                },
                "concurrentBitbucketImportJobsLimit": {
                    "type": "integer",
                    "description": "Maximum number of simultaneous import jobs for the Bitbucket Cloud importer. Introduced in GitLab 16.11.\n"
                },
                "concurrentBitbucketServerImportJobsLimit": {
                    "type": "integer",
                    "description": "Maximum number of simultaneous import jobs for the Bitbucket Server importer. Introduced in GitLab 16.11.\n"
                },
                "concurrentGithubImportJobsLimit": {
                    "type": "integer",
                    "description": "Maximum number of simultaneous import jobs for the GitHub importer. Introduced in GitLab 16.11.\n"
                },
                "containerExpirationPoliciesEnableHistoricEntries": {
                    "type": "boolean",
                    "description": "Enable cleanup policies for all projects.\n"
                },
                "containerRegistryCleanupTagsServiceMaxListSize": {
                    "type": "integer",
                    "description": "The maximum number of tags that can be deleted in a single execution of cleanup policies.\n"
                },
                "containerRegistryDeleteTagsServiceTimeout": {
                    "type": "integer",
                    "description": "The maximum time, in seconds, that the cleanup process can take to delete a batch of tags for cleanup policies.\n"
                },
                "containerRegistryExpirationPoliciesCaching": {
                    "type": "boolean",
                    "description": "Caching during the execution of cleanup policies.\n"
                },
                "containerRegistryExpirationPoliciesWorkerCapacity": {
                    "type": "integer",
                    "description": "Number of workers for cleanup policies.\n"
                },
                "containerRegistryTokenExpireDelay": {
                    "type": "integer",
                    "description": "Container Registry token duration in minutes.\n"
                },
                "deactivateDormantUsers": {
                    "type": "boolean",
                    "description": "Enable automatic deactivation of dormant users.\n"
                },
                "deactivateDormantUsersPeriod": {
                    "type": "integer",
                    "description": "Length of time (in days) after which a user is considered dormant. Introduced in GitLab 15.3.\n"
                },
                "decompressArchiveFileTimeout": {
                    "type": "integer",
                    "description": "Default timeout for decompressing archived files, in seconds. Set to 0 to disable timeouts. Introduced in GitLab 16.4.\n"
                },
                "defaultArtifactsExpireIn": {
                    "type": "string",
                    "description": "Set the default expiration time for each job’s artifacts.\n"
                },
                "defaultBranchName": {
                    "type": "string",
                    "description": "Instance-level custom initial branch name (introduced in GitLab 13.2).\n"
                },
                "defaultBranchProtection": {
                    "type": "integer",
                    "description": "Determine if developers can push to the default branch. Can take: 0 (not protected, both users with the Developer role or Maintainer role can push new commits and force push), 1 (partially protected, users with the Developer role or Maintainer role can push new commits, but cannot force push) or 2 (fully protected, users with the Developer or Maintainer role cannot push new commits, but users with the Developer or Maintainer role can; no one can force push) as a parameter. Default is 2.\n"
                },
                "defaultBranchProtectionDefaults": {
                    "$ref": "#/types/gitlab:index/ApplicationSettingsDefaultBranchProtectionDefaults:ApplicationSettingsDefaultBranchProtectionDefaults",
                    "description": "The default*branch*protection*defaults attribute describes the default branch protection defaults. All parameters are optional.\n"
                },
                "defaultCiConfigPath": {
                    "type": "string",
                    "description": "Default CI/CD configuration file and path for new projects (.gitlab-ci.yml if not set).\n"
                },
                "defaultGroupVisibility": {
                    "type": "string",
                    "description": "What visibility level new groups receive. Can take private, internal and public as a parameter.\n"
                },
                "defaultPreferredLanguage": {
                    "type": "string",
                    "description": "Default preferred language for users who are not logged in.\n"
                },
                "defaultProjectCreation": {
                    "type": "integer",
                    "description": "Default project creation protection. Can take: 0 (No one), 1 (Maintainers) or 2 (Developers + Maintainers).\n"
                },
                "defaultProjectVisibility": {
                    "type": "string",
                    "description": "What visibility level new projects receive. Can take private, internal and public as a parameter.\n"
                },
                "defaultProjectsLimit": {
                    "type": "integer",
                    "description": "Project limit per user.\n"
                },
                "defaultSnippetVisibility": {
                    "type": "string",
                    "description": "What visibility level new snippets receive. Can take private, internal and public as a parameter.\n"
                },
                "defaultSyntaxHighlightingTheme": {
                    "type": "integer",
                    "description": "Default syntax highlighting theme for users who are new or not signed in. See IDs of available themes (https://gitlab.com/gitlab-org/gitlab/blob/master/lib/gitlab/themes.rb#L16)\n"
                },
                "deleteInactiveProjects": {
                    "type": "boolean",
                    "description": "Enable inactive project deletion feature. Introduced in GitLab 14.10. Became operational in GitLab 15.0 (with feature flag inactive*projects*deletion).\n"
                },
                "deleteUnconfirmedUsers": {
                    "type": "boolean",
                    "description": "Specifies whether users who have not confirmed their email should be deleted. When set to true, unconfirmed users are deleted after unconfirmed*users*delete*after*days days. Introduced in GitLab 16.1. Self-managed, Premium and Ultimate only.\n"
                },
                "deletionAdjournedPeriod": {
                    "type": "integer",
                    "description": "The number of days to wait before deleting a project or group that is marked for deletion. Value must be between 1 and 90.\n"
                },
                "diagramsnetEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires diagramsnet_url) Enable Diagrams.net integration.\n"
                },
                "diagramsnetUrl": {
                    "type": "string",
                    "description": "The Diagrams.net instance URL for integration.\n"
                },
                "diffMaxFiles": {
                    "type": "integer",
                    "description": "Maximum files in a diff.\n"
                },
                "diffMaxLines": {
                    "type": "integer",
                    "description": "Maximum lines in a diff.\n"
                },
                "diffMaxPatchBytes": {
                    "type": "integer",
                    "description": "Maximum diff patch size, in bytes.\n"
                },
                "disableAdminOauthScopes": {
                    "type": "boolean",
                    "description": "Stops administrators from connecting their GitLab accounts to non-trusted OAuth 2.0 applications that have the api, read*api, read*repository, write*repository, read*registry, write_registry, or sudo scopes. Introduced in GitLab 15.6.\n"
                },
                "disableFeedToken": {
                    "type": "boolean",
                    "description": "Disable display of RSS/Atom and calendar feed tokens (introduced in GitLab 13.7).\n"
                },
                "disablePersonalAccessTokens": {
                    "type": "boolean",
                    "description": "Disable personal access tokens. Introduced in GitLab 15.7. Self-managed, Premium and Ultimate only. There is no method available to enable a personal access token that’s been disabled through the API. This is a known issue.\n"
                },
                "disabledOauthSignInSources": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Disabled OAuth sign-in sources.\n"
                },
                "dnsRebindingProtectionEnabled": {
                    "type": "boolean",
                    "description": "Enforce DNS rebinding attack protection.\n"
                },
                "domainAllowlists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Force people to use only corporate emails for sign-up. Null means there is no restriction.\n"
                },
                "domainDenylistEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: domain_denylist) Allows blocking sign-ups from emails from specific domains.\n"
                },
                "domainDenylists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Users with email addresses that match these domains cannot sign up. Wildcards allowed. Use separate lines for multiple entries. Ex: domain.com, *.domain.com.\n"
                },
                "downstreamPipelineTriggerLimitPerProjectUserSha": {
                    "type": "integer",
                    "description": "Maximum downstream pipeline trigger rate. Introduced in GitLab 16.10.\n"
                },
                "dsaKeyRestriction": {
                    "type": "integer",
                    "description": "The minimum allowed bit length of an uploaded DSA key. 0 means no restriction. -1 disables DSA keys.\n"
                },
                "duoFeaturesEnabled": {
                    "type": "boolean",
                    "description": "Indicates whether GitLab Duo features are enabled for this instance. Introduced in GitLab 16.10. Self-managed, Premium and Ultimate only.\n"
                },
                "ecdsaKeyRestriction": {
                    "type": "integer",
                    "description": "The minimum allowed curve size (in bits) of an uploaded ECDSA key. 0 means no restriction. -1 disables ECDSA keys.\n"
                },
                "ecdsaSkKeyRestriction": {
                    "type": "integer",
                    "description": "The minimum allowed curve size (in bits) of an uploaded ECDSA*SK key. 0 means no restriction. -1 disables ECDSA*SK keys.\n"
                },
                "ed25519KeyRestriction": {
                    "type": "integer",
                    "description": "The minimum allowed curve size (in bits) of an uploaded ED25519 key. 0 means no restriction. -1 disables ED25519 keys.\n"
                },
                "ed25519SkKeyRestriction": {
                    "type": "integer",
                    "description": "The minimum allowed curve size (in bits) of an uploaded ED25519*SK key. 0 means no restriction. -1 disables ED25519*SK keys.\n"
                },
                "eksAccessKeyId": {
                    "type": "string",
                    "description": "AWS IAM access key ID.\n",
                    "secret": true
                },
                "eksAccountId": {
                    "type": "string",
                    "description": "Amazon account ID.\n"
                },
                "eksIntegrationEnabled": {
                    "type": "boolean",
                    "description": "Enable integration with Amazon EKS.\n"
                },
                "eksSecretAccessKey": {
                    "type": "string",
                    "description": "AWS IAM secret access key.\n",
                    "secret": true
                },
                "elasticsearchAws": {
                    "type": "boolean",
                    "description": "Enable the use of AWS hosted Elasticsearch.\n"
                },
                "elasticsearchAwsAccessKey": {
                    "type": "string",
                    "description": "AWS IAM access key.\n",
                    "secret": true
                },
                "elasticsearchAwsRegion": {
                    "type": "string",
                    "description": "The AWS region the Elasticsearch domain is configured.\n"
                },
                "elasticsearchAwsSecretAccessKey": {
                    "type": "string",
                    "description": "AWS IAM secret access key.\n",
                    "secret": true
                },
                "elasticsearchIndexedFieldLengthLimit": {
                    "type": "integer",
                    "description": "Maximum size of text fields to index by Elasticsearch. 0 value means no limit. This does not apply to repository and wiki indexing.\n"
                },
                "elasticsearchIndexedFileSizeLimitKb": {
                    "type": "integer",
                    "description": "Maximum size of repository and wiki files that are indexed by Elasticsearch.\n"
                },
                "elasticsearchIndexing": {
                    "type": "boolean",
                    "description": "Enable Elasticsearch indexing.\n"
                },
                "elasticsearchLimitIndexing": {
                    "type": "boolean",
                    "description": "Limit Elasticsearch to index certain namespaces and projects.\n"
                },
                "elasticsearchMaxBulkConcurrency": {
                    "type": "integer",
                    "description": "Maximum concurrency of Elasticsearch bulk requests per indexing operation. This only applies to repository indexing operations.\n"
                },
                "elasticsearchMaxBulkSizeMb": {
                    "type": "integer",
                    "description": "Maximum size of Elasticsearch bulk indexing requests in MB. This only applies to repository indexing operations.\n"
                },
                "elasticsearchMaxCodeIndexingConcurrency": {
                    "type": "integer",
                    "description": "Maximum concurrency of Elasticsearch code indexing background jobs. This only applies to repository indexing operations. Premium and Ultimate only.\n"
                },
                "elasticsearchNamespaceIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "The namespaces to index via Elasticsearch if elasticsearch*limit*indexing is enabled.\n"
                },
                "elasticsearchPassword": {
                    "type": "string",
                    "description": "The password of your Elasticsearch instance.\n",
                    "secret": true
                },
                "elasticsearchProjectIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "The projects to index via Elasticsearch if elasticsearch*limit*indexing is enabled.\n"
                },
                "elasticsearchRequeueWorkers": {
                    "type": "boolean",
                    "description": "Enable automatic requeuing of indexing workers. This improves non-code indexing throughput by enqueuing Sidekiq jobs until all documents are processed. Premium and Ultimate only.\n"
                },
                "elasticsearchSearch": {
                    "type": "boolean",
                    "description": "Enable Elasticsearch search.\n"
                },
                "elasticsearchUrls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The URL to use for connecting to Elasticsearch. Use a comma-separated list to support cluster (for example, http://localhost:9200, http://localhost:9201).\n"
                },
                "elasticsearchUsername": {
                    "type": "string",
                    "description": "The username of your Elasticsearch instance.\n"
                },
                "elasticsearchWorkerNumberOfShards": {
                    "type": "integer",
                    "description": "Number of indexing worker shards. This improves non-code indexing throughput by enqueuing more parallel Sidekiq jobs. Premium and Ultimate only.\n"
                },
                "emailAdditionalText": {
                    "type": "string",
                    "description": "Additional text added to the bottom of every email for legal/auditing/compliance reasons.\n"
                },
                "emailAuthorInBody": {
                    "type": "boolean",
                    "description": "Some email servers do not support overriding the email sender name. Enable this option to include the name of the author of the issue, merge request or comment in the email body instead.\n"
                },
                "emailConfirmationSetting": {
                    "type": "string",
                    "description": "Specifies whether users must confirm their email before sign in. Possible values are off, soft, and hard.\n"
                },
                "enableArtifactExternalRedirectWarningPage": {
                    "type": "boolean",
                    "description": "Show the external redirect page that warns you about user-generated content in GitLab Pages.\n"
                },
                "enabledGitAccessProtocol": {
                    "type": "string",
                    "description": "Enabled protocols for Git access. Allowed values are: ssh, http, and nil to allow both protocols.\n"
                },
                "enforceNamespaceStorageLimit": {
                    "type": "boolean",
                    "description": "Enabling this permits enforcement of namespace storage limits.\n"
                },
                "enforceTerms": {
                    "type": "boolean",
                    "description": "(If enabled, requires: terms) Enforce application ToS to all users.\n"
                },
                "externalAuthClientCert": {
                    "type": "string",
                    "description": "(If enabled, requires: external*auth*client_key) The certificate to use to authenticate with the external authorization service.\n"
                },
                "externalAuthClientKey": {
                    "type": "string",
                    "description": "Private key for the certificate when authentication is required for the external authorization service, this is encrypted when stored.\n",
                    "secret": true
                },
                "externalAuthClientKeyPass": {
                    "type": "string",
                    "description": "Passphrase to use for the private key when authenticating with the external service this is encrypted when stored.\n",
                    "secret": true
                },
                "externalAuthorizationServiceDefaultLabel": {
                    "type": "string",
                    "description": "The default classification label to use when requesting authorization and no classification label has been specified on the project.\n"
                },
                "externalAuthorizationServiceEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: external*authorization*service*default*label, external*authorization*service*timeout and external*authorization*service*url) Enable using an external authorization service for accessing projects.\n"
                },
                "externalAuthorizationServiceTimeout": {
                    "type": "number",
                    "description": "The timeout after which an authorization request is aborted, in seconds. When a request times out, access is denied to the user. (min: 0.001, max: 10, step: 0.001).\n"
                },
                "externalAuthorizationServiceUrl": {
                    "type": "string",
                    "description": "URL to which authorization requests are directed.\n"
                },
                "externalPipelineValidationServiceTimeout": {
                    "type": "integer",
                    "description": "How long to wait for a response from the pipeline validation service. Assumes OK if it times out.\n"
                },
                "externalPipelineValidationServiceToken": {
                    "type": "string",
                    "description": "Optional. Token to include as the X-Gitlab-Token header in requests to the URL in external*pipeline*validation*service*url.\n"
                },
                "externalPipelineValidationServiceUrl": {
                    "type": "string",
                    "description": "URL to use for pipeline validation requests.\n"
                },
                "failedLoginAttemptsUnlockPeriodInMinutes": {
                    "type": "integer",
                    "description": "Time period in minutes after which the user is unlocked when maximum number of failed sign-in attempts reached.\n"
                },
                "fileTemplateProjectId": {
                    "type": "integer",
                    "description": "The ID of a project to load custom file templates from.\n"
                },
                "firstDayOfWeek": {
                    "type": "integer",
                    "description": "Start day of the week for calendar views and date pickers. Valid values are 0 for Sunday, 1 for Monday, and 6 for Saturday.\n"
                },
                "geoNodeAllowedIps": {
                    "type": "string",
                    "description": "Comma-separated list of IPs and CIDRs of allowed secondary nodes. For example, 1.1.1.1, 2.2.2.0/24.\n"
                },
                "geoStatusTimeout": {
                    "type": "integer",
                    "description": "The amount of seconds after which a request to get a secondary node status times out.\n"
                },
                "gitRateLimitUsersAlertlists": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "List of user IDs that are emailed when the Git abuse rate limit is exceeded. Maximum: 100 user IDs. Introduced in GitLab 15.9. Self-managed, Ultimate only.\n"
                },
                "gitRateLimitUsersAllowlists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of usernames excluded from Git anti-abuse rate limits. Maximum: 100 usernames. Introduced in GitLab 15.2. Self-managed, Ultimate only.\n"
                },
                "gitTwoFactorSessionExpiry": {
                    "type": "integer",
                    "description": "Maximum duration (in minutes) of a session for Git operations when 2FA is enabled.\n"
                },
                "gitalyTimeoutDefault": {
                    "type": "integer",
                    "description": "Default Gitaly timeout, in seconds. This timeout is not enforced for Git fetch/push operations or Sidekiq jobs. Set to 0 to disable timeouts.\n"
                },
                "gitalyTimeoutFast": {
                    "type": "integer",
                    "description": "Gitaly fast operation timeout, in seconds. Some Gitaly operations are expected to be fast. If they exceed this threshold, there may be a problem with a storage shard and ‘failing fast’ can help maintain the stability of the GitLab instance. Set to 0 to disable timeouts.\n"
                },
                "gitalyTimeoutMedium": {
                    "type": "integer",
                    "description": "Medium Gitaly timeout, in seconds. This should be a value between the Fast and the Default timeout. Set to 0 to disable timeouts.\n"
                },
                "gitlabShellOperationLimit": {
                    "type": "integer",
                    "description": "Maximum number of Git operations per minute a user can perform. Introduced in GitLab 16.2.\n"
                },
                "gitpodEnabled": {
                    "type": "boolean",
                    "description": "Enable Gitpod integration.\n"
                },
                "gitpodUrl": {
                    "type": "string",
                    "description": "The Gitpod instance URL for integration.\n"
                },
                "globallyAllowedIps": {
                    "type": "string",
                    "description": "Comma-separated list of IP addresses and CIDRs always allowed for inbound traffic. For example, 1.1.1.1, 2.2.2.0/24.\n"
                },
                "grafanaEnabled": {
                    "type": "boolean",
                    "description": "Enable Grafana.\n"
                },
                "grafanaUrl": {
                    "type": "string",
                    "description": "Grafana URL.\n"
                },
                "gravatarEnabled": {
                    "type": "boolean",
                    "description": "Enable Gravatar.\n"
                },
                "groupOwnersCanManageDefaultBranchProtection": {
                    "type": "boolean",
                    "description": "Prevent overrides of default branch protection.\n"
                },
                "hashedStorageEnabled": {
                    "type": "boolean",
                    "description": "Create new projects using hashed storage paths: Enable immutable, hash-based paths and repository names to store repositories on disk. This prevents repositories from having to be moved or renamed when the Project URL changes and may improve disk I/O performance. (Always enabled in GitLab versions 13.0 and later, configuration is scheduled for removal in 14.0).\n"
                },
                "helpPageHideCommercialContent": {
                    "type": "boolean",
                    "description": "Hide marketing-related entries from help.\n"
                },
                "helpPageSupportUrl": {
                    "type": "string",
                    "description": "Alternate support URL for help page and help dropdown.\n"
                },
                "helpPageText": {
                    "type": "string",
                    "description": "Custom text displayed on the help page.\n"
                },
                "helpText": {
                    "type": "string",
                    "description": "GitLab server administrator information.\n"
                },
                "hideThirdPartyOffers": {
                    "type": "boolean",
                    "description": "Do not display offers from third parties in GitLab.\n"
                },
                "homePageUrl": {
                    "type": "string",
                    "description": "Redirect to this URL when not logged in.\n"
                },
                "housekeepingEnabled": {
                    "type": "boolean",
                    "description": "Enable or disable Git housekeeping.\n\t\t\tIf enabled, requires either housekeeping*optimize*repository*period OR housekeeping*bitmaps*enabled, housekeeping*full*repack*period, housekeeping*gc*period, and housekeeping*incremental*repack*period.\n\t\t\tOptions housekeeping*bitmaps*enabled, housekeeping*full*repack*period, housekeeping*gc*period, and housekeeping*incremental*repack*period are deprecated. Use housekeeping*optimize*repository*period instead.\n"
                },
                "housekeepingFullRepackPeriod": {
                    "type": "integer",
                    "description": "Number of Git pushes after which an incremental git repack is run.\n",
                    "deprecationMessage": "housekeeping_full_repack_period is deprecated. Use housekeeping_optimize_repository_period instead."
                },
                "housekeepingGcPeriod": {
                    "type": "integer",
                    "description": "Number of Git pushes after which git gc is run.\n",
                    "deprecationMessage": "housekeeping_gc_period is deprecated. Use housekeeping_optimize_repository_period instead."
                },
                "housekeepingIncrementalRepackPeriod": {
                    "type": "integer",
                    "description": "Number of Git pushes after which an incremental git repack is run.\n",
                    "deprecationMessage": "housekeeping_incremental_repack_period is deprecated. Use housekeeping_optimize_repository_period instead."
                },
                "housekeepingOptimizeRepositoryPeriod": {
                    "type": "integer",
                    "description": "Number of Git pushes after which an incremental git repack is run.\n"
                },
                "htmlEmailsEnabled": {
                    "type": "boolean",
                    "description": "Enable HTML emails.\n"
                },
                "importSources": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Sources to allow project import from. Valid values are: `github`, `bitbucket`, `bitbucket_server`, `fogbugz`, `git`, `gitlab.Project`, `gitea`, `manifest`\n"
                },
                "inProductMarketingEmailsEnabled": {
                    "type": "boolean",
                    "description": "Enable in-product marketing emails.\n"
                },
                "inactiveProjectsDeleteAfterMonths": {
                    "type": "integer",
                    "description": "If delete*inactive*projects is true, the time (in months) to wait before deleting inactive projects. Introduced in GitLab 14.10. Became operational in GitLab 15.0.\n"
                },
                "inactiveProjectsMinSizeMb": {
                    "type": "integer",
                    "description": "If delete*inactive*projects is true, the minimum repository size for projects to be checked for inactivity. Introduced in GitLab 14.10. Became operational in GitLab 15.0.\n"
                },
                "inactiveProjectsSendWarningEmailAfterMonths": {
                    "type": "integer",
                    "description": "If delete*inactive*projects is true, sets the time (in months) to wait before emailing maintainers that the project is scheduled be deleted because it is inactive. Introduced in GitLab 14.10. Became operational in GitLab 15.0.\n"
                },
                "includeOptionalMetricsInServicePing": {
                    "type": "boolean",
                    "description": "Whether or not optional metrics are enabled in Service Ping. Introduced in GitLab 16.10.\n"
                },
                "invisibleCaptchaEnabled": {
                    "type": "boolean",
                    "description": "Enable Invisible CAPTCHA spam detection during sign-up.\n"
                },
                "issuesCreateLimit": {
                    "type": "integer",
                    "description": "Max number of issue creation requests per minute per user.\n"
                },
                "jiraConnectApplicationKey": {
                    "type": "string",
                    "description": "ID of the OAuth application used to authenticate with the GitLab for Jira Cloud app.\n"
                },
                "jiraConnectProxyUrl": {
                    "type": "string",
                    "description": "URL of the GitLab instance used as a proxy for the GitLab for Jira Cloud app.\n"
                },
                "jiraConnectPublicKeyStorageEnabled": {
                    "type": "boolean",
                    "description": "Enable public key storage for the GitLab for Jira Cloud app.\n"
                },
                "keepLatestArtifact": {
                    "type": "boolean",
                    "description": "Prevent the deletion of the artifacts from the most recent successful jobs, regardless of the expiry time.\n"
                },
                "localMarkdownVersion": {
                    "type": "integer",
                    "description": "Increase this value when any cached Markdown should be invalidated.\n"
                },
                "lockDuoFeaturesEnabled": {
                    "type": "boolean",
                    "description": "Indicates whether the GitLab Duo features enabled setting is enforced for all subgroups. Introduced in GitLab 16.10. Self-managed, Premium and Ultimate only.\n"
                },
                "mailgunEventsEnabled": {
                    "type": "boolean",
                    "description": "Enable Mailgun event receiver.\n"
                },
                "mailgunSigningKey": {
                    "type": "string",
                    "description": "The Mailgun HTTP webhook signing key for receiving events from webhook.\n",
                    "secret": true
                },
                "maintenanceMode": {
                    "type": "boolean",
                    "description": "When instance is in maintenance mode, non-administrative users can sign in with read-only access and make read-only API requests.\n"
                },
                "maintenanceModeMessage": {
                    "type": "string",
                    "description": "Message displayed when instance is in maintenance mode.\n"
                },
                "mavenPackageRequestsForwarding": {
                    "type": "boolean",
                    "description": "Use repo.maven.apache.org as a default remote repository when the package is not found in the GitLab Package Registry for Maven. Premium and Ultimate only.\n"
                },
                "maxArtifactsSize": {
                    "type": "integer",
                    "description": "Maximum artifacts size in MB.\n"
                },
                "maxAttachmentSize": {
                    "type": "integer",
                    "description": "Limit attachment size in MB.\n"
                },
                "maxDecompressedArchiveSize": {
                    "type": "integer",
                    "description": "Maximum decompressed archive size in bytes.\n"
                },
                "maxExportSize": {
                    "type": "integer",
                    "description": "Maximum export size in MB. 0 for unlimited.\n"
                },
                "maxImportRemoteFileSize": {
                    "type": "integer",
                    "description": "Maximum remote file size for imports from external object storages. Introduced in GitLab 16.3.\n"
                },
                "maxImportSize": {
                    "type": "integer",
                    "description": "Maximum import size in MB. 0 for unlimited.\n"
                },
                "maxLoginAttempts": {
                    "type": "integer",
                    "description": "Maximum number of sign-in attempts before locking out the user.\n"
                },
                "maxNumberOfRepositoryDownloads": {
                    "type": "integer",
                    "description": "Maximum number of unique repositories a user can download in the specified time period before they are banned. Maximum: 10,000 repositories. Introduced in GitLab 15.1.\n"
                },
                "maxNumberOfRepositoryDownloadsWithinTimePeriod": {
                    "type": "integer",
                    "description": "Reporting time period (in seconds). Maximum: 864000 seconds (10 days). Introduced in GitLab 15.1.\n"
                },
                "maxPagesSize": {
                    "type": "integer",
                    "description": "Maximum size of pages repositories in MB.\n"
                },
                "maxPersonalAccessTokenLifetime": {
                    "type": "integer",
                    "description": "Maximum allowable lifetime for access tokens in days.\n"
                },
                "maxSshKeyLifetime": {
                    "type": "integer",
                    "description": "Maximum allowable lifetime for SSH keys in days. Introduced in GitLab 14.6.\n"
                },
                "maxTerraformStateSizeBytes": {
                    "type": "integer"
                },
                "metricsMethodCallThreshold": {
                    "type": "integer",
                    "description": "A method call is only tracked when it takes longer than the given amount of milliseconds.\n"
                },
                "minimumPasswordLength": {
                    "type": "integer",
                    "description": "Indicates whether passwords require a minimum length. Introduced in GitLab 15.1. Premium and Ultimate only.\n"
                },
                "mirrorAvailable": {
                    "type": "boolean",
                    "description": "Allow repository mirroring to configured by project Maintainers. If disabled, only Administrators can configure repository mirroring.\n"
                },
                "mirrorCapacityThreshold": {
                    "type": "integer",
                    "description": "Minimum capacity to be available before scheduling more mirrors preemptively.\n"
                },
                "mirrorMaxCapacity": {
                    "type": "integer",
                    "description": "Maximum number of mirrors that can be synchronizing at the same time.\n"
                },
                "mirrorMaxDelay": {
                    "type": "integer",
                    "description": "Maximum time (in minutes) between updates that a mirror can have when scheduled to synchronize.\n"
                },
                "npmPackageRequestsForwarding": {
                    "type": "boolean",
                    "description": "Use npmjs.org as a default remote repository when the package is not found in the GitLab Package Registry for npm.\n"
                },
                "nugetSkipMetadataUrlValidation": {
                    "type": "boolean",
                    "description": "Indicates whether to skip metadata URL validation for the NuGet package. Introduced in GitLab 17.0.\n"
                },
                "outboundLocalRequestsWhitelists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Define a list of trusted domains or IP addresses to which local requests are allowed when local requests for hooks and services are disabled.\n"
                },
                "packageMetadataPurlTypes": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "List of package registry metadata to sync. See the list of the available values (https://gitlab.com/gitlab-org/gitlab/-/blob/ace16c20d5da7c4928dd03fb139692638b557fe3/app/models/concerns/enums/package_metadata.rb#L5). Self-managed, Ultimate only.\n"
                },
                "packageRegistryAllowAnyoneToPullOption": {
                    "type": "boolean",
                    "description": "Enable to allow anyone to pull from Package Registry visible and changeable.\n"
                },
                "packageRegistryCleanupPoliciesWorkerCapacity": {
                    "type": "integer",
                    "description": "Number of workers assigned to the packages cleanup policies.\n"
                },
                "pagesDomainVerificationEnabled": {
                    "type": "boolean",
                    "description": "Require users to prove ownership of custom domains. Domain verification is an essential security measure for public GitLab sites. Users are required to demonstrate they control a domain before it is enabled.\n"
                },
                "passwordAuthenticationEnabledForGit": {
                    "type": "boolean",
                    "description": "Enable authentication for Git over HTTP(S) via a GitLab account password.\n"
                },
                "passwordAuthenticationEnabledForWeb": {
                    "type": "boolean",
                    "description": "Enable authentication for the web interface via a GitLab account password.\n"
                },
                "passwordLowercaseRequired": {
                    "type": "boolean",
                    "description": "Indicates whether passwords require at least one lowercase letter. Introduced in GitLab 15.1.\n"
                },
                "passwordNumberRequired": {
                    "type": "boolean",
                    "description": "Indicates whether passwords require at least one number. Introduced in GitLab 15.1.\n"
                },
                "passwordSymbolRequired": {
                    "type": "boolean",
                    "description": "Indicates whether passwords require at least one symbol character. Introduced in GitLab 15.1.\n"
                },
                "passwordUppercaseRequired": {
                    "type": "boolean",
                    "description": "Indicates whether passwords require at least one uppercase letter. Introduced in GitLab 15.1.\n"
                },
                "performanceBarAllowedGroupPath": {
                    "type": "string",
                    "description": "Path of the group that is allowed to toggle the performance bar.\n"
                },
                "personalAccessTokenPrefix": {
                    "type": "string",
                    "description": "Prefix for all generated personal access tokens.\n"
                },
                "pipelineLimitPerProjectUserSha": {
                    "type": "integer",
                    "description": "Maximum number of pipeline creation requests per minute per user and commit.\n"
                },
                "plantumlEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: plantuml_url) Enable PlantUML integration.\n"
                },
                "plantumlUrl": {
                    "type": "string",
                    "description": "The PlantUML instance URL for integration.\n"
                },
                "pollingIntervalMultiplier": {
                    "type": "number",
                    "description": "Interval multiplier used by endpoints that perform polling. Set to 0 to disable polling.\n"
                },
                "projectExportEnabled": {
                    "type": "boolean",
                    "description": "Enable project export.\n"
                },
                "projectJobsApiRateLimit": {
                    "type": "integer",
                    "description": "Maximum authenticated requests to /project/:id/jobs per minute. Introduced in GitLab 16.5.\n"
                },
                "projectsApiRateLimitUnauthenticated": {
                    "type": "integer",
                    "description": "Introduced in GitLab 15.10. Max number of requests per 10 minutes per IP address for unauthenticated requests to the list all projects API. To disable throttling set to 0.\n"
                },
                "prometheusMetricsEnabled": {
                    "type": "boolean",
                    "description": "Enable Prometheus metrics.\n"
                },
                "protectedCiVariables": {
                    "type": "boolean",
                    "description": "CI/CD variables are protected by default.\n"
                },
                "pushEventActivitiesLimit": {
                    "type": "integer",
                    "description": "Number of changes (branches or tags) in a single push to determine whether individual push events or bulk push events are created. Bulk push events are created if it surpasses that value.\n"
                },
                "pushEventHooksLimit": {
                    "type": "integer",
                    "description": "Number of changes (branches or tags) in a single push to determine whether webhooks and services fire or not. Webhooks and services aren’t submitted if it surpasses that value.\n"
                },
                "pypiPackageRequestsForwarding": {
                    "type": "boolean",
                    "description": "Use pypi.org as a default remote repository when the package is not found in the GitLab Package Registry for PyPI.\n"
                },
                "rateLimitingResponseText": {
                    "type": "string",
                    "description": "When rate limiting is enabled via the throttle_* settings, send this plain text response when a rate limit is exceeded. ‘Retry later’ is sent if this is blank.\n"
                },
                "rawBlobRequestLimit": {
                    "type": "integer",
                    "description": "Max number of requests per minute for each raw path. To disable throttling set to 0.\n"
                },
                "recaptchaEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: recaptcha*private*key and recaptcha*site*key) Enable reCAPTCHA.\n"
                },
                "recaptchaPrivateKey": {
                    "type": "string",
                    "description": "Private key for reCAPTCHA.\n",
                    "secret": true
                },
                "recaptchaSiteKey": {
                    "type": "string",
                    "description": "Site key for reCAPTCHA.\n",
                    "secret": true
                },
                "receiveMaxInputSize": {
                    "type": "integer",
                    "description": "Maximum push size (MB).\n"
                },
                "receptiveClusterAgentsEnabled": {
                    "type": "boolean",
                    "description": "Enable receptive mode for GitLab Agents for Kubernetes.\n"
                },
                "rememberMeEnabled": {
                    "type": "boolean",
                    "description": "Enable Remember me setting. Introduced in GitLab 16.0.\n"
                },
                "repositoryChecksEnabled": {
                    "type": "boolean",
                    "description": "GitLab periodically runs git fsck in all project and wiki repositories to look for silent disk corruption issues.\n"
                },
                "repositorySizeLimit": {
                    "type": "integer",
                    "description": "Size limit per repository (MB).\n"
                },
                "repositoryStorages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "(GitLab 13.0 and earlier) List of names of enabled storage paths, taken from gitlab.yml. New projects are created in one of these stores, chosen at random.\n"
                },
                "repositoryStoragesWeighted": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "integer"
                    },
                    "description": "(GitLab 13.1 and later) Hash of names of taken from gitlab.yml to weights. New projects are created in one of these stores, chosen by a weighted random selection.\n"
                },
                "requireAdminApprovalAfterUserSignup": {
                    "type": "boolean",
                    "description": "When enabled, any user that signs up for an account using the registration form is placed under a Pending approval state and has to be explicitly approved by an administrator.\n"
                },
                "requireAdminTwoFactorAuthentication": {
                    "type": "boolean",
                    "description": "Allow administrators to require 2FA for all administrators on the instance.\n"
                },
                "requirePersonalAccessTokenExpiry": {
                    "type": "boolean",
                    "description": "When enabled, users must set an expiration date when creating a group or project access token, or a personal access token owned by a non-service account.\n"
                },
                "requireTwoFactorAuthentication": {
                    "type": "boolean",
                    "description": "(If enabled, requires: two*factor*grace_period) Require all users to set up Two-factor authentication.\n"
                },
                "restrictedVisibilityLevels": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Selected levels cannot be used by non-Administrator users for groups, projects or snippets. Can take private, internal and public as a parameter. Null means there is no restriction.\n"
                },
                "rsaKeyRestriction": {
                    "type": "integer",
                    "description": "The minimum allowed bit length of an uploaded RSA key. 0 means no restriction. -1 disables RSA keys.\n"
                },
                "searchRateLimit": {
                    "type": "integer",
                    "description": "Max number of requests per minute for performing a search while authenticated. To disable throttling set to 0.\n"
                },
                "searchRateLimitUnauthenticated": {
                    "type": "integer",
                    "description": "Max number of requests per minute for performing a search while unauthenticated. To disable throttling set to 0.\n"
                },
                "securityApprovalPoliciesLimit": {
                    "type": "integer",
                    "description": "Maximum number of active merge request approval policies per security policy project. Maximum: 20\n"
                },
                "securityPolicyGlobalGroupApproversEnabled": {
                    "type": "boolean",
                    "description": "Whether to look up merge request approval policy approval groups globally or within project hierarchies.\n"
                },
                "securityTxtContent": {
                    "type": "string",
                    "description": "Public security contact information. Introduced in GitLab 16.7.\n"
                },
                "sendUserConfirmationEmail": {
                    "type": "boolean",
                    "description": "Send confirmation email on sign-up.\n"
                },
                "serviceAccessTokensExpirationEnforced": {
                    "type": "boolean",
                    "description": "Flag to indicate if token expiry date can be optional for service account users\n"
                },
                "sessionExpireDelay": {
                    "type": "integer",
                    "description": "Session duration in minutes. GitLab restart is required to apply changes.\n"
                },
                "sharedRunnersEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: shared*runners*text and shared*runners*minutes) Enable shared runners for new projects.\n"
                },
                "sharedRunnersMinutes": {
                    "type": "integer",
                    "description": "Set the maximum number of CI/CD minutes that a group can use on shared runners per month.\n"
                },
                "sharedRunnersText": {
                    "type": "string",
                    "description": "Shared runners text.\n"
                },
                "sidekiqJobLimiterCompressionThresholdBytes": {
                    "type": "integer",
                    "description": "The threshold in bytes at which Sidekiq jobs are compressed before being stored in Redis.\n"
                },
                "sidekiqJobLimiterLimitBytes": {
                    "type": "integer",
                    "description": "The threshold in bytes at which Sidekiq jobs are rejected. 0 means do not reject any job.\n"
                },
                "sidekiqJobLimiterMode": {
                    "type": "string",
                    "description": "track or compress. Sets the behavior for Sidekiq job size limits.\n"
                },
                "signInText": {
                    "type": "string",
                    "description": "Text on the login page.\n"
                },
                "signupEnabled": {
                    "type": "boolean",
                    "description": "Enable registration.\n"
                },
                "silentAdminExportsEnabled": {
                    "type": "boolean",
                    "description": "Enable Silent admin exports.\n"
                },
                "silentModeEnabled": {
                    "type": "boolean",
                    "description": "Enable Silent mode.\n"
                },
                "slackAppEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: slack*app*id, slack*app*secret and slack*app*secret) Enable Slack app.\n"
                },
                "slackAppId": {
                    "type": "string",
                    "description": "The app ID of the Slack-app.\n"
                },
                "slackAppSecret": {
                    "type": "string",
                    "description": "The app secret of the Slack-app.\n",
                    "secret": true
                },
                "slackAppSigningSecret": {
                    "type": "string",
                    "description": "The signing secret of the Slack-app.\n",
                    "secret": true
                },
                "slackAppVerificationToken": {
                    "type": "string",
                    "description": "The verification token of the Slack-app.\n"
                },
                "snippetSizeLimit": {
                    "type": "integer",
                    "description": "Max snippet content size in bytes.\n"
                },
                "snowplowAppId": {
                    "type": "string",
                    "description": "The Snowplow site name / application ID. (for example, gitlab)\n"
                },
                "snowplowCollectorHostname": {
                    "type": "string",
                    "description": "The Snowplow collector hostname. (for example, snowplow.trx.gitlab.net)\n"
                },
                "snowplowCookieDomain": {
                    "type": "string",
                    "description": "The Snowplow cookie domain. (for example, .gitlab.com)\n"
                },
                "snowplowDatabaseCollectorHostname": {
                    "type": "string",
                    "description": "The Snowplow collector for database events hostname. (for example, db-snowplow.trx.gitlab.net)\n"
                },
                "snowplowEnabled": {
                    "type": "boolean",
                    "description": "Enable snowplow tracking.\n"
                },
                "sourcegraphEnabled": {
                    "type": "boolean",
                    "description": "Enables Sourcegraph integration. If enabled, requires sourcegraph_url.\n"
                },
                "sourcegraphPublicOnly": {
                    "type": "boolean",
                    "description": "Blocks Sourcegraph from being loaded on private and internal projects.\n"
                },
                "sourcegraphUrl": {
                    "type": "string",
                    "description": "The Sourcegraph instance URL for integration.\n"
                },
                "spamCheckApiKey": {
                    "type": "string",
                    "description": "API key used by GitLab for accessing the Spam Check service endpoint.\n",
                    "secret": true
                },
                "spamCheckEndpointEnabled": {
                    "type": "boolean",
                    "description": "Enables spam checking using external Spam Check API endpoint.\n"
                },
                "spamCheckEndpointUrl": {
                    "type": "string",
                    "description": "URL of the external Spamcheck service endpoint. Valid URI schemes are grpc or tls. Specifying tls forces communication to be encrypted.\n"
                },
                "staticObjectsExternalStorageAuthToken": {
                    "type": "string",
                    "description": "Authentication token for the external storage linked in static*objects*external*storage*url.\n",
                    "secret": true
                },
                "staticObjectsExternalStorageUrl": {
                    "type": "string",
                    "description": "URL to an external storage for repository static objects.\n",
                    "secret": true
                },
                "suggestPipelineEnabled": {
                    "type": "boolean",
                    "description": "Enable pipeline suggestion banner.\n"
                },
                "terminalMaxSessionTime": {
                    "type": "integer",
                    "description": "Maximum time for web terminal websocket connection (in seconds). Set to 0 for unlimited time.\n"
                },
                "terms": {
                    "type": "string",
                    "description": "(Required by: enforce_terms) Markdown content for the ToS.\n"
                },
                "throttleAuthenticatedApiEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: throttle*authenticated*api*period*in*seconds and throttle*authenticated*api*requests*per*period) Enable authenticated API request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots).\n"
                },
                "throttleAuthenticatedApiPeriodInSeconds": {
                    "type": "integer",
                    "description": "Rate limit period (in seconds).\n"
                },
                "throttleAuthenticatedApiRequestsPerPeriod": {
                    "type": "integer",
                    "description": "Maximum requests per period per user.\n"
                },
                "throttleAuthenticatedPackagesApiEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: throttle*authenticated*packages*api*period*in*seconds and throttle*authenticated*packages*api*requests*per*period) Enable authenticated API request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots). View Package Registry rate limits for more details.\n"
                },
                "throttleAuthenticatedPackagesApiPeriodInSeconds": {
                    "type": "integer",
                    "description": "Rate limit period (in seconds). View Package Registry rate limits for more details.\n"
                },
                "throttleAuthenticatedPackagesApiRequestsPerPeriod": {
                    "type": "integer",
                    "description": "Maximum requests per period per user. View Package Registry rate limits for more details.\n"
                },
                "throttleAuthenticatedWebEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: throttle*authenticated*web*period*in*seconds and throttle*authenticated*web*requests*per*period) Enable authenticated web request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots).\n"
                },
                "throttleAuthenticatedWebPeriodInSeconds": {
                    "type": "integer",
                    "description": "Rate limit period (in seconds).\n"
                },
                "throttleAuthenticatedWebRequestsPerPeriod": {
                    "type": "integer",
                    "description": "Maximum requests per period per user.\n"
                },
                "throttleUnauthenticatedApiEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: throttle*unauthenticated*api*period*in*seconds and throttle*unauthenticated*api*requests*per*period) Enable unauthenticated API request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots).\n"
                },
                "throttleUnauthenticatedApiPeriodInSeconds": {
                    "type": "integer",
                    "description": "Rate limit period in seconds.\n"
                },
                "throttleUnauthenticatedApiRequestsPerPeriod": {
                    "type": "integer",
                    "description": "Max requests per period per IP.\n"
                },
                "throttleUnauthenticatedPackagesApiEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: throttle*unauthenticated*packages*api*period*in*seconds and throttle*unauthenticated*packages*api*requests*per*period) Enable authenticated API request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots). View Package Registry rate limits for more details.\n"
                },
                "throttleUnauthenticatedPackagesApiPeriodInSeconds": {
                    "type": "integer",
                    "description": "Rate limit period (in seconds). View Package Registry rate limits for more details.\n"
                },
                "throttleUnauthenticatedPackagesApiRequestsPerPeriod": {
                    "type": "integer",
                    "description": "Maximum requests per period per user. View Package Registry rate limits for more details.\n"
                },
                "throttleUnauthenticatedWebEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: throttle*unauthenticated*web*period*in*seconds and throttle*unauthenticated*web*requests*per*period) Enable unauthenticated web request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots).\n"
                },
                "throttleUnauthenticatedWebPeriodInSeconds": {
                    "type": "integer",
                    "description": "Rate limit period in seconds.\n"
                },
                "throttleUnauthenticatedWebRequestsPerPeriod": {
                    "type": "integer",
                    "description": "Max requests per period per IP.\n"
                },
                "timeTrackingLimitToHours": {
                    "type": "boolean",
                    "description": "Limit display of time tracking units to hours.\n"
                },
                "twoFactorGracePeriod": {
                    "type": "integer",
                    "description": "Amount of time (in hours) that users are allowed to skip forced configuration of two-factor authentication.\n"
                },
                "unconfirmedUsersDeleteAfterDays": {
                    "type": "integer",
                    "description": "Specifies how many days after sign-up to delete users who have not confirmed their email. Only applicable if delete*unconfirmed*users is set to true. Must be 1 or greater. Introduced in GitLab 16.1. Self-managed, Premium and Ultimate only.\n"
                },
                "uniqueIpsLimitEnabled": {
                    "type": "boolean",
                    "description": "(If enabled, requires: unique*ips*limit*per*user and unique*ips*limit*time*window) Limit sign in from multiple IPs.\n"
                },
                "uniqueIpsLimitPerUser": {
                    "type": "integer",
                    "description": "Maximum number of IPs per user.\n"
                },
                "uniqueIpsLimitTimeWindow": {
                    "type": "integer",
                    "description": "How many seconds an IP is counted towards the limit.\n"
                },
                "updateRunnerVersionsEnabled": {
                    "type": "boolean",
                    "description": "Fetch GitLab Runner release version data from GitLab.com.\n"
                },
                "usagePingEnabled": {
                    "type": "boolean",
                    "description": "Every week GitLab reports license usage back to GitLab, Inc.\n"
                },
                "useClickhouseForAnalytics": {
                    "type": "boolean",
                    "description": "Enables ClickHouse as a data source for analytics reports. ClickHouse must be configured for this setting to take effect. Available on Premium and Ultimate only.\n"
                },
                "userDeactivationEmailsEnabled": {
                    "type": "boolean",
                    "description": "Send an email to users upon account deactivation.\n"
                },
                "userDefaultExternal": {
                    "type": "boolean",
                    "description": "Newly registered users are external by default.\n"
                },
                "userDefaultInternalRegex": {
                    "type": "string",
                    "description": "Specify an email address regex pattern to identify default internal users.\n"
                },
                "userDefaultsToPrivateProfile": {
                    "type": "boolean",
                    "description": "Newly created users have private profile by default. Introduced in GitLab 15.8.\n"
                },
                "userOauthApplications": {
                    "type": "boolean",
                    "description": "Allow users to register any application to use GitLab as an OAuth provider.\n"
                },
                "userShowAddSshKeyMessage": {
                    "type": "boolean",
                    "description": "When set to false disable the You won't be able to pull or push project code via SSH warning shown to users with no uploaded SSH key.\n"
                },
                "validRunnerRegistrars": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of types which are allowed to register a GitLab Runner. Can be [], ['group'], ['project'] or ['group', 'project'].\n"
                },
                "versionCheckEnabled": {
                    "type": "boolean",
                    "description": "Let GitLab inform you when an update is available.\n"
                },
                "webIdeClientsidePreviewEnabled": {
                    "type": "boolean",
                    "description": "Live Preview (allow live previews of JavaScript projects in the Web IDE using CodeSandbox Live Preview).\n"
                },
                "whatsNewVariant": {
                    "type": "string",
                    "description": "What's new variant, possible values: all*tiers, current*tier, and disabled.\n"
                },
                "wikiPageMaxContentBytes": {
                    "type": "integer",
                    "description": "Maximum wiki page content size in bytes. The minimum value is 1024 bytes.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ApplicationSettings resources.\n",
                "properties": {
                    "abuseNotificationEmail": {
                        "type": "string",
                        "description": "If set, abuse reports are sent to this address. Abuse reports are always available in the Admin Area.\n"
                    },
                    "adminMode": {
                        "type": "boolean",
                        "description": "Require administrators to enable Admin Mode by re-authenticating for administrative tasks.\n"
                    },
                    "afterSignOutPath": {
                        "type": "string",
                        "description": "Where to redirect users after logout.\n"
                    },
                    "afterSignUpText": {
                        "type": "string",
                        "description": "Text shown to the user after signing up.\n"
                    },
                    "akismetApiKey": {
                        "type": "string",
                        "description": "API key for Akismet spam protection.\n",
                        "secret": true
                    },
                    "akismetEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: akismet*api*key) Enable or disable Akismet spam protection.\n"
                    },
                    "allowAccountDeletion": {
                        "type": "boolean",
                        "description": "Set to true to allow users to delete their accounts. Premium and Ultimate only.\n"
                    },
                    "allowGroupOwnersToManageLdap": {
                        "type": "boolean",
                        "description": "Set to true to allow group owners to manage LDAP.\n"
                    },
                    "allowLocalRequestsFromSystemHooks": {
                        "type": "boolean",
                        "description": "Allow requests to the local network from system hooks.\n"
                    },
                    "allowLocalRequestsFromWebHooksAndServices": {
                        "type": "boolean",
                        "description": "Allow requests to the local network from web hooks and services.\n"
                    },
                    "allowProjectCreationForGuestAndBelow": {
                        "type": "boolean",
                        "description": "Indicates whether users assigned up to the Guest role can create groups and personal projects.\n"
                    },
                    "allowRunnerRegistrationToken": {
                        "type": "boolean",
                        "description": "Allow using a registration token to create a runner.\n"
                    },
                    "archiveBuildsInHumanReadable": {
                        "type": "string",
                        "description": "Set the duration for which the jobs are considered as old and expired. After that time passes, the jobs are archived and no longer able to be retried. Make it empty to never expire jobs. It has to be no less than 1 day, for example: 15 days, 1 month, 2 years.\n"
                    },
                    "asciidocMaxIncludes": {
                        "type": "integer",
                        "description": "Maximum limit of AsciiDoc include directives being processed in any one document. Maximum: 64.\n"
                    },
                    "assetProxyAllowlists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Assets that match these domains are not proxied. Wildcards allowed. Your GitLab installation URL is automatically allowlisted. GitLab restart is required to apply changes.\n"
                    },
                    "assetProxyEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: asset*proxy*url) Enable proxying of assets. GitLab restart is required to apply changes.\n"
                    },
                    "assetProxySecretKey": {
                        "type": "string",
                        "description": "Shared secret with the asset proxy server. GitLab restart is required to apply changes.\n",
                        "secret": true
                    },
                    "assetProxyUrl": {
                        "type": "string",
                        "description": "URL of the asset proxy server. GitLab restart is required to apply changes.\n"
                    },
                    "authorizedKeysEnabled": {
                        "type": "boolean",
                        "description": "By default, we write to the authorized_keys file to support Git over SSH without additional configuration. GitLab can be optimized to authenticate SSH keys via the database file. Only disable this if you have configured your OpenSSH server to use the AuthorizedKeysCommand.\n"
                    },
                    "autoBanUserOnExcessiveProjectsDownload": {
                        "type": "boolean",
                        "description": "When enabled, users will get automatically banned from the application when they download more than the maximum number of unique projects in the time period specified by max*number*of*repository*downloads and max*number*of*repository*downloads*within*time_period respectively. Introduced in GitLab 15.4. Self-managed, Ultimate only.\n"
                    },
                    "autoDevopsDomain": {
                        "type": "string",
                        "description": "Specify a domain to use by default for every project’s Auto Review Apps and Auto Deploy stages.\n"
                    },
                    "autoDevopsEnabled": {
                        "type": "boolean",
                        "description": "Enable Auto DevOps for projects by default. It automatically builds, tests, and deploys applications based on a predefined CI/CD configuration.\n"
                    },
                    "automaticPurchasedStorageAllocation": {
                        "type": "boolean",
                        "description": "Enabling this permits automatic allocation of purchased storage in a namespace.\n"
                    },
                    "bulkImportConcurrentPipelineBatchLimit": {
                        "type": "integer",
                        "description": "Maximum simultaneous Direct Transfer batches to process.\n"
                    },
                    "bulkImportEnabled": {
                        "type": "boolean",
                        "description": "Enable migrating GitLab groups by direct transfer. Introduced in GitLab 15.8.\n"
                    },
                    "bulkImportMaxDownloadFileSize": {
                        "type": "integer",
                        "description": "Maximum download file size when importing from source GitLab instances by direct transfer. Introduced in GitLab 16.3.\n"
                    },
                    "canCreateGroup": {
                        "type": "boolean",
                        "description": "Indicates whether users can create top-level groups. Introduced in GitLab 15.5.\n"
                    },
                    "checkNamespacePlan": {
                        "type": "boolean",
                        "description": "Enabling this makes only licensed EE features available to projects if the project namespace’s plan includes the feature or if the project is public.\n"
                    },
                    "ciMaxIncludes": {
                        "type": "integer",
                        "description": "The maximum number of includes per pipeline.\n"
                    },
                    "ciMaxTotalYamlSizeBytes": {
                        "type": "integer",
                        "description": "The maximum amount of memory, in bytes, that can be allocated for the pipeline configuration, with all included YAML configuration files.\n"
                    },
                    "commitEmailHostname": {
                        "type": "string",
                        "description": "Custom hostname (for private commit emails).\n"
                    },
                    "concurrentBitbucketImportJobsLimit": {
                        "type": "integer",
                        "description": "Maximum number of simultaneous import jobs for the Bitbucket Cloud importer. Introduced in GitLab 16.11.\n"
                    },
                    "concurrentBitbucketServerImportJobsLimit": {
                        "type": "integer",
                        "description": "Maximum number of simultaneous import jobs for the Bitbucket Server importer. Introduced in GitLab 16.11.\n"
                    },
                    "concurrentGithubImportJobsLimit": {
                        "type": "integer",
                        "description": "Maximum number of simultaneous import jobs for the GitHub importer. Introduced in GitLab 16.11.\n"
                    },
                    "containerExpirationPoliciesEnableHistoricEntries": {
                        "type": "boolean",
                        "description": "Enable cleanup policies for all projects.\n"
                    },
                    "containerRegistryCleanupTagsServiceMaxListSize": {
                        "type": "integer",
                        "description": "The maximum number of tags that can be deleted in a single execution of cleanup policies.\n"
                    },
                    "containerRegistryDeleteTagsServiceTimeout": {
                        "type": "integer",
                        "description": "The maximum time, in seconds, that the cleanup process can take to delete a batch of tags for cleanup policies.\n"
                    },
                    "containerRegistryExpirationPoliciesCaching": {
                        "type": "boolean",
                        "description": "Caching during the execution of cleanup policies.\n"
                    },
                    "containerRegistryExpirationPoliciesWorkerCapacity": {
                        "type": "integer",
                        "description": "Number of workers for cleanup policies.\n"
                    },
                    "containerRegistryTokenExpireDelay": {
                        "type": "integer",
                        "description": "Container Registry token duration in minutes.\n"
                    },
                    "deactivateDormantUsers": {
                        "type": "boolean",
                        "description": "Enable automatic deactivation of dormant users.\n"
                    },
                    "deactivateDormantUsersPeriod": {
                        "type": "integer",
                        "description": "Length of time (in days) after which a user is considered dormant. Introduced in GitLab 15.3.\n"
                    },
                    "decompressArchiveFileTimeout": {
                        "type": "integer",
                        "description": "Default timeout for decompressing archived files, in seconds. Set to 0 to disable timeouts. Introduced in GitLab 16.4.\n"
                    },
                    "defaultArtifactsExpireIn": {
                        "type": "string",
                        "description": "Set the default expiration time for each job’s artifacts.\n"
                    },
                    "defaultBranchName": {
                        "type": "string",
                        "description": "Instance-level custom initial branch name (introduced in GitLab 13.2).\n"
                    },
                    "defaultBranchProtection": {
                        "type": "integer",
                        "description": "Determine if developers can push to the default branch. Can take: 0 (not protected, both users with the Developer role or Maintainer role can push new commits and force push), 1 (partially protected, users with the Developer role or Maintainer role can push new commits, but cannot force push) or 2 (fully protected, users with the Developer or Maintainer role cannot push new commits, but users with the Developer or Maintainer role can; no one can force push) as a parameter. Default is 2.\n"
                    },
                    "defaultBranchProtectionDefaults": {
                        "$ref": "#/types/gitlab:index/ApplicationSettingsDefaultBranchProtectionDefaults:ApplicationSettingsDefaultBranchProtectionDefaults",
                        "description": "The default*branch*protection*defaults attribute describes the default branch protection defaults. All parameters are optional.\n"
                    },
                    "defaultCiConfigPath": {
                        "type": "string",
                        "description": "Default CI/CD configuration file and path for new projects (.gitlab-ci.yml if not set).\n"
                    },
                    "defaultGroupVisibility": {
                        "type": "string",
                        "description": "What visibility level new groups receive. Can take private, internal and public as a parameter.\n"
                    },
                    "defaultPreferredLanguage": {
                        "type": "string",
                        "description": "Default preferred language for users who are not logged in.\n"
                    },
                    "defaultProjectCreation": {
                        "type": "integer",
                        "description": "Default project creation protection. Can take: 0 (No one), 1 (Maintainers) or 2 (Developers + Maintainers).\n"
                    },
                    "defaultProjectVisibility": {
                        "type": "string",
                        "description": "What visibility level new projects receive. Can take private, internal and public as a parameter.\n"
                    },
                    "defaultProjectsLimit": {
                        "type": "integer",
                        "description": "Project limit per user.\n"
                    },
                    "defaultSnippetVisibility": {
                        "type": "string",
                        "description": "What visibility level new snippets receive. Can take private, internal and public as a parameter.\n"
                    },
                    "defaultSyntaxHighlightingTheme": {
                        "type": "integer",
                        "description": "Default syntax highlighting theme for users who are new or not signed in. See IDs of available themes (https://gitlab.com/gitlab-org/gitlab/blob/master/lib/gitlab/themes.rb#L16)\n"
                    },
                    "deleteInactiveProjects": {
                        "type": "boolean",
                        "description": "Enable inactive project deletion feature. Introduced in GitLab 14.10. Became operational in GitLab 15.0 (with feature flag inactive*projects*deletion).\n"
                    },
                    "deleteUnconfirmedUsers": {
                        "type": "boolean",
                        "description": "Specifies whether users who have not confirmed their email should be deleted. When set to true, unconfirmed users are deleted after unconfirmed*users*delete*after*days days. Introduced in GitLab 16.1. Self-managed, Premium and Ultimate only.\n"
                    },
                    "deletionAdjournedPeriod": {
                        "type": "integer",
                        "description": "The number of days to wait before deleting a project or group that is marked for deletion. Value must be between 1 and 90.\n"
                    },
                    "diagramsnetEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires diagramsnet_url) Enable Diagrams.net integration.\n"
                    },
                    "diagramsnetUrl": {
                        "type": "string",
                        "description": "The Diagrams.net instance URL for integration.\n"
                    },
                    "diffMaxFiles": {
                        "type": "integer",
                        "description": "Maximum files in a diff.\n"
                    },
                    "diffMaxLines": {
                        "type": "integer",
                        "description": "Maximum lines in a diff.\n"
                    },
                    "diffMaxPatchBytes": {
                        "type": "integer",
                        "description": "Maximum diff patch size, in bytes.\n"
                    },
                    "disableAdminOauthScopes": {
                        "type": "boolean",
                        "description": "Stops administrators from connecting their GitLab accounts to non-trusted OAuth 2.0 applications that have the api, read*api, read*repository, write*repository, read*registry, write_registry, or sudo scopes. Introduced in GitLab 15.6.\n"
                    },
                    "disableFeedToken": {
                        "type": "boolean",
                        "description": "Disable display of RSS/Atom and calendar feed tokens (introduced in GitLab 13.7).\n"
                    },
                    "disablePersonalAccessTokens": {
                        "type": "boolean",
                        "description": "Disable personal access tokens. Introduced in GitLab 15.7. Self-managed, Premium and Ultimate only. There is no method available to enable a personal access token that’s been disabled through the API. This is a known issue.\n"
                    },
                    "disabledOauthSignInSources": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Disabled OAuth sign-in sources.\n"
                    },
                    "dnsRebindingProtectionEnabled": {
                        "type": "boolean",
                        "description": "Enforce DNS rebinding attack protection.\n"
                    },
                    "domainAllowlists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Force people to use only corporate emails for sign-up. Null means there is no restriction.\n"
                    },
                    "domainDenylistEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: domain_denylist) Allows blocking sign-ups from emails from specific domains.\n"
                    },
                    "domainDenylists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Users with email addresses that match these domains cannot sign up. Wildcards allowed. Use separate lines for multiple entries. Ex: domain.com, *.domain.com.\n"
                    },
                    "downstreamPipelineTriggerLimitPerProjectUserSha": {
                        "type": "integer",
                        "description": "Maximum downstream pipeline trigger rate. Introduced in GitLab 16.10.\n"
                    },
                    "dsaKeyRestriction": {
                        "type": "integer",
                        "description": "The minimum allowed bit length of an uploaded DSA key. 0 means no restriction. -1 disables DSA keys.\n"
                    },
                    "duoFeaturesEnabled": {
                        "type": "boolean",
                        "description": "Indicates whether GitLab Duo features are enabled for this instance. Introduced in GitLab 16.10. Self-managed, Premium and Ultimate only.\n"
                    },
                    "ecdsaKeyRestriction": {
                        "type": "integer",
                        "description": "The minimum allowed curve size (in bits) of an uploaded ECDSA key. 0 means no restriction. -1 disables ECDSA keys.\n"
                    },
                    "ecdsaSkKeyRestriction": {
                        "type": "integer",
                        "description": "The minimum allowed curve size (in bits) of an uploaded ECDSA*SK key. 0 means no restriction. -1 disables ECDSA*SK keys.\n"
                    },
                    "ed25519KeyRestriction": {
                        "type": "integer",
                        "description": "The minimum allowed curve size (in bits) of an uploaded ED25519 key. 0 means no restriction. -1 disables ED25519 keys.\n"
                    },
                    "ed25519SkKeyRestriction": {
                        "type": "integer",
                        "description": "The minimum allowed curve size (in bits) of an uploaded ED25519*SK key. 0 means no restriction. -1 disables ED25519*SK keys.\n"
                    },
                    "eksAccessKeyId": {
                        "type": "string",
                        "description": "AWS IAM access key ID.\n",
                        "secret": true
                    },
                    "eksAccountId": {
                        "type": "string",
                        "description": "Amazon account ID.\n"
                    },
                    "eksIntegrationEnabled": {
                        "type": "boolean",
                        "description": "Enable integration with Amazon EKS.\n"
                    },
                    "eksSecretAccessKey": {
                        "type": "string",
                        "description": "AWS IAM secret access key.\n",
                        "secret": true
                    },
                    "elasticsearchAws": {
                        "type": "boolean",
                        "description": "Enable the use of AWS hosted Elasticsearch.\n"
                    },
                    "elasticsearchAwsAccessKey": {
                        "type": "string",
                        "description": "AWS IAM access key.\n",
                        "secret": true
                    },
                    "elasticsearchAwsRegion": {
                        "type": "string",
                        "description": "The AWS region the Elasticsearch domain is configured.\n"
                    },
                    "elasticsearchAwsSecretAccessKey": {
                        "type": "string",
                        "description": "AWS IAM secret access key.\n",
                        "secret": true
                    },
                    "elasticsearchIndexedFieldLengthLimit": {
                        "type": "integer",
                        "description": "Maximum size of text fields to index by Elasticsearch. 0 value means no limit. This does not apply to repository and wiki indexing.\n"
                    },
                    "elasticsearchIndexedFileSizeLimitKb": {
                        "type": "integer",
                        "description": "Maximum size of repository and wiki files that are indexed by Elasticsearch.\n"
                    },
                    "elasticsearchIndexing": {
                        "type": "boolean",
                        "description": "Enable Elasticsearch indexing.\n"
                    },
                    "elasticsearchLimitIndexing": {
                        "type": "boolean",
                        "description": "Limit Elasticsearch to index certain namespaces and projects.\n"
                    },
                    "elasticsearchMaxBulkConcurrency": {
                        "type": "integer",
                        "description": "Maximum concurrency of Elasticsearch bulk requests per indexing operation. This only applies to repository indexing operations.\n"
                    },
                    "elasticsearchMaxBulkSizeMb": {
                        "type": "integer",
                        "description": "Maximum size of Elasticsearch bulk indexing requests in MB. This only applies to repository indexing operations.\n"
                    },
                    "elasticsearchMaxCodeIndexingConcurrency": {
                        "type": "integer",
                        "description": "Maximum concurrency of Elasticsearch code indexing background jobs. This only applies to repository indexing operations. Premium and Ultimate only.\n"
                    },
                    "elasticsearchNamespaceIds": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "The namespaces to index via Elasticsearch if elasticsearch*limit*indexing is enabled.\n"
                    },
                    "elasticsearchPassword": {
                        "type": "string",
                        "description": "The password of your Elasticsearch instance.\n",
                        "secret": true
                    },
                    "elasticsearchProjectIds": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "The projects to index via Elasticsearch if elasticsearch*limit*indexing is enabled.\n"
                    },
                    "elasticsearchRequeueWorkers": {
                        "type": "boolean",
                        "description": "Enable automatic requeuing of indexing workers. This improves non-code indexing throughput by enqueuing Sidekiq jobs until all documents are processed. Premium and Ultimate only.\n"
                    },
                    "elasticsearchSearch": {
                        "type": "boolean",
                        "description": "Enable Elasticsearch search.\n"
                    },
                    "elasticsearchUrls": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The URL to use for connecting to Elasticsearch. Use a comma-separated list to support cluster (for example, http://localhost:9200, http://localhost:9201).\n"
                    },
                    "elasticsearchUsername": {
                        "type": "string",
                        "description": "The username of your Elasticsearch instance.\n"
                    },
                    "elasticsearchWorkerNumberOfShards": {
                        "type": "integer",
                        "description": "Number of indexing worker shards. This improves non-code indexing throughput by enqueuing more parallel Sidekiq jobs. Premium and Ultimate only.\n"
                    },
                    "emailAdditionalText": {
                        "type": "string",
                        "description": "Additional text added to the bottom of every email for legal/auditing/compliance reasons.\n"
                    },
                    "emailAuthorInBody": {
                        "type": "boolean",
                        "description": "Some email servers do not support overriding the email sender name. Enable this option to include the name of the author of the issue, merge request or comment in the email body instead.\n"
                    },
                    "emailConfirmationSetting": {
                        "type": "string",
                        "description": "Specifies whether users must confirm their email before sign in. Possible values are off, soft, and hard.\n"
                    },
                    "enableArtifactExternalRedirectWarningPage": {
                        "type": "boolean",
                        "description": "Show the external redirect page that warns you about user-generated content in GitLab Pages.\n"
                    },
                    "enabledGitAccessProtocol": {
                        "type": "string",
                        "description": "Enabled protocols for Git access. Allowed values are: ssh, http, and nil to allow both protocols.\n"
                    },
                    "enforceNamespaceStorageLimit": {
                        "type": "boolean",
                        "description": "Enabling this permits enforcement of namespace storage limits.\n"
                    },
                    "enforceTerms": {
                        "type": "boolean",
                        "description": "(If enabled, requires: terms) Enforce application ToS to all users.\n"
                    },
                    "externalAuthClientCert": {
                        "type": "string",
                        "description": "(If enabled, requires: external*auth*client_key) The certificate to use to authenticate with the external authorization service.\n"
                    },
                    "externalAuthClientKey": {
                        "type": "string",
                        "description": "Private key for the certificate when authentication is required for the external authorization service, this is encrypted when stored.\n",
                        "secret": true
                    },
                    "externalAuthClientKeyPass": {
                        "type": "string",
                        "description": "Passphrase to use for the private key when authenticating with the external service this is encrypted when stored.\n",
                        "secret": true
                    },
                    "externalAuthorizationServiceDefaultLabel": {
                        "type": "string",
                        "description": "The default classification label to use when requesting authorization and no classification label has been specified on the project.\n"
                    },
                    "externalAuthorizationServiceEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: external*authorization*service*default*label, external*authorization*service*timeout and external*authorization*service*url) Enable using an external authorization service for accessing projects.\n"
                    },
                    "externalAuthorizationServiceTimeout": {
                        "type": "number",
                        "description": "The timeout after which an authorization request is aborted, in seconds. When a request times out, access is denied to the user. (min: 0.001, max: 10, step: 0.001).\n"
                    },
                    "externalAuthorizationServiceUrl": {
                        "type": "string",
                        "description": "URL to which authorization requests are directed.\n"
                    },
                    "externalPipelineValidationServiceTimeout": {
                        "type": "integer",
                        "description": "How long to wait for a response from the pipeline validation service. Assumes OK if it times out.\n"
                    },
                    "externalPipelineValidationServiceToken": {
                        "type": "string",
                        "description": "Optional. Token to include as the X-Gitlab-Token header in requests to the URL in external*pipeline*validation*service*url.\n"
                    },
                    "externalPipelineValidationServiceUrl": {
                        "type": "string",
                        "description": "URL to use for pipeline validation requests.\n"
                    },
                    "failedLoginAttemptsUnlockPeriodInMinutes": {
                        "type": "integer",
                        "description": "Time period in minutes after which the user is unlocked when maximum number of failed sign-in attempts reached.\n"
                    },
                    "fileTemplateProjectId": {
                        "type": "integer",
                        "description": "The ID of a project to load custom file templates from.\n"
                    },
                    "firstDayOfWeek": {
                        "type": "integer",
                        "description": "Start day of the week for calendar views and date pickers. Valid values are 0 for Sunday, 1 for Monday, and 6 for Saturday.\n"
                    },
                    "geoNodeAllowedIps": {
                        "type": "string",
                        "description": "Comma-separated list of IPs and CIDRs of allowed secondary nodes. For example, 1.1.1.1, 2.2.2.0/24.\n"
                    },
                    "geoStatusTimeout": {
                        "type": "integer",
                        "description": "The amount of seconds after which a request to get a secondary node status times out.\n"
                    },
                    "gitRateLimitUsersAlertlists": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "List of user IDs that are emailed when the Git abuse rate limit is exceeded. Maximum: 100 user IDs. Introduced in GitLab 15.9. Self-managed, Ultimate only.\n"
                    },
                    "gitRateLimitUsersAllowlists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of usernames excluded from Git anti-abuse rate limits. Maximum: 100 usernames. Introduced in GitLab 15.2. Self-managed, Ultimate only.\n"
                    },
                    "gitTwoFactorSessionExpiry": {
                        "type": "integer",
                        "description": "Maximum duration (in minutes) of a session for Git operations when 2FA is enabled.\n"
                    },
                    "gitalyTimeoutDefault": {
                        "type": "integer",
                        "description": "Default Gitaly timeout, in seconds. This timeout is not enforced for Git fetch/push operations or Sidekiq jobs. Set to 0 to disable timeouts.\n"
                    },
                    "gitalyTimeoutFast": {
                        "type": "integer",
                        "description": "Gitaly fast operation timeout, in seconds. Some Gitaly operations are expected to be fast. If they exceed this threshold, there may be a problem with a storage shard and ‘failing fast’ can help maintain the stability of the GitLab instance. Set to 0 to disable timeouts.\n"
                    },
                    "gitalyTimeoutMedium": {
                        "type": "integer",
                        "description": "Medium Gitaly timeout, in seconds. This should be a value between the Fast and the Default timeout. Set to 0 to disable timeouts.\n"
                    },
                    "gitlabDedicatedInstance": {
                        "type": "boolean",
                        "description": "Indicates whether the instance was provisioned for GitLab Dedicated.\n"
                    },
                    "gitlabEnvironmentToolkitInstance": {
                        "type": "boolean",
                        "description": "Indicates whether the instance was provisioned with the GitLab Environment Toolkit for Service Ping reporting.\n"
                    },
                    "gitlabShellOperationLimit": {
                        "type": "integer",
                        "description": "Maximum number of Git operations per minute a user can perform. Introduced in GitLab 16.2.\n"
                    },
                    "gitpodEnabled": {
                        "type": "boolean",
                        "description": "Enable Gitpod integration.\n"
                    },
                    "gitpodUrl": {
                        "type": "string",
                        "description": "The Gitpod instance URL for integration.\n"
                    },
                    "globallyAllowedIps": {
                        "type": "string",
                        "description": "Comma-separated list of IP addresses and CIDRs always allowed for inbound traffic. For example, 1.1.1.1, 2.2.2.0/24.\n"
                    },
                    "grafanaEnabled": {
                        "type": "boolean",
                        "description": "Enable Grafana.\n"
                    },
                    "grafanaUrl": {
                        "type": "string",
                        "description": "Grafana URL.\n"
                    },
                    "gravatarEnabled": {
                        "type": "boolean",
                        "description": "Enable Gravatar.\n"
                    },
                    "groupOwnersCanManageDefaultBranchProtection": {
                        "type": "boolean",
                        "description": "Prevent overrides of default branch protection.\n"
                    },
                    "hashedStorageEnabled": {
                        "type": "boolean",
                        "description": "Create new projects using hashed storage paths: Enable immutable, hash-based paths and repository names to store repositories on disk. This prevents repositories from having to be moved or renamed when the Project URL changes and may improve disk I/O performance. (Always enabled in GitLab versions 13.0 and later, configuration is scheduled for removal in 14.0).\n"
                    },
                    "helpPageHideCommercialContent": {
                        "type": "boolean",
                        "description": "Hide marketing-related entries from help.\n"
                    },
                    "helpPageSupportUrl": {
                        "type": "string",
                        "description": "Alternate support URL for help page and help dropdown.\n"
                    },
                    "helpPageText": {
                        "type": "string",
                        "description": "Custom text displayed on the help page.\n"
                    },
                    "helpText": {
                        "type": "string",
                        "description": "GitLab server administrator information.\n"
                    },
                    "hideThirdPartyOffers": {
                        "type": "boolean",
                        "description": "Do not display offers from third parties in GitLab.\n"
                    },
                    "homePageUrl": {
                        "type": "string",
                        "description": "Redirect to this URL when not logged in.\n"
                    },
                    "housekeepingEnabled": {
                        "type": "boolean",
                        "description": "Enable or disable Git housekeeping.\n\t\t\tIf enabled, requires either housekeeping*optimize*repository*period OR housekeeping*bitmaps*enabled, housekeeping*full*repack*period, housekeeping*gc*period, and housekeeping*incremental*repack*period.\n\t\t\tOptions housekeeping*bitmaps*enabled, housekeeping*full*repack*period, housekeeping*gc*period, and housekeeping*incremental*repack*period are deprecated. Use housekeeping*optimize*repository*period instead.\n"
                    },
                    "housekeepingFullRepackPeriod": {
                        "type": "integer",
                        "description": "Number of Git pushes after which an incremental git repack is run.\n",
                        "deprecationMessage": "housekeeping_full_repack_period is deprecated. Use housekeeping_optimize_repository_period instead."
                    },
                    "housekeepingGcPeriod": {
                        "type": "integer",
                        "description": "Number of Git pushes after which git gc is run.\n",
                        "deprecationMessage": "housekeeping_gc_period is deprecated. Use housekeeping_optimize_repository_period instead."
                    },
                    "housekeepingIncrementalRepackPeriod": {
                        "type": "integer",
                        "description": "Number of Git pushes after which an incremental git repack is run.\n",
                        "deprecationMessage": "housekeeping_incremental_repack_period is deprecated. Use housekeeping_optimize_repository_period instead."
                    },
                    "housekeepingOptimizeRepositoryPeriod": {
                        "type": "integer",
                        "description": "Number of Git pushes after which an incremental git repack is run.\n"
                    },
                    "htmlEmailsEnabled": {
                        "type": "boolean",
                        "description": "Enable HTML emails.\n"
                    },
                    "importSources": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Sources to allow project import from. Valid values are: `github`, `bitbucket`, `bitbucket_server`, `fogbugz`, `git`, `gitlab.Project`, `gitea`, `manifest`\n"
                    },
                    "inProductMarketingEmailsEnabled": {
                        "type": "boolean",
                        "description": "Enable in-product marketing emails.\n"
                    },
                    "inactiveProjectsDeleteAfterMonths": {
                        "type": "integer",
                        "description": "If delete*inactive*projects is true, the time (in months) to wait before deleting inactive projects. Introduced in GitLab 14.10. Became operational in GitLab 15.0.\n"
                    },
                    "inactiveProjectsMinSizeMb": {
                        "type": "integer",
                        "description": "If delete*inactive*projects is true, the minimum repository size for projects to be checked for inactivity. Introduced in GitLab 14.10. Became operational in GitLab 15.0.\n"
                    },
                    "inactiveProjectsSendWarningEmailAfterMonths": {
                        "type": "integer",
                        "description": "If delete*inactive*projects is true, sets the time (in months) to wait before emailing maintainers that the project is scheduled be deleted because it is inactive. Introduced in GitLab 14.10. Became operational in GitLab 15.0.\n"
                    },
                    "includeOptionalMetricsInServicePing": {
                        "type": "boolean",
                        "description": "Whether or not optional metrics are enabled in Service Ping. Introduced in GitLab 16.10.\n"
                    },
                    "invisibleCaptchaEnabled": {
                        "type": "boolean",
                        "description": "Enable Invisible CAPTCHA spam detection during sign-up.\n"
                    },
                    "issuesCreateLimit": {
                        "type": "integer",
                        "description": "Max number of issue creation requests per minute per user.\n"
                    },
                    "jiraConnectApplicationKey": {
                        "type": "string",
                        "description": "ID of the OAuth application used to authenticate with the GitLab for Jira Cloud app.\n"
                    },
                    "jiraConnectProxyUrl": {
                        "type": "string",
                        "description": "URL of the GitLab instance used as a proxy for the GitLab for Jira Cloud app.\n"
                    },
                    "jiraConnectPublicKeyStorageEnabled": {
                        "type": "boolean",
                        "description": "Enable public key storage for the GitLab for Jira Cloud app.\n"
                    },
                    "keepLatestArtifact": {
                        "type": "boolean",
                        "description": "Prevent the deletion of the artifacts from the most recent successful jobs, regardless of the expiry time.\n"
                    },
                    "localMarkdownVersion": {
                        "type": "integer",
                        "description": "Increase this value when any cached Markdown should be invalidated.\n"
                    },
                    "lockDuoFeaturesEnabled": {
                        "type": "boolean",
                        "description": "Indicates whether the GitLab Duo features enabled setting is enforced for all subgroups. Introduced in GitLab 16.10. Self-managed, Premium and Ultimate only.\n"
                    },
                    "mailgunEventsEnabled": {
                        "type": "boolean",
                        "description": "Enable Mailgun event receiver.\n"
                    },
                    "mailgunSigningKey": {
                        "type": "string",
                        "description": "The Mailgun HTTP webhook signing key for receiving events from webhook.\n",
                        "secret": true
                    },
                    "maintenanceMode": {
                        "type": "boolean",
                        "description": "When instance is in maintenance mode, non-administrative users can sign in with read-only access and make read-only API requests.\n"
                    },
                    "maintenanceModeMessage": {
                        "type": "string",
                        "description": "Message displayed when instance is in maintenance mode.\n"
                    },
                    "mavenPackageRequestsForwarding": {
                        "type": "boolean",
                        "description": "Use repo.maven.apache.org as a default remote repository when the package is not found in the GitLab Package Registry for Maven. Premium and Ultimate only.\n"
                    },
                    "maxArtifactsSize": {
                        "type": "integer",
                        "description": "Maximum artifacts size in MB.\n"
                    },
                    "maxAttachmentSize": {
                        "type": "integer",
                        "description": "Limit attachment size in MB.\n"
                    },
                    "maxDecompressedArchiveSize": {
                        "type": "integer",
                        "description": "Maximum decompressed archive size in bytes.\n"
                    },
                    "maxExportSize": {
                        "type": "integer",
                        "description": "Maximum export size in MB. 0 for unlimited.\n"
                    },
                    "maxImportRemoteFileSize": {
                        "type": "integer",
                        "description": "Maximum remote file size for imports from external object storages. Introduced in GitLab 16.3.\n"
                    },
                    "maxImportSize": {
                        "type": "integer",
                        "description": "Maximum import size in MB. 0 for unlimited.\n"
                    },
                    "maxLoginAttempts": {
                        "type": "integer",
                        "description": "Maximum number of sign-in attempts before locking out the user.\n"
                    },
                    "maxNumberOfRepositoryDownloads": {
                        "type": "integer",
                        "description": "Maximum number of unique repositories a user can download in the specified time period before they are banned. Maximum: 10,000 repositories. Introduced in GitLab 15.1.\n"
                    },
                    "maxNumberOfRepositoryDownloadsWithinTimePeriod": {
                        "type": "integer",
                        "description": "Reporting time period (in seconds). Maximum: 864000 seconds (10 days). Introduced in GitLab 15.1.\n"
                    },
                    "maxPagesSize": {
                        "type": "integer",
                        "description": "Maximum size of pages repositories in MB.\n"
                    },
                    "maxPersonalAccessTokenLifetime": {
                        "type": "integer",
                        "description": "Maximum allowable lifetime for access tokens in days.\n"
                    },
                    "maxSshKeyLifetime": {
                        "type": "integer",
                        "description": "Maximum allowable lifetime for SSH keys in days. Introduced in GitLab 14.6.\n"
                    },
                    "maxTerraformStateSizeBytes": {
                        "type": "integer"
                    },
                    "metricsMethodCallThreshold": {
                        "type": "integer",
                        "description": "A method call is only tracked when it takes longer than the given amount of milliseconds.\n"
                    },
                    "minimumPasswordLength": {
                        "type": "integer",
                        "description": "Indicates whether passwords require a minimum length. Introduced in GitLab 15.1. Premium and Ultimate only.\n"
                    },
                    "mirrorAvailable": {
                        "type": "boolean",
                        "description": "Allow repository mirroring to configured by project Maintainers. If disabled, only Administrators can configure repository mirroring.\n"
                    },
                    "mirrorCapacityThreshold": {
                        "type": "integer",
                        "description": "Minimum capacity to be available before scheduling more mirrors preemptively.\n"
                    },
                    "mirrorMaxCapacity": {
                        "type": "integer",
                        "description": "Maximum number of mirrors that can be synchronizing at the same time.\n"
                    },
                    "mirrorMaxDelay": {
                        "type": "integer",
                        "description": "Maximum time (in minutes) between updates that a mirror can have when scheduled to synchronize.\n"
                    },
                    "npmPackageRequestsForwarding": {
                        "type": "boolean",
                        "description": "Use npmjs.org as a default remote repository when the package is not found in the GitLab Package Registry for npm.\n"
                    },
                    "nugetSkipMetadataUrlValidation": {
                        "type": "boolean",
                        "description": "Indicates whether to skip metadata URL validation for the NuGet package. Introduced in GitLab 17.0.\n"
                    },
                    "outboundLocalRequestsWhitelists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Define a list of trusted domains or IP addresses to which local requests are allowed when local requests for hooks and services are disabled.\n"
                    },
                    "packageMetadataPurlTypes": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "List of package registry metadata to sync. See the list of the available values (https://gitlab.com/gitlab-org/gitlab/-/blob/ace16c20d5da7c4928dd03fb139692638b557fe3/app/models/concerns/enums/package_metadata.rb#L5). Self-managed, Ultimate only.\n"
                    },
                    "packageRegistryAllowAnyoneToPullOption": {
                        "type": "boolean",
                        "description": "Enable to allow anyone to pull from Package Registry visible and changeable.\n"
                    },
                    "packageRegistryCleanupPoliciesWorkerCapacity": {
                        "type": "integer",
                        "description": "Number of workers assigned to the packages cleanup policies.\n"
                    },
                    "pagesDomainVerificationEnabled": {
                        "type": "boolean",
                        "description": "Require users to prove ownership of custom domains. Domain verification is an essential security measure for public GitLab sites. Users are required to demonstrate they control a domain before it is enabled.\n"
                    },
                    "passwordAuthenticationEnabledForGit": {
                        "type": "boolean",
                        "description": "Enable authentication for Git over HTTP(S) via a GitLab account password.\n"
                    },
                    "passwordAuthenticationEnabledForWeb": {
                        "type": "boolean",
                        "description": "Enable authentication for the web interface via a GitLab account password.\n"
                    },
                    "passwordLowercaseRequired": {
                        "type": "boolean",
                        "description": "Indicates whether passwords require at least one lowercase letter. Introduced in GitLab 15.1.\n"
                    },
                    "passwordNumberRequired": {
                        "type": "boolean",
                        "description": "Indicates whether passwords require at least one number. Introduced in GitLab 15.1.\n"
                    },
                    "passwordSymbolRequired": {
                        "type": "boolean",
                        "description": "Indicates whether passwords require at least one symbol character. Introduced in GitLab 15.1.\n"
                    },
                    "passwordUppercaseRequired": {
                        "type": "boolean",
                        "description": "Indicates whether passwords require at least one uppercase letter. Introduced in GitLab 15.1.\n"
                    },
                    "performanceBarAllowedGroupPath": {
                        "type": "string",
                        "description": "Path of the group that is allowed to toggle the performance bar.\n"
                    },
                    "personalAccessTokenPrefix": {
                        "type": "string",
                        "description": "Prefix for all generated personal access tokens.\n"
                    },
                    "pipelineLimitPerProjectUserSha": {
                        "type": "integer",
                        "description": "Maximum number of pipeline creation requests per minute per user and commit.\n"
                    },
                    "plantumlEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: plantuml_url) Enable PlantUML integration.\n"
                    },
                    "plantumlUrl": {
                        "type": "string",
                        "description": "The PlantUML instance URL for integration.\n"
                    },
                    "pollingIntervalMultiplier": {
                        "type": "number",
                        "description": "Interval multiplier used by endpoints that perform polling. Set to 0 to disable polling.\n"
                    },
                    "projectExportEnabled": {
                        "type": "boolean",
                        "description": "Enable project export.\n"
                    },
                    "projectJobsApiRateLimit": {
                        "type": "integer",
                        "description": "Maximum authenticated requests to /project/:id/jobs per minute. Introduced in GitLab 16.5.\n"
                    },
                    "projectsApiRateLimitUnauthenticated": {
                        "type": "integer",
                        "description": "Introduced in GitLab 15.10. Max number of requests per 10 minutes per IP address for unauthenticated requests to the list all projects API. To disable throttling set to 0.\n"
                    },
                    "prometheusMetricsEnabled": {
                        "type": "boolean",
                        "description": "Enable Prometheus metrics.\n"
                    },
                    "protectedCiVariables": {
                        "type": "boolean",
                        "description": "CI/CD variables are protected by default.\n"
                    },
                    "pushEventActivitiesLimit": {
                        "type": "integer",
                        "description": "Number of changes (branches or tags) in a single push to determine whether individual push events or bulk push events are created. Bulk push events are created if it surpasses that value.\n"
                    },
                    "pushEventHooksLimit": {
                        "type": "integer",
                        "description": "Number of changes (branches or tags) in a single push to determine whether webhooks and services fire or not. Webhooks and services aren’t submitted if it surpasses that value.\n"
                    },
                    "pypiPackageRequestsForwarding": {
                        "type": "boolean",
                        "description": "Use pypi.org as a default remote repository when the package is not found in the GitLab Package Registry for PyPI.\n"
                    },
                    "rateLimitingResponseText": {
                        "type": "string",
                        "description": "When rate limiting is enabled via the throttle_* settings, send this plain text response when a rate limit is exceeded. ‘Retry later’ is sent if this is blank.\n"
                    },
                    "rawBlobRequestLimit": {
                        "type": "integer",
                        "description": "Max number of requests per minute for each raw path. To disable throttling set to 0.\n"
                    },
                    "recaptchaEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: recaptcha*private*key and recaptcha*site*key) Enable reCAPTCHA.\n"
                    },
                    "recaptchaPrivateKey": {
                        "type": "string",
                        "description": "Private key for reCAPTCHA.\n",
                        "secret": true
                    },
                    "recaptchaSiteKey": {
                        "type": "string",
                        "description": "Site key for reCAPTCHA.\n",
                        "secret": true
                    },
                    "receiveMaxInputSize": {
                        "type": "integer",
                        "description": "Maximum push size (MB).\n"
                    },
                    "receptiveClusterAgentsEnabled": {
                        "type": "boolean",
                        "description": "Enable receptive mode for GitLab Agents for Kubernetes.\n"
                    },
                    "rememberMeEnabled": {
                        "type": "boolean",
                        "description": "Enable Remember me setting. Introduced in GitLab 16.0.\n"
                    },
                    "repositoryChecksEnabled": {
                        "type": "boolean",
                        "description": "GitLab periodically runs git fsck in all project and wiki repositories to look for silent disk corruption issues.\n"
                    },
                    "repositorySizeLimit": {
                        "type": "integer",
                        "description": "Size limit per repository (MB).\n"
                    },
                    "repositoryStorages": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(GitLab 13.0 and earlier) List of names of enabled storage paths, taken from gitlab.yml. New projects are created in one of these stores, chosen at random.\n"
                    },
                    "repositoryStoragesWeighted": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "integer"
                        },
                        "description": "(GitLab 13.1 and later) Hash of names of taken from gitlab.yml to weights. New projects are created in one of these stores, chosen by a weighted random selection.\n"
                    },
                    "requireAdminApprovalAfterUserSignup": {
                        "type": "boolean",
                        "description": "When enabled, any user that signs up for an account using the registration form is placed under a Pending approval state and has to be explicitly approved by an administrator.\n"
                    },
                    "requireAdminTwoFactorAuthentication": {
                        "type": "boolean",
                        "description": "Allow administrators to require 2FA for all administrators on the instance.\n"
                    },
                    "requirePersonalAccessTokenExpiry": {
                        "type": "boolean",
                        "description": "When enabled, users must set an expiration date when creating a group or project access token, or a personal access token owned by a non-service account.\n"
                    },
                    "requireTwoFactorAuthentication": {
                        "type": "boolean",
                        "description": "(If enabled, requires: two*factor*grace_period) Require all users to set up Two-factor authentication.\n"
                    },
                    "restrictedVisibilityLevels": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Selected levels cannot be used by non-Administrator users for groups, projects or snippets. Can take private, internal and public as a parameter. Null means there is no restriction.\n"
                    },
                    "rsaKeyRestriction": {
                        "type": "integer",
                        "description": "The minimum allowed bit length of an uploaded RSA key. 0 means no restriction. -1 disables RSA keys.\n"
                    },
                    "searchRateLimit": {
                        "type": "integer",
                        "description": "Max number of requests per minute for performing a search while authenticated. To disable throttling set to 0.\n"
                    },
                    "searchRateLimitUnauthenticated": {
                        "type": "integer",
                        "description": "Max number of requests per minute for performing a search while unauthenticated. To disable throttling set to 0.\n"
                    },
                    "securityApprovalPoliciesLimit": {
                        "type": "integer",
                        "description": "Maximum number of active merge request approval policies per security policy project. Maximum: 20\n"
                    },
                    "securityPolicyGlobalGroupApproversEnabled": {
                        "type": "boolean",
                        "description": "Whether to look up merge request approval policy approval groups globally or within project hierarchies.\n"
                    },
                    "securityTxtContent": {
                        "type": "string",
                        "description": "Public security contact information. Introduced in GitLab 16.7.\n"
                    },
                    "sendUserConfirmationEmail": {
                        "type": "boolean",
                        "description": "Send confirmation email on sign-up.\n"
                    },
                    "serviceAccessTokensExpirationEnforced": {
                        "type": "boolean",
                        "description": "Flag to indicate if token expiry date can be optional for service account users\n"
                    },
                    "sessionExpireDelay": {
                        "type": "integer",
                        "description": "Session duration in minutes. GitLab restart is required to apply changes.\n"
                    },
                    "sharedRunnersEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: shared*runners*text and shared*runners*minutes) Enable shared runners for new projects.\n"
                    },
                    "sharedRunnersMinutes": {
                        "type": "integer",
                        "description": "Set the maximum number of CI/CD minutes that a group can use on shared runners per month.\n"
                    },
                    "sharedRunnersText": {
                        "type": "string",
                        "description": "Shared runners text.\n"
                    },
                    "sidekiqJobLimiterCompressionThresholdBytes": {
                        "type": "integer",
                        "description": "The threshold in bytes at which Sidekiq jobs are compressed before being stored in Redis.\n"
                    },
                    "sidekiqJobLimiterLimitBytes": {
                        "type": "integer",
                        "description": "The threshold in bytes at which Sidekiq jobs are rejected. 0 means do not reject any job.\n"
                    },
                    "sidekiqJobLimiterMode": {
                        "type": "string",
                        "description": "track or compress. Sets the behavior for Sidekiq job size limits.\n"
                    },
                    "signInText": {
                        "type": "string",
                        "description": "Text on the login page.\n"
                    },
                    "signupEnabled": {
                        "type": "boolean",
                        "description": "Enable registration.\n"
                    },
                    "silentAdminExportsEnabled": {
                        "type": "boolean",
                        "description": "Enable Silent admin exports.\n"
                    },
                    "silentModeEnabled": {
                        "type": "boolean",
                        "description": "Enable Silent mode.\n"
                    },
                    "slackAppEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: slack*app*id, slack*app*secret and slack*app*secret) Enable Slack app.\n"
                    },
                    "slackAppId": {
                        "type": "string",
                        "description": "The app ID of the Slack-app.\n"
                    },
                    "slackAppSecret": {
                        "type": "string",
                        "description": "The app secret of the Slack-app.\n",
                        "secret": true
                    },
                    "slackAppSigningSecret": {
                        "type": "string",
                        "description": "The signing secret of the Slack-app.\n",
                        "secret": true
                    },
                    "slackAppVerificationToken": {
                        "type": "string",
                        "description": "The verification token of the Slack-app.\n"
                    },
                    "snippetSizeLimit": {
                        "type": "integer",
                        "description": "Max snippet content size in bytes.\n"
                    },
                    "snowplowAppId": {
                        "type": "string",
                        "description": "The Snowplow site name / application ID. (for example, gitlab)\n"
                    },
                    "snowplowCollectorHostname": {
                        "type": "string",
                        "description": "The Snowplow collector hostname. (for example, snowplow.trx.gitlab.net)\n"
                    },
                    "snowplowCookieDomain": {
                        "type": "string",
                        "description": "The Snowplow cookie domain. (for example, .gitlab.com)\n"
                    },
                    "snowplowDatabaseCollectorHostname": {
                        "type": "string",
                        "description": "The Snowplow collector for database events hostname. (for example, db-snowplow.trx.gitlab.net)\n"
                    },
                    "snowplowEnabled": {
                        "type": "boolean",
                        "description": "Enable snowplow tracking.\n"
                    },
                    "sourcegraphEnabled": {
                        "type": "boolean",
                        "description": "Enables Sourcegraph integration. If enabled, requires sourcegraph_url.\n"
                    },
                    "sourcegraphPublicOnly": {
                        "type": "boolean",
                        "description": "Blocks Sourcegraph from being loaded on private and internal projects.\n"
                    },
                    "sourcegraphUrl": {
                        "type": "string",
                        "description": "The Sourcegraph instance URL for integration.\n"
                    },
                    "spamCheckApiKey": {
                        "type": "string",
                        "description": "API key used by GitLab for accessing the Spam Check service endpoint.\n",
                        "secret": true
                    },
                    "spamCheckEndpointEnabled": {
                        "type": "boolean",
                        "description": "Enables spam checking using external Spam Check API endpoint.\n"
                    },
                    "spamCheckEndpointUrl": {
                        "type": "string",
                        "description": "URL of the external Spamcheck service endpoint. Valid URI schemes are grpc or tls. Specifying tls forces communication to be encrypted.\n"
                    },
                    "staticObjectsExternalStorageAuthToken": {
                        "type": "string",
                        "description": "Authentication token for the external storage linked in static*objects*external*storage*url.\n",
                        "secret": true
                    },
                    "staticObjectsExternalStorageUrl": {
                        "type": "string",
                        "description": "URL to an external storage for repository static objects.\n",
                        "secret": true
                    },
                    "suggestPipelineEnabled": {
                        "type": "boolean",
                        "description": "Enable pipeline suggestion banner.\n"
                    },
                    "terminalMaxSessionTime": {
                        "type": "integer",
                        "description": "Maximum time for web terminal websocket connection (in seconds). Set to 0 for unlimited time.\n"
                    },
                    "terms": {
                        "type": "string",
                        "description": "(Required by: enforce_terms) Markdown content for the ToS.\n"
                    },
                    "throttleAuthenticatedApiEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: throttle*authenticated*api*period*in*seconds and throttle*authenticated*api*requests*per*period) Enable authenticated API request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots).\n"
                    },
                    "throttleAuthenticatedApiPeriodInSeconds": {
                        "type": "integer",
                        "description": "Rate limit period (in seconds).\n"
                    },
                    "throttleAuthenticatedApiRequestsPerPeriod": {
                        "type": "integer",
                        "description": "Maximum requests per period per user.\n"
                    },
                    "throttleAuthenticatedPackagesApiEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: throttle*authenticated*packages*api*period*in*seconds and throttle*authenticated*packages*api*requests*per*period) Enable authenticated API request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots). View Package Registry rate limits for more details.\n"
                    },
                    "throttleAuthenticatedPackagesApiPeriodInSeconds": {
                        "type": "integer",
                        "description": "Rate limit period (in seconds). View Package Registry rate limits for more details.\n"
                    },
                    "throttleAuthenticatedPackagesApiRequestsPerPeriod": {
                        "type": "integer",
                        "description": "Maximum requests per period per user. View Package Registry rate limits for more details.\n"
                    },
                    "throttleAuthenticatedWebEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: throttle*authenticated*web*period*in*seconds and throttle*authenticated*web*requests*per*period) Enable authenticated web request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots).\n"
                    },
                    "throttleAuthenticatedWebPeriodInSeconds": {
                        "type": "integer",
                        "description": "Rate limit period (in seconds).\n"
                    },
                    "throttleAuthenticatedWebRequestsPerPeriod": {
                        "type": "integer",
                        "description": "Maximum requests per period per user.\n"
                    },
                    "throttleUnauthenticatedApiEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: throttle*unauthenticated*api*period*in*seconds and throttle*unauthenticated*api*requests*per*period) Enable unauthenticated API request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots).\n"
                    },
                    "throttleUnauthenticatedApiPeriodInSeconds": {
                        "type": "integer",
                        "description": "Rate limit period in seconds.\n"
                    },
                    "throttleUnauthenticatedApiRequestsPerPeriod": {
                        "type": "integer",
                        "description": "Max requests per period per IP.\n"
                    },
                    "throttleUnauthenticatedPackagesApiEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: throttle*unauthenticated*packages*api*period*in*seconds and throttle*unauthenticated*packages*api*requests*per*period) Enable authenticated API request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots). View Package Registry rate limits for more details.\n"
                    },
                    "throttleUnauthenticatedPackagesApiPeriodInSeconds": {
                        "type": "integer",
                        "description": "Rate limit period (in seconds). View Package Registry rate limits for more details.\n"
                    },
                    "throttleUnauthenticatedPackagesApiRequestsPerPeriod": {
                        "type": "integer",
                        "description": "Maximum requests per period per user. View Package Registry rate limits for more details.\n"
                    },
                    "throttleUnauthenticatedWebEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: throttle*unauthenticated*web*period*in*seconds and throttle*unauthenticated*web*requests*per*period) Enable unauthenticated web request rate limit. Helps reduce request volume (for example, from crawlers or abusive bots).\n"
                    },
                    "throttleUnauthenticatedWebPeriodInSeconds": {
                        "type": "integer",
                        "description": "Rate limit period in seconds.\n"
                    },
                    "throttleUnauthenticatedWebRequestsPerPeriod": {
                        "type": "integer",
                        "description": "Max requests per period per IP.\n"
                    },
                    "timeTrackingLimitToHours": {
                        "type": "boolean",
                        "description": "Limit display of time tracking units to hours.\n"
                    },
                    "twoFactorGracePeriod": {
                        "type": "integer",
                        "description": "Amount of time (in hours) that users are allowed to skip forced configuration of two-factor authentication.\n"
                    },
                    "unconfirmedUsersDeleteAfterDays": {
                        "type": "integer",
                        "description": "Specifies how many days after sign-up to delete users who have not confirmed their email. Only applicable if delete*unconfirmed*users is set to true. Must be 1 or greater. Introduced in GitLab 16.1. Self-managed, Premium and Ultimate only.\n"
                    },
                    "uniqueIpsLimitEnabled": {
                        "type": "boolean",
                        "description": "(If enabled, requires: unique*ips*limit*per*user and unique*ips*limit*time*window) Limit sign in from multiple IPs.\n"
                    },
                    "uniqueIpsLimitPerUser": {
                        "type": "integer",
                        "description": "Maximum number of IPs per user.\n"
                    },
                    "uniqueIpsLimitTimeWindow": {
                        "type": "integer",
                        "description": "How many seconds an IP is counted towards the limit.\n"
                    },
                    "updateRunnerVersionsEnabled": {
                        "type": "boolean",
                        "description": "Fetch GitLab Runner release version data from GitLab.com.\n"
                    },
                    "usagePingEnabled": {
                        "type": "boolean",
                        "description": "Every week GitLab reports license usage back to GitLab, Inc.\n"
                    },
                    "useClickhouseForAnalytics": {
                        "type": "boolean",
                        "description": "Enables ClickHouse as a data source for analytics reports. ClickHouse must be configured for this setting to take effect. Available on Premium and Ultimate only.\n"
                    },
                    "userDeactivationEmailsEnabled": {
                        "type": "boolean",
                        "description": "Send an email to users upon account deactivation.\n"
                    },
                    "userDefaultExternal": {
                        "type": "boolean",
                        "description": "Newly registered users are external by default.\n"
                    },
                    "userDefaultInternalRegex": {
                        "type": "string",
                        "description": "Specify an email address regex pattern to identify default internal users.\n"
                    },
                    "userDefaultsToPrivateProfile": {
                        "type": "boolean",
                        "description": "Newly created users have private profile by default. Introduced in GitLab 15.8.\n"
                    },
                    "userOauthApplications": {
                        "type": "boolean",
                        "description": "Allow users to register any application to use GitLab as an OAuth provider.\n"
                    },
                    "userShowAddSshKeyMessage": {
                        "type": "boolean",
                        "description": "When set to false disable the You won't be able to pull or push project code via SSH warning shown to users with no uploaded SSH key.\n"
                    },
                    "validRunnerRegistrars": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of types which are allowed to register a GitLab Runner. Can be [], ['group'], ['project'] or ['group', 'project'].\n"
                    },
                    "versionCheckEnabled": {
                        "type": "boolean",
                        "description": "Let GitLab inform you when an update is available.\n"
                    },
                    "webIdeClientsidePreviewEnabled": {
                        "type": "boolean",
                        "description": "Live Preview (allow live previews of JavaScript projects in the Web IDE using CodeSandbox Live Preview).\n"
                    },
                    "whatsNewVariant": {
                        "type": "string",
                        "description": "What's new variant, possible values: all*tiers, current*tier, and disabled.\n"
                    },
                    "wikiPageMaxContentBytes": {
                        "type": "integer",
                        "description": "Maximum wiki page content size in bytes. The minimum value is 1024 bytes.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/branch:Branch": {
            "description": "The `gitlab.Branch` resource allows to manage the lifecycle of a repository branch.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/branches.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\n// Create a project for the branch to use\nconst example = new gitlab.Project(\"example\", {\n    name: \"example\",\n    description: \"An example project\",\n    namespaceId: exampleGitlabGroup.id,\n});\nconst exampleBranch = new gitlab.Branch(\"example\", {\n    name: \"example\",\n    ref: \"main\",\n    project: example.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\n# Create a project for the branch to use\nexample = gitlab.Project(\"example\",\n    name=\"example\",\n    description=\"An example project\",\n    namespace_id=example_gitlab_group[\"id\"])\nexample_branch = gitlab.Branch(\"example\",\n    name=\"example\",\n    ref=\"main\",\n    project=example.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create a project for the branch to use\n    var example = new GitLab.Project(\"example\", new()\n    {\n        Name = \"example\",\n        Description = \"An example project\",\n        NamespaceId = exampleGitlabGroup.Id,\n    });\n\n    var exampleBranch = new GitLab.Branch(\"example\", new()\n    {\n        Name = \"example\",\n        Ref = \"main\",\n        Project = example.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Create a project for the branch to use\n\t\texample, err := gitlab.NewProject(ctx, \"example\", \u0026gitlab.ProjectArgs{\n\t\t\tName:        pulumi.String(\"example\"),\n\t\t\tDescription: pulumi.String(\"An example project\"),\n\t\t\tNamespaceId: pulumi.Any(exampleGitlabGroup.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewBranch(ctx, \"example\", \u0026gitlab.BranchArgs{\n\t\t\tName:    pulumi.String(\"example\"),\n\t\t\tRef:     pulumi.String(\"main\"),\n\t\t\tProject: example.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.Branch;\nimport com.pulumi.gitlab.BranchArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Create a project for the branch to use\n        var example = new Project(\"example\", ProjectArgs.builder()\n            .name(\"example\")\n            .description(\"An example project\")\n            .namespaceId(exampleGitlabGroup.id())\n            .build());\n\n        var exampleBranch = new Branch(\"exampleBranch\", BranchArgs.builder()\n            .name(\"example\")\n            .ref(\"main\")\n            .project(example.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a project for the branch to use\n  example:\n    type: gitlab:Project\n    properties:\n      name: example\n      description: An example project\n      namespaceId: ${exampleGitlabGroup.id}\n  exampleBranch:\n    type: gitlab:Branch\n    name: example\n    properties:\n      name: example\n      ref: main\n      project: ${example.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_branch`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_branch.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitlab branches can be imported with a key composed of `\u003cproject_id\u003e:\u003cbranch_name\u003e`, e.g.\n\n```sh\n$ pulumi import gitlab:index/branch:Branch example \"12345:develop\"\n```\n\n",
            "properties": {
                "canPush": {
                    "type": "boolean",
                    "description": "Bool, true if you can push to the branch.\n"
                },
                "commits": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/BranchCommit:BranchCommit"
                    },
                    "description": "The commit associated with the branch ref.\n"
                },
                "default": {
                    "type": "boolean",
                    "description": "Bool, true if branch is the default branch for the project.\n"
                },
                "developerCanMerge": {
                    "type": "boolean",
                    "description": "Bool, true if developer level access allows to merge branch.\n"
                },
                "developerCanPush": {
                    "type": "boolean",
                    "description": "Bool, true if developer level access allows git push.\n"
                },
                "merged": {
                    "type": "boolean",
                    "description": "Bool, true if the branch has been merged into it's parent.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name for this branch.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project which the branch is created against.\n"
                },
                "protected": {
                    "type": "boolean",
                    "description": "Bool, true if branch has branch protection.\n"
                },
                "ref": {
                    "type": "string",
                    "description": "The ref which the branch is created from.\n"
                },
                "webUrl": {
                    "type": "string",
                    "description": "The url of the created branch (https).\n"
                }
            },
            "required": [
                "canPush",
                "commits",
                "default",
                "developerCanMerge",
                "developerCanPush",
                "merged",
                "name",
                "project",
                "protected",
                "ref",
                "webUrl"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "The name for this branch.\n",
                    "willReplaceOnChanges": true
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project which the branch is created against.\n",
                    "willReplaceOnChanges": true
                },
                "ref": {
                    "type": "string",
                    "description": "The ref which the branch is created from.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "project",
                "ref"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Branch resources.\n",
                "properties": {
                    "canPush": {
                        "type": "boolean",
                        "description": "Bool, true if you can push to the branch.\n"
                    },
                    "commits": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/BranchCommit:BranchCommit"
                        },
                        "description": "The commit associated with the branch ref.\n"
                    },
                    "default": {
                        "type": "boolean",
                        "description": "Bool, true if branch is the default branch for the project.\n"
                    },
                    "developerCanMerge": {
                        "type": "boolean",
                        "description": "Bool, true if developer level access allows to merge branch.\n"
                    },
                    "developerCanPush": {
                        "type": "boolean",
                        "description": "Bool, true if developer level access allows git push.\n"
                    },
                    "merged": {
                        "type": "boolean",
                        "description": "Bool, true if the branch has been merged into it's parent.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name for this branch.\n",
                        "willReplaceOnChanges": true
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or full path of the project which the branch is created against.\n",
                        "willReplaceOnChanges": true
                    },
                    "protected": {
                        "type": "boolean",
                        "description": "Bool, true if branch has branch protection.\n"
                    },
                    "ref": {
                        "type": "string",
                        "description": "The ref which the branch is created from.\n",
                        "willReplaceOnChanges": true
                    },
                    "webUrl": {
                        "type": "string",
                        "description": "The url of the created branch (https).\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/branchProtection:BranchProtection": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst branchProtect = new gitlab.BranchProtection(\"BranchProtect\", {\n    project: \"12345\",\n    branch: \"BranchProtected\",\n    pushAccessLevel: \"developer\",\n    mergeAccessLevel: \"developer\",\n    unprotectAccessLevel: \"developer\",\n    allowForcePush: true,\n    codeOwnerApprovalRequired: true,\n    allowedToPushes: [\n        {\n            userId: 5,\n        },\n        {\n            userId: 521,\n        },\n    ],\n    allowedToMerges: [\n        {\n            userId: 15,\n        },\n        {\n            userId: 37,\n        },\n    ],\n    allowedToUnprotects: [\n        {\n            userId: 15,\n        },\n        {\n            groupId: 42,\n        },\n    ],\n});\n// Example using dynamic block\nconst main = new gitlab.BranchProtection(\"main\", {\n    allowedToPushes: [\n        50,\n        55,\n        60,\n    ].map((v, k) =\u003e ({key: k, value: v})).map(entry =\u003e ({\n        userId: entry.value,\n    })),\n    project: \"12345\",\n    branch: \"main\",\n    pushAccessLevel: \"maintainer\",\n    mergeAccessLevel: \"maintainer\",\n    unprotectAccessLevel: \"maintainer\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nbranch_protect = gitlab.BranchProtection(\"BranchProtect\",\n    project=\"12345\",\n    branch=\"BranchProtected\",\n    push_access_level=\"developer\",\n    merge_access_level=\"developer\",\n    unprotect_access_level=\"developer\",\n    allow_force_push=True,\n    code_owner_approval_required=True,\n    allowed_to_pushes=[\n        {\n            \"user_id\": 5,\n        },\n        {\n            \"user_id\": 521,\n        },\n    ],\n    allowed_to_merges=[\n        {\n            \"user_id\": 15,\n        },\n        {\n            \"user_id\": 37,\n        },\n    ],\n    allowed_to_unprotects=[\n        {\n            \"user_id\": 15,\n        },\n        {\n            \"group_id\": 42,\n        },\n    ])\n# Example using dynamic block\nmain = gitlab.BranchProtection(\"main\",\n    allowed_to_pushes=[{\n        \"user_id\": entry[\"value\"],\n    } for entry in [{\"key\": k, \"value\": v} for k, v in [\n        50,\n        55,\n        60,\n    ]]],\n    project=\"12345\",\n    branch=\"main\",\n    push_access_level=\"maintainer\",\n    merge_access_level=\"maintainer\",\n    unprotect_access_level=\"maintainer\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var branchProtect = new GitLab.BranchProtection(\"BranchProtect\", new()\n    {\n        Project = \"12345\",\n        Branch = \"BranchProtected\",\n        PushAccessLevel = \"developer\",\n        MergeAccessLevel = \"developer\",\n        UnprotectAccessLevel = \"developer\",\n        AllowForcePush = true,\n        CodeOwnerApprovalRequired = true,\n        AllowedToPushes = new[]\n        {\n            new GitLab.Inputs.BranchProtectionAllowedToPushArgs\n            {\n                UserId = 5,\n            },\n            new GitLab.Inputs.BranchProtectionAllowedToPushArgs\n            {\n                UserId = 521,\n            },\n        },\n        AllowedToMerges = new[]\n        {\n            new GitLab.Inputs.BranchProtectionAllowedToMergeArgs\n            {\n                UserId = 15,\n            },\n            new GitLab.Inputs.BranchProtectionAllowedToMergeArgs\n            {\n                UserId = 37,\n            },\n        },\n        AllowedToUnprotects = new[]\n        {\n            new GitLab.Inputs.BranchProtectionAllowedToUnprotectArgs\n            {\n                UserId = 15,\n            },\n            new GitLab.Inputs.BranchProtectionAllowedToUnprotectArgs\n            {\n                GroupId = 42,\n            },\n        },\n    });\n\n    // Example using dynamic block\n    var main = new GitLab.BranchProtection(\"main\", new()\n    {\n        AllowedToPushes = new[]\n        {\n            50,\n            55,\n            60,\n        }.Select((v, k) =\u003e new { Key = k, Value = v }).Select(entry =\u003e \n        {\n            return new GitLab.Inputs.BranchProtectionAllowedToPushArgs\n            {\n                UserId = entry.Value,\n            };\n        }).ToList(),\n        Project = \"12345\",\n        Branch = \"main\",\n        PushAccessLevel = \"maintainer\",\n        MergeAccessLevel = \"maintainer\",\n        UnprotectAccessLevel = \"maintainer\",\n    });\n\n});\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_branch_protection`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_branch_protection.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitlab protected branches can be imported with a key composed of `\u003cproject_id\u003e:\u003cbranch\u003e`, e.g.\n\n```sh\n$ pulumi import gitlab:index/branchProtection:BranchProtection BranchProtect \"12345:main\"\n```\n\n",
            "properties": {
                "allowForcePush": {
                    "type": "boolean",
                    "description": "Can be set to true to allow users with push access to force push.\n"
                },
                "allowedToMerges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/BranchProtectionAllowedToMerge:BranchProtectionAllowedToMerge"
                    },
                    "description": "Array of access levels and user(s)/group(s) allowed to merge to protected branch.\n"
                },
                "allowedToPushes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/BranchProtectionAllowedToPush:BranchProtectionAllowedToPush"
                    },
                    "description": "Array of access levels and user(s)/group(s) allowed to push to protected branch.\n"
                },
                "allowedToUnprotects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/BranchProtectionAllowedToUnprotect:BranchProtectionAllowedToUnprotect"
                    },
                    "description": "Array of access levels and user(s)/group(s) allowed to unprotect push to protected branch.\n"
                },
                "branch": {
                    "type": "string",
                    "description": "Name of the branch.\n"
                },
                "branchProtectionId": {
                    "type": "integer",
                    "description": "The ID of the branch protection (not the branch name).\n"
                },
                "codeOwnerApprovalRequired": {
                    "type": "boolean",
                    "description": "Can be set to true to require code owner approval before merging. Only available for Premium and Ultimate instances.\n"
                },
                "mergeAccessLevel": {
                    "type": "string",
                    "description": "Access levels allowed to merge. Valid values are: `no one`, `developer`, `maintainer`.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The id of the project.\n"
                },
                "pushAccessLevel": {
                    "type": "string",
                    "description": "Access levels allowed to push. Valid values are: `no one`, `developer`, `maintainer`.\n"
                },
                "unprotectAccessLevel": {
                    "type": "string",
                    "description": "Access levels allowed to unprotect. Valid values are: `developer`, `maintainer`, `admin`.\n"
                }
            },
            "required": [
                "allowForcePush",
                "branch",
                "branchProtectionId",
                "codeOwnerApprovalRequired",
                "mergeAccessLevel",
                "project",
                "pushAccessLevel",
                "unprotectAccessLevel"
            ],
            "inputProperties": {
                "allowForcePush": {
                    "type": "boolean",
                    "description": "Can be set to true to allow users with push access to force push.\n"
                },
                "allowedToMerges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/BranchProtectionAllowedToMerge:BranchProtectionAllowedToMerge"
                    },
                    "description": "Array of access levels and user(s)/group(s) allowed to merge to protected branch.\n"
                },
                "allowedToPushes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/BranchProtectionAllowedToPush:BranchProtectionAllowedToPush"
                    },
                    "description": "Array of access levels and user(s)/group(s) allowed to push to protected branch.\n"
                },
                "allowedToUnprotects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/BranchProtectionAllowedToUnprotect:BranchProtectionAllowedToUnprotect"
                    },
                    "description": "Array of access levels and user(s)/group(s) allowed to unprotect push to protected branch.\n"
                },
                "branch": {
                    "type": "string",
                    "description": "Name of the branch.\n"
                },
                "codeOwnerApprovalRequired": {
                    "type": "boolean",
                    "description": "Can be set to true to require code owner approval before merging. Only available for Premium and Ultimate instances.\n"
                },
                "mergeAccessLevel": {
                    "type": "string",
                    "description": "Access levels allowed to merge. Valid values are: `no one`, `developer`, `maintainer`.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The id of the project.\n"
                },
                "pushAccessLevel": {
                    "type": "string",
                    "description": "Access levels allowed to push. Valid values are: `no one`, `developer`, `maintainer`.\n"
                },
                "unprotectAccessLevel": {
                    "type": "string",
                    "description": "Access levels allowed to unprotect. Valid values are: `developer`, `maintainer`, `admin`.\n"
                }
            },
            "requiredInputs": [
                "branch",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering BranchProtection resources.\n",
                "properties": {
                    "allowForcePush": {
                        "type": "boolean",
                        "description": "Can be set to true to allow users with push access to force push.\n"
                    },
                    "allowedToMerges": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/BranchProtectionAllowedToMerge:BranchProtectionAllowedToMerge"
                        },
                        "description": "Array of access levels and user(s)/group(s) allowed to merge to protected branch.\n"
                    },
                    "allowedToPushes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/BranchProtectionAllowedToPush:BranchProtectionAllowedToPush"
                        },
                        "description": "Array of access levels and user(s)/group(s) allowed to push to protected branch.\n"
                    },
                    "allowedToUnprotects": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/BranchProtectionAllowedToUnprotect:BranchProtectionAllowedToUnprotect"
                        },
                        "description": "Array of access levels and user(s)/group(s) allowed to unprotect push to protected branch.\n"
                    },
                    "branch": {
                        "type": "string",
                        "description": "Name of the branch.\n"
                    },
                    "branchProtectionId": {
                        "type": "integer",
                        "description": "The ID of the branch protection (not the branch name).\n"
                    },
                    "codeOwnerApprovalRequired": {
                        "type": "boolean",
                        "description": "Can be set to true to require code owner approval before merging. Only available for Premium and Ultimate instances.\n"
                    },
                    "mergeAccessLevel": {
                        "type": "string",
                        "description": "Access levels allowed to merge. Valid values are: `no one`, `developer`, `maintainer`.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The id of the project.\n"
                    },
                    "pushAccessLevel": {
                        "type": "string",
                        "description": "Access levels allowed to push. Valid values are: `no one`, `developer`, `maintainer`.\n"
                    },
                    "unprotectAccessLevel": {
                        "type": "string",
                        "description": "Access levels allowed to unprotect. Valid values are: `developer`, `maintainer`, `admin`.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/clusterAgent:ClusterAgent": {
            "description": "The `gitlab.ClusterAgent` resource allows to manage the lifecycle of a GitLab Agent for Kubernetes.\n\n\u003e Note that this resource only registers the agent, but doesn't configure it.\n   The configuration needs to be manually added as described in\n   [the docs](https://docs.gitlab.com/ee/user/clusters/agent/install/index.html#create-an-agent-configuration-file).\n   However, a `gitlab.RepositoryFile` resource may be used to achieve that.\n\n\u003e Requires at least maintainer permissions on the project.\n\n\u003e Requires at least GitLab 14.10\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/cluster_agents.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\nimport * as std from \"@pulumi/std\";\n\nconst example = new gitlab.ClusterAgent(\"example\", {\n    project: \"12345\",\n    name: \"agent-1\",\n});\n// Optionally, configure the agent as described in\n// https://docs.gitlab.com/ee/user/clusters/agent/install/index.html#create-an-agent-configuration-file\nconst exampleAgentConfig = new gitlab.RepositoryFile(\"example_agent_config\", {\n    project: example.project,\n    branch: \"main\",\n    filePath: pulumi.interpolate`.gitlab/agents/${example.name}/config.yaml`,\n    content: std.base64encode({\n        input: \"# the GitLab Agent for Kubernetes configuration goes here ...\\n\",\n    }).then(invoke =\u003e invoke.result),\n    authorEmail: \"terraform@example.com\",\n    authorName: \"Terraform\",\n    commitMessage: pulumi.interpolate`feature: add agent config for ${example.name} [skip ci]`,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\nimport pulumi_std as std\n\nexample = gitlab.ClusterAgent(\"example\",\n    project=\"12345\",\n    name=\"agent-1\")\n# Optionally, configure the agent as described in\n# https://docs.gitlab.com/ee/user/clusters/agent/install/index.html#create-an-agent-configuration-file\nexample_agent_config = gitlab.RepositoryFile(\"example_agent_config\",\n    project=example.project,\n    branch=\"main\",\n    file_path=example.name.apply(lambda name: f\".gitlab/agents/{name}/config.yaml\"),\n    content=std.base64encode(input=\"# the GitLab Agent for Kubernetes configuration goes here ...\\n\").result,\n    author_email=\"terraform@example.com\",\n    author_name=\"Terraform\",\n    commit_message=example.name.apply(lambda name: f\"feature: add agent config for {name} [skip ci]\"))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\nusing Std = Pulumi.Std;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new GitLab.ClusterAgent(\"example\", new()\n    {\n        Project = \"12345\",\n        Name = \"agent-1\",\n    });\n\n    // Optionally, configure the agent as described in\n    // https://docs.gitlab.com/ee/user/clusters/agent/install/index.html#create-an-agent-configuration-file\n    var exampleAgentConfig = new GitLab.RepositoryFile(\"example_agent_config\", new()\n    {\n        Project = example.Project,\n        Branch = \"main\",\n        FilePath = example.Name.Apply(name =\u003e $\".gitlab/agents/{name}/config.yaml\"),\n        Content = Std.Base64encode.Invoke(new()\n        {\n            Input = @\"# the GitLab Agent for Kubernetes configuration goes here ...\n\",\n        }).Apply(invoke =\u003e invoke.Result),\n        AuthorEmail = \"terraform@example.com\",\n        AuthorName = \"Terraform\",\n        CommitMessage = example.Name.Apply(name =\u003e $\"feature: add agent config for {name} [skip ci]\"),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi-std/sdk/go/std\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := gitlab.NewClusterAgent(ctx, \"example\", \u0026gitlab.ClusterAgentArgs{\n\t\t\tProject: pulumi.String(\"12345\"),\n\t\t\tName:    pulumi.String(\"agent-1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tinvokeBase64encode, err := std.Base64encode(ctx, \u0026std.Base64encodeArgs{\n\t\t\tInput: \"# the GitLab Agent for Kubernetes configuration goes here ...\\n\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Optionally, configure the agent as described in\n\t\t// https://docs.gitlab.com/ee/user/clusters/agent/install/index.html#create-an-agent-configuration-file\n\t\t_, err = gitlab.NewRepositoryFile(ctx, \"example_agent_config\", \u0026gitlab.RepositoryFileArgs{\n\t\t\tProject: example.Project,\n\t\t\tBranch:  pulumi.String(\"main\"),\n\t\t\tFilePath: example.Name.ApplyT(func(name string) (string, error) {\n\t\t\t\treturn fmt.Sprintf(\".gitlab/agents/%v/config.yaml\", name), nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t\tContent:     pulumi.String(invokeBase64encode.Result),\n\t\t\tAuthorEmail: pulumi.String(\"terraform@example.com\"),\n\t\t\tAuthorName:  pulumi.String(\"Terraform\"),\n\t\t\tCommitMessage: example.Name.ApplyT(func(name string) (string, error) {\n\t\t\t\treturn fmt.Sprintf(\"feature: add agent config for %v [skip ci]\", name), nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ClusterAgent;\nimport com.pulumi.gitlab.ClusterAgentArgs;\nimport com.pulumi.gitlab.RepositoryFile;\nimport com.pulumi.gitlab.RepositoryFileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ClusterAgent(\"example\", ClusterAgentArgs.builder()\n            .project(\"12345\")\n            .name(\"agent-1\")\n            .build());\n\n        // Optionally, configure the agent as described in\n        // https://docs.gitlab.com/ee/user/clusters/agent/install/index.html#create-an-agent-configuration-file\n        var exampleAgentConfig = new RepositoryFile(\"exampleAgentConfig\", RepositoryFileArgs.builder()\n            .project(example.project())\n            .branch(\"main\")\n            .filePath(example.name().applyValue(name -\u003e String.format(\".gitlab/agents/%s/config.yaml\", name)))\n            .content(StdFunctions.base64encode(Base64encodeArgs.builder()\n                .input(\"\"\"\n# the GitLab Agent for Kubernetes configuration goes here ...\n                \"\"\")\n                .build()).result())\n            .authorEmail(\"terraform@example.com\")\n            .authorName(\"Terraform\")\n            .commitMessage(example.name().applyValue(name -\u003e String.format(\"feature: add agent config for %s [skip ci]\", name)))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: gitlab:ClusterAgent\n    properties:\n      project: '12345'\n      name: agent-1\n  # Optionally, configure the agent as described in\n  # // https://docs.gitlab.com/ee/user/clusters/agent/install/index.html#create-an-agent-configuration-file\n  exampleAgentConfig:\n    type: gitlab:RepositoryFile\n    name: example_agent_config\n    properties:\n      project: ${example.project}\n      branch: main\n      filePath: .gitlab/agents/${example.name}/config.yaml\n      content:\n        fn::invoke:\n          Function: std:base64encode\n          Arguments:\n            input: |\n              # the GitLab Agent for Kubernetes configuration goes here ...\n          Return: result\n      authorEmail: terraform@example.com\n      authorName: Terraform\n      commitMessage: 'feature: add agent config for ${example.name} [skip ci]'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_cluster_agent`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_cluster_agent.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab Agent for Kubernetes can be imported with the following command and the id pattern `\u003cproject\u003e:\u003cagent-id\u003e`\n\n```sh\n$ pulumi import gitlab:index/clusterAgent:ClusterAgent example '12345:42'\n```\n\n",
            "properties": {
                "agentId": {
                    "type": "integer",
                    "description": "The ID of the agent.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "The ISO8601 datetime when the agent was created.\n"
                },
                "createdByUserId": {
                    "type": "integer",
                    "description": "The ID of the user who created the agent.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The Name of the agent.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID or full path of the project maintained by the authenticated user.\n"
                }
            },
            "required": [
                "agentId",
                "createdAt",
                "createdByUserId",
                "name",
                "project"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "The Name of the agent.\n",
                    "willReplaceOnChanges": true
                },
                "project": {
                    "type": "string",
                    "description": "ID or full path of the project maintained by the authenticated user.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClusterAgent resources.\n",
                "properties": {
                    "agentId": {
                        "type": "integer",
                        "description": "The ID of the agent.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "The ISO8601 datetime when the agent was created.\n"
                    },
                    "createdByUserId": {
                        "type": "integer",
                        "description": "The ID of the user who created the agent.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The Name of the agent.\n",
                        "willReplaceOnChanges": true
                    },
                    "project": {
                        "type": "string",
                        "description": "ID or full path of the project maintained by the authenticated user.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/clusterAgentToken:ClusterAgentToken": {
            "description": "The `gitlab.ClusterAgentToken` resource allows to manage the lifecycle of a token for a GitLab Agent for Kubernetes.\n\n\u003e Requires at least maintainer permissions on the project.\n\n\u003e Requires at least GitLab 15.0\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/cluster_agents.html#create-an-agent-token)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\nimport * as helm from \"@pulumi/helm\";\n\n// Create token for an agent\nconst example = new gitlab.ClusterAgentToken(\"example\", {\n    project: \"12345\",\n    agentId: 42,\n    name: \"some-token\",\n    description: \"some token\",\n});\n// The following example creates a GitLab Agent for Kubernetes in a given project,\n// creates a token and install the `gitlab-agent` Helm Chart.\n// (see https://gitlab.com/gitlab-org/charts/gitlab-agent)\nconst this = gitlab.getProject({\n    pathWithNamespace: \"my-org/example\",\n});\nconst thisClusterAgent = new gitlab.ClusterAgent(\"this\", {\n    project: _this.then(_this =\u003e _this.id),\n    name: \"my-agent\",\n});\nconst thisClusterAgentToken = new gitlab.ClusterAgentToken(\"this\", {\n    project: _this.then(_this =\u003e _this.id),\n    agentId: thisClusterAgent.agentId,\n    name: \"my-agent-token\",\n    description: \"Token for the my-agent used with `gitlab-agent` Helm Chart\",\n});\nconst gitlabAgent = new helm.index.Release(\"gitlab_agent\", {\n    name: \"gitlab-agent\",\n    namespace: \"gitlab-agent\",\n    createNamespace: true,\n    repository: \"https://charts.gitlab.io\",\n    chart: \"gitlab-agent\",\n    version: \"1.2.0\",\n    set: [{\n        name: \"config.token\",\n        value: thisClusterAgentToken.token,\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\nimport pulumi_helm as helm\n\n# Create token for an agent\nexample = gitlab.ClusterAgentToken(\"example\",\n    project=\"12345\",\n    agent_id=42,\n    name=\"some-token\",\n    description=\"some token\")\n# The following example creates a GitLab Agent for Kubernetes in a given project,\n# creates a token and install the `gitlab-agent` Helm Chart.\n# (see https://gitlab.com/gitlab-org/charts/gitlab-agent)\nthis = gitlab.get_project(path_with_namespace=\"my-org/example\")\nthis_cluster_agent = gitlab.ClusterAgent(\"this\",\n    project=this.id,\n    name=\"my-agent\")\nthis_cluster_agent_token = gitlab.ClusterAgentToken(\"this\",\n    project=this.id,\n    agent_id=this_cluster_agent.agent_id,\n    name=\"my-agent-token\",\n    description=\"Token for the my-agent used with `gitlab-agent` Helm Chart\")\ngitlab_agent = helm.index.Release(\"gitlab_agent\",\n    name=gitlab-agent,\n    namespace=gitlab-agent,\n    create_namespace=True,\n    repository=https://charts.gitlab.io,\n    chart=gitlab-agent,\n    version=1.2.0,\n    set=[{\n        name: config.token,\n        value: this_cluster_agent_token.token,\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\nusing Helm = Pulumi.Helm;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create token for an agent\n    var example = new GitLab.ClusterAgentToken(\"example\", new()\n    {\n        Project = \"12345\",\n        AgentId = 42,\n        Name = \"some-token\",\n        Description = \"some token\",\n    });\n\n    // The following example creates a GitLab Agent for Kubernetes in a given project,\n    // creates a token and install the `gitlab-agent` Helm Chart.\n    // (see https://gitlab.com/gitlab-org/charts/gitlab-agent)\n    var @this = GitLab.GetProject.Invoke(new()\n    {\n        PathWithNamespace = \"my-org/example\",\n    });\n\n    var thisClusterAgent = new GitLab.ClusterAgent(\"this\", new()\n    {\n        Project = @this.Apply(@this =\u003e @this.Apply(getProjectResult =\u003e getProjectResult.Id)),\n        Name = \"my-agent\",\n    });\n\n    var thisClusterAgentToken = new GitLab.ClusterAgentToken(\"this\", new()\n    {\n        Project = @this.Apply(@this =\u003e @this.Apply(getProjectResult =\u003e getProjectResult.Id)),\n        AgentId = thisClusterAgent.AgentId,\n        Name = \"my-agent-token\",\n        Description = \"Token for the my-agent used with `gitlab-agent` Helm Chart\",\n    });\n\n    var gitlabAgent = new Helm.Index.Release(\"gitlab_agent\", new()\n    {\n        Name = \"gitlab-agent\",\n        Namespace = \"gitlab-agent\",\n        CreateNamespace = true,\n        Repository = \"https://charts.gitlab.io\",\n        Chart = \"gitlab-agent\",\n        Version = \"1.2.0\",\n        Set = new[]\n        {\n            \n            {\n                { \"name\", \"config.token\" },\n                { \"value\", thisClusterAgentToken.Token },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi-helm/sdk/go/helm\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Create token for an agent\n\t\t_, err := gitlab.NewClusterAgentToken(ctx, \"example\", \u0026gitlab.ClusterAgentTokenArgs{\n\t\t\tProject:     pulumi.String(\"12345\"),\n\t\t\tAgentId:     pulumi.Int(42),\n\t\t\tName:        pulumi.String(\"some-token\"),\n\t\t\tDescription: pulumi.String(\"some token\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// The following example creates a GitLab Agent for Kubernetes in a given project,\n\t\t// creates a token and install the `gitlab-agent` Helm Chart.\n\t\t// (see https://gitlab.com/gitlab-org/charts/gitlab-agent)\n\t\tthis, err := gitlab.LookupProject(ctx, \u0026gitlab.LookupProjectArgs{\n\t\t\tPathWithNamespace: pulumi.StringRef(\"my-org/example\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tthisClusterAgent, err := gitlab.NewClusterAgent(ctx, \"this\", \u0026gitlab.ClusterAgentArgs{\n\t\t\tProject: pulumi.String(this.Id),\n\t\t\tName:    pulumi.String(\"my-agent\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tthisClusterAgentToken, err := gitlab.NewClusterAgentToken(ctx, \"this\", \u0026gitlab.ClusterAgentTokenArgs{\n\t\t\tProject:     pulumi.String(this.Id),\n\t\t\tAgentId:     thisClusterAgent.AgentId,\n\t\t\tName:        pulumi.String(\"my-agent-token\"),\n\t\t\tDescription: pulumi.String(\"Token for the my-agent used with `gitlab-agent` Helm Chart\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = helm.NewRelease(ctx, \"gitlab_agent\", \u0026helm.ReleaseArgs{\n\t\t\tName:            \"gitlab-agent\",\n\t\t\tNamespace:       \"gitlab-agent\",\n\t\t\tCreateNamespace: true,\n\t\t\tRepository:      \"https://charts.gitlab.io\",\n\t\t\tChart:           \"gitlab-agent\",\n\t\t\tVersion:         \"1.2.0\",\n\t\t\tSet: []map[string]interface{}{\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"name\":  \"config.token\",\n\t\t\t\t\t\"value\": thisClusterAgentToken.Token,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ClusterAgentToken;\nimport com.pulumi.gitlab.ClusterAgentTokenArgs;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetProjectArgs;\nimport com.pulumi.gitlab.ClusterAgent;\nimport com.pulumi.gitlab.ClusterAgentArgs;\nimport com.pulumi.helm.release;\nimport com.pulumi.helm.ReleaseArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Create token for an agent\n        var example = new ClusterAgentToken(\"example\", ClusterAgentTokenArgs.builder()\n            .project(\"12345\")\n            .agentId(42)\n            .name(\"some-token\")\n            .description(\"some token\")\n            .build());\n\n        // The following example creates a GitLab Agent for Kubernetes in a given project,\n        // creates a token and install the `gitlab-agent` Helm Chart.\n        // (see https://gitlab.com/gitlab-org/charts/gitlab-agent)\n        final var this = GitlabFunctions.getProject(GetProjectArgs.builder()\n            .pathWithNamespace(\"my-org/example\")\n            .build());\n\n        var thisClusterAgent = new ClusterAgent(\"thisClusterAgent\", ClusterAgentArgs.builder()\n            .project(this_.id())\n            .name(\"my-agent\")\n            .build());\n\n        var thisClusterAgentToken = new ClusterAgentToken(\"thisClusterAgentToken\", ClusterAgentTokenArgs.builder()\n            .project(this_.id())\n            .agentId(thisClusterAgent.agentId())\n            .name(\"my-agent-token\")\n            .description(\"Token for the my-agent used with `gitlab-agent` Helm Chart\")\n            .build());\n\n        var gitlabAgent = new Release(\"gitlabAgent\", ReleaseArgs.builder()\n            .name(\"gitlab-agent\")\n            .namespace(\"gitlab-agent\")\n            .createNamespace(true)\n            .repository(\"https://charts.gitlab.io\")\n            .chart(\"gitlab-agent\")\n            .version(\"1.2.0\")\n            .set(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create token for an agent\n  example:\n    type: gitlab:ClusterAgentToken\n    properties:\n      project: '12345'\n      agentId: 42\n      name: some-token\n      description: some token\n  thisClusterAgent:\n    type: gitlab:ClusterAgent\n    name: this\n    properties:\n      project: ${this.id}\n      name: my-agent\n  thisClusterAgentToken:\n    type: gitlab:ClusterAgentToken\n    name: this\n    properties:\n      project: ${this.id}\n      agentId: ${thisClusterAgent.agentId}\n      name: my-agent-token\n      description: Token for the my-agent used with `gitlab-agent` Helm Chart\n  gitlabAgent:\n    type: helm:release\n    name: gitlab_agent\n    properties:\n      name: gitlab-agent\n      namespace: gitlab-agent\n      createNamespace: true\n      repository: https://charts.gitlab.io\n      chart: gitlab-agent\n      version: 1.2.0\n      set:\n        - name: config.token\n          value: ${thisClusterAgentToken.token}\nvariables:\n  # The following example creates a GitLab Agent for Kubernetes in a given project,\n  # // creates a token and install the `gitlab-agent` Helm Chart.\n  # // (see https://gitlab.com/gitlab-org/charts/gitlab-agent)\n  this:\n    fn::invoke:\n      Function: gitlab:getProject\n      Arguments:\n        pathWithNamespace: my-org/example\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_cluster_agent_token`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_cluster_agent_token.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nA token for a GitLab Agent for Kubernetes can be imported with the following command and the id pattern `\u003cproject\u003e:\u003cagent-id\u003e:\u003ctoken-id\u003e`:\n\n```sh\n$ pulumi import gitlab:index/clusterAgentToken:ClusterAgentToken example '12345:42:1'\n```\n\nATTENTION: the `token` resource attribute is not available for imported resources as this information cannot be read from the GitLab API.\n\n",
            "properties": {
                "agentId": {
                    "type": "integer",
                    "description": "The ID of the agent.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "The ISO8601 datetime when the agent was created.\n"
                },
                "createdByUserId": {
                    "type": "integer",
                    "description": "The ID of the user who created the agent.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The Description for the agent.\n"
                },
                "lastUsedAt": {
                    "type": "string",
                    "description": "The ISO8601 datetime when the token was last used.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The Name of the agent.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID or full path of the project maintained by the authenticated user.\n"
                },
                "status": {
                    "type": "string",
                    "description": "The status of the token. Valid values are `active`, `revoked`.\n"
                },
                "token": {
                    "type": "string",
                    "description": "The secret token for the agent. The `token` is not available in imported resources.\n",
                    "secret": true
                },
                "tokenId": {
                    "type": "integer",
                    "description": "The ID of the token.\n"
                }
            },
            "required": [
                "agentId",
                "createdAt",
                "createdByUserId",
                "lastUsedAt",
                "name",
                "project",
                "status",
                "token",
                "tokenId"
            ],
            "inputProperties": {
                "agentId": {
                    "type": "integer",
                    "description": "The ID of the agent.\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "The Description for the agent.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The Name of the agent.\n",
                    "willReplaceOnChanges": true
                },
                "project": {
                    "type": "string",
                    "description": "ID or full path of the project maintained by the authenticated user.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "agentId",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClusterAgentToken resources.\n",
                "properties": {
                    "agentId": {
                        "type": "integer",
                        "description": "The ID of the agent.\n",
                        "willReplaceOnChanges": true
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "The ISO8601 datetime when the agent was created.\n"
                    },
                    "createdByUserId": {
                        "type": "integer",
                        "description": "The ID of the user who created the agent.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The Description for the agent.\n",
                        "willReplaceOnChanges": true
                    },
                    "lastUsedAt": {
                        "type": "string",
                        "description": "The ISO8601 datetime when the token was last used.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The Name of the agent.\n",
                        "willReplaceOnChanges": true
                    },
                    "project": {
                        "type": "string",
                        "description": "ID or full path of the project maintained by the authenticated user.\n",
                        "willReplaceOnChanges": true
                    },
                    "status": {
                        "type": "string",
                        "description": "The status of the token. Valid values are `active`, `revoked`.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "The secret token for the agent. The `token` is not available in imported resources.\n",
                        "secret": true
                    },
                    "tokenId": {
                        "type": "integer",
                        "description": "The ID of the token.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/complianceFramework:ComplianceFramework": {
            "description": "The `gitlab.ComplianceFramework` resource allows to manage the lifecycle of a compliance framework on top-level groups.\n\nThere can be only one `default` compliance framework. Of all the configured compliance frameworks marked as default, the last one applied will be the default compliance framework.\n\n\u003e This resource requires a GitLab Enterprise instance with a Premium license to create the compliance framework.\n\n\u003e This resource requires a GitLab Enterprise instance with an Ultimate license to specify a compliance pipeline configuration in the compliance framework.\n\n**Upstream API**: [GitLab GraphQL API docs](https://docs.gitlab.com/ee/api/graphql/reference/#mutationcreatecomplianceframework)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst sample = new gitlab.ComplianceFramework(\"sample\", {\n    namespacePath: \"top-level-group\",\n    name: \"HIPAA\",\n    description: \"A HIPAA Compliance Framework\",\n    color: \"#87BEEF\",\n    \"default\": false,\n    pipelineConfigurationFullPath: \".hipaa.yml@top-level-group/compliance-frameworks\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nsample = gitlab.ComplianceFramework(\"sample\",\n    namespace_path=\"top-level-group\",\n    name=\"HIPAA\",\n    description=\"A HIPAA Compliance Framework\",\n    color=\"#87BEEF\",\n    default=False,\n    pipeline_configuration_full_path=\".hipaa.yml@top-level-group/compliance-frameworks\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var sample = new GitLab.ComplianceFramework(\"sample\", new()\n    {\n        NamespacePath = \"top-level-group\",\n        Name = \"HIPAA\",\n        Description = \"A HIPAA Compliance Framework\",\n        Color = \"#87BEEF\",\n        Default = false,\n        PipelineConfigurationFullPath = \".hipaa.yml@top-level-group/compliance-frameworks\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewComplianceFramework(ctx, \"sample\", \u0026gitlab.ComplianceFrameworkArgs{\n\t\t\tNamespacePath:                 pulumi.String(\"top-level-group\"),\n\t\t\tName:                          pulumi.String(\"HIPAA\"),\n\t\t\tDescription:                   pulumi.String(\"A HIPAA Compliance Framework\"),\n\t\t\tColor:                         pulumi.String(\"#87BEEF\"),\n\t\t\tDefault:                       pulumi.Bool(false),\n\t\t\tPipelineConfigurationFullPath: pulumi.String(\".hipaa.yml@top-level-group/compliance-frameworks\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ComplianceFramework;\nimport com.pulumi.gitlab.ComplianceFrameworkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var sample = new ComplianceFramework(\"sample\", ComplianceFrameworkArgs.builder()\n            .namespacePath(\"top-level-group\")\n            .name(\"HIPAA\")\n            .description(\"A HIPAA Compliance Framework\")\n            .color(\"#87BEEF\")\n            .default_(false)\n            .pipelineConfigurationFullPath(\".hipaa.yml@top-level-group/compliance-frameworks\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  sample:\n    type: gitlab:ComplianceFramework\n    properties:\n      namespacePath: top-level-group\n      name: HIPAA\n      description: A HIPAA Compliance Framework\n      color: '#87BEEF'\n      default: false\n      pipelineConfigurationFullPath: .hipaa.yml@top-level-group/compliance-frameworks\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_compliance_framework`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_compliance_framework.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitlab compliance frameworks can be imported with a key composed of `\u003cnamespace_path\u003e:\u003cframework_id\u003e`, e.g.\n\n```sh\n$ pulumi import gitlab:index/complianceFramework:ComplianceFramework sample \"top-level-group:gid://gitlab/ComplianceManagement::Framework/12345\"\n```\n\n",
            "properties": {
                "color": {
                    "type": "string",
                    "description": "New color representation of the compliance framework in hex format. e.g. #FCA121.\n"
                },
                "default": {
                    "type": "boolean",
                    "description": "Set this compliance framework as the default framework for the group. Default: `false`\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description for the compliance framework.\n"
                },
                "frameworkId": {
                    "type": "string",
                    "description": "Globally unique ID of the compliance framework.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name for the compliance framework.\n"
                },
                "namespacePath": {
                    "type": "string",
                    "description": "Full path of the namespace to add the compliance framework to.\n"
                },
                "pipelineConfigurationFullPath": {
                    "type": "string",
                    "description": "Full path of the compliance pipeline configuration stored in a project repository, such as `.gitlab/.compliance-gitlab-ci.yml@compliance/hipaa`. Required format: `path/file.y[a]ml@group-name/project-name` **Note**: Ultimate license required.\n"
                }
            },
            "required": [
                "color",
                "default",
                "description",
                "frameworkId",
                "name",
                "namespacePath"
            ],
            "inputProperties": {
                "color": {
                    "type": "string",
                    "description": "New color representation of the compliance framework in hex format. e.g. #FCA121.\n"
                },
                "default": {
                    "type": "boolean",
                    "description": "Set this compliance framework as the default framework for the group. Default: `false`\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description for the compliance framework.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name for the compliance framework.\n"
                },
                "namespacePath": {
                    "type": "string",
                    "description": "Full path of the namespace to add the compliance framework to.\n"
                },
                "pipelineConfigurationFullPath": {
                    "type": "string",
                    "description": "Full path of the compliance pipeline configuration stored in a project repository, such as `.gitlab/.compliance-gitlab-ci.yml@compliance/hipaa`. Required format: `path/file.y[a]ml@group-name/project-name` **Note**: Ultimate license required.\n"
                }
            },
            "requiredInputs": [
                "color",
                "description",
                "namespacePath"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComplianceFramework resources.\n",
                "properties": {
                    "color": {
                        "type": "string",
                        "description": "New color representation of the compliance framework in hex format. e.g. #FCA121.\n"
                    },
                    "default": {
                        "type": "boolean",
                        "description": "Set this compliance framework as the default framework for the group. Default: `false`\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description for the compliance framework.\n"
                    },
                    "frameworkId": {
                        "type": "string",
                        "description": "Globally unique ID of the compliance framework.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name for the compliance framework.\n"
                    },
                    "namespacePath": {
                        "type": "string",
                        "description": "Full path of the namespace to add the compliance framework to.\n"
                    },
                    "pipelineConfigurationFullPath": {
                        "type": "string",
                        "description": "Full path of the compliance pipeline configuration stored in a project repository, such as `.gitlab/.compliance-gitlab-ci.yml@compliance/hipaa`. Required format: `path/file.y[a]ml@group-name/project-name` **Note**: Ultimate license required.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/deployKey:DeployKey": {
            "description": "The `gitlab.DeployKey` resource allows to manage the lifecycle of a deploy key.\n\n\u003e To enable an already existing deploy key for another project use the `gitlab.DeployKeyEnable` resource.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/deploy_keys.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = new gitlab.DeployKey(\"example\", {\n    project: \"example/deploying\",\n    title: \"Example deploy key\",\n    key: \"ssh-ed25519 AAAA...\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.DeployKey(\"example\",\n    project=\"example/deploying\",\n    title=\"Example deploy key\",\n    key=\"ssh-ed25519 AAAA...\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new GitLab.DeployKey(\"example\", new()\n    {\n        Project = \"example/deploying\",\n        Title = \"Example deploy key\",\n        Key = \"ssh-ed25519 AAAA...\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewDeployKey(ctx, \"example\", \u0026gitlab.DeployKeyArgs{\n\t\t\tProject: pulumi.String(\"example/deploying\"),\n\t\t\tTitle:   pulumi.String(\"Example deploy key\"),\n\t\t\tKey:     pulumi.String(\"ssh-ed25519 AAAA...\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.DeployKey;\nimport com.pulumi.gitlab.DeployKeyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new DeployKey(\"example\", DeployKeyArgs.builder()\n            .project(\"example/deploying\")\n            .title(\"Example deploy key\")\n            .key(\"ssh-ed25519 AAAA...\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: gitlab:DeployKey\n    properties:\n      project: example/deploying\n      title: Example deploy key\n      key: ssh-ed25519 AAAA...\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_deploy_key`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_deploy_key.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab deploy keys can be imported using an id made up of `{project_id}:{deploy_key_id}`, e.g.\n\n`project_id` can be whatever the [get single project api][get_single_project] takes for\n\nits `:id` value, so for example:\n\n```sh\n$ pulumi import gitlab:index/deployKey:DeployKey test 1:3\n```\n\n```sh\n$ pulumi import gitlab:index/deployKey:DeployKey test richardc/example:3\n```\n\n",
            "properties": {
                "canPush": {
                    "type": "boolean",
                    "description": "Allow this deploy key to be used to push changes to the project. Defaults to `false`.\n"
                },
                "deployKeyId": {
                    "type": "integer",
                    "description": "The id of the project deploy key.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The public ssh key body.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the deploy key to.\n"
                },
                "title": {
                    "type": "string",
                    "description": "A title to describe the deploy key with.\n"
                }
            },
            "required": [
                "deployKeyId",
                "key",
                "project",
                "title"
            ],
            "inputProperties": {
                "canPush": {
                    "type": "boolean",
                    "description": "Allow this deploy key to be used to push changes to the project. Defaults to `false`.\n",
                    "willReplaceOnChanges": true
                },
                "key": {
                    "type": "string",
                    "description": "The public ssh key body.\n",
                    "willReplaceOnChanges": true
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the deploy key to.\n",
                    "willReplaceOnChanges": true
                },
                "title": {
                    "type": "string",
                    "description": "A title to describe the deploy key with.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "key",
                "project",
                "title"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DeployKey resources.\n",
                "properties": {
                    "canPush": {
                        "type": "boolean",
                        "description": "Allow this deploy key to be used to push changes to the project. Defaults to `false`.\n",
                        "willReplaceOnChanges": true
                    },
                    "deployKeyId": {
                        "type": "integer",
                        "description": "The id of the project deploy key.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "The public ssh key body.\n",
                        "willReplaceOnChanges": true
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project to add the deploy key to.\n",
                        "willReplaceOnChanges": true
                    },
                    "title": {
                        "type": "string",
                        "description": "A title to describe the deploy key with.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/deployKeyEnable:DeployKeyEnable": {
            "description": "The `gitlab.DeployKeyEnable` resource allows to enable an already existing deploy key (see `gitlab.DeployKey resource`) for a specific project.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/deploy_keys.html#enable-a-deploy-key)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\n// A repo to host the deployment key\nconst parent = new gitlab.Project(\"parent\", {name: \"parent_project\"});\n// A second repo to use the deployment key from the parent project\nconst foo = new gitlab.Project(\"foo\", {name: \"foo_project\"});\n// Upload a deployment key for the parent repo\nconst parentDeployKey = new gitlab.DeployKey(\"parent\", {\n    project: parent.id,\n    title: \"Example deploy key\",\n    key: \"ssh-ed25519 AAAA...\",\n});\n// Enable the deployment key on the second repo\nconst fooDeployKeyEnable = new gitlab.DeployKeyEnable(\"foo\", {\n    project: foo.id,\n    keyId: parentDeployKey.deployKeyId,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\n# A repo to host the deployment key\nparent = gitlab.Project(\"parent\", name=\"parent_project\")\n# A second repo to use the deployment key from the parent project\nfoo = gitlab.Project(\"foo\", name=\"foo_project\")\n# Upload a deployment key for the parent repo\nparent_deploy_key = gitlab.DeployKey(\"parent\",\n    project=parent.id,\n    title=\"Example deploy key\",\n    key=\"ssh-ed25519 AAAA...\")\n# Enable the deployment key on the second repo\nfoo_deploy_key_enable = gitlab.DeployKeyEnable(\"foo\",\n    project=foo.id,\n    key_id=parent_deploy_key.deploy_key_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // A repo to host the deployment key\n    var parent = new GitLab.Project(\"parent\", new()\n    {\n        Name = \"parent_project\",\n    });\n\n    // A second repo to use the deployment key from the parent project\n    var foo = new GitLab.Project(\"foo\", new()\n    {\n        Name = \"foo_project\",\n    });\n\n    // Upload a deployment key for the parent repo\n    var parentDeployKey = new GitLab.DeployKey(\"parent\", new()\n    {\n        Project = parent.Id,\n        Title = \"Example deploy key\",\n        Key = \"ssh-ed25519 AAAA...\",\n    });\n\n    // Enable the deployment key on the second repo\n    var fooDeployKeyEnable = new GitLab.DeployKeyEnable(\"foo\", new()\n    {\n        Project = foo.Id,\n        KeyId = parentDeployKey.DeployKeyId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// A repo to host the deployment key\n\t\tparent, err := gitlab.NewProject(ctx, \"parent\", \u0026gitlab.ProjectArgs{\n\t\t\tName: pulumi.String(\"parent_project\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// A second repo to use the deployment key from the parent project\n\t\tfoo, err := gitlab.NewProject(ctx, \"foo\", \u0026gitlab.ProjectArgs{\n\t\t\tName: pulumi.String(\"foo_project\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Upload a deployment key for the parent repo\n\t\tparentDeployKey, err := gitlab.NewDeployKey(ctx, \"parent\", \u0026gitlab.DeployKeyArgs{\n\t\t\tProject: parent.ID(),\n\t\t\tTitle:   pulumi.String(\"Example deploy key\"),\n\t\t\tKey:     pulumi.String(\"ssh-ed25519 AAAA...\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Enable the deployment key on the second repo\n\t\t_, err = gitlab.NewDeployKeyEnable(ctx, \"foo\", \u0026gitlab.DeployKeyEnableArgs{\n\t\t\tProject: foo.ID(),\n\t\t\tKeyId:   parentDeployKey.DeployKeyId,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.DeployKey;\nimport com.pulumi.gitlab.DeployKeyArgs;\nimport com.pulumi.gitlab.DeployKeyEnable;\nimport com.pulumi.gitlab.DeployKeyEnableArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // A repo to host the deployment key\n        var parent = new Project(\"parent\", ProjectArgs.builder()\n            .name(\"parent_project\")\n            .build());\n\n        // A second repo to use the deployment key from the parent project\n        var foo = new Project(\"foo\", ProjectArgs.builder()\n            .name(\"foo_project\")\n            .build());\n\n        // Upload a deployment key for the parent repo\n        var parentDeployKey = new DeployKey(\"parentDeployKey\", DeployKeyArgs.builder()\n            .project(parent.id())\n            .title(\"Example deploy key\")\n            .key(\"ssh-ed25519 AAAA...\")\n            .build());\n\n        // Enable the deployment key on the second repo\n        var fooDeployKeyEnable = new DeployKeyEnable(\"fooDeployKeyEnable\", DeployKeyEnableArgs.builder()\n            .project(foo.id())\n            .keyId(parentDeployKey.deployKeyId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # A repo to host the deployment key\n  parent:\n    type: gitlab:Project\n    properties:\n      name: parent_project\n  # A second repo to use the deployment key from the parent project\n  foo:\n    type: gitlab:Project\n    properties:\n      name: foo_project\n  # Upload a deployment key for the parent repo\n  parentDeployKey:\n    type: gitlab:DeployKey\n    name: parent\n    properties:\n      project: ${parent.id}\n      title: Example deploy key\n      key: ssh-ed25519 AAAA...\n  # Enable the deployment key on the second repo\n  fooDeployKeyEnable:\n    type: gitlab:DeployKeyEnable\n    name: foo\n    properties:\n      project: ${foo.id}\n      keyId: ${parentDeployKey.deployKeyId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_deploy_key_enable`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_deploy_key_enable.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab enabled deploy keys can be imported using an id made up of `{project_id}:{deploy_key_id}`, e.g.\n\n`project_id` can be whatever the [get single project api][get_single_project] takes for\n\nits `:id` value, so for example:\n\n```sh\n$ pulumi import gitlab:index/deployKeyEnable:DeployKeyEnable example 12345:67890\n```\n\n```sh\n$ pulumi import gitlab:index/deployKeyEnable:DeployKeyEnable example richardc/example:67890\n```\n\n",
            "properties": {
                "canPush": {
                    "type": "boolean",
                    "description": "Can deploy key push to the project's repository.\n"
                },
                "key": {
                    "type": "string",
                    "description": "Deploy key.\n"
                },
                "keyId": {
                    "type": "string",
                    "description": "The Gitlab key id for the pre-existing deploy key\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the deploy key to.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Deploy key's title.\n"
                }
            },
            "required": [
                "key",
                "keyId",
                "project",
                "title"
            ],
            "inputProperties": {
                "canPush": {
                    "type": "boolean",
                    "description": "Can deploy key push to the project's repository.\n",
                    "willReplaceOnChanges": true
                },
                "key": {
                    "type": "string",
                    "description": "Deploy key.\n"
                },
                "keyId": {
                    "type": "string",
                    "description": "The Gitlab key id for the pre-existing deploy key\n",
                    "willReplaceOnChanges": true
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the deploy key to.\n",
                    "willReplaceOnChanges": true
                },
                "title": {
                    "type": "string",
                    "description": "Deploy key's title.\n"
                }
            },
            "requiredInputs": [
                "keyId",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DeployKeyEnable resources.\n",
                "properties": {
                    "canPush": {
                        "type": "boolean",
                        "description": "Can deploy key push to the project's repository.\n",
                        "willReplaceOnChanges": true
                    },
                    "key": {
                        "type": "string",
                        "description": "Deploy key.\n"
                    },
                    "keyId": {
                        "type": "string",
                        "description": "The Gitlab key id for the pre-existing deploy key\n",
                        "willReplaceOnChanges": true
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project to add the deploy key to.\n",
                        "willReplaceOnChanges": true
                    },
                    "title": {
                        "type": "string",
                        "description": "Deploy key's title.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/deployToken:DeployToken": {
            "description": "The `gitlab.DeployToken` resource allows to manage the lifecycle of group and project deploy tokens.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/deploy_tokens.html)\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_deploy_token`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_deploy_token.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab deploy tokens can be imported using an id made up of `{type}:{type_id}:{deploy_token_id}`, where type is one of: project, group.\n\n```sh\n$ pulumi import gitlab:index/deployToken:DeployToken group_token group:1:3\n```\n\n```sh\n$ pulumi import gitlab:index/deployToken:DeployToken project_token project:1:4\n```\n\nNote: the `token` resource attribute is not available for imported resources as this information cannot be read from the GitLab API.\n\n",
            "properties": {
                "deployTokenId": {
                    "type": "integer",
                    "description": "The id of the deploy token.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "Time the token will expire it, RFC3339 format. Will not expire per default.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The name or id of the group to add the deploy token to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A name to describe the deploy token with.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the deploy token to.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Valid values: `read_repository`, `read_registry`, `read_package_registry`, `write_registry`, `write_package_registry`.\n"
                },
                "token": {
                    "type": "string",
                    "description": "The secret token. This is only populated when creating a new deploy token. **Note**: The token is not available for imported resources.\n",
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "A username for the deploy token. Default is `gitlab+deploy-token-{n}`.\n"
                }
            },
            "required": [
                "deployTokenId",
                "name",
                "scopes",
                "token",
                "username"
            ],
            "inputProperties": {
                "expiresAt": {
                    "type": "string",
                    "description": "Time the token will expire it, RFC3339 format. Will not expire per default.\n",
                    "willReplaceOnChanges": true
                },
                "group": {
                    "type": "string",
                    "description": "The name or id of the group to add the deploy token to.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "A name to describe the deploy token with.\n",
                    "willReplaceOnChanges": true
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the deploy token to.\n",
                    "willReplaceOnChanges": true
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Valid values: `read_repository`, `read_registry`, `read_package_registry`, `write_registry`, `write_package_registry`.\n",
                    "willReplaceOnChanges": true
                },
                "username": {
                    "type": "string",
                    "description": "A username for the deploy token. Default is `gitlab+deploy-token-{n}`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "scopes"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DeployToken resources.\n",
                "properties": {
                    "deployTokenId": {
                        "type": "integer",
                        "description": "The id of the deploy token.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "Time the token will expire it, RFC3339 format. Will not expire per default.\n",
                        "willReplaceOnChanges": true
                    },
                    "group": {
                        "type": "string",
                        "description": "The name or id of the group to add the deploy token to.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "A name to describe the deploy token with.\n",
                        "willReplaceOnChanges": true
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project to add the deploy token to.\n",
                        "willReplaceOnChanges": true
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Valid values: `read_repository`, `read_registry`, `read_package_registry`, `write_registry`, `write_package_registry`.\n",
                        "willReplaceOnChanges": true
                    },
                    "token": {
                        "type": "string",
                        "description": "The secret token. This is only populated when creating a new deploy token. **Note**: The token is not available for imported resources.\n",
                        "secret": true
                    },
                    "username": {
                        "type": "string",
                        "description": "A username for the deploy token. Default is `gitlab+deploy-token-{n}`.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/globalLevelNotifications:GlobalLevelNotifications": {
            "description": "The `gitlab.GlobalLevelNotifications` resource allows to manage global notifications.\n\t\t\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/notification_settings.html#group--project-level-notification-settings)\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_global_level_notifications`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_global_level_notifications.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nNote: You can import a global notification state using \"gitlab\" as the ID.\n\nThe ID will always be gitlab, because the global notificatio only exists\n\nonce per user\n\n```sh\n$ pulumi import gitlab:index/globalLevelNotifications:GlobalLevelNotifications example gitlab\n```\n\n",
            "properties": {
                "closeIssue": {
                    "type": "boolean",
                    "description": "Enable notifications for closed issues. Can only be used when `level` is `custom`.\n"
                },
                "closeMergeRequest": {
                    "type": "boolean",
                    "description": "Enable notifications for closed merge requests. Can only be used when `level` is `custom`.\n"
                },
                "failedPipeline": {
                    "type": "boolean",
                    "description": "Enable notifications for failed pipelines. Can only be used when `level` is `custom`.\n"
                },
                "fixedPipeline": {
                    "type": "boolean",
                    "description": "Enable notifications for fixed pipelines. Can only be used when `level` is `custom`.\n"
                },
                "issueDue": {
                    "type": "boolean",
                    "description": "Enable notifications for due issues. Can only be used when `level` is `custom`.\n"
                },
                "level": {
                    "type": "string",
                    "description": "The level of the notification. Valid values are: `disabled`, `participating`, `watch`, `global`, `mention`, `custom`.\n"
                },
                "mergeMergeRequest": {
                    "type": "boolean",
                    "description": "Enable notifications for merged merge requests. Can only be used when `level` is `custom`.\n"
                },
                "mergeWhenPipelineSucceeds": {
                    "type": "boolean",
                    "description": "Enable notifications for merged merge requests when the pipeline succeeds. Can only be used when `level` is `custom`.\n"
                },
                "movedProject": {
                    "type": "boolean",
                    "description": "Enable notifications for moved projects. Can only be used when `level` is `custom`.\n"
                },
                "newIssue": {
                    "type": "boolean",
                    "description": "Enable notifications for new issues. Can only be used when `level` is `custom`.\n"
                },
                "newMergeRequest": {
                    "type": "boolean",
                    "description": "Enable notifications for new merge requests. Can only be used when `level` is `custom`.\n"
                },
                "newNote": {
                    "type": "boolean",
                    "description": "Enable notifications for new notes on merge requests. Can only be used when `level` is `custom`.\n"
                },
                "pushToMergeRequest": {
                    "type": "boolean",
                    "description": "Enable notifications for push to merge request branches. Can only be used when `level` is `custom`.\n"
                },
                "reassignIssue": {
                    "type": "boolean",
                    "description": "Enable notifications for issue reassignments. Can only be used when `level` is `custom`.\n"
                },
                "reassignMergeRequest": {
                    "type": "boolean",
                    "description": "Enable notifications for merge request reassignments. Can only be used when `level` is `custom`.\n"
                },
                "reopenIssue": {
                    "type": "boolean",
                    "description": "Enable notifications for reopened issues. Can only be used when `level` is `custom`.\n"
                },
                "reopenMergeRequest": {
                    "type": "boolean",
                    "description": "Enable notifications for reopened merge requests. Can only be used when `level` is `custom`.\n"
                },
                "successPipeline": {
                    "type": "boolean",
                    "description": "Enable notifications for successful pipelines. Can only be used when `level` is `custom`.\n"
                }
            },
            "required": [
                "closeIssue",
                "closeMergeRequest",
                "failedPipeline",
                "fixedPipeline",
                "issueDue",
                "level",
                "mergeMergeRequest",
                "mergeWhenPipelineSucceeds",
                "movedProject",
                "newIssue",
                "newMergeRequest",
                "newNote",
                "pushToMergeRequest",
                "reassignIssue",
                "reassignMergeRequest",
                "reopenIssue",
                "reopenMergeRequest",
                "successPipeline"
            ],
            "inputProperties": {
                "closeIssue": {
                    "type": "boolean",
                    "description": "Enable notifications for closed issues. Can only be used when `level` is `custom`.\n"
                },
                "closeMergeRequest": {
                    "type": "boolean",
                    "description": "Enable notifications for closed merge requests. Can only be used when `level` is `custom`.\n"
                },
                "failedPipeline": {
                    "type": "boolean",
                    "description": "Enable notifications for failed pipelines. Can only be used when `level` is `custom`.\n"
                },
                "fixedPipeline": {
                    "type": "boolean",
                    "description": "Enable notifications for fixed pipelines. Can only be used when `level` is `custom`.\n"
                },
                "issueDue": {
                    "type": "boolean",
                    "description": "Enable notifications for due issues. Can only be used when `level` is `custom`.\n"
                },
                "level": {
                    "type": "string",
                    "description": "The level of the notification. Valid values are: `disabled`, `participating`, `watch`, `global`, `mention`, `custom`.\n"
                },
                "mergeMergeRequest": {
                    "type": "boolean",
                    "description": "Enable notifications for merged merge requests. Can only be used when `level` is `custom`.\n"
                },
                "mergeWhenPipelineSucceeds": {
                    "type": "boolean",
                    "description": "Enable notifications for merged merge requests when the pipeline succeeds. Can only be used when `level` is `custom`.\n"
                },
                "movedProject": {
                    "type": "boolean",
                    "description": "Enable notifications for moved projects. Can only be used when `level` is `custom`.\n"
                },
                "newIssue": {
                    "type": "boolean",
                    "description": "Enable notifications for new issues. Can only be used when `level` is `custom`.\n"
                },
                "newMergeRequest": {
                    "type": "boolean",
                    "description": "Enable notifications for new merge requests. Can only be used when `level` is `custom`.\n"
                },
                "newNote": {
                    "type": "boolean",
                    "description": "Enable notifications for new notes on merge requests. Can only be used when `level` is `custom`.\n"
                },
                "pushToMergeRequest": {
                    "type": "boolean",
                    "description": "Enable notifications for push to merge request branches. Can only be used when `level` is `custom`.\n"
                },
                "reassignIssue": {
                    "type": "boolean",
                    "description": "Enable notifications for issue reassignments. Can only be used when `level` is `custom`.\n"
                },
                "reassignMergeRequest": {
                    "type": "boolean",
                    "description": "Enable notifications for merge request reassignments. Can only be used when `level` is `custom`.\n"
                },
                "reopenIssue": {
                    "type": "boolean",
                    "description": "Enable notifications for reopened issues. Can only be used when `level` is `custom`.\n"
                },
                "reopenMergeRequest": {
                    "type": "boolean",
                    "description": "Enable notifications for reopened merge requests. Can only be used when `level` is `custom`.\n"
                },
                "successPipeline": {
                    "type": "boolean",
                    "description": "Enable notifications for successful pipelines. Can only be used when `level` is `custom`.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GlobalLevelNotifications resources.\n",
                "properties": {
                    "closeIssue": {
                        "type": "boolean",
                        "description": "Enable notifications for closed issues. Can only be used when `level` is `custom`.\n"
                    },
                    "closeMergeRequest": {
                        "type": "boolean",
                        "description": "Enable notifications for closed merge requests. Can only be used when `level` is `custom`.\n"
                    },
                    "failedPipeline": {
                        "type": "boolean",
                        "description": "Enable notifications for failed pipelines. Can only be used when `level` is `custom`.\n"
                    },
                    "fixedPipeline": {
                        "type": "boolean",
                        "description": "Enable notifications for fixed pipelines. Can only be used when `level` is `custom`.\n"
                    },
                    "issueDue": {
                        "type": "boolean",
                        "description": "Enable notifications for due issues. Can only be used when `level` is `custom`.\n"
                    },
                    "level": {
                        "type": "string",
                        "description": "The level of the notification. Valid values are: `disabled`, `participating`, `watch`, `global`, `mention`, `custom`.\n"
                    },
                    "mergeMergeRequest": {
                        "type": "boolean",
                        "description": "Enable notifications for merged merge requests. Can only be used when `level` is `custom`.\n"
                    },
                    "mergeWhenPipelineSucceeds": {
                        "type": "boolean",
                        "description": "Enable notifications for merged merge requests when the pipeline succeeds. Can only be used when `level` is `custom`.\n"
                    },
                    "movedProject": {
                        "type": "boolean",
                        "description": "Enable notifications for moved projects. Can only be used when `level` is `custom`.\n"
                    },
                    "newIssue": {
                        "type": "boolean",
                        "description": "Enable notifications for new issues. Can only be used when `level` is `custom`.\n"
                    },
                    "newMergeRequest": {
                        "type": "boolean",
                        "description": "Enable notifications for new merge requests. Can only be used when `level` is `custom`.\n"
                    },
                    "newNote": {
                        "type": "boolean",
                        "description": "Enable notifications for new notes on merge requests. Can only be used when `level` is `custom`.\n"
                    },
                    "pushToMergeRequest": {
                        "type": "boolean",
                        "description": "Enable notifications for push to merge request branches. Can only be used when `level` is `custom`.\n"
                    },
                    "reassignIssue": {
                        "type": "boolean",
                        "description": "Enable notifications for issue reassignments. Can only be used when `level` is `custom`.\n"
                    },
                    "reassignMergeRequest": {
                        "type": "boolean",
                        "description": "Enable notifications for merge request reassignments. Can only be used when `level` is `custom`.\n"
                    },
                    "reopenIssue": {
                        "type": "boolean",
                        "description": "Enable notifications for reopened issues. Can only be used when `level` is `custom`.\n"
                    },
                    "reopenMergeRequest": {
                        "type": "boolean",
                        "description": "Enable notifications for reopened merge requests. Can only be used when `level` is `custom`.\n"
                    },
                    "successPipeline": {
                        "type": "boolean",
                        "description": "Enable notifications for successful pipelines. Can only be used when `level` is `custom`.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/group:Group": {
            "description": "The `gitlab.Group` resource allows to manage the lifecycle of a group.\n\n\u003e On GitLab SaaS, you must use the GitLab UI to create groups without a parent group. You cannot use this provider nor the API to do this.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/groups.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = new gitlab.Group(\"example\", {\n    name: \"example\",\n    path: \"example\",\n    description: \"An example group\",\n});\n// Create a project in the example group\nconst exampleProject = new gitlab.Project(\"example\", {\n    name: \"example\",\n    description: \"An example project\",\n    namespaceId: example.id,\n});\n// Group with custom push rules\nconst example_two = new gitlab.Group(\"example-two\", {\n    name: \"example-two\",\n    path: \"example-two\",\n    description: \"An example group with push rules\",\n    pushRules: {\n        authorEmailRegex: \"@example\\\\.com$\",\n        commitCommitterCheck: true,\n        memberCheck: true,\n        preventSecrets: true,\n    },\n});\n// Group with custom default branch protection defaults\nconst example_three = new gitlab.Group(\"example-three\", {\n    name: \"example-three\",\n    path: \"example-three\",\n    description: \"An example group with default branch protection defaults\",\n    defaultBranchProtectionDefaults: {\n        allowedToPushes: [\"developer\"],\n        allowForcePush: true,\n        allowedToMerges: [\n            \"developer\",\n            \"maintainer\",\n        ],\n        developerCanInitialPush: true,\n    },\n});\n// Group with custom default branch protection defaults\nconst example_four = new gitlab.Group(\"example-four\", {\n    name: \"example-four\",\n    path: \"example-four\",\n    description: \"An example group with default branch protection defaults\",\n    defaultBranchProtectionDefaults: {\n        allowedToPushes: [\"no one\"],\n        allowForcePush: true,\n        allowedToMerges: [\"no one\"],\n        developerCanInitialPush: true,\n    },\n});\n// Group with a default branch name specified\nconst example_five = new gitlab.Group(\"example-five\", {\n    name: \"example\",\n    path: \"example\",\n    defaultBranch: \"develop\",\n    description: \"An example group with a default branch name\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.Group(\"example\",\n    name=\"example\",\n    path=\"example\",\n    description=\"An example group\")\n# Create a project in the example group\nexample_project = gitlab.Project(\"example\",\n    name=\"example\",\n    description=\"An example project\",\n    namespace_id=example.id)\n# Group with custom push rules\nexample_two = gitlab.Group(\"example-two\",\n    name=\"example-two\",\n    path=\"example-two\",\n    description=\"An example group with push rules\",\n    push_rules={\n        \"author_email_regex\": \"@example\\\\.com$\",\n        \"commit_committer_check\": True,\n        \"member_check\": True,\n        \"prevent_secrets\": True,\n    })\n# Group with custom default branch protection defaults\nexample_three = gitlab.Group(\"example-three\",\n    name=\"example-three\",\n    path=\"example-three\",\n    description=\"An example group with default branch protection defaults\",\n    default_branch_protection_defaults={\n        \"allowed_to_pushes\": [\"developer\"],\n        \"allow_force_push\": True,\n        \"allowed_to_merges\": [\n            \"developer\",\n            \"maintainer\",\n        ],\n        \"developer_can_initial_push\": True,\n    })\n# Group with custom default branch protection defaults\nexample_four = gitlab.Group(\"example-four\",\n    name=\"example-four\",\n    path=\"example-four\",\n    description=\"An example group with default branch protection defaults\",\n    default_branch_protection_defaults={\n        \"allowed_to_pushes\": [\"no one\"],\n        \"allow_force_push\": True,\n        \"allowed_to_merges\": [\"no one\"],\n        \"developer_can_initial_push\": True,\n    })\n# Group with a default branch name specified\nexample_five = gitlab.Group(\"example-five\",\n    name=\"example\",\n    path=\"example\",\n    default_branch=\"develop\",\n    description=\"An example group with a default branch name\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new GitLab.Group(\"example\", new()\n    {\n        Name = \"example\",\n        Path = \"example\",\n        Description = \"An example group\",\n    });\n\n    // Create a project in the example group\n    var exampleProject = new GitLab.Project(\"example\", new()\n    {\n        Name = \"example\",\n        Description = \"An example project\",\n        NamespaceId = example.Id,\n    });\n\n    // Group with custom push rules\n    var example_two = new GitLab.Group(\"example-two\", new()\n    {\n        Name = \"example-two\",\n        Path = \"example-two\",\n        Description = \"An example group with push rules\",\n        PushRules = new GitLab.Inputs.GroupPushRulesArgs\n        {\n            AuthorEmailRegex = \"@example\\\\.com$\",\n            CommitCommitterCheck = true,\n            MemberCheck = true,\n            PreventSecrets = true,\n        },\n    });\n\n    // Group with custom default branch protection defaults\n    var example_three = new GitLab.Group(\"example-three\", new()\n    {\n        Name = \"example-three\",\n        Path = \"example-three\",\n        Description = \"An example group with default branch protection defaults\",\n        DefaultBranchProtectionDefaults = new GitLab.Inputs.GroupDefaultBranchProtectionDefaultsArgs\n        {\n            AllowedToPushes = new[]\n            {\n                \"developer\",\n            },\n            AllowForcePush = true,\n            AllowedToMerges = new[]\n            {\n                \"developer\",\n                \"maintainer\",\n            },\n            DeveloperCanInitialPush = true,\n        },\n    });\n\n    // Group with custom default branch protection defaults\n    var example_four = new GitLab.Group(\"example-four\", new()\n    {\n        Name = \"example-four\",\n        Path = \"example-four\",\n        Description = \"An example group with default branch protection defaults\",\n        DefaultBranchProtectionDefaults = new GitLab.Inputs.GroupDefaultBranchProtectionDefaultsArgs\n        {\n            AllowedToPushes = new[]\n            {\n                \"no one\",\n            },\n            AllowForcePush = true,\n            AllowedToMerges = new[]\n            {\n                \"no one\",\n            },\n            DeveloperCanInitialPush = true,\n        },\n    });\n\n    // Group with a default branch name specified\n    var example_five = new GitLab.Group(\"example-five\", new()\n    {\n        Name = \"example\",\n        Path = \"example\",\n        DefaultBranch = \"develop\",\n        Description = \"An example group with a default branch name\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := gitlab.NewGroup(ctx, \"example\", \u0026gitlab.GroupArgs{\n\t\t\tName:        pulumi.String(\"example\"),\n\t\t\tPath:        pulumi.String(\"example\"),\n\t\t\tDescription: pulumi.String(\"An example group\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Create a project in the example group\n\t\t_, err = gitlab.NewProject(ctx, \"example\", \u0026gitlab.ProjectArgs{\n\t\t\tName:        pulumi.String(\"example\"),\n\t\t\tDescription: pulumi.String(\"An example project\"),\n\t\t\tNamespaceId: example.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Group with custom push rules\n\t\t_, err = gitlab.NewGroup(ctx, \"example-two\", \u0026gitlab.GroupArgs{\n\t\t\tName:        pulumi.String(\"example-two\"),\n\t\t\tPath:        pulumi.String(\"example-two\"),\n\t\t\tDescription: pulumi.String(\"An example group with push rules\"),\n\t\t\tPushRules: \u0026gitlab.GroupPushRulesArgs{\n\t\t\t\tAuthorEmailRegex:     pulumi.String(\"@example\\\\.com$\"),\n\t\t\t\tCommitCommitterCheck: pulumi.Bool(true),\n\t\t\t\tMemberCheck:          pulumi.Bool(true),\n\t\t\t\tPreventSecrets:       pulumi.Bool(true),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Group with custom default branch protection defaults\n\t\t_, err = gitlab.NewGroup(ctx, \"example-three\", \u0026gitlab.GroupArgs{\n\t\t\tName:        pulumi.String(\"example-three\"),\n\t\t\tPath:        pulumi.String(\"example-three\"),\n\t\t\tDescription: pulumi.String(\"An example group with default branch protection defaults\"),\n\t\t\tDefaultBranchProtectionDefaults: \u0026gitlab.GroupDefaultBranchProtectionDefaultsArgs{\n\t\t\t\tAllowedToPushes: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"developer\"),\n\t\t\t\t},\n\t\t\t\tAllowForcePush: pulumi.Bool(true),\n\t\t\t\tAllowedToMerges: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"developer\"),\n\t\t\t\t\tpulumi.String(\"maintainer\"),\n\t\t\t\t},\n\t\t\t\tDeveloperCanInitialPush: pulumi.Bool(true),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Group with custom default branch protection defaults\n\t\t_, err = gitlab.NewGroup(ctx, \"example-four\", \u0026gitlab.GroupArgs{\n\t\t\tName:        pulumi.String(\"example-four\"),\n\t\t\tPath:        pulumi.String(\"example-four\"),\n\t\t\tDescription: pulumi.String(\"An example group with default branch protection defaults\"),\n\t\t\tDefaultBranchProtectionDefaults: \u0026gitlab.GroupDefaultBranchProtectionDefaultsArgs{\n\t\t\t\tAllowedToPushes: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"no one\"),\n\t\t\t\t},\n\t\t\t\tAllowForcePush: pulumi.Bool(true),\n\t\t\t\tAllowedToMerges: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"no one\"),\n\t\t\t\t},\n\t\t\t\tDeveloperCanInitialPush: pulumi.Bool(true),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Group with a default branch name specified\n\t\t_, err = gitlab.NewGroup(ctx, \"example-five\", \u0026gitlab.GroupArgs{\n\t\t\tName:          pulumi.String(\"example\"),\n\t\t\tPath:          pulumi.String(\"example\"),\n\t\t\tDefaultBranch: pulumi.String(\"develop\"),\n\t\t\tDescription:   pulumi.String(\"An example group with a default branch name\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Group;\nimport com.pulumi.gitlab.GroupArgs;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.inputs.GroupPushRulesArgs;\nimport com.pulumi.gitlab.inputs.GroupDefaultBranchProtectionDefaultsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Group(\"example\", GroupArgs.builder()\n            .name(\"example\")\n            .path(\"example\")\n            .description(\"An example group\")\n            .build());\n\n        // Create a project in the example group\n        var exampleProject = new Project(\"exampleProject\", ProjectArgs.builder()\n            .name(\"example\")\n            .description(\"An example project\")\n            .namespaceId(example.id())\n            .build());\n\n        // Group with custom push rules\n        var example_two = new Group(\"example-two\", GroupArgs.builder()\n            .name(\"example-two\")\n            .path(\"example-two\")\n            .description(\"An example group with push rules\")\n            .pushRules(GroupPushRulesArgs.builder()\n                .authorEmailRegex(\"@example\\\\.com$\")\n                .commitCommitterCheck(true)\n                .memberCheck(true)\n                .preventSecrets(true)\n                .build())\n            .build());\n\n        // Group with custom default branch protection defaults\n        var example_three = new Group(\"example-three\", GroupArgs.builder()\n            .name(\"example-three\")\n            .path(\"example-three\")\n            .description(\"An example group with default branch protection defaults\")\n            .defaultBranchProtectionDefaults(GroupDefaultBranchProtectionDefaultsArgs.builder()\n                .allowedToPushes(\"developer\")\n                .allowForcePush(true)\n                .allowedToMerges(                \n                    \"developer\",\n                    \"maintainer\")\n                .developerCanInitialPush(true)\n                .build())\n            .build());\n\n        // Group with custom default branch protection defaults\n        var example_four = new Group(\"example-four\", GroupArgs.builder()\n            .name(\"example-four\")\n            .path(\"example-four\")\n            .description(\"An example group with default branch protection defaults\")\n            .defaultBranchProtectionDefaults(GroupDefaultBranchProtectionDefaultsArgs.builder()\n                .allowedToPushes(\"no one\")\n                .allowForcePush(true)\n                .allowedToMerges(\"no one\")\n                .developerCanInitialPush(true)\n                .build())\n            .build());\n\n        // Group with a default branch name specified\n        var example_five = new Group(\"example-five\", GroupArgs.builder()\n            .name(\"example\")\n            .path(\"example\")\n            .defaultBranch(\"develop\")\n            .description(\"An example group with a default branch name\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: gitlab:Group\n    properties:\n      name: example\n      path: example\n      description: An example group\n  # Create a project in the example group\n  exampleProject:\n    type: gitlab:Project\n    name: example\n    properties:\n      name: example\n      description: An example project\n      namespaceId: ${example.id}\n  # Group with custom push rules\n  example-two:\n    type: gitlab:Group\n    properties:\n      name: example-two\n      path: example-two\n      description: An example group with push rules\n      pushRules:\n        authorEmailRegex: '@example\\.com$'\n        commitCommitterCheck: true\n        memberCheck: true\n        preventSecrets: true\n  # Group with custom default branch protection defaults\n  example-three:\n    type: gitlab:Group\n    properties:\n      name: example-three\n      path: example-three\n      description: An example group with default branch protection defaults\n      defaultBranchProtectionDefaults:\n        allowedToPushes:\n          - developer\n        allowForcePush: true\n        allowedToMerges:\n          - developer\n          - maintainer\n        developerCanInitialPush: true\n  # Group with custom default branch protection defaults\n  example-four:\n    type: gitlab:Group\n    properties:\n      name: example-four\n      path: example-four\n      description: An example group with default branch protection defaults\n      defaultBranchProtectionDefaults:\n        allowedToPushes:\n          - no one\n        allowForcePush: true\n        allowedToMerges:\n          - no one\n        developerCanInitialPush: true\n  # Group with a default branch name specified\n  example-five:\n    type: gitlab:Group\n    properties:\n      name: example\n      path: example\n      defaultBranch: develop\n      description: An example group with a default branch name\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_group`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_group.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\n```sh\n$ pulumi import gitlab:index/group:Group You can import a group state using `\u003cresource\u003e \u003cid\u003e`. The\n```\n\n`id` can be whatever the [details of a group][details_of_a_group] api takes for\n\nits `:id` value, so for example:\n\n```sh\n$ pulumi import gitlab:index/group:Group example example\n```\n\n",
            "properties": {
                "allowedEmailDomainsLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of email address domains to allow group access. Will be concatenated together into a comma separated string.\n"
                },
                "autoDevopsEnabled": {
                    "type": "boolean",
                    "description": "Default to Auto DevOps pipeline for all projects within this group.\n"
                },
                "avatar": {
                    "type": "string",
                    "description": "A local path to the avatar image to upload. **Note**: not available for imported resources.\n"
                },
                "avatarHash": {
                    "type": "string",
                    "description": "The hash of the avatar image. Use `filesha256(\"path/to/avatar.png\")` whenever possible. **Note**: this is used to trigger an update of the avatar. If it's not given, but an avatar is given, the avatar will be updated each time.\n"
                },
                "avatarUrl": {
                    "type": "string",
                    "description": "The URL of the avatar image.\n"
                },
                "defaultBranch": {
                    "type": "string",
                    "description": "Initial default branch name.\n"
                },
                "defaultBranchProtection": {
                    "type": "integer",
                    "description": "See https://docs.gitlab.com/ee/api/groups.html#options-for-default*branch*protection. Valid values are: `0`, `1`, `2`, `3`, `4`.\n",
                    "deprecationMessage": "Deprecated in GitLab 17.0. Use default_branch_protection_defaults instead."
                },
                "defaultBranchProtectionDefaults": {
                    "$ref": "#/types/gitlab:index/GroupDefaultBranchProtectionDefaults:GroupDefaultBranchProtectionDefaults",
                    "description": "The default branch protection defaults\n"
                },
                "description": {
                    "type": "string",
                    "description": "The group's description.\n"
                },
                "emailsEnabled": {
                    "type": "boolean",
                    "description": "Enable email notifications.\n"
                },
                "extraSharedRunnersMinutesLimit": {
                    "type": "integer",
                    "description": "Can be set by administrators only. Additional CI/CD minutes for this group.\n"
                },
                "fullName": {
                    "type": "string",
                    "description": "The full name of the group.\n"
                },
                "fullPath": {
                    "type": "string",
                    "description": "The full path of the group.\n"
                },
                "ipRestrictionRanges": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of IP addresses or subnet masks to restrict group access. Will be concatenated together into a comma separated string. Only allowed on top level groups.\n"
                },
                "lfsEnabled": {
                    "type": "boolean",
                    "description": "Enable/disable Large File Storage (LFS) for the projects in this group.\n"
                },
                "membershipLock": {
                    "type": "boolean",
                    "description": "Users cannot be added to projects in this group.\n"
                },
                "mentionsDisabled": {
                    "type": "boolean",
                    "description": "Disable the capability of a group from getting mentioned.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the group.\n"
                },
                "parentId": {
                    "type": "integer",
                    "description": "Id of the parent group (creates a nested group).\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path of the group.\n"
                },
                "permanentlyRemoveOnDelete": {
                    "type": "boolean",
                    "description": "Whether the group should be permanently removed during a `delete` operation. This only works with subgroups. Must be configured via an `apply` before the `destroy` is run.\n"
                },
                "preventForkingOutsideGroup": {
                    "type": "boolean",
                    "description": "Defaults to false. When enabled, users can not fork projects from this group to external namespaces.\n"
                },
                "projectCreationLevel": {
                    "type": "string",
                    "description": "Determine if developers can create projects in the group. Valid values are: `noone`, `maintainer`, `developer`\n"
                },
                "pushRules": {
                    "$ref": "#/types/gitlab:index/GroupPushRules:GroupPushRules",
                    "description": "Push rules for the group.\n"
                },
                "requestAccessEnabled": {
                    "type": "boolean",
                    "description": "Allow users to request member access.\n"
                },
                "requireTwoFactorAuthentication": {
                    "type": "boolean",
                    "description": "Require all users in this group to setup Two-factor authentication.\n"
                },
                "runnersToken": {
                    "type": "string",
                    "description": "The group level registration token to use during runner setup.\n",
                    "secret": true
                },
                "shareWithGroupLock": {
                    "type": "boolean",
                    "description": "Prevent sharing a project with another group within this group.\n"
                },
                "sharedRunnersMinutesLimit": {
                    "type": "integer",
                    "description": "Can be set by administrators only. Maximum number of monthly CI/CD minutes for this group. Can be nil (default; inherit system default), 0 (unlimited), or \u003e 0.\n"
                },
                "sharedRunnersSetting": {
                    "type": "string",
                    "description": "Enable or disable shared runners for a group’s subgroups and projects. Valid values are: `enabled`, `disabled_and_overridable`, `disabled_and_unoverridable`, `disabled_with_override`.\n"
                },
                "subgroupCreationLevel": {
                    "type": "string",
                    "description": "Allowed to create subgroups. Valid values are: `owner`, `maintainer`.\n"
                },
                "twoFactorGracePeriod": {
                    "type": "integer",
                    "description": "Defaults to 48. Time before Two-factor authentication is enforced (in hours).\n"
                },
                "visibilityLevel": {
                    "type": "string",
                    "description": "The group's visibility. Can be `private`, `internal`, or `public`. Valid values are: `private`, `internal`, `public`.\n"
                },
                "webUrl": {
                    "type": "string",
                    "description": "Web URL of the group.\n"
                },
                "wikiAccessLevel": {
                    "type": "string",
                    "description": "The group's wiki access level. Only available on Premium and Ultimate plans. Valid values are `disabled`, `private`, `enabled`.\n"
                }
            },
            "required": [
                "autoDevopsEnabled",
                "avatarHash",
                "avatarUrl",
                "defaultBranchProtection",
                "defaultBranchProtectionDefaults",
                "emailsEnabled",
                "extraSharedRunnersMinutesLimit",
                "fullName",
                "fullPath",
                "lfsEnabled",
                "mentionsDisabled",
                "name",
                "parentId",
                "path",
                "preventForkingOutsideGroup",
                "projectCreationLevel",
                "pushRules",
                "requestAccessEnabled",
                "requireTwoFactorAuthentication",
                "runnersToken",
                "shareWithGroupLock",
                "sharedRunnersMinutesLimit",
                "sharedRunnersSetting",
                "subgroupCreationLevel",
                "twoFactorGracePeriod",
                "visibilityLevel",
                "webUrl",
                "wikiAccessLevel"
            ],
            "inputProperties": {
                "allowedEmailDomainsLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of email address domains to allow group access. Will be concatenated together into a comma separated string.\n"
                },
                "autoDevopsEnabled": {
                    "type": "boolean",
                    "description": "Default to Auto DevOps pipeline for all projects within this group.\n"
                },
                "avatar": {
                    "type": "string",
                    "description": "A local path to the avatar image to upload. **Note**: not available for imported resources.\n"
                },
                "avatarHash": {
                    "type": "string",
                    "description": "The hash of the avatar image. Use `filesha256(\"path/to/avatar.png\")` whenever possible. **Note**: this is used to trigger an update of the avatar. If it's not given, but an avatar is given, the avatar will be updated each time.\n"
                },
                "defaultBranch": {
                    "type": "string",
                    "description": "Initial default branch name.\n"
                },
                "defaultBranchProtection": {
                    "type": "integer",
                    "description": "See https://docs.gitlab.com/ee/api/groups.html#options-for-default*branch*protection. Valid values are: `0`, `1`, `2`, `3`, `4`.\n",
                    "deprecationMessage": "Deprecated in GitLab 17.0. Use default_branch_protection_defaults instead."
                },
                "defaultBranchProtectionDefaults": {
                    "$ref": "#/types/gitlab:index/GroupDefaultBranchProtectionDefaults:GroupDefaultBranchProtectionDefaults",
                    "description": "The default branch protection defaults\n"
                },
                "description": {
                    "type": "string",
                    "description": "The group's description.\n"
                },
                "emailsEnabled": {
                    "type": "boolean",
                    "description": "Enable email notifications.\n"
                },
                "extraSharedRunnersMinutesLimit": {
                    "type": "integer",
                    "description": "Can be set by administrators only. Additional CI/CD minutes for this group.\n"
                },
                "ipRestrictionRanges": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of IP addresses or subnet masks to restrict group access. Will be concatenated together into a comma separated string. Only allowed on top level groups.\n"
                },
                "lfsEnabled": {
                    "type": "boolean",
                    "description": "Enable/disable Large File Storage (LFS) for the projects in this group.\n"
                },
                "membershipLock": {
                    "type": "boolean",
                    "description": "Users cannot be added to projects in this group.\n"
                },
                "mentionsDisabled": {
                    "type": "boolean",
                    "description": "Disable the capability of a group from getting mentioned.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the group.\n"
                },
                "parentId": {
                    "type": "integer",
                    "description": "Id of the parent group (creates a nested group).\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path of the group.\n"
                },
                "permanentlyRemoveOnDelete": {
                    "type": "boolean",
                    "description": "Whether the group should be permanently removed during a `delete` operation. This only works with subgroups. Must be configured via an `apply` before the `destroy` is run.\n"
                },
                "preventForkingOutsideGroup": {
                    "type": "boolean",
                    "description": "Defaults to false. When enabled, users can not fork projects from this group to external namespaces.\n"
                },
                "projectCreationLevel": {
                    "type": "string",
                    "description": "Determine if developers can create projects in the group. Valid values are: `noone`, `maintainer`, `developer`\n"
                },
                "pushRules": {
                    "$ref": "#/types/gitlab:index/GroupPushRules:GroupPushRules",
                    "description": "Push rules for the group.\n"
                },
                "requestAccessEnabled": {
                    "type": "boolean",
                    "description": "Allow users to request member access.\n"
                },
                "requireTwoFactorAuthentication": {
                    "type": "boolean",
                    "description": "Require all users in this group to setup Two-factor authentication.\n"
                },
                "shareWithGroupLock": {
                    "type": "boolean",
                    "description": "Prevent sharing a project with another group within this group.\n"
                },
                "sharedRunnersMinutesLimit": {
                    "type": "integer",
                    "description": "Can be set by administrators only. Maximum number of monthly CI/CD minutes for this group. Can be nil (default; inherit system default), 0 (unlimited), or \u003e 0.\n"
                },
                "sharedRunnersSetting": {
                    "type": "string",
                    "description": "Enable or disable shared runners for a group’s subgroups and projects. Valid values are: `enabled`, `disabled_and_overridable`, `disabled_and_unoverridable`, `disabled_with_override`.\n"
                },
                "subgroupCreationLevel": {
                    "type": "string",
                    "description": "Allowed to create subgroups. Valid values are: `owner`, `maintainer`.\n"
                },
                "twoFactorGracePeriod": {
                    "type": "integer",
                    "description": "Defaults to 48. Time before Two-factor authentication is enforced (in hours).\n"
                },
                "visibilityLevel": {
                    "type": "string",
                    "description": "The group's visibility. Can be `private`, `internal`, or `public`. Valid values are: `private`, `internal`, `public`.\n"
                },
                "wikiAccessLevel": {
                    "type": "string",
                    "description": "The group's wiki access level. Only available on Premium and Ultimate plans. Valid values are `disabled`, `private`, `enabled`.\n"
                }
            },
            "requiredInputs": [
                "path"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Group resources.\n",
                "properties": {
                    "allowedEmailDomainsLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of email address domains to allow group access. Will be concatenated together into a comma separated string.\n"
                    },
                    "autoDevopsEnabled": {
                        "type": "boolean",
                        "description": "Default to Auto DevOps pipeline for all projects within this group.\n"
                    },
                    "avatar": {
                        "type": "string",
                        "description": "A local path to the avatar image to upload. **Note**: not available for imported resources.\n"
                    },
                    "avatarHash": {
                        "type": "string",
                        "description": "The hash of the avatar image. Use `filesha256(\"path/to/avatar.png\")` whenever possible. **Note**: this is used to trigger an update of the avatar. If it's not given, but an avatar is given, the avatar will be updated each time.\n"
                    },
                    "avatarUrl": {
                        "type": "string",
                        "description": "The URL of the avatar image.\n"
                    },
                    "defaultBranch": {
                        "type": "string",
                        "description": "Initial default branch name.\n"
                    },
                    "defaultBranchProtection": {
                        "type": "integer",
                        "description": "See https://docs.gitlab.com/ee/api/groups.html#options-for-default*branch*protection. Valid values are: `0`, `1`, `2`, `3`, `4`.\n",
                        "deprecationMessage": "Deprecated in GitLab 17.0. Use default_branch_protection_defaults instead."
                    },
                    "defaultBranchProtectionDefaults": {
                        "$ref": "#/types/gitlab:index/GroupDefaultBranchProtectionDefaults:GroupDefaultBranchProtectionDefaults",
                        "description": "The default branch protection defaults\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The group's description.\n"
                    },
                    "emailsEnabled": {
                        "type": "boolean",
                        "description": "Enable email notifications.\n"
                    },
                    "extraSharedRunnersMinutesLimit": {
                        "type": "integer",
                        "description": "Can be set by administrators only. Additional CI/CD minutes for this group.\n"
                    },
                    "fullName": {
                        "type": "string",
                        "description": "The full name of the group.\n"
                    },
                    "fullPath": {
                        "type": "string",
                        "description": "The full path of the group.\n"
                    },
                    "ipRestrictionRanges": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of IP addresses or subnet masks to restrict group access. Will be concatenated together into a comma separated string. Only allowed on top level groups.\n"
                    },
                    "lfsEnabled": {
                        "type": "boolean",
                        "description": "Enable/disable Large File Storage (LFS) for the projects in this group.\n"
                    },
                    "membershipLock": {
                        "type": "boolean",
                        "description": "Users cannot be added to projects in this group.\n"
                    },
                    "mentionsDisabled": {
                        "type": "boolean",
                        "description": "Disable the capability of a group from getting mentioned.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the group.\n"
                    },
                    "parentId": {
                        "type": "integer",
                        "description": "Id of the parent group (creates a nested group).\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path of the group.\n"
                    },
                    "permanentlyRemoveOnDelete": {
                        "type": "boolean",
                        "description": "Whether the group should be permanently removed during a `delete` operation. This only works with subgroups. Must be configured via an `apply` before the `destroy` is run.\n"
                    },
                    "preventForkingOutsideGroup": {
                        "type": "boolean",
                        "description": "Defaults to false. When enabled, users can not fork projects from this group to external namespaces.\n"
                    },
                    "projectCreationLevel": {
                        "type": "string",
                        "description": "Determine if developers can create projects in the group. Valid values are: `noone`, `maintainer`, `developer`\n"
                    },
                    "pushRules": {
                        "$ref": "#/types/gitlab:index/GroupPushRules:GroupPushRules",
                        "description": "Push rules for the group.\n"
                    },
                    "requestAccessEnabled": {
                        "type": "boolean",
                        "description": "Allow users to request member access.\n"
                    },
                    "requireTwoFactorAuthentication": {
                        "type": "boolean",
                        "description": "Require all users in this group to setup Two-factor authentication.\n"
                    },
                    "runnersToken": {
                        "type": "string",
                        "description": "The group level registration token to use during runner setup.\n",
                        "secret": true
                    },
                    "shareWithGroupLock": {
                        "type": "boolean",
                        "description": "Prevent sharing a project with another group within this group.\n"
                    },
                    "sharedRunnersMinutesLimit": {
                        "type": "integer",
                        "description": "Can be set by administrators only. Maximum number of monthly CI/CD minutes for this group. Can be nil (default; inherit system default), 0 (unlimited), or \u003e 0.\n"
                    },
                    "sharedRunnersSetting": {
                        "type": "string",
                        "description": "Enable or disable shared runners for a group’s subgroups and projects. Valid values are: `enabled`, `disabled_and_overridable`, `disabled_and_unoverridable`, `disabled_with_override`.\n"
                    },
                    "subgroupCreationLevel": {
                        "type": "string",
                        "description": "Allowed to create subgroups. Valid values are: `owner`, `maintainer`.\n"
                    },
                    "twoFactorGracePeriod": {
                        "type": "integer",
                        "description": "Defaults to 48. Time before Two-factor authentication is enforced (in hours).\n"
                    },
                    "visibilityLevel": {
                        "type": "string",
                        "description": "The group's visibility. Can be `private`, `internal`, or `public`. Valid values are: `private`, `internal`, `public`.\n"
                    },
                    "webUrl": {
                        "type": "string",
                        "description": "Web URL of the group.\n"
                    },
                    "wikiAccessLevel": {
                        "type": "string",
                        "description": "The group's wiki access level. Only available on Premium and Ultimate plans. Valid values are `disabled`, `private`, `enabled`.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupAccessToken:GroupAccessToken": {
            "description": "The `gitlab.GroupAccessToken` resource allows to manage the lifecycle of a group access token.\n\n\u003e Observability scopes are in beta and may not work on all instances. See more details in [the documentation](https://docs.gitlab.com/ee/operations/tracing.html)\n\n\u003e Use `rotation_configuration` to automatically rotate tokens instead of using `timestamp()` as timestamp will cause changes with every plan. `pulumi up` must still be run to rotate the token.\n\n\u003e Due to [Automatic reuse detection](https://docs.gitlab.com/ee/api/group_access_tokens.html#automatic-reuse-detection) it's possible that a new Group Access Token will immediately be revoked. Check if an old process using the old token is running if this happens.\n\n**Upstream API**: [GitLab REST API](https://docs.gitlab.com/ee/api/group_access_tokens.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = new gitlab.GroupAccessToken(\"example\", {\n    group: \"25\",\n    name: \"Example group access token\",\n    expiresAt: \"2020-03-14\",\n    accessLevel: \"developer\",\n    scopes: [\"api\"],\n});\nconst exampleGroupVariable = new gitlab.GroupVariable(\"example\", {\n    group: \"25\",\n    key: \"gat\",\n    value: example.token,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.GroupAccessToken(\"example\",\n    group=\"25\",\n    name=\"Example group access token\",\n    expires_at=\"2020-03-14\",\n    access_level=\"developer\",\n    scopes=[\"api\"])\nexample_group_variable = gitlab.GroupVariable(\"example\",\n    group=\"25\",\n    key=\"gat\",\n    value=example.token)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new GitLab.GroupAccessToken(\"example\", new()\n    {\n        Group = \"25\",\n        Name = \"Example group access token\",\n        ExpiresAt = \"2020-03-14\",\n        AccessLevel = \"developer\",\n        Scopes = new[]\n        {\n            \"api\",\n        },\n    });\n\n    var exampleGroupVariable = new GitLab.GroupVariable(\"example\", new()\n    {\n        Group = \"25\",\n        Key = \"gat\",\n        Value = example.Token,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := gitlab.NewGroupAccessToken(ctx, \"example\", \u0026gitlab.GroupAccessTokenArgs{\n\t\t\tGroup:       pulumi.String(\"25\"),\n\t\t\tName:        pulumi.String(\"Example group access token\"),\n\t\t\tExpiresAt:   pulumi.String(\"2020-03-14\"),\n\t\t\tAccessLevel: pulumi.String(\"developer\"),\n\t\t\tScopes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"api\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewGroupVariable(ctx, \"example\", \u0026gitlab.GroupVariableArgs{\n\t\t\tGroup: pulumi.String(\"25\"),\n\t\t\tKey:   pulumi.String(\"gat\"),\n\t\t\tValue: example.Token,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GroupAccessToken;\nimport com.pulumi.gitlab.GroupAccessTokenArgs;\nimport com.pulumi.gitlab.GroupVariable;\nimport com.pulumi.gitlab.GroupVariableArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new GroupAccessToken(\"example\", GroupAccessTokenArgs.builder()\n            .group(\"25\")\n            .name(\"Example group access token\")\n            .expiresAt(\"2020-03-14\")\n            .accessLevel(\"developer\")\n            .scopes(\"api\")\n            .build());\n\n        var exampleGroupVariable = new GroupVariable(\"exampleGroupVariable\", GroupVariableArgs.builder()\n            .group(\"25\")\n            .key(\"gat\")\n            .value(example.token())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: gitlab:GroupAccessToken\n    properties:\n      group: '25'\n      name: Example group access token\n      expiresAt: 2020-03-14\n      accessLevel: developer\n      scopes:\n        - api\n  exampleGroupVariable:\n    type: gitlab:GroupVariable\n    name: example\n    properties:\n      group: '25'\n      key: gat\n      value: ${example.token}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_group_access_token`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_group_access_token.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nA GitLab Group Access Token can be imported using a key composed of `\u003cgroup-id\u003e:\u003ctoken-id\u003e`, e.g.\n\n```sh\n$ pulumi import gitlab:index/groupAccessToken:GroupAccessToken example \"12345:1\"\n```\n\nATTENTION: the `token` resource attribute is not available for imported resources as this information cannot be read from the GitLab API.\n\n",
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "The access level for the group access token. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`. Default is `maintainer`.\n"
                },
                "active": {
                    "type": "boolean",
                    "description": "True if the token is active.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Time the token has been created, RFC3339 format.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "When the token will expire, YYYY-MM-DD format.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The ID or full path of the group.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the group access token.\n"
                },
                "revoked": {
                    "type": "boolean",
                    "description": "True if the token is revoked.\n"
                },
                "rotationConfiguration": {
                    "$ref": "#/types/gitlab:index/GroupAccessTokenRotationConfiguration:GroupAccessTokenRotationConfiguration",
                    "description": "The configuration for when to rotate a token automatically. Will not rotate a token until `pulumi up` is run.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The scopes of the group access token. Valid values are: `api`, `read_api`, `read_registry`, `write_registry`, `read_repository`, `write_repository`, `create_runner`, `manage_runner`, `ai_features`, `k8s_proxy`, `read_observability`, `write_observability`\n"
                },
                "token": {
                    "type": "string",
                    "description": "The token of the group access token. **Note**: the token is not available for imported resources.\n",
                    "secret": true
                },
                "userId": {
                    "type": "integer",
                    "description": "The user_id associated to the token.\n"
                }
            },
            "required": [
                "accessLevel",
                "active",
                "createdAt",
                "expiresAt",
                "group",
                "name",
                "revoked",
                "scopes",
                "token",
                "userId"
            ],
            "inputProperties": {
                "accessLevel": {
                    "type": "string",
                    "description": "The access level for the group access token. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`. Default is `maintainer`.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "When the token will expire, YYYY-MM-DD format.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The ID or full path of the group.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the group access token.\n"
                },
                "rotationConfiguration": {
                    "$ref": "#/types/gitlab:index/GroupAccessTokenRotationConfiguration:GroupAccessTokenRotationConfiguration",
                    "description": "The configuration for when to rotate a token automatically. Will not rotate a token until `pulumi up` is run.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The scopes of the group access token. Valid values are: `api`, `read_api`, `read_registry`, `write_registry`, `read_repository`, `write_repository`, `create_runner`, `manage_runner`, `ai_features`, `k8s_proxy`, `read_observability`, `write_observability`\n"
                }
            },
            "requiredInputs": [
                "group",
                "scopes"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupAccessToken resources.\n",
                "properties": {
                    "accessLevel": {
                        "type": "string",
                        "description": "The access level for the group access token. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`. Default is `maintainer`.\n"
                    },
                    "active": {
                        "type": "boolean",
                        "description": "True if the token is active.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Time the token has been created, RFC3339 format.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "When the token will expire, YYYY-MM-DD format.\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "The ID or full path of the group.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the group access token.\n"
                    },
                    "revoked": {
                        "type": "boolean",
                        "description": "True if the token is revoked.\n"
                    },
                    "rotationConfiguration": {
                        "$ref": "#/types/gitlab:index/GroupAccessTokenRotationConfiguration:GroupAccessTokenRotationConfiguration",
                        "description": "The configuration for when to rotate a token automatically. Will not rotate a token until `pulumi up` is run.\n"
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The scopes of the group access token. Valid values are: `api`, `read_api`, `read_registry`, `write_registry`, `read_repository`, `write_repository`, `create_runner`, `manage_runner`, `ai_features`, `k8s_proxy`, `read_observability`, `write_observability`\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "The token of the group access token. **Note**: the token is not available for imported resources.\n",
                        "secret": true
                    },
                    "userId": {
                        "type": "integer",
                        "description": "The user_id associated to the token.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupBadge:GroupBadge": {
            "description": "The `gitlab.GroupBadge` resource allows to manage the lifecycle of group badges.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/user/project/badges.html#group-badges)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = new gitlab.Group(\"foo\", {name: \"foo-group\"});\nconst example = new gitlab.GroupBadge(\"example\", {\n    group: foo.id,\n    linkUrl: \"https://example.com/badge-123\",\n    imageUrl: \"https://example.com/badge-123.svg\",\n});\n// Pipeline status badges with placeholders will be enabled for each project\nconst gitlabPipeline = new gitlab.GroupBadge(\"gitlab_pipeline\", {\n    group: foo.id,\n    linkUrl: \"https://gitlab.example.com/%{project_path}/-/pipelines?ref=%{default_branch}\",\n    imageUrl: \"https://gitlab.example.com/%{project_path}/badges/%{default_branch}/pipeline.svg\",\n});\n// Test coverage report badges with placeholders will be enabled for each project\nconst gitlabCoverage = new gitlab.GroupBadge(\"gitlab_coverage\", {\n    group: foo.id,\n    linkUrl: \"https://gitlab.example.com/%{project_path}/-/jobs\",\n    imageUrl: \"https://gitlab.example.com/%{project_path}/badges/%{default_branch}/coverage.svg\",\n});\n// Latest release badges with placeholders will be enabled for each project\nconst gitlabRelease = new gitlab.GroupBadge(\"gitlab_release\", {\n    group: foo.id,\n    linkUrl: \"https://gitlab.example.com/%{project_path}/-/releases\",\n    imageUrl: \"https://gitlab.example.com/%{project_path}/-/badges/release.svg\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.Group(\"foo\", name=\"foo-group\")\nexample = gitlab.GroupBadge(\"example\",\n    group=foo.id,\n    link_url=\"https://example.com/badge-123\",\n    image_url=\"https://example.com/badge-123.svg\")\n# Pipeline status badges with placeholders will be enabled for each project\ngitlab_pipeline = gitlab.GroupBadge(\"gitlab_pipeline\",\n    group=foo.id,\n    link_url=\"https://gitlab.example.com/%{project_path}/-/pipelines?ref=%{default_branch}\",\n    image_url=\"https://gitlab.example.com/%{project_path}/badges/%{default_branch}/pipeline.svg\")\n# Test coverage report badges with placeholders will be enabled for each project\ngitlab_coverage = gitlab.GroupBadge(\"gitlab_coverage\",\n    group=foo.id,\n    link_url=\"https://gitlab.example.com/%{project_path}/-/jobs\",\n    image_url=\"https://gitlab.example.com/%{project_path}/badges/%{default_branch}/coverage.svg\")\n# Latest release badges with placeholders will be enabled for each project\ngitlab_release = gitlab.GroupBadge(\"gitlab_release\",\n    group=foo.id,\n    link_url=\"https://gitlab.example.com/%{project_path}/-/releases\",\n    image_url=\"https://gitlab.example.com/%{project_path}/-/badges/release.svg\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = new GitLab.Group(\"foo\", new()\n    {\n        Name = \"foo-group\",\n    });\n\n    var example = new GitLab.GroupBadge(\"example\", new()\n    {\n        Group = foo.Id,\n        LinkUrl = \"https://example.com/badge-123\",\n        ImageUrl = \"https://example.com/badge-123.svg\",\n    });\n\n    // Pipeline status badges with placeholders will be enabled for each project\n    var gitlabPipeline = new GitLab.GroupBadge(\"gitlab_pipeline\", new()\n    {\n        Group = foo.Id,\n        LinkUrl = \"https://gitlab.example.com/%{project_path}/-/pipelines?ref=%{default_branch}\",\n        ImageUrl = \"https://gitlab.example.com/%{project_path}/badges/%{default_branch}/pipeline.svg\",\n    });\n\n    // Test coverage report badges with placeholders will be enabled for each project\n    var gitlabCoverage = new GitLab.GroupBadge(\"gitlab_coverage\", new()\n    {\n        Group = foo.Id,\n        LinkUrl = \"https://gitlab.example.com/%{project_path}/-/jobs\",\n        ImageUrl = \"https://gitlab.example.com/%{project_path}/badges/%{default_branch}/coverage.svg\",\n    });\n\n    // Latest release badges with placeholders will be enabled for each project\n    var gitlabRelease = new GitLab.GroupBadge(\"gitlab_release\", new()\n    {\n        Group = foo.Id,\n        LinkUrl = \"https://gitlab.example.com/%{project_path}/-/releases\",\n        ImageUrl = \"https://gitlab.example.com/%{project_path}/-/badges/release.svg\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfoo, err := gitlab.NewGroup(ctx, \"foo\", \u0026gitlab.GroupArgs{\n\t\t\tName: pulumi.String(\"foo-group\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewGroupBadge(ctx, \"example\", \u0026gitlab.GroupBadgeArgs{\n\t\t\tGroup:    foo.ID(),\n\t\t\tLinkUrl:  pulumi.String(\"https://example.com/badge-123\"),\n\t\t\tImageUrl: pulumi.String(\"https://example.com/badge-123.svg\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Pipeline status badges with placeholders will be enabled for each project\n\t\t_, err = gitlab.NewGroupBadge(ctx, \"gitlab_pipeline\", \u0026gitlab.GroupBadgeArgs{\n\t\t\tGroup:    foo.ID(),\n\t\t\tLinkUrl:  pulumi.String(\"https://gitlab.example.com/%{project_path}/-/pipelines?ref=%{default_branch}\"),\n\t\t\tImageUrl: pulumi.String(\"https://gitlab.example.com/%{project_path}/badges/%{default_branch}/pipeline.svg\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Test coverage report badges with placeholders will be enabled for each project\n\t\t_, err = gitlab.NewGroupBadge(ctx, \"gitlab_coverage\", \u0026gitlab.GroupBadgeArgs{\n\t\t\tGroup:    foo.ID(),\n\t\t\tLinkUrl:  pulumi.String(\"https://gitlab.example.com/%{project_path}/-/jobs\"),\n\t\t\tImageUrl: pulumi.String(\"https://gitlab.example.com/%{project_path}/badges/%{default_branch}/coverage.svg\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Latest release badges with placeholders will be enabled for each project\n\t\t_, err = gitlab.NewGroupBadge(ctx, \"gitlab_release\", \u0026gitlab.GroupBadgeArgs{\n\t\t\tGroup:    foo.ID(),\n\t\t\tLinkUrl:  pulumi.String(\"https://gitlab.example.com/%{project_path}/-/releases\"),\n\t\t\tImageUrl: pulumi.String(\"https://gitlab.example.com/%{project_path}/-/badges/release.svg\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Group;\nimport com.pulumi.gitlab.GroupArgs;\nimport com.pulumi.gitlab.GroupBadge;\nimport com.pulumi.gitlab.GroupBadgeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var foo = new Group(\"foo\", GroupArgs.builder()\n            .name(\"foo-group\")\n            .build());\n\n        var example = new GroupBadge(\"example\", GroupBadgeArgs.builder()\n            .group(foo.id())\n            .linkUrl(\"https://example.com/badge-123\")\n            .imageUrl(\"https://example.com/badge-123.svg\")\n            .build());\n\n        // Pipeline status badges with placeholders will be enabled for each project\n        var gitlabPipeline = new GroupBadge(\"gitlabPipeline\", GroupBadgeArgs.builder()\n            .group(foo.id())\n            .linkUrl(\"https://gitlab.example.com/%{project_path}/-/pipelines?ref=%{default_branch}\")\n            .imageUrl(\"https://gitlab.example.com/%{project_path}/badges/%{default_branch}/pipeline.svg\")\n            .build());\n\n        // Test coverage report badges with placeholders will be enabled for each project\n        var gitlabCoverage = new GroupBadge(\"gitlabCoverage\", GroupBadgeArgs.builder()\n            .group(foo.id())\n            .linkUrl(\"https://gitlab.example.com/%{project_path}/-/jobs\")\n            .imageUrl(\"https://gitlab.example.com/%{project_path}/badges/%{default_branch}/coverage.svg\")\n            .build());\n\n        // Latest release badges with placeholders will be enabled for each project\n        var gitlabRelease = new GroupBadge(\"gitlabRelease\", GroupBadgeArgs.builder()\n            .group(foo.id())\n            .linkUrl(\"https://gitlab.example.com/%{project_path}/-/releases\")\n            .imageUrl(\"https://gitlab.example.com/%{project_path}/-/badges/release.svg\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  foo:\n    type: gitlab:Group\n    properties:\n      name: foo-group\n  example:\n    type: gitlab:GroupBadge\n    properties:\n      group: ${foo.id}\n      linkUrl: https://example.com/badge-123\n      imageUrl: https://example.com/badge-123.svg\n  # Pipeline status badges with placeholders will be enabled for each project\n  gitlabPipeline:\n    type: gitlab:GroupBadge\n    name: gitlab_pipeline\n    properties:\n      group: ${foo.id}\n      linkUrl: https://gitlab.example.com/%{project_path}/-/pipelines?ref=%{default_branch}\n      imageUrl: https://gitlab.example.com/%{project_path}/badges/%{default_branch}/pipeline.svg\n  # Test coverage report badges with placeholders will be enabled for each project\n  gitlabCoverage:\n    type: gitlab:GroupBadge\n    name: gitlab_coverage\n    properties:\n      group: ${foo.id}\n      linkUrl: https://gitlab.example.com/%{project_path}/-/jobs\n      imageUrl: https://gitlab.example.com/%{project_path}/badges/%{default_branch}/coverage.svg\n  # Latest release badges with placeholders will be enabled for each project\n  gitlabRelease:\n    type: gitlab:GroupBadge\n    name: gitlab_release\n    properties:\n      group: ${foo.id}\n      linkUrl: https://gitlab.example.com/%{project_path}/-/releases\n      imageUrl: https://gitlab.example.com/%{project_path}/-/badges/release.svg\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_group_badge`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_group_badge.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab group badges can be imported using an id made up of `{group_id}:{badge_id}`, e.g.\n\n```sh\n$ pulumi import gitlab:index/groupBadge:GroupBadge foo 1:3\n```\n\n",
            "properties": {
                "group": {
                    "type": "string",
                    "description": "The id of the group to add the badge to.\n"
                },
                "imageUrl": {
                    "type": "string",
                    "description": "The image url which will be presented on group overview.\n"
                },
                "linkUrl": {
                    "type": "string",
                    "description": "The url linked with the badge.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the badge.\n"
                },
                "renderedImageUrl": {
                    "type": "string",
                    "description": "The image_url argument rendered (in case of use of placeholders).\n"
                },
                "renderedLinkUrl": {
                    "type": "string",
                    "description": "The link_url argument rendered (in case of use of placeholders).\n"
                }
            },
            "required": [
                "group",
                "imageUrl",
                "linkUrl",
                "name",
                "renderedImageUrl",
                "renderedLinkUrl"
            ],
            "inputProperties": {
                "group": {
                    "type": "string",
                    "description": "The id of the group to add the badge to.\n"
                },
                "imageUrl": {
                    "type": "string",
                    "description": "The image url which will be presented on group overview.\n"
                },
                "linkUrl": {
                    "type": "string",
                    "description": "The url linked with the badge.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the badge.\n"
                }
            },
            "requiredInputs": [
                "group",
                "imageUrl",
                "linkUrl"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupBadge resources.\n",
                "properties": {
                    "group": {
                        "type": "string",
                        "description": "The id of the group to add the badge to.\n"
                    },
                    "imageUrl": {
                        "type": "string",
                        "description": "The image url which will be presented on group overview.\n"
                    },
                    "linkUrl": {
                        "type": "string",
                        "description": "The url linked with the badge.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the badge.\n"
                    },
                    "renderedImageUrl": {
                        "type": "string",
                        "description": "The image_url argument rendered (in case of use of placeholders).\n"
                    },
                    "renderedLinkUrl": {
                        "type": "string",
                        "description": "The link_url argument rendered (in case of use of placeholders).\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupCluster:GroupCluster": {
            "description": "The `gitlab.GroupCluster` resource allows to manage the lifecycle of a group cluster.\n\n\u003e This is deprecated GitLab feature since 14.5\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/group_clusters.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = new gitlab.Group(\"foo\", {\n    name: \"foo-group\",\n    path: \"foo-path\",\n});\nconst bar = new gitlab.GroupCluster(\"bar\", {\n    group: foo.id,\n    name: \"bar-cluster\",\n    domain: \"example.com\",\n    enabled: true,\n    kubernetesApiUrl: \"https://124.124.124\",\n    kubernetesToken: \"some-token\",\n    kubernetesCaCert: \"some-cert\",\n    kubernetesAuthorizationType: \"rbac\",\n    environmentScope: \"*\",\n    managementProjectId: \"123456\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.Group(\"foo\",\n    name=\"foo-group\",\n    path=\"foo-path\")\nbar = gitlab.GroupCluster(\"bar\",\n    group=foo.id,\n    name=\"bar-cluster\",\n    domain=\"example.com\",\n    enabled=True,\n    kubernetes_api_url=\"https://124.124.124\",\n    kubernetes_token=\"some-token\",\n    kubernetes_ca_cert=\"some-cert\",\n    kubernetes_authorization_type=\"rbac\",\n    environment_scope=\"*\",\n    management_project_id=\"123456\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = new GitLab.Group(\"foo\", new()\n    {\n        Name = \"foo-group\",\n        Path = \"foo-path\",\n    });\n\n    var bar = new GitLab.GroupCluster(\"bar\", new()\n    {\n        Group = foo.Id,\n        Name = \"bar-cluster\",\n        Domain = \"example.com\",\n        Enabled = true,\n        KubernetesApiUrl = \"https://124.124.124\",\n        KubernetesToken = \"some-token\",\n        KubernetesCaCert = \"some-cert\",\n        KubernetesAuthorizationType = \"rbac\",\n        EnvironmentScope = \"*\",\n        ManagementProjectId = \"123456\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfoo, err := gitlab.NewGroup(ctx, \"foo\", \u0026gitlab.GroupArgs{\n\t\t\tName: pulumi.String(\"foo-group\"),\n\t\t\tPath: pulumi.String(\"foo-path\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewGroupCluster(ctx, \"bar\", \u0026gitlab.GroupClusterArgs{\n\t\t\tGroup:                       foo.ID(),\n\t\t\tName:                        pulumi.String(\"bar-cluster\"),\n\t\t\tDomain:                      pulumi.String(\"example.com\"),\n\t\t\tEnabled:                     pulumi.Bool(true),\n\t\t\tKubernetesApiUrl:            pulumi.String(\"https://124.124.124\"),\n\t\t\tKubernetesToken:             pulumi.String(\"some-token\"),\n\t\t\tKubernetesCaCert:            pulumi.String(\"some-cert\"),\n\t\t\tKubernetesAuthorizationType: pulumi.String(\"rbac\"),\n\t\t\tEnvironmentScope:            pulumi.String(\"*\"),\n\t\t\tManagementProjectId:         pulumi.String(\"123456\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Group;\nimport com.pulumi.gitlab.GroupArgs;\nimport com.pulumi.gitlab.GroupCluster;\nimport com.pulumi.gitlab.GroupClusterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var foo = new Group(\"foo\", GroupArgs.builder()\n            .name(\"foo-group\")\n            .path(\"foo-path\")\n            .build());\n\n        var bar = new GroupCluster(\"bar\", GroupClusterArgs.builder()\n            .group(foo.id())\n            .name(\"bar-cluster\")\n            .domain(\"example.com\")\n            .enabled(true)\n            .kubernetesApiUrl(\"https://124.124.124\")\n            .kubernetesToken(\"some-token\")\n            .kubernetesCaCert(\"some-cert\")\n            .kubernetesAuthorizationType(\"rbac\")\n            .environmentScope(\"*\")\n            .managementProjectId(\"123456\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  foo:\n    type: gitlab:Group\n    properties:\n      name: foo-group\n      path: foo-path\n  bar:\n    type: gitlab:GroupCluster\n    properties:\n      group: ${foo.id}\n      name: bar-cluster\n      domain: example.com\n      enabled: true\n      kubernetesApiUrl: https://124.124.124\n      kubernetesToken: some-token\n      kubernetesCaCert: some-cert\n      kubernetesAuthorizationType: rbac\n      environmentScope: '*'\n      managementProjectId: '123456'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_group_cluster`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_group_cluster.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab group clusters can be imported using an id made up of `groupid:clusterid`, e.g.\n\n```sh\n$ pulumi import gitlab:index/groupCluster:GroupCluster bar 123:321\n```\n\n",
            "properties": {
                "clusterType": {
                    "type": "string",
                    "description": "Cluster type.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Create time.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The base domain of the cluster.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Determines if cluster is active or not. Defaults to `true`. This attribute cannot be read.\n"
                },
                "environmentScope": {
                    "type": "string",
                    "description": "The associated environment to the cluster. Defaults to `*`.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The id of the group to add the cluster to.\n"
                },
                "kubernetesApiUrl": {
                    "type": "string",
                    "description": "The URL to access the Kubernetes API.\n"
                },
                "kubernetesAuthorizationType": {
                    "type": "string",
                    "description": "The cluster authorization type. Valid values are `rbac`, `abac`, `unknown_authorization`. Defaults to `rbac`.\n"
                },
                "kubernetesCaCert": {
                    "type": "string",
                    "description": "TLS certificate (needed if API is using a self-signed TLS certificate).\n"
                },
                "kubernetesToken": {
                    "type": "string",
                    "description": "The token to authenticate against Kubernetes.\n",
                    "secret": true
                },
                "managed": {
                    "type": "boolean",
                    "description": "Determines if cluster is managed by gitlab or not. Defaults to `true`. This attribute cannot be read.\n"
                },
                "managementProjectId": {
                    "type": "string",
                    "description": "The ID of the management project for the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of cluster.\n"
                },
                "platformType": {
                    "type": "string",
                    "description": "Platform type.\n"
                },
                "providerType": {
                    "type": "string",
                    "description": "Provider type.\n"
                }
            },
            "required": [
                "clusterType",
                "createdAt",
                "group",
                "kubernetesApiUrl",
                "kubernetesToken",
                "name",
                "platformType",
                "providerType"
            ],
            "inputProperties": {
                "domain": {
                    "type": "string",
                    "description": "The base domain of the cluster.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Determines if cluster is active or not. Defaults to `true`. This attribute cannot be read.\n",
                    "willReplaceOnChanges": true
                },
                "environmentScope": {
                    "type": "string",
                    "description": "The associated environment to the cluster. Defaults to `*`.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The id of the group to add the cluster to.\n",
                    "willReplaceOnChanges": true
                },
                "kubernetesApiUrl": {
                    "type": "string",
                    "description": "The URL to access the Kubernetes API.\n"
                },
                "kubernetesAuthorizationType": {
                    "type": "string",
                    "description": "The cluster authorization type. Valid values are `rbac`, `abac`, `unknown_authorization`. Defaults to `rbac`.\n",
                    "willReplaceOnChanges": true
                },
                "kubernetesCaCert": {
                    "type": "string",
                    "description": "TLS certificate (needed if API is using a self-signed TLS certificate).\n"
                },
                "kubernetesToken": {
                    "type": "string",
                    "description": "The token to authenticate against Kubernetes.\n",
                    "secret": true
                },
                "managed": {
                    "type": "boolean",
                    "description": "Determines if cluster is managed by gitlab or not. Defaults to `true`. This attribute cannot be read.\n",
                    "willReplaceOnChanges": true
                },
                "managementProjectId": {
                    "type": "string",
                    "description": "The ID of the management project for the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of cluster.\n"
                }
            },
            "requiredInputs": [
                "group",
                "kubernetesApiUrl",
                "kubernetesToken"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupCluster resources.\n",
                "properties": {
                    "clusterType": {
                        "type": "string",
                        "description": "Cluster type.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Create time.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The base domain of the cluster.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Determines if cluster is active or not. Defaults to `true`. This attribute cannot be read.\n",
                        "willReplaceOnChanges": true
                    },
                    "environmentScope": {
                        "type": "string",
                        "description": "The associated environment to the cluster. Defaults to `*`.\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "The id of the group to add the cluster to.\n",
                        "willReplaceOnChanges": true
                    },
                    "kubernetesApiUrl": {
                        "type": "string",
                        "description": "The URL to access the Kubernetes API.\n"
                    },
                    "kubernetesAuthorizationType": {
                        "type": "string",
                        "description": "The cluster authorization type. Valid values are `rbac`, `abac`, `unknown_authorization`. Defaults to `rbac`.\n",
                        "willReplaceOnChanges": true
                    },
                    "kubernetesCaCert": {
                        "type": "string",
                        "description": "TLS certificate (needed if API is using a self-signed TLS certificate).\n"
                    },
                    "kubernetesToken": {
                        "type": "string",
                        "description": "The token to authenticate against Kubernetes.\n",
                        "secret": true
                    },
                    "managed": {
                        "type": "boolean",
                        "description": "Determines if cluster is managed by gitlab or not. Defaults to `true`. This attribute cannot be read.\n",
                        "willReplaceOnChanges": true
                    },
                    "managementProjectId": {
                        "type": "string",
                        "description": "The ID of the management project for the cluster.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of cluster.\n"
                    },
                    "platformType": {
                        "type": "string",
                        "description": "Platform type.\n"
                    },
                    "providerType": {
                        "type": "string",
                        "description": "Provider type.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupCustomAttribute:GroupCustomAttribute": {
            "description": "The `gitlab.GroupCustomAttribute` resource allows to manage custom attributes for a group.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/custom_attributes.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst attr = new gitlab.GroupCustomAttribute(\"attr\", {\n    group: 42,\n    key: \"location\",\n    value: \"Greenland\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nattr = gitlab.GroupCustomAttribute(\"attr\",\n    group=42,\n    key=\"location\",\n    value=\"Greenland\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var attr = new GitLab.GroupCustomAttribute(\"attr\", new()\n    {\n        Group = 42,\n        Key = \"location\",\n        Value = \"Greenland\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewGroupCustomAttribute(ctx, \"attr\", \u0026gitlab.GroupCustomAttributeArgs{\n\t\t\tGroup: pulumi.Int(42),\n\t\t\tKey:   pulumi.String(\"location\"),\n\t\t\tValue: pulumi.String(\"Greenland\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GroupCustomAttribute;\nimport com.pulumi.gitlab.GroupCustomAttributeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var attr = new GroupCustomAttribute(\"attr\", GroupCustomAttributeArgs.builder()\n            .group(\"42\")\n            .key(\"location\")\n            .value(\"Greenland\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  attr:\n    type: gitlab:GroupCustomAttribute\n    properties:\n      group: '42'\n      key: location\n      value: Greenland\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_group_custom_attribute`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_group_custom_attribute.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nYou can import a group custom attribute using the an id made up of `{group-id}:{key}`, e.g.\n\n```sh\n$ pulumi import gitlab:index/groupCustomAttribute:GroupCustomAttribute attr 42:location\n```\n\n",
            "properties": {
                "group": {
                    "type": "integer",
                    "description": "The id of the group.\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key for the Custom Attribute.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value for the Custom Attribute.\n"
                }
            },
            "required": [
                "group",
                "key",
                "value"
            ],
            "inputProperties": {
                "group": {
                    "type": "integer",
                    "description": "The id of the group.\n"
                },
                "key": {
                    "type": "string",
                    "description": "Key for the Custom Attribute.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value for the Custom Attribute.\n"
                }
            },
            "requiredInputs": [
                "group",
                "key",
                "value"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupCustomAttribute resources.\n",
                "properties": {
                    "group": {
                        "type": "integer",
                        "description": "The id of the group.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "Key for the Custom Attribute.\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "Value for the Custom Attribute.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupEpicBoard:GroupEpicBoard": {
            "description": "The `gitlab.GroupEpicBoard` resource allows to manage the lifecycle of a epic board in a group.\n\n\u003e Multiple epic boards on one group requires a GitLab Premium or above License.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/group_boards.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = new gitlab.Group(\"example\", {\n    name: \"test_group\",\n    path: \"test_group\",\n    description: \"An example group\",\n});\nconst label1 = new gitlab.GroupLabel(\"label_1\", {\n    group: example.id,\n    color: \"#FF0000\",\n    name: \"red-label\",\n});\nconst label3 = new gitlab.GroupLabel(\"label_3\", {\n    group: example.id,\n    name: \"label-3\",\n    color: \"#003000\",\n});\nconst epicBoard = new gitlab.GroupEpicBoard(\"epic_board\", {\n    name: \"epic board 6\",\n    group: example.path,\n    lists: [{\n        labelId: label1.labelId,\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.Group(\"example\",\n    name=\"test_group\",\n    path=\"test_group\",\n    description=\"An example group\")\nlabel1 = gitlab.GroupLabel(\"label_1\",\n    group=example.id,\n    color=\"#FF0000\",\n    name=\"red-label\")\nlabel3 = gitlab.GroupLabel(\"label_3\",\n    group=example.id,\n    name=\"label-3\",\n    color=\"#003000\")\nepic_board = gitlab.GroupEpicBoard(\"epic_board\",\n    name=\"epic board 6\",\n    group=example.path,\n    lists=[{\n        \"label_id\": label1.label_id,\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new GitLab.Group(\"example\", new()\n    {\n        Name = \"test_group\",\n        Path = \"test_group\",\n        Description = \"An example group\",\n    });\n\n    var label1 = new GitLab.GroupLabel(\"label_1\", new()\n    {\n        Group = example.Id,\n        Color = \"#FF0000\",\n        Name = \"red-label\",\n    });\n\n    var label3 = new GitLab.GroupLabel(\"label_3\", new()\n    {\n        Group = example.Id,\n        Name = \"label-3\",\n        Color = \"#003000\",\n    });\n\n    var epicBoard = new GitLab.GroupEpicBoard(\"epic_board\", new()\n    {\n        Name = \"epic board 6\",\n        Group = example.Path,\n        Lists = new[]\n        {\n            new GitLab.Inputs.GroupEpicBoardListArgs\n            {\n                LabelId = label1.LabelId,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := gitlab.NewGroup(ctx, \"example\", \u0026gitlab.GroupArgs{\n\t\t\tName:        pulumi.String(\"test_group\"),\n\t\t\tPath:        pulumi.String(\"test_group\"),\n\t\t\tDescription: pulumi.String(\"An example group\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tlabel1, err := gitlab.NewGroupLabel(ctx, \"label_1\", \u0026gitlab.GroupLabelArgs{\n\t\t\tGroup: example.ID(),\n\t\t\tColor: pulumi.String(\"#FF0000\"),\n\t\t\tName:  pulumi.String(\"red-label\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewGroupLabel(ctx, \"label_3\", \u0026gitlab.GroupLabelArgs{\n\t\t\tGroup: example.ID(),\n\t\t\tName:  pulumi.String(\"label-3\"),\n\t\t\tColor: pulumi.String(\"#003000\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewGroupEpicBoard(ctx, \"epic_board\", \u0026gitlab.GroupEpicBoardArgs{\n\t\t\tName:  pulumi.String(\"epic board 6\"),\n\t\t\tGroup: example.Path,\n\t\t\tLists: gitlab.GroupEpicBoardListArray{\n\t\t\t\t\u0026gitlab.GroupEpicBoardListArgs{\n\t\t\t\t\tLabelId: label1.LabelId,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Group;\nimport com.pulumi.gitlab.GroupArgs;\nimport com.pulumi.gitlab.GroupLabel;\nimport com.pulumi.gitlab.GroupLabelArgs;\nimport com.pulumi.gitlab.GroupEpicBoard;\nimport com.pulumi.gitlab.GroupEpicBoardArgs;\nimport com.pulumi.gitlab.inputs.GroupEpicBoardListArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new Group(\"example\", GroupArgs.builder()\n            .name(\"test_group\")\n            .path(\"test_group\")\n            .description(\"An example group\")\n            .build());\n\n        var label1 = new GroupLabel(\"label1\", GroupLabelArgs.builder()\n            .group(example.id())\n            .color(\"#FF0000\")\n            .name(\"red-label\")\n            .build());\n\n        var label3 = new GroupLabel(\"label3\", GroupLabelArgs.builder()\n            .group(example.id())\n            .name(\"label-3\")\n            .color(\"#003000\")\n            .build());\n\n        var epicBoard = new GroupEpicBoard(\"epicBoard\", GroupEpicBoardArgs.builder()\n            .name(\"epic board 6\")\n            .group(example.path())\n            .lists(GroupEpicBoardListArgs.builder()\n                .labelId(label1.labelId())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: gitlab:Group\n    properties:\n      name: test_group\n      path: test_group\n      description: An example group\n  label1:\n    type: gitlab:GroupLabel\n    name: label_1\n    properties:\n      group: ${example.id}\n      color: '#FF0000'\n      name: red-label\n  label3:\n    type: gitlab:GroupLabel\n    name: label_3\n    properties:\n      group: ${example.id}\n      name: label-3\n      color: '#003000'\n  epicBoard:\n    type: gitlab:GroupEpicBoard\n    name: epic_board\n    properties:\n      name: epic board 6\n      group: ${example.path}\n      lists:\n        - labelId: ${label1.labelId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_group_epic_board`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_group_epic_board.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nYou can import this resource with an id made up of `{group-id}:{epic-board-id}`, e.g.\n\n```sh\n$ pulumi import gitlab:index/groupEpicBoard:GroupEpicBoard agile 70:156\n```\n\n",
            "properties": {
                "group": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the group owned by the authenticated user.\n"
                },
                "lists": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/GroupEpicBoardList:GroupEpicBoardList"
                    },
                    "description": "The list of epic board lists.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the board.\n"
                }
            },
            "required": [
                "group",
                "name"
            ],
            "inputProperties": {
                "group": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the group owned by the authenticated user.\n"
                },
                "lists": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/GroupEpicBoardList:GroupEpicBoardList"
                    },
                    "description": "The list of epic board lists.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the board.\n"
                }
            },
            "requiredInputs": [
                "group"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupEpicBoard resources.\n",
                "properties": {
                    "group": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the group owned by the authenticated user.\n"
                    },
                    "lists": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/GroupEpicBoardList:GroupEpicBoardList"
                        },
                        "description": "The list of epic board lists.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the board.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupHook:GroupHook": {
            "description": "The `gitlab.GroupHook` resource allows to manage the lifecycle of a group hook.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/groups.html#hooks)\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_group_hook`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_group_hook.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nA GitLab Group Hook can be imported using a key composed of `\u003cgroup-id\u003e:\u003chook-id\u003e`, e.g.\n\n```sh\n$ pulumi import gitlab:index/groupHook:GroupHook example \"12345:1\"\n```\n\nNOTE: the `token` resource attribute is not available for imported resources as this information cannot be read from the GitLab API.\n\n",
            "properties": {
                "confidentialIssuesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for confidential issues events.\n"
                },
                "confidentialNoteEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for confidential note events.\n"
                },
                "customHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/GroupHookCustomHeader:GroupHookCustomHeader"
                    },
                    "description": "Custom headers for the project webhook.\n"
                },
                "customWebhookTemplate": {
                    "type": "string",
                    "description": "Custom webhook template.\n"
                },
                "deploymentEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for deployment events.\n"
                },
                "enableSslVerification": {
                    "type": "boolean",
                    "description": "Enable SSL verification when invoking the hook.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The full path or id of the group to add the hook to.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The id of the group for the hook.\n"
                },
                "hookId": {
                    "type": "integer",
                    "description": "The id of the group hook.\n"
                },
                "issuesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for issues events.\n"
                },
                "jobEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for job events.\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for merge requests events.\n"
                },
                "noteEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for note events.\n"
                },
                "pipelineEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for pipeline events.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for push events.\n"
                },
                "pushEventsBranchFilter": {
                    "type": "string",
                    "description": "Invoke the hook for push events on matching branches only.\n"
                },
                "releasesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for release events.\n"
                },
                "subgroupEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for subgroup events.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for tag push events.\n"
                },
                "token": {
                    "type": "string",
                    "description": "A token to present when invoking the hook. The token is not available for imported resources.\n",
                    "secret": true
                },
                "url": {
                    "type": "string",
                    "description": "The url of the hook to invoke. Forces re-creation to preserve `token`.\n"
                },
                "wikiPageEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for wiki page events.\n"
                }
            },
            "required": [
                "confidentialIssuesEvents",
                "confidentialNoteEvents",
                "customWebhookTemplate",
                "deploymentEvents",
                "enableSslVerification",
                "group",
                "groupId",
                "hookId",
                "issuesEvents",
                "jobEvents",
                "mergeRequestsEvents",
                "noteEvents",
                "pipelineEvents",
                "pushEvents",
                "pushEventsBranchFilter",
                "releasesEvents",
                "subgroupEvents",
                "tagPushEvents",
                "token",
                "url",
                "wikiPageEvents"
            ],
            "inputProperties": {
                "confidentialIssuesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for confidential issues events.\n"
                },
                "confidentialNoteEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for confidential note events.\n"
                },
                "customHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/GroupHookCustomHeader:GroupHookCustomHeader"
                    },
                    "description": "Custom headers for the project webhook.\n"
                },
                "customWebhookTemplate": {
                    "type": "string",
                    "description": "Custom webhook template.\n"
                },
                "deploymentEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for deployment events.\n"
                },
                "enableSslVerification": {
                    "type": "boolean",
                    "description": "Enable SSL verification when invoking the hook.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The full path or id of the group to add the hook to.\n"
                },
                "issuesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for issues events.\n"
                },
                "jobEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for job events.\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for merge requests events.\n"
                },
                "noteEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for note events.\n"
                },
                "pipelineEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for pipeline events.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for push events.\n"
                },
                "pushEventsBranchFilter": {
                    "type": "string",
                    "description": "Invoke the hook for push events on matching branches only.\n"
                },
                "releasesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for release events.\n"
                },
                "subgroupEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for subgroup events.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for tag push events.\n"
                },
                "token": {
                    "type": "string",
                    "description": "A token to present when invoking the hook. The token is not available for imported resources.\n",
                    "secret": true
                },
                "url": {
                    "type": "string",
                    "description": "The url of the hook to invoke. Forces re-creation to preserve `token`.\n"
                },
                "wikiPageEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for wiki page events.\n"
                }
            },
            "requiredInputs": [
                "group",
                "url"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupHook resources.\n",
                "properties": {
                    "confidentialIssuesEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for confidential issues events.\n"
                    },
                    "confidentialNoteEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for confidential note events.\n"
                    },
                    "customHeaders": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/GroupHookCustomHeader:GroupHookCustomHeader"
                        },
                        "description": "Custom headers for the project webhook.\n"
                    },
                    "customWebhookTemplate": {
                        "type": "string",
                        "description": "Custom webhook template.\n"
                    },
                    "deploymentEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for deployment events.\n"
                    },
                    "enableSslVerification": {
                        "type": "boolean",
                        "description": "Enable SSL verification when invoking the hook.\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "The full path or id of the group to add the hook to.\n"
                    },
                    "groupId": {
                        "type": "integer",
                        "description": "The id of the group for the hook.\n"
                    },
                    "hookId": {
                        "type": "integer",
                        "description": "The id of the group hook.\n"
                    },
                    "issuesEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for issues events.\n"
                    },
                    "jobEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for job events.\n"
                    },
                    "mergeRequestsEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for merge requests events.\n"
                    },
                    "noteEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for note events.\n"
                    },
                    "pipelineEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for pipeline events.\n"
                    },
                    "pushEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for push events.\n"
                    },
                    "pushEventsBranchFilter": {
                        "type": "string",
                        "description": "Invoke the hook for push events on matching branches only.\n"
                    },
                    "releasesEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for release events.\n"
                    },
                    "subgroupEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for subgroup events.\n"
                    },
                    "tagPushEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for tag push events.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "A token to present when invoking the hook. The token is not available for imported resources.\n",
                        "secret": true
                    },
                    "url": {
                        "type": "string",
                        "description": "The url of the hook to invoke. Forces re-creation to preserve `token`.\n"
                    },
                    "wikiPageEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for wiki page events.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupIssueBoard:GroupIssueBoard": {
            "description": "The `gitlab.GroupIssueBoard` resource allows to manage the lifecycle of a issue board in a group.\n\n\u003e Multiple issue boards on one group requires a GitLab Premium or above License.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/group_boards.html)\n",
            "properties": {
                "group": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the group owned by the authenticated user.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of label names which the board should be scoped to.\n"
                },
                "lists": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/GroupIssueBoardList:GroupIssueBoardList"
                    },
                    "description": "The list of issue board lists.\n"
                },
                "milestoneId": {
                    "type": "integer",
                    "description": "The milestone the board should be scoped to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the board.\n"
                }
            },
            "required": [
                "group",
                "name"
            ],
            "inputProperties": {
                "group": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the group owned by the authenticated user.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of label names which the board should be scoped to.\n"
                },
                "lists": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/GroupIssueBoardList:GroupIssueBoardList"
                    },
                    "description": "The list of issue board lists.\n"
                },
                "milestoneId": {
                    "type": "integer",
                    "description": "The milestone the board should be scoped to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the board.\n"
                }
            },
            "requiredInputs": [
                "group"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupIssueBoard resources.\n",
                "properties": {
                    "group": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the group owned by the authenticated user.\n"
                    },
                    "labels": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of label names which the board should be scoped to.\n"
                    },
                    "lists": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/GroupIssueBoardList:GroupIssueBoardList"
                        },
                        "description": "The list of issue board lists.\n"
                    },
                    "milestoneId": {
                        "type": "integer",
                        "description": "The milestone the board should be scoped to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the board.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupLabel:GroupLabel": {
            "description": "The `gitlab.GroupLabel` resource allows to manage the lifecycle of labels within a group.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/user/project/labels.html#group-labels)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst fixme = new gitlab.GroupLabel(\"fixme\", {\n    group: \"example\",\n    name: \"fixme\",\n    description: \"issue with failing tests\",\n    color: \"#ffcc00\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfixme = gitlab.GroupLabel(\"fixme\",\n    group=\"example\",\n    name=\"fixme\",\n    description=\"issue with failing tests\",\n    color=\"#ffcc00\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var fixme = new GitLab.GroupLabel(\"fixme\", new()\n    {\n        Group = \"example\",\n        Name = \"fixme\",\n        Description = \"issue with failing tests\",\n        Color = \"#ffcc00\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewGroupLabel(ctx, \"fixme\", \u0026gitlab.GroupLabelArgs{\n\t\t\tGroup:       pulumi.String(\"example\"),\n\t\t\tName:        pulumi.String(\"fixme\"),\n\t\t\tDescription: pulumi.String(\"issue with failing tests\"),\n\t\t\tColor:       pulumi.String(\"#ffcc00\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GroupLabel;\nimport com.pulumi.gitlab.GroupLabelArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var fixme = new GroupLabel(\"fixme\", GroupLabelArgs.builder()\n            .group(\"example\")\n            .name(\"fixme\")\n            .description(\"issue with failing tests\")\n            .color(\"#ffcc00\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  fixme:\n    type: gitlab:GroupLabel\n    properties:\n      group: example\n      name: fixme\n      description: issue with failing tests\n      color: '#ffcc00'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_group_label`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_group_label.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitlab group labels can be imported using an id made up of `{group_id}:{group_label_id}`, e.g.\n\n```sh\n$ pulumi import gitlab:index/groupLabel:GroupLabel example 12345:fixme\n```\n\n",
            "properties": {
                "color": {
                    "type": "string",
                    "description": "The color of the label given in 6-digit hex notation with leading '#' sign (e.g. #FFAABB) or one of the [CSS color names](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords).\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the label.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The name or id of the group to add the label to.\n"
                },
                "labelId": {
                    "type": "integer",
                    "description": "The id of the group label.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the label.\n"
                }
            },
            "required": [
                "color",
                "group",
                "labelId",
                "name"
            ],
            "inputProperties": {
                "color": {
                    "type": "string",
                    "description": "The color of the label given in 6-digit hex notation with leading '#' sign (e.g. #FFAABB) or one of the [CSS color names](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords).\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the label.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The name or id of the group to add the label to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the label.\n"
                }
            },
            "requiredInputs": [
                "color",
                "group"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupLabel resources.\n",
                "properties": {
                    "color": {
                        "type": "string",
                        "description": "The color of the label given in 6-digit hex notation with leading '#' sign (e.g. #FFAABB) or one of the [CSS color names](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords).\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the label.\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "The name or id of the group to add the label to.\n"
                    },
                    "labelId": {
                        "type": "integer",
                        "description": "The id of the group label.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the label.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupLdapLink:GroupLdapLink": {
            "description": "The `gitlab.GroupLdapLink` resource allows to manage the lifecycle of an LDAP integration with a group.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/groups.html#ldap-group-links)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nresources:\n  test:\n    type: gitlab:GroupLdapLink\n    properties:\n      groupId: '12345'\n      cn: testuser\n      groupAccess: developer\n      ldapProvider: ldapmain\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_group_ldap_link`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_group_ldap_link.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab group ldap links can be imported using an id made up of `group_id:ldap_provider:cn:filter`. CN and Filter are mutually exclusive, so one will be missing.\n\nIf using the CN for the group link, the ID will end with a blank filter (\":\"). e.g.,\n\n```sh\n$ pulumi import gitlab:index/groupLdapLink:GroupLdapLink test \"12345:ldapmain:testcn:\"\n```\n\nIf using the Filter for the group link, the ID will have two \"::\" in the middle due to having a blank CN. e.g.,\n\n```sh\n$ pulumi import gitlab:index/groupLdapLink:GroupLdapLink test \"12345:ldapmain::testfilter\"\n```\n\n",
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Minimum access level for members of the LDAP group. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`\n",
                    "deprecationMessage": "Use `group_access` instead of the `access_level` attribute."
                },
                "cn": {
                    "type": "string",
                    "description": "The CN of the LDAP group to link with. Required if `filter` is not provided.\n"
                },
                "filter": {
                    "type": "string",
                    "description": "The LDAP filter for the group. Required if `cn` is not provided. Requires GitLab Premium or above.\n"
                },
                "force": {
                    "type": "boolean",
                    "description": "If true, then delete and replace an existing LDAP link if one exists. Will also remove an LDAP link if the parent group is not found.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the group\n"
                },
                "groupAccess": {
                    "type": "string",
                    "description": "Minimum access level for members of the LDAP group. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`\n"
                },
                "ldapProvider": {
                    "type": "string",
                    "description": "The name of the LDAP provider as stored in the GitLab database. Note that this is NOT the value of the `label` attribute as shown in the web UI. In most cases this will be `ldapmain` but you may use the [LDAP check rake task](https://docs.gitlab.com/ee/administration/raketasks/ldap.html#check) for receiving the LDAP server name: `LDAP: ... Server: ldapmain`\n"
                }
            },
            "required": [
                "cn",
                "filter",
                "group",
                "ldapProvider"
            ],
            "inputProperties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Minimum access level for members of the LDAP group. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`\n",
                    "deprecationMessage": "Use `group_access` instead of the `access_level` attribute.",
                    "willReplaceOnChanges": true
                },
                "cn": {
                    "type": "string",
                    "description": "The CN of the LDAP group to link with. Required if `filter` is not provided.\n",
                    "willReplaceOnChanges": true
                },
                "filter": {
                    "type": "string",
                    "description": "The LDAP filter for the group. Required if `cn` is not provided. Requires GitLab Premium or above.\n",
                    "willReplaceOnChanges": true
                },
                "force": {
                    "type": "boolean",
                    "description": "If true, then delete and replace an existing LDAP link if one exists. Will also remove an LDAP link if the parent group is not found.\n",
                    "willReplaceOnChanges": true
                },
                "group": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the group\n",
                    "willReplaceOnChanges": true
                },
                "groupAccess": {
                    "type": "string",
                    "description": "Minimum access level for members of the LDAP group. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`\n",
                    "willReplaceOnChanges": true
                },
                "ldapProvider": {
                    "type": "string",
                    "description": "The name of the LDAP provider as stored in the GitLab database. Note that this is NOT the value of the `label` attribute as shown in the web UI. In most cases this will be `ldapmain` but you may use the [LDAP check rake task](https://docs.gitlab.com/ee/administration/raketasks/ldap.html#check) for receiving the LDAP server name: `LDAP: ... Server: ldapmain`\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "group",
                "ldapProvider"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupLdapLink resources.\n",
                "properties": {
                    "accessLevel": {
                        "type": "string",
                        "description": "Minimum access level for members of the LDAP group. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`\n",
                        "deprecationMessage": "Use `group_access` instead of the `access_level` attribute.",
                        "willReplaceOnChanges": true
                    },
                    "cn": {
                        "type": "string",
                        "description": "The CN of the LDAP group to link with. Required if `filter` is not provided.\n",
                        "willReplaceOnChanges": true
                    },
                    "filter": {
                        "type": "string",
                        "description": "The LDAP filter for the group. Required if `cn` is not provided. Requires GitLab Premium or above.\n",
                        "willReplaceOnChanges": true
                    },
                    "force": {
                        "type": "boolean",
                        "description": "If true, then delete and replace an existing LDAP link if one exists. Will also remove an LDAP link if the parent group is not found.\n",
                        "willReplaceOnChanges": true
                    },
                    "group": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the group\n",
                        "willReplaceOnChanges": true
                    },
                    "groupAccess": {
                        "type": "string",
                        "description": "Minimum access level for members of the LDAP group. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`\n",
                        "willReplaceOnChanges": true
                    },
                    "ldapProvider": {
                        "type": "string",
                        "description": "The name of the LDAP provider as stored in the GitLab database. Note that this is NOT the value of the `label` attribute as shown in the web UI. In most cases this will be `ldapmain` but you may use the [LDAP check rake task](https://docs.gitlab.com/ee/administration/raketasks/ldap.html#check) for receiving the LDAP server name: `LDAP: ... Server: ldapmain`\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupMembership:GroupMembership": {
            "description": "The `gitlab.GroupMembership` resource allows to manage the lifecycle of a users group membership.\n\n\u003e If a group should grant membership to another group use the `gitlab.GroupShareGroup` resource instead.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/members.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst test = new gitlab.GroupMembership(\"test\", {\n    groupId: \"12345\",\n    userId: 1337,\n    accessLevel: \"guest\",\n    expiresAt: \"2020-12-31\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\ntest = gitlab.GroupMembership(\"test\",\n    group_id=\"12345\",\n    user_id=1337,\n    access_level=\"guest\",\n    expires_at=\"2020-12-31\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new GitLab.GroupMembership(\"test\", new()\n    {\n        GroupId = \"12345\",\n        UserId = 1337,\n        AccessLevel = \"guest\",\n        ExpiresAt = \"2020-12-31\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewGroupMembership(ctx, \"test\", \u0026gitlab.GroupMembershipArgs{\n\t\t\tGroupId:     pulumi.String(\"12345\"),\n\t\t\tUserId:      pulumi.Int(1337),\n\t\t\tAccessLevel: pulumi.String(\"guest\"),\n\t\t\tExpiresAt:   pulumi.String(\"2020-12-31\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GroupMembership;\nimport com.pulumi.gitlab.GroupMembershipArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new GroupMembership(\"test\", GroupMembershipArgs.builder()\n            .groupId(\"12345\")\n            .userId(1337)\n            .accessLevel(\"guest\")\n            .expiresAt(\"2020-12-31\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: gitlab:GroupMembership\n    properties:\n      groupId: '12345'\n      userId: 1337\n      accessLevel: guest\n      expiresAt: 2020-12-31\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_group_membership`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_group_membership.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab group membership can be imported using an id made up of `group_id:user_id`, e.g.\n\n```sh\n$ pulumi import gitlab:index/groupMembership:GroupMembership test \"12345:1337\"\n```\n\n",
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Access level for the member. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "Expiration date for the group membership. Format: `YYYY-MM-DD`\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "The id of the group.\n"
                },
                "memberRoleId": {
                    "type": "integer",
                    "description": "The ID of a custom member role. Only available for Ultimate instances.\n"
                },
                "skipSubresourcesOnDestroy": {
                    "type": "boolean",
                    "description": "Whether the deletion of direct memberships of the removed member in subgroups and projects should be skipped. Only used during a destroy.\n"
                },
                "unassignIssuablesOnDestroy": {
                    "type": "boolean",
                    "description": "Whether the removed member should be unassigned from any issues or merge requests inside a given group or project. Only used during a destroy.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The id of the user.\n"
                }
            },
            "required": [
                "accessLevel",
                "groupId",
                "userId"
            ],
            "inputProperties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Access level for the member. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "Expiration date for the group membership. Format: `YYYY-MM-DD`\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "The id of the group.\n",
                    "willReplaceOnChanges": true
                },
                "memberRoleId": {
                    "type": "integer",
                    "description": "The ID of a custom member role. Only available for Ultimate instances.\n"
                },
                "skipSubresourcesOnDestroy": {
                    "type": "boolean",
                    "description": "Whether the deletion of direct memberships of the removed member in subgroups and projects should be skipped. Only used during a destroy.\n"
                },
                "unassignIssuablesOnDestroy": {
                    "type": "boolean",
                    "description": "Whether the removed member should be unassigned from any issues or merge requests inside a given group or project. Only used during a destroy.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The id of the user.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accessLevel",
                "groupId",
                "userId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupMembership resources.\n",
                "properties": {
                    "accessLevel": {
                        "type": "string",
                        "description": "Access level for the member. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "Expiration date for the group membership. Format: `YYYY-MM-DD`\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "The id of the group.\n",
                        "willReplaceOnChanges": true
                    },
                    "memberRoleId": {
                        "type": "integer",
                        "description": "The ID of a custom member role. Only available for Ultimate instances.\n"
                    },
                    "skipSubresourcesOnDestroy": {
                        "type": "boolean",
                        "description": "Whether the deletion of direct memberships of the removed member in subgroups and projects should be skipped. Only used during a destroy.\n"
                    },
                    "unassignIssuablesOnDestroy": {
                        "type": "boolean",
                        "description": "Whether the removed member should be unassigned from any issues or merge requests inside a given group or project. Only used during a destroy.\n"
                    },
                    "userId": {
                        "type": "integer",
                        "description": "The id of the user.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupProjectFileTemplate:GroupProjectFileTemplate": {
            "description": "The `gitlab.GroupProjectFileTemplate` resource allows setting a project from which\ncustom file templates will be loaded. In order to use this resource, the project selected must be a direct child of\nthe group selected. After the resource has run, `gitlab_project_template.template_project_id` is available for use.\nFor more information about which file types are available as templates, view \n[GitLab's documentation](https://docs.gitlab.com/ee/user/group/custom_project_templates.html)\n\n\u003e This resource requires a GitLab Enterprise instance with a Premium license.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/groups.html#update-group)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = new gitlab.Group(\"foo\", {\n    name: \"group\",\n    path: \"group\",\n    description: \"An example group\",\n});\nconst bar = new gitlab.Project(\"bar\", {\n    name: \"template project\",\n    description: \"contains file templates\",\n    visibilityLevel: \"public\",\n    namespaceId: foo.id,\n});\nconst templateLink = new gitlab.GroupProjectFileTemplate(\"template_link\", {\n    groupId: foo.id,\n    fileTemplateProjectId: bar.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.Group(\"foo\",\n    name=\"group\",\n    path=\"group\",\n    description=\"An example group\")\nbar = gitlab.Project(\"bar\",\n    name=\"template project\",\n    description=\"contains file templates\",\n    visibility_level=\"public\",\n    namespace_id=foo.id)\ntemplate_link = gitlab.GroupProjectFileTemplate(\"template_link\",\n    group_id=foo.id,\n    file_template_project_id=bar.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = new GitLab.Group(\"foo\", new()\n    {\n        Name = \"group\",\n        Path = \"group\",\n        Description = \"An example group\",\n    });\n\n    var bar = new GitLab.Project(\"bar\", new()\n    {\n        Name = \"template project\",\n        Description = \"contains file templates\",\n        VisibilityLevel = \"public\",\n        NamespaceId = foo.Id,\n    });\n\n    var templateLink = new GitLab.GroupProjectFileTemplate(\"template_link\", new()\n    {\n        GroupId = foo.Id,\n        FileTemplateProjectId = bar.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfoo, err := gitlab.NewGroup(ctx, \"foo\", \u0026gitlab.GroupArgs{\n\t\t\tName:        pulumi.String(\"group\"),\n\t\t\tPath:        pulumi.String(\"group\"),\n\t\t\tDescription: pulumi.String(\"An example group\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tbar, err := gitlab.NewProject(ctx, \"bar\", \u0026gitlab.ProjectArgs{\n\t\t\tName:            pulumi.String(\"template project\"),\n\t\t\tDescription:     pulumi.String(\"contains file templates\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t\tNamespaceId:     foo.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewGroupProjectFileTemplate(ctx, \"template_link\", \u0026gitlab.GroupProjectFileTemplateArgs{\n\t\t\tGroupId:               foo.ID(),\n\t\t\tFileTemplateProjectId: bar.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Group;\nimport com.pulumi.gitlab.GroupArgs;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.GroupProjectFileTemplate;\nimport com.pulumi.gitlab.GroupProjectFileTemplateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var foo = new Group(\"foo\", GroupArgs.builder()\n            .name(\"group\")\n            .path(\"group\")\n            .description(\"An example group\")\n            .build());\n\n        var bar = new Project(\"bar\", ProjectArgs.builder()\n            .name(\"template project\")\n            .description(\"contains file templates\")\n            .visibilityLevel(\"public\")\n            .namespaceId(foo.id())\n            .build());\n\n        var templateLink = new GroupProjectFileTemplate(\"templateLink\", GroupProjectFileTemplateArgs.builder()\n            .groupId(foo.id())\n            .fileTemplateProjectId(bar.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  foo:\n    type: gitlab:Group\n    properties:\n      name: group\n      path: group\n      description: An example group\n  bar:\n    type: gitlab:Project\n    properties:\n      name: template project\n      description: contains file templates\n      visibilityLevel: public\n      namespaceId: ${foo.id}\n  templateLink:\n    type: gitlab:GroupProjectFileTemplate\n    name: template_link\n    properties:\n      groupId: ${foo.id}\n      fileTemplateProjectId: ${bar.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "fileTemplateProjectId": {
                    "type": "integer",
                    "description": "The ID of the project that will be used for file templates. This project must be the direct\n\t\t\tchild of the project defined by the group_id\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of the group that will use the file template project. This group must be the direct\n            parent of the project defined by project_id\n"
                }
            },
            "required": [
                "fileTemplateProjectId",
                "groupId"
            ],
            "inputProperties": {
                "fileTemplateProjectId": {
                    "type": "integer",
                    "description": "The ID of the project that will be used for file templates. This project must be the direct\n\t\t\tchild of the project defined by the group_id\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of the group that will use the file template project. This group must be the direct\n            parent of the project defined by project_id\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "fileTemplateProjectId",
                "groupId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupProjectFileTemplate resources.\n",
                "properties": {
                    "fileTemplateProjectId": {
                        "type": "integer",
                        "description": "The ID of the project that will be used for file templates. This project must be the direct\n\t\t\tchild of the project defined by the group_id\n"
                    },
                    "groupId": {
                        "type": "integer",
                        "description": "The ID of the group that will use the file template project. This group must be the direct\n            parent of the project defined by project_id\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupProtectedEnvironment:GroupProtectedEnvironment": {
            "description": "The `gitlab.GroupProtectedEnvironment` resource allows to manage the lifecycle of a protected environment in a group.\n\n\u003e In order to use a user_id in the `deploy_access_levels` configuration,\n   you need to make sure that users have access to the group with Maintainer role or higher.\n   In order to use a group_id in the `deploy_access_levels` configuration,\n   the group_id must be a sub-group under the given group.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/group_protected_environments.html)\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_group_protected_environment`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_group_protected_environment.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab group protected environments can be imported using an id made up of `groupId:environmentName`, e.g.\n\n```sh\n$ pulumi import gitlab:index/groupProtectedEnvironment:GroupProtectedEnvironment bar 123:production\n```\n\n",
            "properties": {
                "approvalRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/GroupProtectedEnvironmentApprovalRule:GroupProtectedEnvironmentApprovalRule"
                    },
                    "description": "Array of approval rules to deploy, with each described by a hash. Elements in the `approval_rules` should be one of `user_id`, `group_id` or `access_level`.\n"
                },
                "deployAccessLevels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/GroupProtectedEnvironmentDeployAccessLevel:GroupProtectedEnvironmentDeployAccessLevel"
                    },
                    "description": "Array of access levels allowed to deploy, with each described by a hash. Elements in the `deploy_access_levels` should be one of `user_id`, `group_id` or `access_level`.\n"
                },
                "environment": {
                    "type": "string",
                    "description": "The deployment tier of the environment.  Valid values are `production`, `staging`, `testing`, `development`, `other`.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The ID or full path of the group which the protected environment is created against.\n"
                }
            },
            "required": [
                "approvalRules",
                "deployAccessLevels",
                "environment",
                "group"
            ],
            "inputProperties": {
                "approvalRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/GroupProtectedEnvironmentApprovalRule:GroupProtectedEnvironmentApprovalRule"
                    },
                    "description": "Array of approval rules to deploy, with each described by a hash. Elements in the `approval_rules` should be one of `user_id`, `group_id` or `access_level`.\n"
                },
                "deployAccessLevels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/GroupProtectedEnvironmentDeployAccessLevel:GroupProtectedEnvironmentDeployAccessLevel"
                    },
                    "description": "Array of access levels allowed to deploy, with each described by a hash. Elements in the `deploy_access_levels` should be one of `user_id`, `group_id` or `access_level`.\n"
                },
                "environment": {
                    "type": "string",
                    "description": "The deployment tier of the environment.  Valid values are `production`, `staging`, `testing`, `development`, `other`.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The ID or full path of the group which the protected environment is created against.\n"
                }
            },
            "requiredInputs": [
                "deployAccessLevels",
                "environment",
                "group"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupProtectedEnvironment resources.\n",
                "properties": {
                    "approvalRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/GroupProtectedEnvironmentApprovalRule:GroupProtectedEnvironmentApprovalRule"
                        },
                        "description": "Array of approval rules to deploy, with each described by a hash. Elements in the `approval_rules` should be one of `user_id`, `group_id` or `access_level`.\n"
                    },
                    "deployAccessLevels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/GroupProtectedEnvironmentDeployAccessLevel:GroupProtectedEnvironmentDeployAccessLevel"
                        },
                        "description": "Array of access levels allowed to deploy, with each described by a hash. Elements in the `deploy_access_levels` should be one of `user_id`, `group_id` or `access_level`.\n"
                    },
                    "environment": {
                        "type": "string",
                        "description": "The deployment tier of the environment.  Valid values are `production`, `staging`, `testing`, `development`, `other`.\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "The ID or full path of the group which the protected environment is created against.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupSamlLink:GroupSamlLink": {
            "description": "The `gitlab.GroupSamlLink` resource allows to manage the lifecycle of an SAML integration with a group.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/groups.html#saml-group-links)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\n// Basic example\nconst test = new gitlab.GroupSamlLink(\"test\", {\n    group: \"12345\",\n    accessLevel: \"developer\",\n    samlGroupName: \"samlgroupname1\",\n});\n// Example using a Custom Role (Ultimate only)\n// When using the custom role, the `access_level` must match the\n// base role used to create the custom role.\nconst testCustomRole = new gitlab.GroupSamlLink(\"test_custom_role\", {\n    group: \"12345\",\n    accessLevel: \"developer\",\n    samlGroupName: \"samlgroupname1\",\n    memberRoleId: 123,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\n# Basic example\ntest = gitlab.GroupSamlLink(\"test\",\n    group=\"12345\",\n    access_level=\"developer\",\n    saml_group_name=\"samlgroupname1\")\n# Example using a Custom Role (Ultimate only)\n# When using the custom role, the `access_level` must match the\n# base role used to create the custom role.\ntest_custom_role = gitlab.GroupSamlLink(\"test_custom_role\",\n    group=\"12345\",\n    access_level=\"developer\",\n    saml_group_name=\"samlgroupname1\",\n    member_role_id=123)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Basic example\n    var test = new GitLab.GroupSamlLink(\"test\", new()\n    {\n        Group = \"12345\",\n        AccessLevel = \"developer\",\n        SamlGroupName = \"samlgroupname1\",\n    });\n\n    // Example using a Custom Role (Ultimate only)\n    // When using the custom role, the `access_level` must match the\n    // base role used to create the custom role.\n    var testCustomRole = new GitLab.GroupSamlLink(\"test_custom_role\", new()\n    {\n        Group = \"12345\",\n        AccessLevel = \"developer\",\n        SamlGroupName = \"samlgroupname1\",\n        MemberRoleId = 123,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Basic example\n\t\t_, err := gitlab.NewGroupSamlLink(ctx, \"test\", \u0026gitlab.GroupSamlLinkArgs{\n\t\t\tGroup:         pulumi.String(\"12345\"),\n\t\t\tAccessLevel:   pulumi.String(\"developer\"),\n\t\t\tSamlGroupName: pulumi.String(\"samlgroupname1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Example using a Custom Role (Ultimate only)\n\t\t// When using the custom role, the `access_level` must match the\n\t\t// base role used to create the custom role.\n\t\t_, err = gitlab.NewGroupSamlLink(ctx, \"test_custom_role\", \u0026gitlab.GroupSamlLinkArgs{\n\t\t\tGroup:         pulumi.String(\"12345\"),\n\t\t\tAccessLevel:   pulumi.String(\"developer\"),\n\t\t\tSamlGroupName: pulumi.String(\"samlgroupname1\"),\n\t\t\tMemberRoleId:  pulumi.Int(123),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GroupSamlLink;\nimport com.pulumi.gitlab.GroupSamlLinkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Basic example\n        var test = new GroupSamlLink(\"test\", GroupSamlLinkArgs.builder()\n            .group(\"12345\")\n            .accessLevel(\"developer\")\n            .samlGroupName(\"samlgroupname1\")\n            .build());\n\n        // Example using a Custom Role (Ultimate only)\n        // When using the custom role, the `access_level` must match the\n        // base role used to create the custom role.\n        var testCustomRole = new GroupSamlLink(\"testCustomRole\", GroupSamlLinkArgs.builder()\n            .group(\"12345\")\n            .accessLevel(\"developer\")\n            .samlGroupName(\"samlgroupname1\")\n            .memberRoleId(123)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Basic example\n  test:\n    type: gitlab:GroupSamlLink\n    properties:\n      group: '12345'\n      accessLevel: developer\n      samlGroupName: samlgroupname1\n  # Example using a Custom Role (Ultimate only)\n  # When using the custom role, the `access_level` must match the\n  # base role used to create the custom role.\n  testCustomRole:\n    type: gitlab:GroupSamlLink\n    name: test_custom_role\n    properties:\n      group: '12345'\n      accessLevel: developer\n      samlGroupName: samlgroupname1\n      memberRoleId: 123\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_group_saml_link`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_group_saml_link.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab group saml links can be imported using an id made up of `group_id:saml_group_name`, e.g.\n\n```sh\n$ pulumi import gitlab:index/groupSamlLink:GroupSamlLink test \"12345:samlgroupname1\"\n```\n\n",
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Access level for members of the SAML group. Valid values are: `guest`, `reporter`, `developer`, `maintainer`, `owner`.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The ID or path of the group to add the SAML Group Link to.\n"
                },
                "memberRoleId": {
                    "type": "integer",
                    "description": "The ID of a custom member role. Only available for Ultimate instances. When using a custom role, the `access_level` must match the base role used to create the custom role.\n"
                },
                "samlGroupName": {
                    "type": "string",
                    "description": "The name of the SAML group.\n"
                }
            },
            "required": [
                "accessLevel",
                "group",
                "samlGroupName"
            ],
            "inputProperties": {
                "accessLevel": {
                    "type": "string",
                    "description": "Access level for members of the SAML group. Valid values are: `guest`, `reporter`, `developer`, `maintainer`, `owner`.\n",
                    "willReplaceOnChanges": true
                },
                "group": {
                    "type": "string",
                    "description": "The ID or path of the group to add the SAML Group Link to.\n",
                    "willReplaceOnChanges": true
                },
                "memberRoleId": {
                    "type": "integer",
                    "description": "The ID of a custom member role. Only available for Ultimate instances. When using a custom role, the `access_level` must match the base role used to create the custom role.\n",
                    "willReplaceOnChanges": true
                },
                "samlGroupName": {
                    "type": "string",
                    "description": "The name of the SAML group.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accessLevel",
                "group",
                "samlGroupName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupSamlLink resources.\n",
                "properties": {
                    "accessLevel": {
                        "type": "string",
                        "description": "Access level for members of the SAML group. Valid values are: `guest`, `reporter`, `developer`, `maintainer`, `owner`.\n",
                        "willReplaceOnChanges": true
                    },
                    "group": {
                        "type": "string",
                        "description": "The ID or path of the group to add the SAML Group Link to.\n",
                        "willReplaceOnChanges": true
                    },
                    "memberRoleId": {
                        "type": "integer",
                        "description": "The ID of a custom member role. Only available for Ultimate instances. When using a custom role, the `access_level` must match the base role used to create the custom role.\n",
                        "willReplaceOnChanges": true
                    },
                    "samlGroupName": {
                        "type": "string",
                        "description": "The name of the SAML group.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupSecurityPolicyAttachment:GroupSecurityPolicyAttachment": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\n// This resource can be used to attach a security policy to a pre-existing group\nconst foo = new gitlab.GroupSecurityPolicyAttachment(\"foo\", {\n    group: \"1234\",\n    policyProject: \"4567\",\n});\n// Or Terraform can create a new project, add a policy to that project,\n// then attach that policy project to other groups.\nconst my_policy_project = new gitlab.Project(\"my-policy-project\", {name: \"security-policy-project\"});\nconst policy_yml = new gitlab.RepositoryFile(\"policy-yml\", {\n    project: my_policy_project.id,\n    filePath: \".gitlab/security-policies/my-policy.yml\",\n    branch: \"master\",\n    encoding: \"text\",\n    content: `---\napproval_policy:\n- name: test\ndescription: test\nenabled: true\nrules:\n- type: any_merge_request\n    branch_type: protected\n    commits: any\napproval_settings:\n    block_branch_modification: true\n    prevent_pushing_and_force_pushing: true\n    prevent_approval_by_author: true\n    prevent_approval_by_commit_author: true\n    remove_approvals_with_new_commit: true\n    require_password_to_approve: false\nfallback_behavior:\n    fail: closed\npolicy_scope:\n  compliance_frameworks:\n  - id: 1010101\n  - id: 0101010\nactions:\n- type: send_bot_message\n    enabled: true\n`,\n});\n// Multiple policies can be attached to a single project by repeating this resource or using a `for_each`\nconst my_policy = new gitlab.GroupSecurityPolicyAttachment(\"my-policy\", {\n    group: \"1234\",\n    policyProject: my_policy_project.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\n# This resource can be used to attach a security policy to a pre-existing group\nfoo = gitlab.GroupSecurityPolicyAttachment(\"foo\",\n    group=\"1234\",\n    policy_project=\"4567\")\n# Or Terraform can create a new project, add a policy to that project,\n# then attach that policy project to other groups.\nmy_policy_project = gitlab.Project(\"my-policy-project\", name=\"security-policy-project\")\npolicy_yml = gitlab.RepositoryFile(\"policy-yml\",\n    project=my_policy_project.id,\n    file_path=\".gitlab/security-policies/my-policy.yml\",\n    branch=\"master\",\n    encoding=\"text\",\n    content=\"\"\"---\napproval_policy:\n- name: test\ndescription: test\nenabled: true\nrules:\n- type: any_merge_request\n    branch_type: protected\n    commits: any\napproval_settings:\n    block_branch_modification: true\n    prevent_pushing_and_force_pushing: true\n    prevent_approval_by_author: true\n    prevent_approval_by_commit_author: true\n    remove_approvals_with_new_commit: true\n    require_password_to_approve: false\nfallback_behavior:\n    fail: closed\npolicy_scope:\n  compliance_frameworks:\n  - id: 1010101\n  - id: 0101010\nactions:\n- type: send_bot_message\n    enabled: true\n\"\"\")\n# Multiple policies can be attached to a single project by repeating this resource or using a `for_each`\nmy_policy = gitlab.GroupSecurityPolicyAttachment(\"my-policy\",\n    group=\"1234\",\n    policy_project=my_policy_project.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // This resource can be used to attach a security policy to a pre-existing group\n    var foo = new GitLab.GroupSecurityPolicyAttachment(\"foo\", new()\n    {\n        Group = \"1234\",\n        PolicyProject = \"4567\",\n    });\n\n    // Or Terraform can create a new project, add a policy to that project,\n    // then attach that policy project to other groups.\n    var my_policy_project = new GitLab.Project(\"my-policy-project\", new()\n    {\n        Name = \"security-policy-project\",\n    });\n\n    var policy_yml = new GitLab.RepositoryFile(\"policy-yml\", new()\n    {\n        Project = my_policy_project.Id,\n        FilePath = \".gitlab/security-policies/my-policy.yml\",\n        Branch = \"master\",\n        Encoding = \"text\",\n        Content = @\"---\napproval_policy:\n- name: test\ndescription: test\nenabled: true\nrules:\n- type: any_merge_request\n    branch_type: protected\n    commits: any\napproval_settings:\n    block_branch_modification: true\n    prevent_pushing_and_force_pushing: true\n    prevent_approval_by_author: true\n    prevent_approval_by_commit_author: true\n    remove_approvals_with_new_commit: true\n    require_password_to_approve: false\nfallback_behavior:\n    fail: closed\npolicy_scope:\n  compliance_frameworks:\n  - id: 1010101\n  - id: 0101010\nactions:\n- type: send_bot_message\n    enabled: true\n\",\n    });\n\n    // Multiple policies can be attached to a single project by repeating this resource or using a `for_each`\n    var my_policy = new GitLab.GroupSecurityPolicyAttachment(\"my-policy\", new()\n    {\n        Group = \"1234\",\n        PolicyProject = my_policy_project.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// This resource can be used to attach a security policy to a pre-existing group\n\t\t_, err := gitlab.NewGroupSecurityPolicyAttachment(ctx, \"foo\", \u0026gitlab.GroupSecurityPolicyAttachmentArgs{\n\t\t\tGroup:         pulumi.String(\"1234\"),\n\t\t\tPolicyProject: pulumi.String(\"4567\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Or Terraform can create a new project, add a policy to that project,\n\t\t// then attach that policy project to other groups.\n\t\t_, err = gitlab.NewProject(ctx, \"my-policy-project\", \u0026gitlab.ProjectArgs{\n\t\t\tName: pulumi.String(\"security-policy-project\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewRepositoryFile(ctx, \"policy-yml\", \u0026gitlab.RepositoryFileArgs{\n\t\t\tProject:  my_policy_project.ID(),\n\t\t\tFilePath: pulumi.String(\".gitlab/security-policies/my-policy.yml\"),\n\t\t\tBranch:   pulumi.String(\"master\"),\n\t\t\tEncoding: pulumi.String(\"text\"),\n\t\t\tContent: pulumi.String(`---\napproval_policy:\n- name: test\ndescription: test\nenabled: true\nrules:\n- type: any_merge_request\n    branch_type: protected\n    commits: any\napproval_settings:\n    block_branch_modification: true\n    prevent_pushing_and_force_pushing: true\n    prevent_approval_by_author: true\n    prevent_approval_by_commit_author: true\n    remove_approvals_with_new_commit: true\n    require_password_to_approve: false\nfallback_behavior:\n    fail: closed\npolicy_scope:\n  compliance_frameworks:\n  - id: 1010101\n  - id: 0101010\nactions:\n- type: send_bot_message\n    enabled: true\n`),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Multiple policies can be attached to a single project by repeating this resource or using a `for_each`\n\t\t_, err = gitlab.NewGroupSecurityPolicyAttachment(ctx, \"my-policy\", \u0026gitlab.GroupSecurityPolicyAttachmentArgs{\n\t\t\tGroup:         pulumi.String(\"1234\"),\n\t\t\tPolicyProject: my_policy_project.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GroupSecurityPolicyAttachment;\nimport com.pulumi.gitlab.GroupSecurityPolicyAttachmentArgs;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.RepositoryFile;\nimport com.pulumi.gitlab.RepositoryFileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // This resource can be used to attach a security policy to a pre-existing group\n        var foo = new GroupSecurityPolicyAttachment(\"foo\", GroupSecurityPolicyAttachmentArgs.builder()\n            .group(1234)\n            .policyProject(4567)\n            .build());\n\n        // Or Terraform can create a new project, add a policy to that project,\n        // then attach that policy project to other groups.\n        var my_policy_project = new Project(\"my-policy-project\", ProjectArgs.builder()\n            .name(\"security-policy-project\")\n            .build());\n\n        var policy_yml = new RepositoryFile(\"policy-yml\", RepositoryFileArgs.builder()\n            .project(my_policy_project.id())\n            .filePath(\".gitlab/security-policies/my-policy.yml\")\n            .branch(\"master\")\n            .encoding(\"text\")\n            .content(\"\"\"\n---\napproval_policy:\n- name: test\ndescription: test\nenabled: true\nrules:\n- type: any_merge_request\n    branch_type: protected\n    commits: any\napproval_settings:\n    block_branch_modification: true\n    prevent_pushing_and_force_pushing: true\n    prevent_approval_by_author: true\n    prevent_approval_by_commit_author: true\n    remove_approvals_with_new_commit: true\n    require_password_to_approve: false\nfallback_behavior:\n    fail: closed\npolicy_scope:\n  compliance_frameworks:\n  - id: 1010101\n  - id: 0101010\nactions:\n- type: send_bot_message\n    enabled: true\n            \"\"\")\n            .build());\n\n        // Multiple policies can be attached to a single project by repeating this resource or using a `for_each`\n        var my_policy = new GroupSecurityPolicyAttachment(\"my-policy\", GroupSecurityPolicyAttachmentArgs.builder()\n            .group(1234)\n            .policyProject(my_policy_project.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # This resource can be used to attach a security policy to a pre-existing group\n  foo:\n    type: gitlab:GroupSecurityPolicyAttachment\n    properties:\n      group: 1234\n      policyProject: 4567\n  # Or Terraform can create a new project, add a policy to that project,\n  # then attach that policy project to other groups.\n  my-policy-project:\n    type: gitlab:Project\n    properties:\n      name: security-policy-project\n  policy-yml:\n    type: gitlab:RepositoryFile\n    properties:\n      project: ${[\"my-policy-project\"].id}\n      filePath: .gitlab/security-policies/my-policy.yml\n      branch: master\n      encoding: text\n      content: |\n        ---\n        approval_policy:\n        - name: test\n        description: test\n        enabled: true\n        rules:\n        - type: any_merge_request\n            branch_type: protected\n            commits: any\n        approval_settings:\n            block_branch_modification: true\n            prevent_pushing_and_force_pushing: true\n            prevent_approval_by_author: true\n            prevent_approval_by_commit_author: true\n            remove_approvals_with_new_commit: true\n            require_password_to_approve: false\n        fallback_behavior:\n            fail: closed\n        policy_scope:\n          compliance_frameworks:\n          - id: 1010101\n          - id: 0101010\n        actions:\n        - type: send_bot_message\n            enabled: true\n  # Multiple policies can be attached to a single project by repeating this resource or using a `for_each`\n  my-policy:\n    type: gitlab:GroupSecurityPolicyAttachment\n    properties:\n      group: 1234\n      policyProject: ${[\"my-policy-project\"].id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_group_security_policy_attachment`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_group_security_policy_attachment.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab group security policy attachments can be imported using an id made up of `group:policy_project_id` where the policy project ID is the project ID of the policy project, e.g.\n\n```sh\n$ pulumi import gitlab:index/groupSecurityPolicyAttachment:GroupSecurityPolicyAttachment foo 1:2\n```\n\n",
            "properties": {
                "group": {
                    "type": "string",
                    "description": "The ID or Full Path of the group which will have the security policy project assigned to it.\n"
                },
                "groupGraphqlId": {
                    "type": "string",
                    "description": "The GraphQL ID of the group to which the security policty project will be attached.\n"
                },
                "policyProject": {
                    "type": "string",
                    "description": "The ID or Full Path of the security policy project.\n"
                },
                "policyProjectGraphqlId": {
                    "type": "string",
                    "description": "The GraphQL ID of the security policy project.\n"
                }
            },
            "required": [
                "group",
                "groupGraphqlId",
                "policyProject",
                "policyProjectGraphqlId"
            ],
            "inputProperties": {
                "group": {
                    "type": "string",
                    "description": "The ID or Full Path of the group which will have the security policy project assigned to it.\n"
                },
                "policyProject": {
                    "type": "string",
                    "description": "The ID or Full Path of the security policy project.\n"
                }
            },
            "requiredInputs": [
                "group",
                "policyProject"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupSecurityPolicyAttachment resources.\n",
                "properties": {
                    "group": {
                        "type": "string",
                        "description": "The ID or Full Path of the group which will have the security policy project assigned to it.\n"
                    },
                    "groupGraphqlId": {
                        "type": "string",
                        "description": "The GraphQL ID of the group to which the security policty project will be attached.\n"
                    },
                    "policyProject": {
                        "type": "string",
                        "description": "The ID or Full Path of the security policy project.\n"
                    },
                    "policyProjectGraphqlId": {
                        "type": "string",
                        "description": "The GraphQL ID of the security policy project.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupServiceAccount:GroupServiceAccount": {
            "description": "The `gitlab.GroupServiceAccount` resource allows creating a GitLab group service account.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/group_service_accounts.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\n// This must be a top-level group\nconst example = new gitlab.Group(\"example\", {\n    name: \"example\",\n    path: \"example\",\n    description: \"An example group\",\n});\n// The service account against the top-level group\nconst exampleSa = new gitlab.GroupServiceAccount(\"example_sa\", {\n    group: example.id,\n    name: \"example-name\",\n    username: \"example-username\",\n});\n// Group to assign the service account to. Can be the same top-level group resource as above, or a subgroup of that group.\nconst exampleSubgroup = new gitlab.Group(\"example_subgroup\", {\n    name: \"subgroup\",\n    path: \"example/subgroup\",\n    description: \"An example subgroup\",\n});\n// To assign the service account to a group\nconst exampleMembership = new gitlab.GroupMembership(\"example_membership\", {\n    groupId: exampleSubgroup.id,\n    userId: exampleSa.serviceAccountId,\n    accessLevel: \"developer\",\n    expiresAt: \"2020-03-14\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\n# This must be a top-level group\nexample = gitlab.Group(\"example\",\n    name=\"example\",\n    path=\"example\",\n    description=\"An example group\")\n# The service account against the top-level group\nexample_sa = gitlab.GroupServiceAccount(\"example_sa\",\n    group=example.id,\n    name=\"example-name\",\n    username=\"example-username\")\n# Group to assign the service account to. Can be the same top-level group resource as above, or a subgroup of that group.\nexample_subgroup = gitlab.Group(\"example_subgroup\",\n    name=\"subgroup\",\n    path=\"example/subgroup\",\n    description=\"An example subgroup\")\n# To assign the service account to a group\nexample_membership = gitlab.GroupMembership(\"example_membership\",\n    group_id=example_subgroup.id,\n    user_id=example_sa.service_account_id,\n    access_level=\"developer\",\n    expires_at=\"2020-03-14\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // This must be a top-level group\n    var example = new GitLab.Group(\"example\", new()\n    {\n        Name = \"example\",\n        Path = \"example\",\n        Description = \"An example group\",\n    });\n\n    // The service account against the top-level group\n    var exampleSa = new GitLab.GroupServiceAccount(\"example_sa\", new()\n    {\n        Group = example.Id,\n        Name = \"example-name\",\n        Username = \"example-username\",\n    });\n\n    // Group to assign the service account to. Can be the same top-level group resource as above, or a subgroup of that group.\n    var exampleSubgroup = new GitLab.Group(\"example_subgroup\", new()\n    {\n        Name = \"subgroup\",\n        Path = \"example/subgroup\",\n        Description = \"An example subgroup\",\n    });\n\n    // To assign the service account to a group\n    var exampleMembership = new GitLab.GroupMembership(\"example_membership\", new()\n    {\n        GroupId = exampleSubgroup.Id,\n        UserId = exampleSa.ServiceAccountId,\n        AccessLevel = \"developer\",\n        ExpiresAt = \"2020-03-14\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// This must be a top-level group\n\t\texample, err := gitlab.NewGroup(ctx, \"example\", \u0026gitlab.GroupArgs{\n\t\t\tName:        pulumi.String(\"example\"),\n\t\t\tPath:        pulumi.String(\"example\"),\n\t\t\tDescription: pulumi.String(\"An example group\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// The service account against the top-level group\n\t\texampleSa, err := gitlab.NewGroupServiceAccount(ctx, \"example_sa\", \u0026gitlab.GroupServiceAccountArgs{\n\t\t\tGroup:    example.ID(),\n\t\t\tName:     pulumi.String(\"example-name\"),\n\t\t\tUsername: pulumi.String(\"example-username\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Group to assign the service account to. Can be the same top-level group resource as above, or a subgroup of that group.\n\t\texampleSubgroup, err := gitlab.NewGroup(ctx, \"example_subgroup\", \u0026gitlab.GroupArgs{\n\t\t\tName:        pulumi.String(\"subgroup\"),\n\t\t\tPath:        pulumi.String(\"example/subgroup\"),\n\t\t\tDescription: pulumi.String(\"An example subgroup\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// To assign the service account to a group\n\t\t_, err = gitlab.NewGroupMembership(ctx, \"example_membership\", \u0026gitlab.GroupMembershipArgs{\n\t\t\tGroupId:     exampleSubgroup.ID(),\n\t\t\tUserId:      exampleSa.ServiceAccountId,\n\t\t\tAccessLevel: pulumi.String(\"developer\"),\n\t\t\tExpiresAt:   pulumi.String(\"2020-03-14\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Group;\nimport com.pulumi.gitlab.GroupArgs;\nimport com.pulumi.gitlab.GroupServiceAccount;\nimport com.pulumi.gitlab.GroupServiceAccountArgs;\nimport com.pulumi.gitlab.GroupMembership;\nimport com.pulumi.gitlab.GroupMembershipArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // This must be a top-level group\n        var example = new Group(\"example\", GroupArgs.builder()\n            .name(\"example\")\n            .path(\"example\")\n            .description(\"An example group\")\n            .build());\n\n        // The service account against the top-level group\n        var exampleSa = new GroupServiceAccount(\"exampleSa\", GroupServiceAccountArgs.builder()\n            .group(example.id())\n            .name(\"example-name\")\n            .username(\"example-username\")\n            .build());\n\n        // Group to assign the service account to. Can be the same top-level group resource as above, or a subgroup of that group.\n        var exampleSubgroup = new Group(\"exampleSubgroup\", GroupArgs.builder()\n            .name(\"subgroup\")\n            .path(\"example/subgroup\")\n            .description(\"An example subgroup\")\n            .build());\n\n        // To assign the service account to a group\n        var exampleMembership = new GroupMembership(\"exampleMembership\", GroupMembershipArgs.builder()\n            .groupId(exampleSubgroup.id())\n            .userId(exampleSa.serviceAccountId())\n            .accessLevel(\"developer\")\n            .expiresAt(\"2020-03-14\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # This must be a top-level group\n  example:\n    type: gitlab:Group\n    properties:\n      name: example\n      path: example\n      description: An example group\n  # The service account against the top-level group\n  exampleSa:\n    type: gitlab:GroupServiceAccount\n    name: example_sa\n    properties:\n      group: ${example.id}\n      name: example-name\n      username: example-username\n  # Group to assign the service account to. Can be the same top-level group resource as above, or a subgroup of that group.\n  exampleSubgroup:\n    type: gitlab:Group\n    name: example_subgroup\n    properties:\n      name: subgroup\n      path: example/subgroup\n      description: An example subgroup\n  # To assign the service account to a group\n  exampleMembership:\n    type: gitlab:GroupMembership\n    name: example_membership\n    properties:\n      groupId: ${exampleSubgroup.id}\n      userId: ${exampleSa.serviceAccountId}\n      accessLevel: developer\n      expiresAt: 2020-03-14\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_group_service_account`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_group_service_account.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\n```sh\n$ pulumi import gitlab:index/groupServiceAccount:GroupServiceAccount You can import a group service account using `\u003cresource\u003e \u003cid\u003e`. The\n```\n\n`id` is in the form of \u003cgroup_id\u003e:\u003cservice_account_id\u003e\n\n```sh\n$ pulumi import gitlab:index/groupServiceAccount:GroupServiceAccount example example\n```\n\n",
            "properties": {
                "group": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the group that the service account is created in. Must be a top level group.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the user. If not specified, the default Service account user name is used.\n"
                },
                "serviceAccountId": {
                    "type": "string",
                    "description": "The service account id.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The username of the user. If not specified, it’s automatically generated.\n"
                }
            },
            "required": [
                "group",
                "name",
                "serviceAccountId"
            ],
            "inputProperties": {
                "group": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the group that the service account is created in. Must be a top level group.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the user. If not specified, the default Service account user name is used.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The username of the user. If not specified, it’s automatically generated.\n"
                }
            },
            "requiredInputs": [
                "group"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupServiceAccount resources.\n",
                "properties": {
                    "group": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the group that the service account is created in. Must be a top level group.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the user. If not specified, the default Service account user name is used.\n"
                    },
                    "serviceAccountId": {
                        "type": "string",
                        "description": "The service account id.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "The username of the user. If not specified, it’s automatically generated.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupServiceAccountAccessToken:GroupServiceAccountAccessToken": {
            "description": "The `gitlab.GroupServiceAccountAccessToken` resource allows to manage the lifecycle of a group service account access token.\n\n\u003e Use of the `timestamp()` function with expires_at will cause the resource to be re-created with every apply, it's recommended to use `plantimestamp()` or a static value instead.\n\n\u003e Reading the access token status of a service account requires an admin token or a top-level group owner token on gitlab.com. As a result, this resource will ignore permission errors when attempting to read the token status, and will rely on the values in state instead. This can lead to apply-time failures if the token configured for the provider doesn't have permissions to rotate tokens for the service account.\n\n**Upstream API**: [GitLab API docs](https://docs.gitlab.com/ee/api/group_service_accounts.html#create-a-personal-access-token-for-a-service-account-user)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\n// This must be a top-level group\nconst example = new gitlab.Group(\"example\", {\n    name: \"example\",\n    path: \"example\",\n    description: \"An example group\",\n});\n// The service account against the top-level group\nconst exampleSa = new gitlab.GroupServiceAccount(\"example_sa\", {\n    group: example.id,\n    name: \"example-name\",\n    username: \"example-username\",\n});\n// To assign the service account to a group\nconst exampleMembership = new gitlab.GroupMembership(\"example_membership\", {\n    groupId: example.id,\n    userId: exampleSa.serviceAccountId,\n    accessLevel: \"developer\",\n    expiresAt: \"2020-03-14\",\n});\n// The service account access token\nconst exampleSaToken = new gitlab.GroupServiceAccountAccessToken(\"example_sa_token\", {\n    group: example.id,\n    userId: exampleSa.serviceAccountId,\n    name: \"Example service account access token\",\n    expiresAt: \"2020-03-14\",\n    scopes: [\"api\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\n# This must be a top-level group\nexample = gitlab.Group(\"example\",\n    name=\"example\",\n    path=\"example\",\n    description=\"An example group\")\n# The service account against the top-level group\nexample_sa = gitlab.GroupServiceAccount(\"example_sa\",\n    group=example.id,\n    name=\"example-name\",\n    username=\"example-username\")\n# To assign the service account to a group\nexample_membership = gitlab.GroupMembership(\"example_membership\",\n    group_id=example.id,\n    user_id=example_sa.service_account_id,\n    access_level=\"developer\",\n    expires_at=\"2020-03-14\")\n# The service account access token\nexample_sa_token = gitlab.GroupServiceAccountAccessToken(\"example_sa_token\",\n    group=example.id,\n    user_id=example_sa.service_account_id,\n    name=\"Example service account access token\",\n    expires_at=\"2020-03-14\",\n    scopes=[\"api\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // This must be a top-level group\n    var example = new GitLab.Group(\"example\", new()\n    {\n        Name = \"example\",\n        Path = \"example\",\n        Description = \"An example group\",\n    });\n\n    // The service account against the top-level group\n    var exampleSa = new GitLab.GroupServiceAccount(\"example_sa\", new()\n    {\n        Group = example.Id,\n        Name = \"example-name\",\n        Username = \"example-username\",\n    });\n\n    // To assign the service account to a group\n    var exampleMembership = new GitLab.GroupMembership(\"example_membership\", new()\n    {\n        GroupId = example.Id,\n        UserId = exampleSa.ServiceAccountId,\n        AccessLevel = \"developer\",\n        ExpiresAt = \"2020-03-14\",\n    });\n\n    // The service account access token\n    var exampleSaToken = new GitLab.GroupServiceAccountAccessToken(\"example_sa_token\", new()\n    {\n        Group = example.Id,\n        UserId = exampleSa.ServiceAccountId,\n        Name = \"Example service account access token\",\n        ExpiresAt = \"2020-03-14\",\n        Scopes = new[]\n        {\n            \"api\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// This must be a top-level group\n\t\texample, err := gitlab.NewGroup(ctx, \"example\", \u0026gitlab.GroupArgs{\n\t\t\tName:        pulumi.String(\"example\"),\n\t\t\tPath:        pulumi.String(\"example\"),\n\t\t\tDescription: pulumi.String(\"An example group\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// The service account against the top-level group\n\t\texampleSa, err := gitlab.NewGroupServiceAccount(ctx, \"example_sa\", \u0026gitlab.GroupServiceAccountArgs{\n\t\t\tGroup:    example.ID(),\n\t\t\tName:     pulumi.String(\"example-name\"),\n\t\t\tUsername: pulumi.String(\"example-username\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// To assign the service account to a group\n\t\t_, err = gitlab.NewGroupMembership(ctx, \"example_membership\", \u0026gitlab.GroupMembershipArgs{\n\t\t\tGroupId:     example.ID(),\n\t\t\tUserId:      exampleSa.ServiceAccountId,\n\t\t\tAccessLevel: pulumi.String(\"developer\"),\n\t\t\tExpiresAt:   pulumi.String(\"2020-03-14\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// The service account access token\n\t\t_, err = gitlab.NewGroupServiceAccountAccessToken(ctx, \"example_sa_token\", \u0026gitlab.GroupServiceAccountAccessTokenArgs{\n\t\t\tGroup:     example.ID(),\n\t\t\tUserId:    exampleSa.ServiceAccountId,\n\t\t\tName:      pulumi.String(\"Example service account access token\"),\n\t\t\tExpiresAt: pulumi.String(\"2020-03-14\"),\n\t\t\tScopes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"api\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Group;\nimport com.pulumi.gitlab.GroupArgs;\nimport com.pulumi.gitlab.GroupServiceAccount;\nimport com.pulumi.gitlab.GroupServiceAccountArgs;\nimport com.pulumi.gitlab.GroupMembership;\nimport com.pulumi.gitlab.GroupMembershipArgs;\nimport com.pulumi.gitlab.GroupServiceAccountAccessToken;\nimport com.pulumi.gitlab.GroupServiceAccountAccessTokenArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // This must be a top-level group\n        var example = new Group(\"example\", GroupArgs.builder()\n            .name(\"example\")\n            .path(\"example\")\n            .description(\"An example group\")\n            .build());\n\n        // The service account against the top-level group\n        var exampleSa = new GroupServiceAccount(\"exampleSa\", GroupServiceAccountArgs.builder()\n            .group(example.id())\n            .name(\"example-name\")\n            .username(\"example-username\")\n            .build());\n\n        // To assign the service account to a group\n        var exampleMembership = new GroupMembership(\"exampleMembership\", GroupMembershipArgs.builder()\n            .groupId(example.id())\n            .userId(exampleSa.serviceAccountId())\n            .accessLevel(\"developer\")\n            .expiresAt(\"2020-03-14\")\n            .build());\n\n        // The service account access token\n        var exampleSaToken = new GroupServiceAccountAccessToken(\"exampleSaToken\", GroupServiceAccountAccessTokenArgs.builder()\n            .group(example.id())\n            .userId(exampleSa.serviceAccountId())\n            .name(\"Example service account access token\")\n            .expiresAt(\"2020-03-14\")\n            .scopes(\"api\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # This must be a top-level group\n  example:\n    type: gitlab:Group\n    properties:\n      name: example\n      path: example\n      description: An example group\n  # The service account against the top-level group\n  exampleSa:\n    type: gitlab:GroupServiceAccount\n    name: example_sa\n    properties:\n      group: ${example.id}\n      name: example-name\n      username: example-username\n  # To assign the service account to a group\n  exampleMembership:\n    type: gitlab:GroupMembership\n    name: example_membership\n    properties:\n      groupId: ${example.id}\n      userId: ${exampleSa.serviceAccountId}\n      accessLevel: developer\n      expiresAt: 2020-03-14\n  # The service account access token\n  exampleSaToken:\n    type: gitlab:GroupServiceAccountAccessToken\n    name: example_sa_token\n    properties:\n      group: ${example.id}\n      userId: ${exampleSa.serviceAccountId}\n      name: Example service account access token\n      expiresAt: 2020-03-14\n      scopes:\n        - api\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_group_service_account_access_token`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_group_service_account_access_token.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\n```sh\n$ pulumi import gitlab:index/groupServiceAccountAccessToken:GroupServiceAccountAccessToken You can import a service account access token using `\u003cresource\u003e \u003cid\u003e`. The\n```\n\n`id` is in the form of \u003cgroup_id\u003e:\u003cservice_account_id\u003e:\u003caccess_token_id\u003e\n\nImporting an access token does not import the access token value.\n\n```sh\n$ pulumi import gitlab:index/groupServiceAccountAccessToken:GroupServiceAccountAccessToken example 1:2:3\n```\n\n",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "True if the token is active.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Time the token has been created, RFC3339 format.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "The personal access token expiry date. When left blank, the token follows the standard rule of expiry for personal access tokens.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the group containing the service account. Must be a top level group.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the personal access token.\n"
                },
                "revoked": {
                    "type": "boolean",
                    "description": "True if the token is revoked.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The scopes of the group service account access token. valid values are: `api`, `read_api`, `read_registry`, `write_registry`, `read_repository`, `write_repository`, `create_runner`, `manage_runner`, `ai_features`, `k8s_proxy`, `read_observability`, `write_observability`\n"
                },
                "token": {
                    "type": "string",
                    "description": "The token of the group service account access token. **Note**: the token is not available for imported resources.\n",
                    "secret": true
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID of a service account user.\n"
                }
            },
            "required": [
                "active",
                "createdAt",
                "expiresAt",
                "group",
                "name",
                "revoked",
                "scopes",
                "token",
                "userId"
            ],
            "inputProperties": {
                "expiresAt": {
                    "type": "string",
                    "description": "The personal access token expiry date. When left blank, the token follows the standard rule of expiry for personal access tokens.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the group containing the service account. Must be a top level group.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the personal access token.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The scopes of the group service account access token. valid values are: `api`, `read_api`, `read_registry`, `write_registry`, `read_repository`, `write_repository`, `create_runner`, `manage_runner`, `ai_features`, `k8s_proxy`, `read_observability`, `write_observability`\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID of a service account user.\n"
                }
            },
            "requiredInputs": [
                "group",
                "scopes",
                "userId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupServiceAccountAccessToken resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "True if the token is active.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Time the token has been created, RFC3339 format.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "The personal access token expiry date. When left blank, the token follows the standard rule of expiry for personal access tokens.\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the group containing the service account. Must be a top level group.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the personal access token.\n"
                    },
                    "revoked": {
                        "type": "boolean",
                        "description": "True if the token is revoked.\n"
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The scopes of the group service account access token. valid values are: `api`, `read_api`, `read_registry`, `write_registry`, `read_repository`, `write_repository`, `create_runner`, `manage_runner`, `ai_features`, `k8s_proxy`, `read_observability`, `write_observability`\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "The token of the group service account access token. **Note**: the token is not available for imported resources.\n",
                        "secret": true
                    },
                    "userId": {
                        "type": "integer",
                        "description": "The ID of a service account user.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupShareGroup:GroupShareGroup": {
            "description": "The `gitlab.GroupShareGroup` resource allows to manage the lifecycle of group shared with another group.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/groups.html#share-groups-with-groups)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst test = new gitlab.GroupShareGroup(\"test\", {\n    groupId: foo.id,\n    shareGroupId: bar.id,\n    groupAccess: \"guest\",\n    expiresAt: \"2099-01-01\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\ntest = gitlab.GroupShareGroup(\"test\",\n    group_id=foo[\"id\"],\n    share_group_id=bar[\"id\"],\n    group_access=\"guest\",\n    expires_at=\"2099-01-01\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new GitLab.GroupShareGroup(\"test\", new()\n    {\n        GroupId = foo.Id,\n        ShareGroupId = bar.Id,\n        GroupAccess = \"guest\",\n        ExpiresAt = \"2099-01-01\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewGroupShareGroup(ctx, \"test\", \u0026gitlab.GroupShareGroupArgs{\n\t\t\tGroupId:      pulumi.Any(foo.Id),\n\t\t\tShareGroupId: pulumi.Any(bar.Id),\n\t\t\tGroupAccess:  pulumi.String(\"guest\"),\n\t\t\tExpiresAt:    pulumi.String(\"2099-01-01\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GroupShareGroup;\nimport com.pulumi.gitlab.GroupShareGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new GroupShareGroup(\"test\", GroupShareGroupArgs.builder()\n            .groupId(foo.id())\n            .shareGroupId(bar.id())\n            .groupAccess(\"guest\")\n            .expiresAt(\"2099-01-01\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: gitlab:GroupShareGroup\n    properties:\n      groupId: ${foo.id}\n      shareGroupId: ${bar.id}\n      groupAccess: guest\n      expiresAt: 2099-01-01\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_group_share_group`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_group_share_group.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab group shares can be imported using an id made up of `mainGroupId:shareGroupId`, e.g.\n\n```sh\n$ pulumi import gitlab:index/groupShareGroup:GroupShareGroup test 12345:1337\n```\n\n",
            "properties": {
                "expiresAt": {
                    "type": "string",
                    "description": "Share expiration date. Format: `YYYY-MM-DD`\n"
                },
                "groupAccess": {
                    "type": "string",
                    "description": "The access level to grant the group. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "The id of the main group to be shared.\n"
                },
                "shareGroupId": {
                    "type": "integer",
                    "description": "The id of the additional group with which the main group will be shared.\n"
                }
            },
            "required": [
                "groupAccess",
                "groupId",
                "shareGroupId"
            ],
            "inputProperties": {
                "expiresAt": {
                    "type": "string",
                    "description": "Share expiration date. Format: `YYYY-MM-DD`\n",
                    "willReplaceOnChanges": true
                },
                "groupAccess": {
                    "type": "string",
                    "description": "The access level to grant the group. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`\n",
                    "willReplaceOnChanges": true
                },
                "groupId": {
                    "type": "string",
                    "description": "The id of the main group to be shared.\n",
                    "willReplaceOnChanges": true
                },
                "shareGroupId": {
                    "type": "integer",
                    "description": "The id of the additional group with which the main group will be shared.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "groupAccess",
                "groupId",
                "shareGroupId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupShareGroup resources.\n",
                "properties": {
                    "expiresAt": {
                        "type": "string",
                        "description": "Share expiration date. Format: `YYYY-MM-DD`\n",
                        "willReplaceOnChanges": true
                    },
                    "groupAccess": {
                        "type": "string",
                        "description": "The access level to grant the group. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`\n",
                        "willReplaceOnChanges": true
                    },
                    "groupId": {
                        "type": "string",
                        "description": "The id of the main group to be shared.\n",
                        "willReplaceOnChanges": true
                    },
                    "shareGroupId": {
                        "type": "integer",
                        "description": "The id of the additional group with which the main group will be shared.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/groupVariable:GroupVariable": {
            "description": "The `gitlab.GroupVariable` resource allows to manage the lifecycle of a CI/CD variable for a group.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/group_level_variables.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = new gitlab.GroupVariable(\"example\", {\n    group: \"12345\",\n    key: \"group_variable_key\",\n    value: \"group_variable_value\",\n    \"protected\": false,\n    masked: false,\n    environmentScope: \"*\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.GroupVariable(\"example\",\n    group=\"12345\",\n    key=\"group_variable_key\",\n    value=\"group_variable_value\",\n    protected=False,\n    masked=False,\n    environment_scope=\"*\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new GitLab.GroupVariable(\"example\", new()\n    {\n        Group = \"12345\",\n        Key = \"group_variable_key\",\n        Value = \"group_variable_value\",\n        Protected = false,\n        Masked = false,\n        EnvironmentScope = \"*\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewGroupVariable(ctx, \"example\", \u0026gitlab.GroupVariableArgs{\n\t\t\tGroup:            pulumi.String(\"12345\"),\n\t\t\tKey:              pulumi.String(\"group_variable_key\"),\n\t\t\tValue:            pulumi.String(\"group_variable_value\"),\n\t\t\tProtected:        pulumi.Bool(false),\n\t\t\tMasked:           pulumi.Bool(false),\n\t\t\tEnvironmentScope: pulumi.String(\"*\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GroupVariable;\nimport com.pulumi.gitlab.GroupVariableArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new GroupVariable(\"example\", GroupVariableArgs.builder()\n            .group(\"12345\")\n            .key(\"group_variable_key\")\n            .value(\"group_variable_value\")\n            .protected_(false)\n            .masked(false)\n            .environmentScope(\"*\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: gitlab:GroupVariable\n    properties:\n      group: '12345'\n      key: group_variable_key\n      value: group_variable_value\n      protected: false\n      masked: false\n      environmentScope: '*'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_group_variable`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_group_variable.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab group variables can be imported using an id made up of `groupid:variablename:scope`, e.g.\n\n```sh\n$ pulumi import gitlab:index/groupVariable:GroupVariable example 12345:group_variable_key:*\n```\n\n",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "The description of the variable.\n"
                },
                "environmentScope": {
                    "type": "string",
                    "description": "The environment scope of the variable. Defaults to all environment (`*`). Note that in Community Editions of Gitlab, values other than `*` will cause inconsistent plans.\n"
                },
                "group": {
                    "type": "string",
                    "description": "The name or id of the group.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The name of the variable.\n"
                },
                "masked": {
                    "type": "boolean",
                    "description": "If set to `true`, the value of the variable will be hidden in job logs. The value must meet the [masking requirements](https://docs.gitlab.com/ee/ci/variables/#masked-variables). Defaults to `false`.\n"
                },
                "protected": {
                    "type": "boolean",
                    "description": "If set to `true`, the variable will be passed only to pipelines running on protected branches and tags. Defaults to `false`.\n"
                },
                "raw": {
                    "type": "boolean",
                    "description": "Whether the variable is treated as a raw string. Default: false. When true, variables in the value are not expanded.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the variable.\n"
                },
                "variableType": {
                    "type": "string",
                    "description": "The type of a variable. Valid values are: `env_var`, `file`. Default is `env_var`.\n"
                }
            },
            "required": [
                "group",
                "key",
                "value"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "The description of the variable.\n"
                },
                "environmentScope": {
                    "type": "string",
                    "description": "The environment scope of the variable. Defaults to all environment (`*`). Note that in Community Editions of Gitlab, values other than `*` will cause inconsistent plans.\n",
                    "willReplaceOnChanges": true
                },
                "group": {
                    "type": "string",
                    "description": "The name or id of the group.\n",
                    "willReplaceOnChanges": true
                },
                "key": {
                    "type": "string",
                    "description": "The name of the variable.\n",
                    "willReplaceOnChanges": true
                },
                "masked": {
                    "type": "boolean",
                    "description": "If set to `true`, the value of the variable will be hidden in job logs. The value must meet the [masking requirements](https://docs.gitlab.com/ee/ci/variables/#masked-variables). Defaults to `false`.\n"
                },
                "protected": {
                    "type": "boolean",
                    "description": "If set to `true`, the variable will be passed only to pipelines running on protected branches and tags. Defaults to `false`.\n"
                },
                "raw": {
                    "type": "boolean",
                    "description": "Whether the variable is treated as a raw string. Default: false. When true, variables in the value are not expanded.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the variable.\n"
                },
                "variableType": {
                    "type": "string",
                    "description": "The type of a variable. Valid values are: `env_var`, `file`. Default is `env_var`.\n"
                }
            },
            "requiredInputs": [
                "group",
                "key",
                "value"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupVariable resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "The description of the variable.\n"
                    },
                    "environmentScope": {
                        "type": "string",
                        "description": "The environment scope of the variable. Defaults to all environment (`*`). Note that in Community Editions of Gitlab, values other than `*` will cause inconsistent plans.\n",
                        "willReplaceOnChanges": true
                    },
                    "group": {
                        "type": "string",
                        "description": "The name or id of the group.\n",
                        "willReplaceOnChanges": true
                    },
                    "key": {
                        "type": "string",
                        "description": "The name of the variable.\n",
                        "willReplaceOnChanges": true
                    },
                    "masked": {
                        "type": "boolean",
                        "description": "If set to `true`, the value of the variable will be hidden in job logs. The value must meet the [masking requirements](https://docs.gitlab.com/ee/ci/variables/#masked-variables). Defaults to `false`.\n"
                    },
                    "protected": {
                        "type": "boolean",
                        "description": "If set to `true`, the variable will be passed only to pipelines running on protected branches and tags. Defaults to `false`.\n"
                    },
                    "raw": {
                        "type": "boolean",
                        "description": "Whether the variable is treated as a raw string. Default: false. When true, variables in the value are not expanded.\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "The value of the variable.\n"
                    },
                    "variableType": {
                        "type": "string",
                        "description": "The type of a variable. Valid values are: `env_var`, `file`. Default is `env_var`.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/instanceCluster:InstanceCluster": {
            "description": "The `gitlab.InstanceCluster` resource allows to manage the lifecycle of an instance cluster.\n\n\u003e This is deprecated GitLab feature since 14.5\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/instance_clusters.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst bar = new gitlab.InstanceCluster(\"bar\", {\n    name: \"bar-cluster\",\n    domain: \"example.com\",\n    enabled: true,\n    kubernetesApiUrl: \"https://124.124.124\",\n    kubernetesToken: \"some-token\",\n    kubernetesCaCert: \"some-cert\",\n    kubernetesNamespace: \"namespace\",\n    kubernetesAuthorizationType: \"rbac\",\n    environmentScope: \"*\",\n    managementProjectId: \"123456\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nbar = gitlab.InstanceCluster(\"bar\",\n    name=\"bar-cluster\",\n    domain=\"example.com\",\n    enabled=True,\n    kubernetes_api_url=\"https://124.124.124\",\n    kubernetes_token=\"some-token\",\n    kubernetes_ca_cert=\"some-cert\",\n    kubernetes_namespace=\"namespace\",\n    kubernetes_authorization_type=\"rbac\",\n    environment_scope=\"*\",\n    management_project_id=\"123456\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var bar = new GitLab.InstanceCluster(\"bar\", new()\n    {\n        Name = \"bar-cluster\",\n        Domain = \"example.com\",\n        Enabled = true,\n        KubernetesApiUrl = \"https://124.124.124\",\n        KubernetesToken = \"some-token\",\n        KubernetesCaCert = \"some-cert\",\n        KubernetesNamespace = \"namespace\",\n        KubernetesAuthorizationType = \"rbac\",\n        EnvironmentScope = \"*\",\n        ManagementProjectId = \"123456\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewInstanceCluster(ctx, \"bar\", \u0026gitlab.InstanceClusterArgs{\n\t\t\tName:                        pulumi.String(\"bar-cluster\"),\n\t\t\tDomain:                      pulumi.String(\"example.com\"),\n\t\t\tEnabled:                     pulumi.Bool(true),\n\t\t\tKubernetesApiUrl:            pulumi.String(\"https://124.124.124\"),\n\t\t\tKubernetesToken:             pulumi.String(\"some-token\"),\n\t\t\tKubernetesCaCert:            pulumi.String(\"some-cert\"),\n\t\t\tKubernetesNamespace:         pulumi.String(\"namespace\"),\n\t\t\tKubernetesAuthorizationType: pulumi.String(\"rbac\"),\n\t\t\tEnvironmentScope:            pulumi.String(\"*\"),\n\t\t\tManagementProjectId:         pulumi.String(\"123456\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.InstanceCluster;\nimport com.pulumi.gitlab.InstanceClusterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var bar = new InstanceCluster(\"bar\", InstanceClusterArgs.builder()\n            .name(\"bar-cluster\")\n            .domain(\"example.com\")\n            .enabled(true)\n            .kubernetesApiUrl(\"https://124.124.124\")\n            .kubernetesToken(\"some-token\")\n            .kubernetesCaCert(\"some-cert\")\n            .kubernetesNamespace(\"namespace\")\n            .kubernetesAuthorizationType(\"rbac\")\n            .environmentScope(\"*\")\n            .managementProjectId(\"123456\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  bar:\n    type: gitlab:InstanceCluster\n    properties:\n      name: bar-cluster\n      domain: example.com\n      enabled: true\n      kubernetesApiUrl: https://124.124.124\n      kubernetesToken: some-token\n      kubernetesCaCert: some-cert\n      kubernetesNamespace: namespace\n      kubernetesAuthorizationType: rbac\n      environmentScope: '*'\n      managementProjectId: '123456'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_instance_cluster`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_instance_cluster.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab instance clusters can be imported using a `clusterid`, e.g.\n\n```sh\n$ pulumi import gitlab:index/instanceCluster:InstanceCluster bar 123\n```\n\n",
            "properties": {
                "clusterType": {
                    "type": "string",
                    "description": "Cluster type.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Create time.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The base domain of the cluster.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Determines if cluster is active or not. Defaults to `true`. This attribute cannot be read.\n"
                },
                "environmentScope": {
                    "type": "string",
                    "description": "The associated environment to the cluster. Defaults to `*`.\n"
                },
                "kubernetesApiUrl": {
                    "type": "string",
                    "description": "The URL to access the Kubernetes API.\n"
                },
                "kubernetesAuthorizationType": {
                    "type": "string",
                    "description": "The cluster authorization type. Valid values are `rbac`, `abac`, `unknown_authorization`. Defaults to `rbac`.\n"
                },
                "kubernetesCaCert": {
                    "type": "string",
                    "description": "TLS certificate (needed if API is using a self-signed TLS certificate).\n"
                },
                "kubernetesNamespace": {
                    "type": "string",
                    "description": "The unique namespace related to the instance.\n"
                },
                "kubernetesToken": {
                    "type": "string",
                    "description": "The token to authenticate against Kubernetes. This attribute cannot be read.\n",
                    "secret": true
                },
                "managed": {
                    "type": "boolean",
                    "description": "Determines if cluster is managed by gitlab or not. Defaults to `true`. This attribute cannot be read.\n"
                },
                "managementProjectId": {
                    "type": "string",
                    "description": "The ID of the management project for the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of cluster.\n"
                },
                "platformType": {
                    "type": "string",
                    "description": "Platform type.\n"
                },
                "providerType": {
                    "type": "string",
                    "description": "Provider type.\n"
                }
            },
            "required": [
                "clusterType",
                "createdAt",
                "kubernetesApiUrl",
                "kubernetesToken",
                "name",
                "platformType",
                "providerType"
            ],
            "inputProperties": {
                "domain": {
                    "type": "string",
                    "description": "The base domain of the cluster.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Determines if cluster is active or not. Defaults to `true`. This attribute cannot be read.\n",
                    "willReplaceOnChanges": true
                },
                "environmentScope": {
                    "type": "string",
                    "description": "The associated environment to the cluster. Defaults to `*`.\n"
                },
                "kubernetesApiUrl": {
                    "type": "string",
                    "description": "The URL to access the Kubernetes API.\n"
                },
                "kubernetesAuthorizationType": {
                    "type": "string",
                    "description": "The cluster authorization type. Valid values are `rbac`, `abac`, `unknown_authorization`. Defaults to `rbac`.\n",
                    "willReplaceOnChanges": true
                },
                "kubernetesCaCert": {
                    "type": "string",
                    "description": "TLS certificate (needed if API is using a self-signed TLS certificate).\n"
                },
                "kubernetesNamespace": {
                    "type": "string",
                    "description": "The unique namespace related to the instance.\n"
                },
                "kubernetesToken": {
                    "type": "string",
                    "description": "The token to authenticate against Kubernetes. This attribute cannot be read.\n",
                    "secret": true
                },
                "managed": {
                    "type": "boolean",
                    "description": "Determines if cluster is managed by gitlab or not. Defaults to `true`. This attribute cannot be read.\n",
                    "willReplaceOnChanges": true
                },
                "managementProjectId": {
                    "type": "string",
                    "description": "The ID of the management project for the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of cluster.\n"
                }
            },
            "requiredInputs": [
                "kubernetesApiUrl",
                "kubernetesToken"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering InstanceCluster resources.\n",
                "properties": {
                    "clusterType": {
                        "type": "string",
                        "description": "Cluster type.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Create time.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The base domain of the cluster.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Determines if cluster is active or not. Defaults to `true`. This attribute cannot be read.\n",
                        "willReplaceOnChanges": true
                    },
                    "environmentScope": {
                        "type": "string",
                        "description": "The associated environment to the cluster. Defaults to `*`.\n"
                    },
                    "kubernetesApiUrl": {
                        "type": "string",
                        "description": "The URL to access the Kubernetes API.\n"
                    },
                    "kubernetesAuthorizationType": {
                        "type": "string",
                        "description": "The cluster authorization type. Valid values are `rbac`, `abac`, `unknown_authorization`. Defaults to `rbac`.\n",
                        "willReplaceOnChanges": true
                    },
                    "kubernetesCaCert": {
                        "type": "string",
                        "description": "TLS certificate (needed if API is using a self-signed TLS certificate).\n"
                    },
                    "kubernetesNamespace": {
                        "type": "string",
                        "description": "The unique namespace related to the instance.\n"
                    },
                    "kubernetesToken": {
                        "type": "string",
                        "description": "The token to authenticate against Kubernetes. This attribute cannot be read.\n",
                        "secret": true
                    },
                    "managed": {
                        "type": "boolean",
                        "description": "Determines if cluster is managed by gitlab or not. Defaults to `true`. This attribute cannot be read.\n",
                        "willReplaceOnChanges": true
                    },
                    "managementProjectId": {
                        "type": "string",
                        "description": "The ID of the management project for the cluster.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of cluster.\n"
                    },
                    "platformType": {
                        "type": "string",
                        "description": "Platform type.\n"
                    },
                    "providerType": {
                        "type": "string",
                        "description": "Provider type.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/instanceVariable:InstanceVariable": {
            "description": "The `gitlab.InstanceVariable` resource allows to manage the lifecycle of an instance-level CI/CD variable.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/instance_level_ci_variables.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = new gitlab.InstanceVariable(\"example\", {\n    key: \"instance_variable_key\",\n    value: \"instance_variable_value\",\n    \"protected\": false,\n    masked: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.InstanceVariable(\"example\",\n    key=\"instance_variable_key\",\n    value=\"instance_variable_value\",\n    protected=False,\n    masked=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new GitLab.InstanceVariable(\"example\", new()\n    {\n        Key = \"instance_variable_key\",\n        Value = \"instance_variable_value\",\n        Protected = false,\n        Masked = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewInstanceVariable(ctx, \"example\", \u0026gitlab.InstanceVariableArgs{\n\t\t\tKey:       pulumi.String(\"instance_variable_key\"),\n\t\t\tValue:     pulumi.String(\"instance_variable_value\"),\n\t\t\tProtected: pulumi.Bool(false),\n\t\t\tMasked:    pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.InstanceVariable;\nimport com.pulumi.gitlab.InstanceVariableArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new InstanceVariable(\"example\", InstanceVariableArgs.builder()\n            .key(\"instance_variable_key\")\n            .value(\"instance_variable_value\")\n            .protected_(false)\n            .masked(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: gitlab:InstanceVariable\n    properties:\n      key: instance_variable_key\n      value: instance_variable_value\n      protected: false\n      masked: false\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_instance_variable`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_instance_variable.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab instance variables can be imported using an id made up of `variablename`, e.g.\n\n```sh\n$ pulumi import gitlab:index/instanceVariable:InstanceVariable example instance_variable_key\n```\n\n",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "The description of the variable. Maximum of 255 characters.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The name of the variable.\n"
                },
                "masked": {
                    "type": "boolean",
                    "description": "If set to `true`, the value of the variable will be hidden in job logs. The value must meet the [masking requirements](https://docs.gitlab.com/ee/ci/variables/#masked-variables). Defaults to `false`.\n"
                },
                "protected": {
                    "type": "boolean",
                    "description": "If set to `true`, the variable will be passed only to pipelines running on protected branches and tags. Defaults to `false`.\n"
                },
                "raw": {
                    "type": "boolean",
                    "description": "Whether the variable is treated as a raw string. Default: false. When true, variables in the value are not expanded.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the variable.\n"
                },
                "variableType": {
                    "type": "string",
                    "description": "The type of a variable. Valid values are: `env_var`, `file`. Default is `env_var`.\n"
                }
            },
            "required": [
                "key",
                "value"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "The description of the variable. Maximum of 255 characters.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The name of the variable.\n",
                    "willReplaceOnChanges": true
                },
                "masked": {
                    "type": "boolean",
                    "description": "If set to `true`, the value of the variable will be hidden in job logs. The value must meet the [masking requirements](https://docs.gitlab.com/ee/ci/variables/#masked-variables). Defaults to `false`.\n"
                },
                "protected": {
                    "type": "boolean",
                    "description": "If set to `true`, the variable will be passed only to pipelines running on protected branches and tags. Defaults to `false`.\n"
                },
                "raw": {
                    "type": "boolean",
                    "description": "Whether the variable is treated as a raw string. Default: false. When true, variables in the value are not expanded.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the variable.\n"
                },
                "variableType": {
                    "type": "string",
                    "description": "The type of a variable. Valid values are: `env_var`, `file`. Default is `env_var`.\n"
                }
            },
            "requiredInputs": [
                "key",
                "value"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering InstanceVariable resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "The description of the variable. Maximum of 255 characters.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "The name of the variable.\n",
                        "willReplaceOnChanges": true
                    },
                    "masked": {
                        "type": "boolean",
                        "description": "If set to `true`, the value of the variable will be hidden in job logs. The value must meet the [masking requirements](https://docs.gitlab.com/ee/ci/variables/#masked-variables). Defaults to `false`.\n"
                    },
                    "protected": {
                        "type": "boolean",
                        "description": "If set to `true`, the variable will be passed only to pipelines running on protected branches and tags. Defaults to `false`.\n"
                    },
                    "raw": {
                        "type": "boolean",
                        "description": "Whether the variable is treated as a raw string. Default: false. When true, variables in the value are not expanded.\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "The value of the variable.\n"
                    },
                    "variableType": {
                        "type": "string",
                        "description": "The type of a variable. Valid values are: `env_var`, `file`. Default is `env_var`.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/integrationCustomIssueTracker:IntegrationCustomIssueTracker": {
            "description": "The `gitlab.IntegrationCustomIssueTracker` resource allows to manage the lifecycle of a project integration with Custom Issue Tracker.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/integrations.html#custom-issue-tracker)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst awesomeProject = new gitlab.Project(\"awesome_project\", {\n    name: \"awesome_project\",\n    description: \"My awesome project.\",\n    visibilityLevel: \"public\",\n});\nconst tracker = new gitlab.IntegrationCustomIssueTracker(\"tracker\", {\n    project: awesomeProject.id,\n    projectUrl: \"https://customtracker.com/issues\",\n    issuesUrl: \"https://customtracker.com/TEST-:id\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nawesome_project = gitlab.Project(\"awesome_project\",\n    name=\"awesome_project\",\n    description=\"My awesome project.\",\n    visibility_level=\"public\")\ntracker = gitlab.IntegrationCustomIssueTracker(\"tracker\",\n    project=awesome_project.id,\n    project_url=\"https://customtracker.com/issues\",\n    issues_url=\"https://customtracker.com/TEST-:id\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var awesomeProject = new GitLab.Project(\"awesome_project\", new()\n    {\n        Name = \"awesome_project\",\n        Description = \"My awesome project.\",\n        VisibilityLevel = \"public\",\n    });\n\n    var tracker = new GitLab.IntegrationCustomIssueTracker(\"tracker\", new()\n    {\n        Project = awesomeProject.Id,\n        ProjectUrl = \"https://customtracker.com/issues\",\n        IssuesUrl = \"https://customtracker.com/TEST-:id\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tawesomeProject, err := gitlab.NewProject(ctx, \"awesome_project\", \u0026gitlab.ProjectArgs{\n\t\t\tName:            pulumi.String(\"awesome_project\"),\n\t\t\tDescription:     pulumi.String(\"My awesome project.\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewIntegrationCustomIssueTracker(ctx, \"tracker\", \u0026gitlab.IntegrationCustomIssueTrackerArgs{\n\t\t\tProject:    awesomeProject.ID(),\n\t\t\tProjectUrl: pulumi.String(\"https://customtracker.com/issues\"),\n\t\t\tIssuesUrl:  pulumi.String(\"https://customtracker.com/TEST-:id\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.IntegrationCustomIssueTracker;\nimport com.pulumi.gitlab.IntegrationCustomIssueTrackerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var awesomeProject = new Project(\"awesomeProject\", ProjectArgs.builder()\n            .name(\"awesome_project\")\n            .description(\"My awesome project.\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var tracker = new IntegrationCustomIssueTracker(\"tracker\", IntegrationCustomIssueTrackerArgs.builder()\n            .project(awesomeProject.id())\n            .projectUrl(\"https://customtracker.com/issues\")\n            .issuesUrl(\"https://customtracker.com/TEST-:id\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  awesomeProject:\n    type: gitlab:Project\n    name: awesome_project\n    properties:\n      name: awesome_project\n      description: My awesome project.\n      visibilityLevel: public\n  tracker:\n    type: gitlab:IntegrationCustomIssueTracker\n    properties:\n      project: ${awesomeProject.id}\n      projectUrl: https://customtracker.com/issues\n      issuesUrl: https://customtracker.com/TEST-:id\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_integration_custom_issue_tracker`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_integration_custom_issue_tracker.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nYou can import a gitlab_integration_custom_issue_tracker state using the project ID, e.g.\n\n```sh\n$ pulumi import gitlab:index/integrationCustomIssueTracker:IntegrationCustomIssueTracker tracker 1\n```\n\n",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "Whether the integration is active.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "The ISO8601 date/time that this integration was activated at in UTC.\n"
                },
                "issuesUrl": {
                    "type": "string",
                    "description": "The URL to view an issue in the external issue tracker. Must contain :id.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project for the custom issue tracker.\n"
                },
                "projectUrl": {
                    "type": "string",
                    "description": "The URL to the project in the external issue tracker.\n"
                },
                "slug": {
                    "type": "string",
                    "description": "The name of the integration in lowercase, shortened to 63 bytes, and with everything except 0-9 and a-z replaced with -. No leading / trailing -. Use in URLs, host names and domain names.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "The ISO8601 date/time that this integration was last updated at in UTC.\n"
                }
            },
            "required": [
                "active",
                "createdAt",
                "issuesUrl",
                "project",
                "projectUrl",
                "slug",
                "updatedAt"
            ],
            "inputProperties": {
                "issuesUrl": {
                    "type": "string",
                    "description": "The URL to view an issue in the external issue tracker. Must contain :id.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project for the custom issue tracker.\n"
                },
                "projectUrl": {
                    "type": "string",
                    "description": "The URL to the project in the external issue tracker.\n"
                }
            },
            "requiredInputs": [
                "issuesUrl",
                "project",
                "projectUrl"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IntegrationCustomIssueTracker resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "Whether the integration is active.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "The ISO8601 date/time that this integration was activated at in UTC.\n"
                    },
                    "issuesUrl": {
                        "type": "string",
                        "description": "The URL to view an issue in the external issue tracker. Must contain :id.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or full path of the project for the custom issue tracker.\n"
                    },
                    "projectUrl": {
                        "type": "string",
                        "description": "The URL to the project in the external issue tracker.\n"
                    },
                    "slug": {
                        "type": "string",
                        "description": "The name of the integration in lowercase, shortened to 63 bytes, and with everything except 0-9 and a-z replaced with -. No leading / trailing -. Use in URLs, host names and domain names.\n"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "The ISO8601 date/time that this integration was last updated at in UTC.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/integrationEmailsOnPush:IntegrationEmailsOnPush": {
            "description": "The `gitlab.IntegrationEmailsOnPush` resource allows to manage the lifecycle of a project integration with Emails on Push Service.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/integrations.html#emails-on-push)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst awesomeProject = new gitlab.Project(\"awesome_project\", {\n    name: \"awesome_project\",\n    description: \"My awesome project.\",\n    visibilityLevel: \"public\",\n});\nconst emails = new gitlab.IntegrationEmailsOnPush(\"emails\", {\n    project: awesomeProject.id,\n    recipients: \"myrecipient@example.com myotherrecipient@example.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nawesome_project = gitlab.Project(\"awesome_project\",\n    name=\"awesome_project\",\n    description=\"My awesome project.\",\n    visibility_level=\"public\")\nemails = gitlab.IntegrationEmailsOnPush(\"emails\",\n    project=awesome_project.id,\n    recipients=\"myrecipient@example.com myotherrecipient@example.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var awesomeProject = new GitLab.Project(\"awesome_project\", new()\n    {\n        Name = \"awesome_project\",\n        Description = \"My awesome project.\",\n        VisibilityLevel = \"public\",\n    });\n\n    var emails = new GitLab.IntegrationEmailsOnPush(\"emails\", new()\n    {\n        Project = awesomeProject.Id,\n        Recipients = \"myrecipient@example.com myotherrecipient@example.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tawesomeProject, err := gitlab.NewProject(ctx, \"awesome_project\", \u0026gitlab.ProjectArgs{\n\t\t\tName:            pulumi.String(\"awesome_project\"),\n\t\t\tDescription:     pulumi.String(\"My awesome project.\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewIntegrationEmailsOnPush(ctx, \"emails\", \u0026gitlab.IntegrationEmailsOnPushArgs{\n\t\t\tProject:    awesomeProject.ID(),\n\t\t\tRecipients: pulumi.String(\"myrecipient@example.com myotherrecipient@example.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.IntegrationEmailsOnPush;\nimport com.pulumi.gitlab.IntegrationEmailsOnPushArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var awesomeProject = new Project(\"awesomeProject\", ProjectArgs.builder()\n            .name(\"awesome_project\")\n            .description(\"My awesome project.\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var emails = new IntegrationEmailsOnPush(\"emails\", IntegrationEmailsOnPushArgs.builder()\n            .project(awesomeProject.id())\n            .recipients(\"myrecipient@example.com myotherrecipient@example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  awesomeProject:\n    type: gitlab:Project\n    name: awesome_project\n    properties:\n      name: awesome_project\n      description: My awesome project.\n      visibilityLevel: public\n  emails:\n    type: gitlab:IntegrationEmailsOnPush\n    properties:\n      project: ${awesomeProject.id}\n      recipients: myrecipient@example.com myotherrecipient@example.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_integration_emails_on_push`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_integration_emails_on_push.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nYou can import a gitlab_integration_emails_on_push state using the project ID, e.g.\n\n```sh\n$ pulumi import gitlab:index/integrationEmailsOnPush:IntegrationEmailsOnPush emails 1\n```\n\n",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "Whether the integration is active.\n"
                },
                "branchesToBeNotified": {
                    "type": "string",
                    "description": "Branches to send notifications for. Valid options are `all`, `default`, `protected`, `default_and_protected`. Notifications are always fired for tag pushes.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "The ISO8601 date/time that this integration was activated at in UTC.\n"
                },
                "disableDiffs": {
                    "type": "boolean",
                    "description": "Disable code diffs.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID or full-path of the project you want to activate integration on.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for push events.\n"
                },
                "recipients": {
                    "type": "string",
                    "description": "Emails separated by whitespace.\n"
                },
                "sendFromCommitterEmail": {
                    "type": "boolean",
                    "description": "Send from committer.\n"
                },
                "slug": {
                    "type": "string",
                    "description": "The name of the integration in lowercase, shortened to 63 bytes, and with everything except 0-9 and a-z replaced with -. No leading / trailing -. Use in URLs, host names and domain names.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for tag push events.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Title of the integration.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "The ISO8601 date/time that this integration was last updated at in UTC.\n"
                }
            },
            "required": [
                "active",
                "createdAt",
                "project",
                "recipients",
                "slug",
                "title",
                "updatedAt"
            ],
            "inputProperties": {
                "branchesToBeNotified": {
                    "type": "string",
                    "description": "Branches to send notifications for. Valid options are `all`, `default`, `protected`, `default_and_protected`. Notifications are always fired for tag pushes.\n"
                },
                "disableDiffs": {
                    "type": "boolean",
                    "description": "Disable code diffs.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID or full-path of the project you want to activate integration on.\n",
                    "willReplaceOnChanges": true
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for push events.\n"
                },
                "recipients": {
                    "type": "string",
                    "description": "Emails separated by whitespace.\n"
                },
                "sendFromCommitterEmail": {
                    "type": "boolean",
                    "description": "Send from committer.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for tag push events.\n"
                }
            },
            "requiredInputs": [
                "project",
                "recipients"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IntegrationEmailsOnPush resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "Whether the integration is active.\n"
                    },
                    "branchesToBeNotified": {
                        "type": "string",
                        "description": "Branches to send notifications for. Valid options are `all`, `default`, `protected`, `default_and_protected`. Notifications are always fired for tag pushes.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "The ISO8601 date/time that this integration was activated at in UTC.\n"
                    },
                    "disableDiffs": {
                        "type": "boolean",
                        "description": "Disable code diffs.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "ID or full-path of the project you want to activate integration on.\n",
                        "willReplaceOnChanges": true
                    },
                    "pushEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for push events.\n"
                    },
                    "recipients": {
                        "type": "string",
                        "description": "Emails separated by whitespace.\n"
                    },
                    "sendFromCommitterEmail": {
                        "type": "boolean",
                        "description": "Send from committer.\n"
                    },
                    "slug": {
                        "type": "string",
                        "description": "The name of the integration in lowercase, shortened to 63 bytes, and with everything except 0-9 and a-z replaced with -. No leading / trailing -. Use in URLs, host names and domain names.\n"
                    },
                    "tagPushEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for tag push events.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "Title of the integration.\n"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "The ISO8601 date/time that this integration was last updated at in UTC.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/integrationExternalWiki:IntegrationExternalWiki": {
            "description": "The `gitlab.IntegrationExternalWiki` resource allows to manage the lifecycle of a project integration with External Wiki Service.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/integrations.html#external-wiki)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst awesomeProject = new gitlab.Project(\"awesome_project\", {\n    name: \"awesome_project\",\n    description: \"My awesome project.\",\n    visibilityLevel: \"public\",\n});\nconst wiki = new gitlab.IntegrationExternalWiki(\"wiki\", {\n    project: awesomeProject.id,\n    externalWikiUrl: \"https://MyAwesomeExternalWikiURL.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nawesome_project = gitlab.Project(\"awesome_project\",\n    name=\"awesome_project\",\n    description=\"My awesome project.\",\n    visibility_level=\"public\")\nwiki = gitlab.IntegrationExternalWiki(\"wiki\",\n    project=awesome_project.id,\n    external_wiki_url=\"https://MyAwesomeExternalWikiURL.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var awesomeProject = new GitLab.Project(\"awesome_project\", new()\n    {\n        Name = \"awesome_project\",\n        Description = \"My awesome project.\",\n        VisibilityLevel = \"public\",\n    });\n\n    var wiki = new GitLab.IntegrationExternalWiki(\"wiki\", new()\n    {\n        Project = awesomeProject.Id,\n        ExternalWikiUrl = \"https://MyAwesomeExternalWikiURL.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tawesomeProject, err := gitlab.NewProject(ctx, \"awesome_project\", \u0026gitlab.ProjectArgs{\n\t\t\tName:            pulumi.String(\"awesome_project\"),\n\t\t\tDescription:     pulumi.String(\"My awesome project.\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewIntegrationExternalWiki(ctx, \"wiki\", \u0026gitlab.IntegrationExternalWikiArgs{\n\t\t\tProject:         awesomeProject.ID(),\n\t\t\tExternalWikiUrl: pulumi.String(\"https://MyAwesomeExternalWikiURL.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.IntegrationExternalWiki;\nimport com.pulumi.gitlab.IntegrationExternalWikiArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var awesomeProject = new Project(\"awesomeProject\", ProjectArgs.builder()\n            .name(\"awesome_project\")\n            .description(\"My awesome project.\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var wiki = new IntegrationExternalWiki(\"wiki\", IntegrationExternalWikiArgs.builder()\n            .project(awesomeProject.id())\n            .externalWikiUrl(\"https://MyAwesomeExternalWikiURL.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  awesomeProject:\n    type: gitlab:Project\n    name: awesome_project\n    properties:\n      name: awesome_project\n      description: My awesome project.\n      visibilityLevel: public\n  wiki:\n    type: gitlab:IntegrationExternalWiki\n    properties:\n      project: ${awesomeProject.id}\n      externalWikiUrl: https://MyAwesomeExternalWikiURL.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_integration_external_wiki`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_integration_external_wiki.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nYou can import a gitlab_integration_external_wiki state using the project ID, e.g.\n\n```sh\n$ pulumi import gitlab:index/integrationExternalWiki:IntegrationExternalWiki wiki 1\n```\n\n",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "Whether the integration is active.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "The ISO8601 date/time that this integration was activated at in UTC.\n"
                },
                "externalWikiUrl": {
                    "type": "string",
                    "description": "The URL of the external wiki.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n"
                },
                "slug": {
                    "type": "string",
                    "description": "The name of the integration in lowercase, shortened to 63 bytes, and with everything except 0-9 and a-z replaced with -. No leading / trailing -. Use in URLs, host names and domain names.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Title of the integration.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "The ISO8601 date/time that this integration was last updated at in UTC.\n"
                }
            },
            "required": [
                "active",
                "createdAt",
                "externalWikiUrl",
                "project",
                "slug",
                "title",
                "updatedAt"
            ],
            "inputProperties": {
                "externalWikiUrl": {
                    "type": "string",
                    "description": "The URL of the external wiki.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "externalWikiUrl",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IntegrationExternalWiki resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "Whether the integration is active.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "The ISO8601 date/time that this integration was activated at in UTC.\n"
                    },
                    "externalWikiUrl": {
                        "type": "string",
                        "description": "The URL of the external wiki.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "ID of the project you want to activate integration on.\n",
                        "willReplaceOnChanges": true
                    },
                    "slug": {
                        "type": "string",
                        "description": "The name of the integration in lowercase, shortened to 63 bytes, and with everything except 0-9 and a-z replaced with -. No leading / trailing -. Use in URLs, host names and domain names.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "Title of the integration.\n"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "The ISO8601 date/time that this integration was last updated at in UTC.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/integrationGithub:IntegrationGithub": {
            "description": "The `gitlab.IntegrationGithub` resource allows to manage the lifecycle of a project integration with GitHub.\n\n\u003e This resource requires a GitLab Enterprise instance.\n\t\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/integrations.html#github)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst awesomeProject = new gitlab.Project(\"awesome_project\", {\n    name: \"awesome_project\",\n    description: \"My awesome project.\",\n    visibilityLevel: \"public\",\n});\nconst github = new gitlab.IntegrationGithub(\"github\", {\n    project: awesomeProject.id,\n    token: \"REDACTED\",\n    repositoryUrl: \"https://github.com/gitlabhq/terraform-provider-gitlab\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nawesome_project = gitlab.Project(\"awesome_project\",\n    name=\"awesome_project\",\n    description=\"My awesome project.\",\n    visibility_level=\"public\")\ngithub = gitlab.IntegrationGithub(\"github\",\n    project=awesome_project.id,\n    token=\"REDACTED\",\n    repository_url=\"https://github.com/gitlabhq/terraform-provider-gitlab\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var awesomeProject = new GitLab.Project(\"awesome_project\", new()\n    {\n        Name = \"awesome_project\",\n        Description = \"My awesome project.\",\n        VisibilityLevel = \"public\",\n    });\n\n    var github = new GitLab.IntegrationGithub(\"github\", new()\n    {\n        Project = awesomeProject.Id,\n        Token = \"REDACTED\",\n        RepositoryUrl = \"https://github.com/gitlabhq/terraform-provider-gitlab\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tawesomeProject, err := gitlab.NewProject(ctx, \"awesome_project\", \u0026gitlab.ProjectArgs{\n\t\t\tName:            pulumi.String(\"awesome_project\"),\n\t\t\tDescription:     pulumi.String(\"My awesome project.\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewIntegrationGithub(ctx, \"github\", \u0026gitlab.IntegrationGithubArgs{\n\t\t\tProject:       awesomeProject.ID(),\n\t\t\tToken:         pulumi.String(\"REDACTED\"),\n\t\t\tRepositoryUrl: pulumi.String(\"https://github.com/gitlabhq/terraform-provider-gitlab\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.IntegrationGithub;\nimport com.pulumi.gitlab.IntegrationGithubArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var awesomeProject = new Project(\"awesomeProject\", ProjectArgs.builder()\n            .name(\"awesome_project\")\n            .description(\"My awesome project.\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var github = new IntegrationGithub(\"github\", IntegrationGithubArgs.builder()\n            .project(awesomeProject.id())\n            .token(\"REDACTED\")\n            .repositoryUrl(\"https://github.com/gitlabhq/terraform-provider-gitlab\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  awesomeProject:\n    type: gitlab:Project\n    name: awesome_project\n    properties:\n      name: awesome_project\n      description: My awesome project.\n      visibilityLevel: public\n  github:\n    type: gitlab:IntegrationGithub\n    properties:\n      project: ${awesomeProject.id}\n      token: REDACTED\n      repositoryUrl: https://github.com/gitlabhq/terraform-provider-gitlab\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_integration_github`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_integration_github.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\n```sh\n$ pulumi import gitlab:index/integrationGithub:IntegrationGithub You can import a gitlab_integration_github state using `\u003cresource\u003e \u003cproject_id\u003e`:\n```\n\n```sh\n$ pulumi import gitlab:index/integrationGithub:IntegrationGithub github 1\n```\n\n",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "Whether the integration is active.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Create time.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n"
                },
                "repositoryUrl": {
                    "type": "string"
                },
                "staticContext": {
                    "type": "boolean",
                    "description": "Append instance name instead of branch to the status. Must enable to set a GitLab status check as *required* in GitHub. See [Static / dynamic status check names] to learn more.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Title.\n"
                },
                "token": {
                    "type": "string",
                    "description": "A GitHub personal access token with at least `repo:status` scope.\n",
                    "secret": true
                },
                "updatedAt": {
                    "type": "string",
                    "description": "Update time.\n"
                }
            },
            "required": [
                "active",
                "createdAt",
                "project",
                "repositoryUrl",
                "title",
                "token",
                "updatedAt"
            ],
            "inputProperties": {
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n",
                    "willReplaceOnChanges": true
                },
                "repositoryUrl": {
                    "type": "string"
                },
                "staticContext": {
                    "type": "boolean",
                    "description": "Append instance name instead of branch to the status. Must enable to set a GitLab status check as *required* in GitHub. See [Static / dynamic status check names] to learn more.\n"
                },
                "token": {
                    "type": "string",
                    "description": "A GitHub personal access token with at least `repo:status` scope.\n",
                    "secret": true
                }
            },
            "requiredInputs": [
                "project",
                "repositoryUrl",
                "token"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IntegrationGithub resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "Whether the integration is active.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Create time.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "ID of the project you want to activate integration on.\n",
                        "willReplaceOnChanges": true
                    },
                    "repositoryUrl": {
                        "type": "string"
                    },
                    "staticContext": {
                        "type": "boolean",
                        "description": "Append instance name instead of branch to the status. Must enable to set a GitLab status check as *required* in GitHub. See [Static / dynamic status check names] to learn more.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "Title.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "A GitHub personal access token with at least `repo:status` scope.\n",
                        "secret": true
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "Update time.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/integrationJenkins:IntegrationJenkins": {
            "description": "The `gitlab.IntegrationJenkins` resource allows to manage the lifecycle of a project integration with Jenkins.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/integrations.html#jenkins)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst awesomeProject = new gitlab.Project(\"awesome_project\", {\n    name: \"awesome_project\",\n    description: \"My awesome project.\",\n    visibilityLevel: \"public\",\n});\nconst jenkins = new gitlab.IntegrationJenkins(\"jenkins\", {\n    project: awesomeProject.id,\n    jenkinsUrl: \"http://jenkins.example.com\",\n    projectName: \"my_project_name\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nawesome_project = gitlab.Project(\"awesome_project\",\n    name=\"awesome_project\",\n    description=\"My awesome project.\",\n    visibility_level=\"public\")\njenkins = gitlab.IntegrationJenkins(\"jenkins\",\n    project=awesome_project.id,\n    jenkins_url=\"http://jenkins.example.com\",\n    project_name=\"my_project_name\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var awesomeProject = new GitLab.Project(\"awesome_project\", new()\n    {\n        Name = \"awesome_project\",\n        Description = \"My awesome project.\",\n        VisibilityLevel = \"public\",\n    });\n\n    var jenkins = new GitLab.IntegrationJenkins(\"jenkins\", new()\n    {\n        Project = awesomeProject.Id,\n        JenkinsUrl = \"http://jenkins.example.com\",\n        ProjectName = \"my_project_name\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tawesomeProject, err := gitlab.NewProject(ctx, \"awesome_project\", \u0026gitlab.ProjectArgs{\n\t\t\tName:            pulumi.String(\"awesome_project\"),\n\t\t\tDescription:     pulumi.String(\"My awesome project.\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewIntegrationJenkins(ctx, \"jenkins\", \u0026gitlab.IntegrationJenkinsArgs{\n\t\t\tProject:     awesomeProject.ID(),\n\t\t\tJenkinsUrl:  pulumi.String(\"http://jenkins.example.com\"),\n\t\t\tProjectName: pulumi.String(\"my_project_name\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.IntegrationJenkins;\nimport com.pulumi.gitlab.IntegrationJenkinsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var awesomeProject = new Project(\"awesomeProject\", ProjectArgs.builder()\n            .name(\"awesome_project\")\n            .description(\"My awesome project.\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var jenkins = new IntegrationJenkins(\"jenkins\", IntegrationJenkinsArgs.builder()\n            .project(awesomeProject.id())\n            .jenkinsUrl(\"http://jenkins.example.com\")\n            .projectName(\"my_project_name\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  awesomeProject:\n    type: gitlab:Project\n    name: awesome_project\n    properties:\n      name: awesome_project\n      description: My awesome project.\n      visibilityLevel: public\n  jenkins:\n    type: gitlab:IntegrationJenkins\n    properties:\n      project: ${awesomeProject.id}\n      jenkinsUrl: http://jenkins.example.com\n      projectName: my_project_name\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_integration_jenkins`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_integration_jenkins.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\n```sh\n$ pulumi import gitlab:index/integrationJenkins:IntegrationJenkins You can import a gitlab_integration_jenkins state using `\u003cresource\u003e \u003cproject_id\u003e`:\n```\n\n```sh\n$ pulumi import gitlab:index/integrationJenkins:IntegrationJenkins jenkins 1\n```\n\n",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "Whether the integration is active.\n"
                },
                "enableSslVerification": {
                    "type": "boolean",
                    "description": "Enable SSL verification. Defaults to `true` (enabled).\n"
                },
                "jenkinsUrl": {
                    "type": "string",
                    "description": "Jenkins URL like `http://jenkins.example.com`\n"
                },
                "mergeRequestEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for merge request events.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password for authentication with the Jenkins server, if authentication is required by the server.\n",
                    "secret": true
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n"
                },
                "projectName": {
                    "type": "string",
                    "description": "The URL-friendly project name. Example: `my_project_name`.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for push events.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for tag push events.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username for authentication with the Jenkins server, if authentication is required by the server.\n"
                }
            },
            "required": [
                "active",
                "enableSslVerification",
                "jenkinsUrl",
                "mergeRequestEvents",
                "project",
                "projectName",
                "pushEvents",
                "tagPushEvents"
            ],
            "inputProperties": {
                "enableSslVerification": {
                    "type": "boolean",
                    "description": "Enable SSL verification. Defaults to `true` (enabled).\n"
                },
                "jenkinsUrl": {
                    "type": "string",
                    "description": "Jenkins URL like `http://jenkins.example.com`\n"
                },
                "mergeRequestEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for merge request events.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password for authentication with the Jenkins server, if authentication is required by the server.\n",
                    "secret": true
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n"
                },
                "projectName": {
                    "type": "string",
                    "description": "The URL-friendly project name. Example: `my_project_name`.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for push events.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for tag push events.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username for authentication with the Jenkins server, if authentication is required by the server.\n"
                }
            },
            "requiredInputs": [
                "jenkinsUrl",
                "project",
                "projectName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IntegrationJenkins resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "Whether the integration is active.\n"
                    },
                    "enableSslVerification": {
                        "type": "boolean",
                        "description": "Enable SSL verification. Defaults to `true` (enabled).\n"
                    },
                    "jenkinsUrl": {
                        "type": "string",
                        "description": "Jenkins URL like `http://jenkins.example.com`\n"
                    },
                    "mergeRequestEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for merge request events.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "Password for authentication with the Jenkins server, if authentication is required by the server.\n",
                        "secret": true
                    },
                    "project": {
                        "type": "string",
                        "description": "ID of the project you want to activate integration on.\n"
                    },
                    "projectName": {
                        "type": "string",
                        "description": "The URL-friendly project name. Example: `my_project_name`.\n"
                    },
                    "pushEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for push events.\n"
                    },
                    "tagPushEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for tag push events.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Username for authentication with the Jenkins server, if authentication is required by the server.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/integrationJira:IntegrationJira": {
            "description": "The `gitlab.IntegrationJira` resource allows to manage the lifecycle of a project integration with Jira.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/integrations.html#jira)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst awesomeProject = new gitlab.Project(\"awesome_project\", {\n    name: \"awesome_project\",\n    description: \"My awesome project.\",\n    visibilityLevel: \"public\",\n});\nconst jira = new gitlab.IntegrationJira(\"jira\", {\n    project: awesomeProject.id,\n    url: \"https://jira.example.com\",\n    username: \"user\",\n    password: \"mypass\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nawesome_project = gitlab.Project(\"awesome_project\",\n    name=\"awesome_project\",\n    description=\"My awesome project.\",\n    visibility_level=\"public\")\njira = gitlab.IntegrationJira(\"jira\",\n    project=awesome_project.id,\n    url=\"https://jira.example.com\",\n    username=\"user\",\n    password=\"mypass\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var awesomeProject = new GitLab.Project(\"awesome_project\", new()\n    {\n        Name = \"awesome_project\",\n        Description = \"My awesome project.\",\n        VisibilityLevel = \"public\",\n    });\n\n    var jira = new GitLab.IntegrationJira(\"jira\", new()\n    {\n        Project = awesomeProject.Id,\n        Url = \"https://jira.example.com\",\n        Username = \"user\",\n        Password = \"mypass\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tawesomeProject, err := gitlab.NewProject(ctx, \"awesome_project\", \u0026gitlab.ProjectArgs{\n\t\t\tName:            pulumi.String(\"awesome_project\"),\n\t\t\tDescription:     pulumi.String(\"My awesome project.\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewIntegrationJira(ctx, \"jira\", \u0026gitlab.IntegrationJiraArgs{\n\t\t\tProject:  awesomeProject.ID(),\n\t\t\tUrl:      pulumi.String(\"https://jira.example.com\"),\n\t\t\tUsername: pulumi.String(\"user\"),\n\t\t\tPassword: pulumi.String(\"mypass\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.IntegrationJira;\nimport com.pulumi.gitlab.IntegrationJiraArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var awesomeProject = new Project(\"awesomeProject\", ProjectArgs.builder()\n            .name(\"awesome_project\")\n            .description(\"My awesome project.\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var jira = new IntegrationJira(\"jira\", IntegrationJiraArgs.builder()\n            .project(awesomeProject.id())\n            .url(\"https://jira.example.com\")\n            .username(\"user\")\n            .password(\"mypass\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  awesomeProject:\n    type: gitlab:Project\n    name: awesome_project\n    properties:\n      name: awesome_project\n      description: My awesome project.\n      visibilityLevel: public\n  jira:\n    type: gitlab:IntegrationJira\n    properties:\n      project: ${awesomeProject.id}\n      url: https://jira.example.com\n      username: user\n      password: mypass\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_integration_jira`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_integration_jira.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nYou can import a gitlab_integration_jira state using the project ID, e.g.\n\n```sh\n$ pulumi import gitlab:index/integrationJira:IntegrationJira jira 1\n```\n\n",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "Whether the integration is active.\n"
                },
                "apiUrl": {
                    "type": "string",
                    "description": "The base URL to the Jira instance API. Web URL value is used if not set. For example, https://jira-api.example.com.\n"
                },
                "commentOnEventEnabled": {
                    "type": "boolean",
                    "description": "Enable comments inside Jira issues on each GitLab event (commit / merge request)\n"
                },
                "commitEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for commit events\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Create time.\n"
                },
                "issuesEnabled": {
                    "type": "boolean",
                    "description": "Enable viewing Jira issues in GitLab.\n"
                },
                "jiraAuthType": {
                    "type": "integer",
                    "description": "The authentication method to be used with Jira. 0 means Basic Authentication. 1 means Jira personal access token. Defaults to 0.\n"
                },
                "jiraIssuePrefix": {
                    "type": "string",
                    "description": "Prefix to match Jira issue keys.\n"
                },
                "jiraIssueRegex": {
                    "type": "string",
                    "description": "Regular expression to match Jira issue keys.\n"
                },
                "jiraIssueTransitionAutomatic": {
                    "type": "boolean",
                    "description": "Enable automatic issue transitions. Takes precedence over jira*issue*transition_id if enabled. Defaults to false.\n"
                },
                "jiraIssueTransitionId": {
                    "type": "string",
                    "description": "The ID of a transition that moves issues to a closed state. You can find this number under the JIRA workflow administration (Administration \u003e Issues \u003e Workflows) by selecting View under Operations of the desired workflow of your project. By default, this ID is set to 2. *Note**: importing this field is only supported since GitLab 15.2.\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for merge request events\n"
                },
                "password": {
                    "type": "string",
                    "description": "The Jira API token, password, or personal access token to be used with Jira. When your authentication method is basic (jira*auth*type is 0), use an API token for Jira Cloud or a password for Jira Data Center or Jira Server. When your authentication method is a Jira personal access token (jira*auth*type is 1), use the personal access token.\n",
                    "secret": true
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n"
                },
                "projectKey": {
                    "type": "string",
                    "description": "The short identifier for your JIRA project, all uppercase, e.g., PROJ.\n"
                },
                "projectKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Keys of Jira projects. When issues_enabled is true, this setting specifies which Jira projects to view issues from in GitLab.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Title.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "Update time.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL to the JIRA project which is being linked to this GitLab project. For example, https://jira.example.com.\n"
                },
                "useInheritedSettings": {
                    "type": "boolean",
                    "description": "Indicates whether or not to inherit default settings. Defaults to false.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The email or username to be used with Jira. For Jira Cloud use an email, for Jira Data Center and Jira Server use a username. Required when using Basic authentication (jira*auth*type is 0).\n"
                }
            },
            "required": [
                "active",
                "apiUrl",
                "commitEvents",
                "createdAt",
                "mergeRequestsEvents",
                "password",
                "project",
                "title",
                "updatedAt",
                "url"
            ],
            "inputProperties": {
                "apiUrl": {
                    "type": "string",
                    "description": "The base URL to the Jira instance API. Web URL value is used if not set. For example, https://jira-api.example.com.\n"
                },
                "commentOnEventEnabled": {
                    "type": "boolean",
                    "description": "Enable comments inside Jira issues on each GitLab event (commit / merge request)\n"
                },
                "commitEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for commit events\n"
                },
                "issuesEnabled": {
                    "type": "boolean",
                    "description": "Enable viewing Jira issues in GitLab.\n"
                },
                "jiraAuthType": {
                    "type": "integer",
                    "description": "The authentication method to be used with Jira. 0 means Basic Authentication. 1 means Jira personal access token. Defaults to 0.\n"
                },
                "jiraIssuePrefix": {
                    "type": "string",
                    "description": "Prefix to match Jira issue keys.\n"
                },
                "jiraIssueRegex": {
                    "type": "string",
                    "description": "Regular expression to match Jira issue keys.\n"
                },
                "jiraIssueTransitionAutomatic": {
                    "type": "boolean",
                    "description": "Enable automatic issue transitions. Takes precedence over jira*issue*transition_id if enabled. Defaults to false.\n"
                },
                "jiraIssueTransitionId": {
                    "type": "string",
                    "description": "The ID of a transition that moves issues to a closed state. You can find this number under the JIRA workflow administration (Administration \u003e Issues \u003e Workflows) by selecting View under Operations of the desired workflow of your project. By default, this ID is set to 2. *Note**: importing this field is only supported since GitLab 15.2.\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for merge request events\n"
                },
                "password": {
                    "type": "string",
                    "description": "The Jira API token, password, or personal access token to be used with Jira. When your authentication method is basic (jira*auth*type is 0), use an API token for Jira Cloud or a password for Jira Data Center or Jira Server. When your authentication method is a Jira personal access token (jira*auth*type is 1), use the personal access token.\n",
                    "secret": true
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n",
                    "willReplaceOnChanges": true
                },
                "projectKey": {
                    "type": "string",
                    "description": "The short identifier for your JIRA project, all uppercase, e.g., PROJ.\n"
                },
                "projectKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Keys of Jira projects. When issues_enabled is true, this setting specifies which Jira projects to view issues from in GitLab.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL to the JIRA project which is being linked to this GitLab project. For example, https://jira.example.com.\n"
                },
                "useInheritedSettings": {
                    "type": "boolean",
                    "description": "Indicates whether or not to inherit default settings. Defaults to false.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The email or username to be used with Jira. For Jira Cloud use an email, for Jira Data Center and Jira Server use a username. Required when using Basic authentication (jira*auth*type is 0).\n"
                }
            },
            "requiredInputs": [
                "password",
                "project",
                "url"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IntegrationJira resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "Whether the integration is active.\n"
                    },
                    "apiUrl": {
                        "type": "string",
                        "description": "The base URL to the Jira instance API. Web URL value is used if not set. For example, https://jira-api.example.com.\n"
                    },
                    "commentOnEventEnabled": {
                        "type": "boolean",
                        "description": "Enable comments inside Jira issues on each GitLab event (commit / merge request)\n"
                    },
                    "commitEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for commit events\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Create time.\n"
                    },
                    "issuesEnabled": {
                        "type": "boolean",
                        "description": "Enable viewing Jira issues in GitLab.\n"
                    },
                    "jiraAuthType": {
                        "type": "integer",
                        "description": "The authentication method to be used with Jira. 0 means Basic Authentication. 1 means Jira personal access token. Defaults to 0.\n"
                    },
                    "jiraIssuePrefix": {
                        "type": "string",
                        "description": "Prefix to match Jira issue keys.\n"
                    },
                    "jiraIssueRegex": {
                        "type": "string",
                        "description": "Regular expression to match Jira issue keys.\n"
                    },
                    "jiraIssueTransitionAutomatic": {
                        "type": "boolean",
                        "description": "Enable automatic issue transitions. Takes precedence over jira*issue*transition_id if enabled. Defaults to false.\n"
                    },
                    "jiraIssueTransitionId": {
                        "type": "string",
                        "description": "The ID of a transition that moves issues to a closed state. You can find this number under the JIRA workflow administration (Administration \u003e Issues \u003e Workflows) by selecting View under Operations of the desired workflow of your project. By default, this ID is set to 2. *Note**: importing this field is only supported since GitLab 15.2.\n"
                    },
                    "mergeRequestsEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for merge request events\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "The Jira API token, password, or personal access token to be used with Jira. When your authentication method is basic (jira*auth*type is 0), use an API token for Jira Cloud or a password for Jira Data Center or Jira Server. When your authentication method is a Jira personal access token (jira*auth*type is 1), use the personal access token.\n",
                        "secret": true
                    },
                    "project": {
                        "type": "string",
                        "description": "ID of the project you want to activate integration on.\n",
                        "willReplaceOnChanges": true
                    },
                    "projectKey": {
                        "type": "string",
                        "description": "The short identifier for your JIRA project, all uppercase, e.g., PROJ.\n"
                    },
                    "projectKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Keys of Jira projects. When issues_enabled is true, this setting specifies which Jira projects to view issues from in GitLab.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "Title.\n"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "Update time.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "The URL to the JIRA project which is being linked to this GitLab project. For example, https://jira.example.com.\n"
                    },
                    "useInheritedSettings": {
                        "type": "boolean",
                        "description": "Indicates whether or not to inherit default settings. Defaults to false.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "The email or username to be used with Jira. For Jira Cloud use an email, for Jira Data Center and Jira Server use a username. Required when using Basic authentication (jira*auth*type is 0).\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/integrationMattermost:IntegrationMattermost": {
            "description": "The `gitlab.IntegrationMattermost` resource allows to manage the lifecycle of a project integration with Mattermost.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/integrations.html#mattermost-notifications)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst awesomeProject = new gitlab.Project(\"awesome_project\", {\n    name: \"awesome_project\",\n    description: \"My awesome project.\",\n    visibilityLevel: \"public\",\n});\nconst mattermost = new gitlab.IntegrationMattermost(\"mattermost\", {\n    project: awesomeProject.id,\n    webhook: \"https://webhook.com\",\n    username: \"myuser\",\n    pushEvents: true,\n    pushChannel: \"push_chan\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nawesome_project = gitlab.Project(\"awesome_project\",\n    name=\"awesome_project\",\n    description=\"My awesome project.\",\n    visibility_level=\"public\")\nmattermost = gitlab.IntegrationMattermost(\"mattermost\",\n    project=awesome_project.id,\n    webhook=\"https://webhook.com\",\n    username=\"myuser\",\n    push_events=True,\n    push_channel=\"push_chan\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var awesomeProject = new GitLab.Project(\"awesome_project\", new()\n    {\n        Name = \"awesome_project\",\n        Description = \"My awesome project.\",\n        VisibilityLevel = \"public\",\n    });\n\n    var mattermost = new GitLab.IntegrationMattermost(\"mattermost\", new()\n    {\n        Project = awesomeProject.Id,\n        Webhook = \"https://webhook.com\",\n        Username = \"myuser\",\n        PushEvents = true,\n        PushChannel = \"push_chan\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tawesomeProject, err := gitlab.NewProject(ctx, \"awesome_project\", \u0026gitlab.ProjectArgs{\n\t\t\tName:            pulumi.String(\"awesome_project\"),\n\t\t\tDescription:     pulumi.String(\"My awesome project.\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewIntegrationMattermost(ctx, \"mattermost\", \u0026gitlab.IntegrationMattermostArgs{\n\t\t\tProject:     awesomeProject.ID(),\n\t\t\tWebhook:     pulumi.String(\"https://webhook.com\"),\n\t\t\tUsername:    pulumi.String(\"myuser\"),\n\t\t\tPushEvents:  pulumi.Bool(true),\n\t\t\tPushChannel: pulumi.String(\"push_chan\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.IntegrationMattermost;\nimport com.pulumi.gitlab.IntegrationMattermostArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var awesomeProject = new Project(\"awesomeProject\", ProjectArgs.builder()\n            .name(\"awesome_project\")\n            .description(\"My awesome project.\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var mattermost = new IntegrationMattermost(\"mattermost\", IntegrationMattermostArgs.builder()\n            .project(awesomeProject.id())\n            .webhook(\"https://webhook.com\")\n            .username(\"myuser\")\n            .pushEvents(true)\n            .pushChannel(\"push_chan\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  awesomeProject:\n    type: gitlab:Project\n    name: awesome_project\n    properties:\n      name: awesome_project\n      description: My awesome project.\n      visibilityLevel: public\n  mattermost:\n    type: gitlab:IntegrationMattermost\n    properties:\n      project: ${awesomeProject.id}\n      webhook: https://webhook.com\n      username: myuser\n      pushEvents: true\n      pushChannel: push_chan\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_integration_mattermost`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_integration_mattermost.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nYou can import a gitlab_integration_mattermost.mattermost state using the project ID, e.g.\n\n```sh\n$ pulumi import gitlab:index/integrationMattermost:IntegrationMattermost mattermost 1\n```\n\n",
            "properties": {
                "branchesToBeNotified": {
                    "type": "string",
                    "description": "Branches to send notifications for. Valid options are \"all\", \"default\", \"protected\", and \"default*and*protected\".\n"
                },
                "confidentialIssueChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive confidential issue events notifications.\n"
                },
                "confidentialIssuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential issues events.\n"
                },
                "confidentialNoteChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive confidential note events notifications.\n"
                },
                "confidentialNoteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential note events.\n"
                },
                "issueChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive issue events notifications.\n"
                },
                "issuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for issues events.\n"
                },
                "mergeRequestChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive merge request events notifications.\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for merge requests events.\n"
                },
                "noteChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive note events notifications.\n"
                },
                "noteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for note events.\n"
                },
                "notifyOnlyBrokenPipelines": {
                    "type": "boolean",
                    "description": "Send notifications for broken pipelines.\n"
                },
                "pipelineChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive pipeline events notifications.\n"
                },
                "pipelineEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for pipeline events.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n"
                },
                "pushChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive push events notifications.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for push events.\n"
                },
                "tagPushChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive tag push events notifications.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for tag push events.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username to use.\n"
                },
                "webhook": {
                    "type": "string",
                    "description": "Webhook URL (Example, https://mattermost.yourdomain.com/hooks/...). This value cannot be imported.\n"
                },
                "wikiPageChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive wiki page events notifications.\n"
                },
                "wikiPageEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for wiki page events.\n"
                }
            },
            "required": [
                "branchesToBeNotified",
                "confidentialIssuesEvents",
                "confidentialNoteEvents",
                "issuesEvents",
                "mergeRequestsEvents",
                "noteEvents",
                "notifyOnlyBrokenPipelines",
                "pipelineEvents",
                "project",
                "pushEvents",
                "tagPushEvents",
                "webhook",
                "wikiPageEvents"
            ],
            "inputProperties": {
                "branchesToBeNotified": {
                    "type": "string",
                    "description": "Branches to send notifications for. Valid options are \"all\", \"default\", \"protected\", and \"default*and*protected\".\n"
                },
                "confidentialIssueChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive confidential issue events notifications.\n"
                },
                "confidentialIssuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential issues events.\n"
                },
                "confidentialNoteChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive confidential note events notifications.\n"
                },
                "confidentialNoteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential note events.\n"
                },
                "issueChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive issue events notifications.\n"
                },
                "issuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for issues events.\n"
                },
                "mergeRequestChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive merge request events notifications.\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for merge requests events.\n"
                },
                "noteChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive note events notifications.\n"
                },
                "noteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for note events.\n"
                },
                "notifyOnlyBrokenPipelines": {
                    "type": "boolean",
                    "description": "Send notifications for broken pipelines.\n"
                },
                "pipelineChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive pipeline events notifications.\n"
                },
                "pipelineEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for pipeline events.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n",
                    "willReplaceOnChanges": true
                },
                "pushChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive push events notifications.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for push events.\n"
                },
                "tagPushChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive tag push events notifications.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for tag push events.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username to use.\n"
                },
                "webhook": {
                    "type": "string",
                    "description": "Webhook URL (Example, https://mattermost.yourdomain.com/hooks/...). This value cannot be imported.\n"
                },
                "wikiPageChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive wiki page events notifications.\n"
                },
                "wikiPageEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for wiki page events.\n"
                }
            },
            "requiredInputs": [
                "project",
                "webhook"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IntegrationMattermost resources.\n",
                "properties": {
                    "branchesToBeNotified": {
                        "type": "string",
                        "description": "Branches to send notifications for. Valid options are \"all\", \"default\", \"protected\", and \"default*and*protected\".\n"
                    },
                    "confidentialIssueChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive confidential issue events notifications.\n"
                    },
                    "confidentialIssuesEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for confidential issues events.\n"
                    },
                    "confidentialNoteChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive confidential note events notifications.\n"
                    },
                    "confidentialNoteEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for confidential note events.\n"
                    },
                    "issueChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive issue events notifications.\n"
                    },
                    "issuesEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for issues events.\n"
                    },
                    "mergeRequestChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive merge request events notifications.\n"
                    },
                    "mergeRequestsEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for merge requests events.\n"
                    },
                    "noteChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive note events notifications.\n"
                    },
                    "noteEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for note events.\n"
                    },
                    "notifyOnlyBrokenPipelines": {
                        "type": "boolean",
                        "description": "Send notifications for broken pipelines.\n"
                    },
                    "pipelineChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive pipeline events notifications.\n"
                    },
                    "pipelineEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for pipeline events.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "ID of the project you want to activate integration on.\n",
                        "willReplaceOnChanges": true
                    },
                    "pushChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive push events notifications.\n"
                    },
                    "pushEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for push events.\n"
                    },
                    "tagPushChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive tag push events notifications.\n"
                    },
                    "tagPushEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for tag push events.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Username to use.\n"
                    },
                    "webhook": {
                        "type": "string",
                        "description": "Webhook URL (Example, https://mattermost.yourdomain.com/hooks/...). This value cannot be imported.\n"
                    },
                    "wikiPageChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive wiki page events notifications.\n"
                    },
                    "wikiPageEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for wiki page events.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/integrationMicrosoftTeams:IntegrationMicrosoftTeams": {
            "description": "The `gitlab.IntegrationMicrosoftTeams` resource allows to manage the lifecycle of a project integration with Microsoft Teams.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/integrations.html#microsoft-teams)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst awesomeProject = new gitlab.Project(\"awesome_project\", {\n    name: \"awesome_project\",\n    description: \"My awesome project.\",\n    visibilityLevel: \"public\",\n});\nconst teams = new gitlab.IntegrationMicrosoftTeams(\"teams\", {\n    project: awesomeProject.id,\n    webhook: \"https://testurl.com/?token=XYZ\",\n    pushEvents: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nawesome_project = gitlab.Project(\"awesome_project\",\n    name=\"awesome_project\",\n    description=\"My awesome project.\",\n    visibility_level=\"public\")\nteams = gitlab.IntegrationMicrosoftTeams(\"teams\",\n    project=awesome_project.id,\n    webhook=\"https://testurl.com/?token=XYZ\",\n    push_events=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var awesomeProject = new GitLab.Project(\"awesome_project\", new()\n    {\n        Name = \"awesome_project\",\n        Description = \"My awesome project.\",\n        VisibilityLevel = \"public\",\n    });\n\n    var teams = new GitLab.IntegrationMicrosoftTeams(\"teams\", new()\n    {\n        Project = awesomeProject.Id,\n        Webhook = \"https://testurl.com/?token=XYZ\",\n        PushEvents = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tawesomeProject, err := gitlab.NewProject(ctx, \"awesome_project\", \u0026gitlab.ProjectArgs{\n\t\t\tName:            pulumi.String(\"awesome_project\"),\n\t\t\tDescription:     pulumi.String(\"My awesome project.\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewIntegrationMicrosoftTeams(ctx, \"teams\", \u0026gitlab.IntegrationMicrosoftTeamsArgs{\n\t\t\tProject:    awesomeProject.ID(),\n\t\t\tWebhook:    pulumi.String(\"https://testurl.com/?token=XYZ\"),\n\t\t\tPushEvents: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.IntegrationMicrosoftTeams;\nimport com.pulumi.gitlab.IntegrationMicrosoftTeamsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var awesomeProject = new Project(\"awesomeProject\", ProjectArgs.builder()\n            .name(\"awesome_project\")\n            .description(\"My awesome project.\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var teams = new IntegrationMicrosoftTeams(\"teams\", IntegrationMicrosoftTeamsArgs.builder()\n            .project(awesomeProject.id())\n            .webhook(\"https://testurl.com/?token=XYZ\")\n            .pushEvents(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  awesomeProject:\n    type: gitlab:Project\n    name: awesome_project\n    properties:\n      name: awesome_project\n      description: My awesome project.\n      visibilityLevel: public\n  teams:\n    type: gitlab:IntegrationMicrosoftTeams\n    properties:\n      project: ${awesomeProject.id}\n      webhook: https://testurl.com/?token=XYZ\n      pushEvents: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_integration_microsoft_teams`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_integration_microsoft_teams.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nYou can import a gitlab_integration_microsoft_teams state using the project ID, e.g.\n\n```sh\n$ pulumi import gitlab:index/integrationMicrosoftTeams:IntegrationMicrosoftTeams teams 1\n```\n\n",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "Whether the integration is active.\n"
                },
                "branchesToBeNotified": {
                    "type": "string",
                    "description": "Branches to send notifications for. Valid options are “all”, “default”, “protected”, and “default*and*protected”. The default value is “default”\n"
                },
                "confidentialIssuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential issue events\n"
                },
                "confidentialNoteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential note events\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Create time.\n"
                },
                "issuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for issue events\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for merge request events\n"
                },
                "noteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for note events\n"
                },
                "notifyOnlyBrokenPipelines": {
                    "type": "boolean",
                    "description": "Send notifications for broken pipelines\n"
                },
                "pipelineEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for pipeline events\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for push events\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for tag push events\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "Update time.\n"
                },
                "webhook": {
                    "type": "string",
                    "description": "The Microsoft Teams webhook (Example, https://outlook.office.com/webhook/...). This value cannot be imported.\n"
                },
                "wikiPageEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for wiki page events\n"
                }
            },
            "required": [
                "active",
                "createdAt",
                "project",
                "updatedAt",
                "webhook"
            ],
            "inputProperties": {
                "branchesToBeNotified": {
                    "type": "string",
                    "description": "Branches to send notifications for. Valid options are “all”, “default”, “protected”, and “default*and*protected”. The default value is “default”\n"
                },
                "confidentialIssuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential issue events\n"
                },
                "confidentialNoteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential note events\n"
                },
                "issuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for issue events\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for merge request events\n"
                },
                "noteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for note events\n"
                },
                "notifyOnlyBrokenPipelines": {
                    "type": "boolean",
                    "description": "Send notifications for broken pipelines\n"
                },
                "pipelineEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for pipeline events\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n",
                    "willReplaceOnChanges": true
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for push events\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for tag push events\n"
                },
                "webhook": {
                    "type": "string",
                    "description": "The Microsoft Teams webhook (Example, https://outlook.office.com/webhook/...). This value cannot be imported.\n"
                },
                "wikiPageEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for wiki page events\n"
                }
            },
            "requiredInputs": [
                "project",
                "webhook"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IntegrationMicrosoftTeams resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "Whether the integration is active.\n"
                    },
                    "branchesToBeNotified": {
                        "type": "string",
                        "description": "Branches to send notifications for. Valid options are “all”, “default”, “protected”, and “default*and*protected”. The default value is “default”\n"
                    },
                    "confidentialIssuesEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for confidential issue events\n"
                    },
                    "confidentialNoteEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for confidential note events\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Create time.\n"
                    },
                    "issuesEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for issue events\n"
                    },
                    "mergeRequestsEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for merge request events\n"
                    },
                    "noteEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for note events\n"
                    },
                    "notifyOnlyBrokenPipelines": {
                        "type": "boolean",
                        "description": "Send notifications for broken pipelines\n"
                    },
                    "pipelineEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for pipeline events\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "ID of the project you want to activate integration on.\n",
                        "willReplaceOnChanges": true
                    },
                    "pushEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for push events\n"
                    },
                    "tagPushEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for tag push events\n"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "Update time.\n"
                    },
                    "webhook": {
                        "type": "string",
                        "description": "The Microsoft Teams webhook (Example, https://outlook.office.com/webhook/...). This value cannot be imported.\n"
                    },
                    "wikiPageEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for wiki page events\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/integrationPipelinesEmail:IntegrationPipelinesEmail": {
            "description": "The `gitlab.IntegrationPipelinesEmail` resource allows to manage the lifecycle of a project integration with Pipeline Emails Service.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/integrations.html#pipeline-emails)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst awesomeProject = new gitlab.Project(\"awesome_project\", {\n    name: \"awesome_project\",\n    description: \"My awesome project.\",\n    visibilityLevel: \"public\",\n});\nconst email = new gitlab.IntegrationPipelinesEmail(\"email\", {\n    project: awesomeProject.id,\n    recipients: [\"gitlab@user.create\"],\n    notifyOnlyBrokenPipelines: true,\n    branchesToBeNotified: \"all\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nawesome_project = gitlab.Project(\"awesome_project\",\n    name=\"awesome_project\",\n    description=\"My awesome project.\",\n    visibility_level=\"public\")\nemail = gitlab.IntegrationPipelinesEmail(\"email\",\n    project=awesome_project.id,\n    recipients=[\"gitlab@user.create\"],\n    notify_only_broken_pipelines=True,\n    branches_to_be_notified=\"all\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var awesomeProject = new GitLab.Project(\"awesome_project\", new()\n    {\n        Name = \"awesome_project\",\n        Description = \"My awesome project.\",\n        VisibilityLevel = \"public\",\n    });\n\n    var email = new GitLab.IntegrationPipelinesEmail(\"email\", new()\n    {\n        Project = awesomeProject.Id,\n        Recipients = new[]\n        {\n            \"gitlab@user.create\",\n        },\n        NotifyOnlyBrokenPipelines = true,\n        BranchesToBeNotified = \"all\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tawesomeProject, err := gitlab.NewProject(ctx, \"awesome_project\", \u0026gitlab.ProjectArgs{\n\t\t\tName:            pulumi.String(\"awesome_project\"),\n\t\t\tDescription:     pulumi.String(\"My awesome project.\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewIntegrationPipelinesEmail(ctx, \"email\", \u0026gitlab.IntegrationPipelinesEmailArgs{\n\t\t\tProject: awesomeProject.ID(),\n\t\t\tRecipients: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"gitlab@user.create\"),\n\t\t\t},\n\t\t\tNotifyOnlyBrokenPipelines: pulumi.Bool(true),\n\t\t\tBranchesToBeNotified:      pulumi.String(\"all\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.IntegrationPipelinesEmail;\nimport com.pulumi.gitlab.IntegrationPipelinesEmailArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var awesomeProject = new Project(\"awesomeProject\", ProjectArgs.builder()\n            .name(\"awesome_project\")\n            .description(\"My awesome project.\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var email = new IntegrationPipelinesEmail(\"email\", IntegrationPipelinesEmailArgs.builder()\n            .project(awesomeProject.id())\n            .recipients(\"gitlab@user.create\")\n            .notifyOnlyBrokenPipelines(true)\n            .branchesToBeNotified(\"all\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  awesomeProject:\n    type: gitlab:Project\n    name: awesome_project\n    properties:\n      name: awesome_project\n      description: My awesome project.\n      visibilityLevel: public\n  email:\n    type: gitlab:IntegrationPipelinesEmail\n    properties:\n      project: ${awesomeProject.id}\n      recipients:\n        - gitlab@user.create\n      notifyOnlyBrokenPipelines: true\n      branchesToBeNotified: all\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_integration_pipelines_email`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_integration_pipelines_email.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nYou can import a gitlab_integration_pipelines_email state using the project ID, e.g.\n\n```sh\n$ pulumi import gitlab:index/integrationPipelinesEmail:IntegrationPipelinesEmail email 1\n```\n\n",
            "properties": {
                "branchesToBeNotified": {
                    "type": "string",
                    "description": "Branches to send notifications for. Valid options are `all`, `default`, `protected`, and `default_and_protected`. Default is `default`\n"
                },
                "notifyOnlyBrokenPipelines": {
                    "type": "boolean",
                    "description": "Notify only broken pipelines. Default is true.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n"
                },
                "recipients": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ") email addresses where notifications are sent.\n"
                }
            },
            "required": [
                "project",
                "recipients"
            ],
            "inputProperties": {
                "branchesToBeNotified": {
                    "type": "string",
                    "description": "Branches to send notifications for. Valid options are `all`, `default`, `protected`, and `default_and_protected`. Default is `default`\n"
                },
                "notifyOnlyBrokenPipelines": {
                    "type": "boolean",
                    "description": "Notify only broken pipelines. Default is true.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n",
                    "willReplaceOnChanges": true
                },
                "recipients": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ") email addresses where notifications are sent.\n"
                }
            },
            "requiredInputs": [
                "project",
                "recipients"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IntegrationPipelinesEmail resources.\n",
                "properties": {
                    "branchesToBeNotified": {
                        "type": "string",
                        "description": "Branches to send notifications for. Valid options are `all`, `default`, `protected`, and `default_and_protected`. Default is `default`\n"
                    },
                    "notifyOnlyBrokenPipelines": {
                        "type": "boolean",
                        "description": "Notify only broken pipelines. Default is true.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "ID of the project you want to activate integration on.\n",
                        "willReplaceOnChanges": true
                    },
                    "recipients": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": ") email addresses where notifications are sent.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/integrationSlack:IntegrationSlack": {
            "description": "The `gitlab.IntegrationSlack` resource allows to manage the lifecycle of a project integration with Slack.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/integrations.html#slack-notifications)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst awesomeProject = new gitlab.Project(\"awesome_project\", {\n    name: \"awesome_project\",\n    description: \"My awesome project.\",\n    visibilityLevel: \"public\",\n});\nconst slack = new gitlab.IntegrationSlack(\"slack\", {\n    project: awesomeProject.id,\n    webhook: \"https://webhook.com\",\n    username: \"myuser\",\n    pushEvents: true,\n    pushChannel: \"push_chan\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nawesome_project = gitlab.Project(\"awesome_project\",\n    name=\"awesome_project\",\n    description=\"My awesome project.\",\n    visibility_level=\"public\")\nslack = gitlab.IntegrationSlack(\"slack\",\n    project=awesome_project.id,\n    webhook=\"https://webhook.com\",\n    username=\"myuser\",\n    push_events=True,\n    push_channel=\"push_chan\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var awesomeProject = new GitLab.Project(\"awesome_project\", new()\n    {\n        Name = \"awesome_project\",\n        Description = \"My awesome project.\",\n        VisibilityLevel = \"public\",\n    });\n\n    var slack = new GitLab.IntegrationSlack(\"slack\", new()\n    {\n        Project = awesomeProject.Id,\n        Webhook = \"https://webhook.com\",\n        Username = \"myuser\",\n        PushEvents = true,\n        PushChannel = \"push_chan\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tawesomeProject, err := gitlab.NewProject(ctx, \"awesome_project\", \u0026gitlab.ProjectArgs{\n\t\t\tName:            pulumi.String(\"awesome_project\"),\n\t\t\tDescription:     pulumi.String(\"My awesome project.\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewIntegrationSlack(ctx, \"slack\", \u0026gitlab.IntegrationSlackArgs{\n\t\t\tProject:     awesomeProject.ID(),\n\t\t\tWebhook:     pulumi.String(\"https://webhook.com\"),\n\t\t\tUsername:    pulumi.String(\"myuser\"),\n\t\t\tPushEvents:  pulumi.Bool(true),\n\t\t\tPushChannel: pulumi.String(\"push_chan\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.IntegrationSlack;\nimport com.pulumi.gitlab.IntegrationSlackArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var awesomeProject = new Project(\"awesomeProject\", ProjectArgs.builder()\n            .name(\"awesome_project\")\n            .description(\"My awesome project.\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var slack = new IntegrationSlack(\"slack\", IntegrationSlackArgs.builder()\n            .project(awesomeProject.id())\n            .webhook(\"https://webhook.com\")\n            .username(\"myuser\")\n            .pushEvents(true)\n            .pushChannel(\"push_chan\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  awesomeProject:\n    type: gitlab:Project\n    name: awesome_project\n    properties:\n      name: awesome_project\n      description: My awesome project.\n      visibilityLevel: public\n  slack:\n    type: gitlab:IntegrationSlack\n    properties:\n      project: ${awesomeProject.id}\n      webhook: https://webhook.com\n      username: myuser\n      pushEvents: true\n      pushChannel: push_chan\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_integration_slack`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_integration_slack.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nYou can import a gitlab_integration_slack.slack state using the project ID, e.g.\n\n```sh\n$ pulumi import gitlab:index/integrationSlack:IntegrationSlack slack 1\n```\n\n",
            "properties": {
                "branchesToBeNotified": {
                    "type": "string",
                    "description": "Branches to send notifications for. Valid options are \"all\", \"default\", \"protected\", and \"default*and*protected\".\n"
                },
                "confidentialIssueChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive confidential issue events notifications.\n"
                },
                "confidentialIssuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential issues events.\n"
                },
                "confidentialNoteChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive confidential note events notifications.\n"
                },
                "confidentialNoteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential note events.\n"
                },
                "issueChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive issue events notifications.\n"
                },
                "issuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for issues events.\n"
                },
                "jobEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for job events. **ATTENTION**: This attribute is currently not being submitted to the GitLab API, due to https://github.com/xanzy/go-gitlab/issues/1354.\n"
                },
                "mergeRequestChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive merge request events notifications.\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for merge requests events.\n"
                },
                "noteChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive note events notifications.\n"
                },
                "noteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for note events.\n"
                },
                "notifyOnlyBrokenPipelines": {
                    "type": "boolean",
                    "description": "Send notifications for broken pipelines.\n"
                },
                "notifyOnlyDefaultBranch": {
                    "type": "boolean",
                    "description": "This parameter has been replaced with `branches_to_be_notified`.\n",
                    "deprecationMessage": "use 'branches_to_be_notified' argument instead"
                },
                "pipelineChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive pipeline events notifications.\n"
                },
                "pipelineEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for pipeline events.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n"
                },
                "pushChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive push events notifications.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for push events.\n"
                },
                "tagPushChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive tag push events notifications.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for tag push events.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username to use.\n"
                },
                "webhook": {
                    "type": "string",
                    "description": "Webhook URL (Example, https://hooks.slack.com/services/...). This value cannot be imported.\n"
                },
                "wikiPageChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive wiki page events notifications.\n"
                },
                "wikiPageEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for wiki page events.\n"
                }
            },
            "required": [
                "branchesToBeNotified",
                "confidentialIssuesEvents",
                "confidentialNoteChannel",
                "confidentialNoteEvents",
                "issuesEvents",
                "jobEvents",
                "mergeRequestsEvents",
                "noteEvents",
                "notifyOnlyBrokenPipelines",
                "notifyOnlyDefaultBranch",
                "pipelineEvents",
                "project",
                "pushEvents",
                "tagPushEvents",
                "webhook",
                "wikiPageEvents"
            ],
            "inputProperties": {
                "branchesToBeNotified": {
                    "type": "string",
                    "description": "Branches to send notifications for. Valid options are \"all\", \"default\", \"protected\", and \"default*and*protected\".\n"
                },
                "confidentialIssueChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive confidential issue events notifications.\n"
                },
                "confidentialIssuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential issues events.\n"
                },
                "confidentialNoteChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive confidential note events notifications.\n"
                },
                "confidentialNoteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential note events.\n"
                },
                "issueChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive issue events notifications.\n"
                },
                "issuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for issues events.\n"
                },
                "mergeRequestChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive merge request events notifications.\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for merge requests events.\n"
                },
                "noteChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive note events notifications.\n"
                },
                "noteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for note events.\n"
                },
                "notifyOnlyBrokenPipelines": {
                    "type": "boolean",
                    "description": "Send notifications for broken pipelines.\n"
                },
                "notifyOnlyDefaultBranch": {
                    "type": "boolean",
                    "description": "This parameter has been replaced with `branches_to_be_notified`.\n",
                    "deprecationMessage": "use 'branches_to_be_notified' argument instead"
                },
                "pipelineChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive pipeline events notifications.\n"
                },
                "pipelineEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for pipeline events.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n",
                    "willReplaceOnChanges": true
                },
                "pushChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive push events notifications.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for push events.\n"
                },
                "tagPushChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive tag push events notifications.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for tag push events.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username to use.\n"
                },
                "webhook": {
                    "type": "string",
                    "description": "Webhook URL (Example, https://hooks.slack.com/services/...). This value cannot be imported.\n"
                },
                "wikiPageChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive wiki page events notifications.\n"
                },
                "wikiPageEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for wiki page events.\n"
                }
            },
            "requiredInputs": [
                "project",
                "webhook"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IntegrationSlack resources.\n",
                "properties": {
                    "branchesToBeNotified": {
                        "type": "string",
                        "description": "Branches to send notifications for. Valid options are \"all\", \"default\", \"protected\", and \"default*and*protected\".\n"
                    },
                    "confidentialIssueChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive confidential issue events notifications.\n"
                    },
                    "confidentialIssuesEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for confidential issues events.\n"
                    },
                    "confidentialNoteChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive confidential note events notifications.\n"
                    },
                    "confidentialNoteEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for confidential note events.\n"
                    },
                    "issueChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive issue events notifications.\n"
                    },
                    "issuesEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for issues events.\n"
                    },
                    "jobEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for job events. **ATTENTION**: This attribute is currently not being submitted to the GitLab API, due to https://github.com/xanzy/go-gitlab/issues/1354.\n"
                    },
                    "mergeRequestChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive merge request events notifications.\n"
                    },
                    "mergeRequestsEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for merge requests events.\n"
                    },
                    "noteChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive note events notifications.\n"
                    },
                    "noteEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for note events.\n"
                    },
                    "notifyOnlyBrokenPipelines": {
                        "type": "boolean",
                        "description": "Send notifications for broken pipelines.\n"
                    },
                    "notifyOnlyDefaultBranch": {
                        "type": "boolean",
                        "description": "This parameter has been replaced with `branches_to_be_notified`.\n",
                        "deprecationMessage": "use 'branches_to_be_notified' argument instead"
                    },
                    "pipelineChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive pipeline events notifications.\n"
                    },
                    "pipelineEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for pipeline events.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "ID of the project you want to activate integration on.\n",
                        "willReplaceOnChanges": true
                    },
                    "pushChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive push events notifications.\n"
                    },
                    "pushEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for push events.\n"
                    },
                    "tagPushChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive tag push events notifications.\n"
                    },
                    "tagPushEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for tag push events.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Username to use.\n"
                    },
                    "webhook": {
                        "type": "string",
                        "description": "Webhook URL (Example, https://hooks.slack.com/services/...). This value cannot be imported.\n"
                    },
                    "wikiPageChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive wiki page events notifications.\n"
                    },
                    "wikiPageEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for wiki page events.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/integrationTelegram:IntegrationTelegram": {
            "description": "The `gitlab.IntegrationTelegram` resource allows to manage the lifecycle of a project integration with Telegram.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/integrations.html#telegram)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst awesomeProject = new gitlab.Project(\"awesome_project\", {\n    name: \"awesome_project\",\n    description: \"My awesome project.\",\n    visibilityLevel: \"public\",\n});\nconst _default = new gitlab.IntegrationTelegram(\"default\", {\n    token: \"123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11\",\n    room: \"-1000000000000000\",\n    notifyOnlyBrokenPipelines: false,\n    branchesToBeNotified: \"all\",\n    pushEvents: false,\n    issuesEvents: false,\n    confidentialIssuesEvents: false,\n    mergeRequestsEvents: false,\n    tagPushEvents: false,\n    noteEvents: false,\n    confidentialNoteEvents: false,\n    pipelineEvents: false,\n    wikiPageEvents: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nawesome_project = gitlab.Project(\"awesome_project\",\n    name=\"awesome_project\",\n    description=\"My awesome project.\",\n    visibility_level=\"public\")\ndefault = gitlab.IntegrationTelegram(\"default\",\n    token=\"123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11\",\n    room=\"-1000000000000000\",\n    notify_only_broken_pipelines=False,\n    branches_to_be_notified=\"all\",\n    push_events=False,\n    issues_events=False,\n    confidential_issues_events=False,\n    merge_requests_events=False,\n    tag_push_events=False,\n    note_events=False,\n    confidential_note_events=False,\n    pipeline_events=False,\n    wiki_page_events=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var awesomeProject = new GitLab.Project(\"awesome_project\", new()\n    {\n        Name = \"awesome_project\",\n        Description = \"My awesome project.\",\n        VisibilityLevel = \"public\",\n    });\n\n    var @default = new GitLab.IntegrationTelegram(\"default\", new()\n    {\n        Token = \"123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11\",\n        Room = \"-1000000000000000\",\n        NotifyOnlyBrokenPipelines = false,\n        BranchesToBeNotified = \"all\",\n        PushEvents = false,\n        IssuesEvents = false,\n        ConfidentialIssuesEvents = false,\n        MergeRequestsEvents = false,\n        TagPushEvents = false,\n        NoteEvents = false,\n        ConfidentialNoteEvents = false,\n        PipelineEvents = false,\n        WikiPageEvents = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewProject(ctx, \"awesome_project\", \u0026gitlab.ProjectArgs{\n\t\t\tName:            pulumi.String(\"awesome_project\"),\n\t\t\tDescription:     pulumi.String(\"My awesome project.\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewIntegrationTelegram(ctx, \"default\", \u0026gitlab.IntegrationTelegramArgs{\n\t\t\tToken:                     pulumi.String(\"123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11\"),\n\t\t\tRoom:                      pulumi.String(\"-1000000000000000\"),\n\t\t\tNotifyOnlyBrokenPipelines: pulumi.Bool(false),\n\t\t\tBranchesToBeNotified:      pulumi.String(\"all\"),\n\t\t\tPushEvents:                pulumi.Bool(false),\n\t\t\tIssuesEvents:              pulumi.Bool(false),\n\t\t\tConfidentialIssuesEvents:  pulumi.Bool(false),\n\t\t\tMergeRequestsEvents:       pulumi.Bool(false),\n\t\t\tTagPushEvents:             pulumi.Bool(false),\n\t\t\tNoteEvents:                pulumi.Bool(false),\n\t\t\tConfidentialNoteEvents:    pulumi.Bool(false),\n\t\t\tPipelineEvents:            pulumi.Bool(false),\n\t\t\tWikiPageEvents:            pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.IntegrationTelegram;\nimport com.pulumi.gitlab.IntegrationTelegramArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var awesomeProject = new Project(\"awesomeProject\", ProjectArgs.builder()\n            .name(\"awesome_project\")\n            .description(\"My awesome project.\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var default_ = new IntegrationTelegram(\"default\", IntegrationTelegramArgs.builder()\n            .token(\"123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11\")\n            .room(\"-1000000000000000\")\n            .notifyOnlyBrokenPipelines(false)\n            .branchesToBeNotified(\"all\")\n            .pushEvents(false)\n            .issuesEvents(false)\n            .confidentialIssuesEvents(false)\n            .mergeRequestsEvents(false)\n            .tagPushEvents(false)\n            .noteEvents(false)\n            .confidentialNoteEvents(false)\n            .pipelineEvents(false)\n            .wikiPageEvents(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  awesomeProject:\n    type: gitlab:Project\n    name: awesome_project\n    properties:\n      name: awesome_project\n      description: My awesome project.\n      visibilityLevel: public\n  default:\n    type: gitlab:IntegrationTelegram\n    properties:\n      token: 123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11\n      room: '-1000000000000000'\n      notifyOnlyBrokenPipelines: false\n      branchesToBeNotified: all\n      pushEvents: false\n      issuesEvents: false\n      confidentialIssuesEvents: false\n      mergeRequestsEvents: false\n      tagPushEvents: false\n      noteEvents: false\n      confidentialNoteEvents: false\n      pipelineEvents: false\n      wikiPageEvents: false\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_integration_telegram`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_integration_telegram.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nYou can import a gitlab_integration_telegram state using the project ID, e.g.\n\n```sh\n$ pulumi import gitlab:index/integrationTelegram:IntegrationTelegram default 1\n```\n\n",
            "properties": {
                "branchesToBeNotified": {
                    "type": "string",
                    "description": "Branches to send notifications for (introduced in GitLab 16.5). Update of this attribute was not supported before Gitlab 16.11 due to API bug. Valid options are `all`, `default`, `protected`, `default_and_protected`.\n"
                },
                "confidentialIssuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential issues events.\n"
                },
                "confidentialNoteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential note events.\n"
                },
                "issuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for issues events.\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for merge requests events.\n"
                },
                "noteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for note events.\n"
                },
                "notifyOnlyBrokenPipelines": {
                    "type": "boolean",
                    "description": "Send notifications for broken pipelines.\n"
                },
                "pipelineEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for pipeline events.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project to integrate with Telegram.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for push events.\n"
                },
                "room": {
                    "type": "string",
                    "description": "Unique identifier for the target chat or the username of the target channel (in the format `@channelusername`)\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for tag push events.\n"
                },
                "token": {
                    "type": "string",
                    "description": "The Telegram bot token.\n",
                    "secret": true
                },
                "wikiPageEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for wiki page events.\n"
                }
            },
            "required": [
                "branchesToBeNotified",
                "confidentialIssuesEvents",
                "confidentialNoteEvents",
                "issuesEvents",
                "mergeRequestsEvents",
                "noteEvents",
                "notifyOnlyBrokenPipelines",
                "pipelineEvents",
                "project",
                "pushEvents",
                "room",
                "tagPushEvents",
                "token",
                "wikiPageEvents"
            ],
            "inputProperties": {
                "branchesToBeNotified": {
                    "type": "string",
                    "description": "Branches to send notifications for (introduced in GitLab 16.5). Update of this attribute was not supported before Gitlab 16.11 due to API bug. Valid options are `all`, `default`, `protected`, `default_and_protected`.\n"
                },
                "confidentialIssuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential issues events.\n"
                },
                "confidentialNoteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential note events.\n"
                },
                "issuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for issues events.\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for merge requests events.\n"
                },
                "noteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for note events.\n"
                },
                "notifyOnlyBrokenPipelines": {
                    "type": "boolean",
                    "description": "Send notifications for broken pipelines.\n"
                },
                "pipelineEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for pipeline events.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project to integrate with Telegram.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for push events.\n"
                },
                "room": {
                    "type": "string",
                    "description": "Unique identifier for the target chat or the username of the target channel (in the format `@channelusername`)\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for tag push events.\n"
                },
                "token": {
                    "type": "string",
                    "description": "The Telegram bot token.\n",
                    "secret": true
                },
                "wikiPageEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for wiki page events.\n"
                }
            },
            "requiredInputs": [
                "confidentialIssuesEvents",
                "confidentialNoteEvents",
                "issuesEvents",
                "mergeRequestsEvents",
                "noteEvents",
                "pipelineEvents",
                "project",
                "pushEvents",
                "room",
                "tagPushEvents",
                "token",
                "wikiPageEvents"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IntegrationTelegram resources.\n",
                "properties": {
                    "branchesToBeNotified": {
                        "type": "string",
                        "description": "Branches to send notifications for (introduced in GitLab 16.5). Update of this attribute was not supported before Gitlab 16.11 due to API bug. Valid options are `all`, `default`, `protected`, `default_and_protected`.\n"
                    },
                    "confidentialIssuesEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for confidential issues events.\n"
                    },
                    "confidentialNoteEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for confidential note events.\n"
                    },
                    "issuesEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for issues events.\n"
                    },
                    "mergeRequestsEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for merge requests events.\n"
                    },
                    "noteEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for note events.\n"
                    },
                    "notifyOnlyBrokenPipelines": {
                        "type": "boolean",
                        "description": "Send notifications for broken pipelines.\n"
                    },
                    "pipelineEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for pipeline events.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or full path of the project to integrate with Telegram.\n"
                    },
                    "pushEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for push events.\n"
                    },
                    "room": {
                        "type": "string",
                        "description": "Unique identifier for the target chat or the username of the target channel (in the format `@channelusername`)\n"
                    },
                    "tagPushEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for tag push events.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "The Telegram bot token.\n",
                        "secret": true
                    },
                    "wikiPageEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for wiki page events.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/label:Label": {
            "description": "The `gitlab.Label` resource allows to manage the lifecycle of a project label.\n\n\u003e This resource is deprecated. use `gitlab.ProjectLabel`instead!\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/labels.html#project-labels)\n",
            "properties": {
                "color": {
                    "type": "string",
                    "description": "The color of the label given in 6-digit hex notation with leading '#' sign (e.g. #FFAABB) or one of the [CSS color names](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords).\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the label.\n"
                },
                "labelId": {
                    "type": "integer",
                    "description": "The id of the project label.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the label.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the label to.\n"
                }
            },
            "required": [
                "color",
                "labelId",
                "name",
                "project"
            ],
            "inputProperties": {
                "color": {
                    "type": "string",
                    "description": "The color of the label given in 6-digit hex notation with leading '#' sign (e.g. #FFAABB) or one of the [CSS color names](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords).\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the label.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the label.\n",
                    "willReplaceOnChanges": true
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the label to.\n"
                }
            },
            "requiredInputs": [
                "color",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Label resources.\n",
                "properties": {
                    "color": {
                        "type": "string",
                        "description": "The color of the label given in 6-digit hex notation with leading '#' sign (e.g. #FFAABB) or one of the [CSS color names](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords).\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the label.\n"
                    },
                    "labelId": {
                        "type": "integer",
                        "description": "The id of the project label.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the label.\n",
                        "willReplaceOnChanges": true
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project to add the label to.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/memberRole:MemberRole": {
            "description": "The `gitlab.MemberRole` resource allows to manage the lifecycle of a custom member role.\n\nCustom roles allow an organization to create user roles with the precise privileges and permissions required for that organization’s needs.\n\n\u003e This resource requires an Ultimate license.\n\n\u003e Most custom roles are considered billable users that use a seat. [Custom roles billing and seat usage](https://docs.gitlab.com/ee/user/custom_roles.html#billing-and-seat-usage)\n\n\u003e There can be only 10 custom roles on your instance or namespace. See [issue 450929](https://gitlab.com/gitlab-org/gitlab/-/issues/450929) for more details.\n\n**Upstream API**: [GitLab GraphQL API docs](https://docs.gitlab.com/ee/api/graphql/reference/#mutationmemberrolecreate)\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_member_role`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_member_role.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab member role can be imported using the id made up of `gid://gitlab/MemberRole/\u003cID\u003e` e.g.\n\n```sh\n$ pulumi import gitlab:index/memberRole:MemberRole example 'gid://gitlab/MemberRole/123'\n```\n\n",
            "properties": {
                "baseAccessLevel": {
                    "type": "string",
                    "description": "The base access level for the custom role. Valid values are: `DEVELOPER`, `GUEST`, `MAINTAINER`, `MINIMAL_ACCESS`, `OWNER`, `REPORTER`\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Timestamp of when the member role was created. Only available with GitLab version 17.3 or higher.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description for the member role.\n"
                },
                "editPath": {
                    "type": "string",
                    "description": "The Web UI path to edit the member role\n"
                },
                "enabledPermissions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "All permissions enabled for the custom role. Valid values are: `ADMIN_CICD_VARIABLES`, `ADMIN_COMPLIANCE_FRAMEWORK`, `ADMIN_GROUP_MEMBER`, `ADMIN_INTEGRATIONS`, `ADMIN_MERGE_REQUEST`, `ADMIN_PUSH_RULES`, `ADMIN_RUNNERS`, `ADMIN_TERRAFORM_STATE`, `ADMIN_VULNERABILITY`, `ADMIN_WEB_HOOK`, `ARCHIVE_PROJECT`, `MANAGE_DEPLOY_TOKENS`, `MANAGE_GROUP_ACCESS_TOKENS`, `MANAGE_MERGE_REQUEST_SETTINGS`, `MANAGE_PROJECT_ACCESS_TOKENS`, `MANAGE_SECURITY_POLICY_LINK`, `READ_CODE`, `READ_CRM_CONTACT`, `READ_DEPENDENCY`, `READ_RUNNERS`, `READ_VULNERABILITY`, `REMOVE_GROUP`, `REMOVE_PROJECT`\n"
                },
                "groupPath": {
                    "type": "string",
                    "description": "Full path of the namespace to create the member role in. **Required for SAAS** **Not allowed for self-managed**\n"
                },
                "iid": {
                    "type": "integer",
                    "description": "The id integer value extracted from the `id` attribute\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name for the member role.\n"
                }
            },
            "required": [
                "baseAccessLevel",
                "createdAt",
                "description",
                "editPath",
                "enabledPermissions",
                "groupPath",
                "iid",
                "name"
            ],
            "inputProperties": {
                "baseAccessLevel": {
                    "type": "string",
                    "description": "The base access level for the custom role. Valid values are: `DEVELOPER`, `GUEST`, `MAINTAINER`, `MINIMAL_ACCESS`, `OWNER`, `REPORTER`\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description for the member role.\n"
                },
                "enabledPermissions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "All permissions enabled for the custom role. Valid values are: `ADMIN_CICD_VARIABLES`, `ADMIN_COMPLIANCE_FRAMEWORK`, `ADMIN_GROUP_MEMBER`, `ADMIN_INTEGRATIONS`, `ADMIN_MERGE_REQUEST`, `ADMIN_PUSH_RULES`, `ADMIN_RUNNERS`, `ADMIN_TERRAFORM_STATE`, `ADMIN_VULNERABILITY`, `ADMIN_WEB_HOOK`, `ARCHIVE_PROJECT`, `MANAGE_DEPLOY_TOKENS`, `MANAGE_GROUP_ACCESS_TOKENS`, `MANAGE_MERGE_REQUEST_SETTINGS`, `MANAGE_PROJECT_ACCESS_TOKENS`, `MANAGE_SECURITY_POLICY_LINK`, `READ_CODE`, `READ_CRM_CONTACT`, `READ_DEPENDENCY`, `READ_RUNNERS`, `READ_VULNERABILITY`, `REMOVE_GROUP`, `REMOVE_PROJECT`\n"
                },
                "groupPath": {
                    "type": "string",
                    "description": "Full path of the namespace to create the member role in. **Required for SAAS** **Not allowed for self-managed**\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name for the member role.\n"
                }
            },
            "requiredInputs": [
                "baseAccessLevel",
                "enabledPermissions"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MemberRole resources.\n",
                "properties": {
                    "baseAccessLevel": {
                        "type": "string",
                        "description": "The base access level for the custom role. Valid values are: `DEVELOPER`, `GUEST`, `MAINTAINER`, `MINIMAL_ACCESS`, `OWNER`, `REPORTER`\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Timestamp of when the member role was created. Only available with GitLab version 17.3 or higher.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description for the member role.\n"
                    },
                    "editPath": {
                        "type": "string",
                        "description": "The Web UI path to edit the member role\n"
                    },
                    "enabledPermissions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "All permissions enabled for the custom role. Valid values are: `ADMIN_CICD_VARIABLES`, `ADMIN_COMPLIANCE_FRAMEWORK`, `ADMIN_GROUP_MEMBER`, `ADMIN_INTEGRATIONS`, `ADMIN_MERGE_REQUEST`, `ADMIN_PUSH_RULES`, `ADMIN_RUNNERS`, `ADMIN_TERRAFORM_STATE`, `ADMIN_VULNERABILITY`, `ADMIN_WEB_HOOK`, `ARCHIVE_PROJECT`, `MANAGE_DEPLOY_TOKENS`, `MANAGE_GROUP_ACCESS_TOKENS`, `MANAGE_MERGE_REQUEST_SETTINGS`, `MANAGE_PROJECT_ACCESS_TOKENS`, `MANAGE_SECURITY_POLICY_LINK`, `READ_CODE`, `READ_CRM_CONTACT`, `READ_DEPENDENCY`, `READ_RUNNERS`, `READ_VULNERABILITY`, `REMOVE_GROUP`, `REMOVE_PROJECT`\n"
                    },
                    "groupPath": {
                        "type": "string",
                        "description": "Full path of the namespace to create the member role in. **Required for SAAS** **Not allowed for self-managed**\n"
                    },
                    "iid": {
                        "type": "integer",
                        "description": "The id integer value extracted from the `id` attribute\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name for the member role.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/pagesDomain:PagesDomain": {
            "description": "The `gitlab.PagesDomain` resource allows connecting custom domains and TLS certificates in GitLab Pages.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/pages_domains.html)\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_pages_domain`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_pages_domain.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab pages domain can be imported using an id made up of `projectId:domain` _without_ the http protocol, e.g.\n\n```sh\n$ pulumi import gitlab:index/pagesDomain:PagesDomain this 123:example.com\n```\n\n",
            "properties": {
                "autoSslEnabled": {
                    "type": "boolean",
                    "description": "Enables [automatic generation](https://docs.gitlab.com/ee/user/project/pages/custom_domains_ssl_tls_certification/lets_encrypt_integration.html) of SSL certificates issued by Let’s Encrypt for custom domains. When this is set to \"true\", certificate can't be provided.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The certificate in PEM format with intermediates following in most specific to least specific order.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The custom domain indicated by the user.\n"
                },
                "expired": {
                    "type": "boolean",
                    "description": "Whether the certificate is expired.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The certificate key in PEM format.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or [URL-encoded path of the project](https://docs.gitlab.com/ee/api/index.html#namespaced-path-encoding) owned by the authenticated user.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL for the given domain.\n"
                },
                "verificationCode": {
                    "type": "string",
                    "description": "The verification code for the domain.\n",
                    "secret": true
                },
                "verified": {
                    "type": "boolean",
                    "description": "The certificate data.\n"
                }
            },
            "required": [
                "autoSslEnabled",
                "certificate",
                "domain",
                "expired",
                "project",
                "url",
                "verificationCode",
                "verified"
            ],
            "inputProperties": {
                "autoSslEnabled": {
                    "type": "boolean",
                    "description": "Enables [automatic generation](https://docs.gitlab.com/ee/user/project/pages/custom_domains_ssl_tls_certification/lets_encrypt_integration.html) of SSL certificates issued by Let’s Encrypt for custom domains. When this is set to \"true\", certificate can't be provided.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The certificate in PEM format with intermediates following in most specific to least specific order.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The custom domain indicated by the user.\n"
                },
                "expired": {
                    "type": "boolean",
                    "description": "Whether the certificate is expired.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The certificate key in PEM format.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or [URL-encoded path of the project](https://docs.gitlab.com/ee/api/index.html#namespaced-path-encoding) owned by the authenticated user.\n"
                }
            },
            "requiredInputs": [
                "domain",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PagesDomain resources.\n",
                "properties": {
                    "autoSslEnabled": {
                        "type": "boolean",
                        "description": "Enables [automatic generation](https://docs.gitlab.com/ee/user/project/pages/custom_domains_ssl_tls_certification/lets_encrypt_integration.html) of SSL certificates issued by Let’s Encrypt for custom domains. When this is set to \"true\", certificate can't be provided.\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "The certificate in PEM format with intermediates following in most specific to least specific order.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The custom domain indicated by the user.\n"
                    },
                    "expired": {
                        "type": "boolean",
                        "description": "Whether the certificate is expired.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "The certificate key in PEM format.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or [URL-encoded path of the project](https://docs.gitlab.com/ee/api/index.html#namespaced-path-encoding) owned by the authenticated user.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "The URL for the given domain.\n"
                    },
                    "verificationCode": {
                        "type": "string",
                        "description": "The verification code for the domain.\n",
                        "secret": true
                    },
                    "verified": {
                        "type": "boolean",
                        "description": "The certificate data.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/personalAccessToken:PersonalAccessToken": {
            "description": "The `gitlab.PersonalAccessToken` resource allows to manage the lifecycle of a personal access token.\n\n\u003e This resource requires administration privileges.\n\n\u003e Use of the `timestamp()` function with expires_at will cause the resource to be re-created with every apply, it's recommended to use `plantimestamp()` or a static value instead.\n\n\u003e Observability scopes are in beta and may not work on all instances. See more details in [the documentation](https://docs.gitlab.com/ee/operations/tracing.html)\n\n\u003e Use `rotation_configuration` to automatically rotate tokens instead of using `timestamp()` as timestamp will cause changes with every plan. `pulumi up` must still be run to rotate the token.\n\n\u003e Due to [Automatic reuse detection](https://docs.gitlab.com/ee/api/personal_access_tokens.html#automatic-reuse-detection) it's possible that a new Personal Access Token will immediately be revoked. Check if an old process using the old token is running if this happens.\n\n**Upstream API**: [GitLab API docs](https://docs.gitlab.com/ee/api/personal_access_tokens.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = new gitlab.PersonalAccessToken(\"example\", {\n    userId: 25,\n    name: \"Example personal access token\",\n    expiresAt: \"2020-03-14\",\n    scopes: [\"api\"],\n});\nconst exampleProjectVariable = new gitlab.ProjectVariable(\"example\", {\n    project: exampleGitlabProject.id,\n    key: \"pat\",\n    value: example.token,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.PersonalAccessToken(\"example\",\n    user_id=25,\n    name=\"Example personal access token\",\n    expires_at=\"2020-03-14\",\n    scopes=[\"api\"])\nexample_project_variable = gitlab.ProjectVariable(\"example\",\n    project=example_gitlab_project[\"id\"],\n    key=\"pat\",\n    value=example.token)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new GitLab.PersonalAccessToken(\"example\", new()\n    {\n        UserId = 25,\n        Name = \"Example personal access token\",\n        ExpiresAt = \"2020-03-14\",\n        Scopes = new[]\n        {\n            \"api\",\n        },\n    });\n\n    var exampleProjectVariable = new GitLab.ProjectVariable(\"example\", new()\n    {\n        Project = exampleGitlabProject.Id,\n        Key = \"pat\",\n        Value = example.Token,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := gitlab.NewPersonalAccessToken(ctx, \"example\", \u0026gitlab.PersonalAccessTokenArgs{\n\t\t\tUserId:    pulumi.Int(25),\n\t\t\tName:      pulumi.String(\"Example personal access token\"),\n\t\t\tExpiresAt: pulumi.String(\"2020-03-14\"),\n\t\t\tScopes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"api\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectVariable(ctx, \"example\", \u0026gitlab.ProjectVariableArgs{\n\t\t\tProject: pulumi.Any(exampleGitlabProject.Id),\n\t\t\tKey:     pulumi.String(\"pat\"),\n\t\t\tValue:   example.Token,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.PersonalAccessToken;\nimport com.pulumi.gitlab.PersonalAccessTokenArgs;\nimport com.pulumi.gitlab.ProjectVariable;\nimport com.pulumi.gitlab.ProjectVariableArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new PersonalAccessToken(\"example\", PersonalAccessTokenArgs.builder()\n            .userId(\"25\")\n            .name(\"Example personal access token\")\n            .expiresAt(\"2020-03-14\")\n            .scopes(\"api\")\n            .build());\n\n        var exampleProjectVariable = new ProjectVariable(\"exampleProjectVariable\", ProjectVariableArgs.builder()\n            .project(exampleGitlabProject.id())\n            .key(\"pat\")\n            .value(example.token())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: gitlab:PersonalAccessToken\n    properties:\n      userId: '25'\n      name: Example personal access token\n      expiresAt: 2020-03-14\n      scopes:\n        - api\n  exampleProjectVariable:\n    type: gitlab:ProjectVariable\n    name: example\n    properties:\n      project: ${exampleGitlabProject.id}\n      key: pat\n      value: ${example.token}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_personal_access_token`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_personal_access_token.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nA GitLab Personal Access Token can be imported using a key composed of `\u003cuser-id\u003e:\u003ctoken-id\u003e`, e.g.\n\n```sh\n$ pulumi import gitlab:index/personalAccessToken:PersonalAccessToken example \"12345:1\"\n```\n\nNOTE: the `token` resource attribute is not available for imported resources as this information cannot be read from the GitLab API.\n\n",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "True if the token is active.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Time the token has been created, RFC3339 format.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "When the token will expire, YYYY-MM-DD format. Is automatically set when `rotation_configuration` is used.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the personal access token.\n"
                },
                "revoked": {
                    "type": "boolean",
                    "description": "True if the token is revoked.\n"
                },
                "rotationConfiguration": {
                    "$ref": "#/types/gitlab:index/PersonalAccessTokenRotationConfiguration:PersonalAccessTokenRotationConfiguration",
                    "description": "The configuration for when to rotate a token automatically. Will not rotate a token until `pulumi up` is run.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The scopes of the personal access token. valid values are: `api`, `read_user`, `read_api`, `read_repository`, `write_repository`, `read_registry`, `write_registry`, `sudo`, `admin_mode`, `create_runner`, `manage_runner`, `ai_features`, `k8s_proxy`, `read_service_ping`\n"
                },
                "token": {
                    "type": "string",
                    "description": "The token of the personal access token. **Note**: the token is not available for imported resources.\n",
                    "secret": true
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID of the user.\n"
                }
            },
            "required": [
                "active",
                "createdAt",
                "expiresAt",
                "name",
                "revoked",
                "scopes",
                "token",
                "userId"
            ],
            "inputProperties": {
                "expiresAt": {
                    "type": "string",
                    "description": "When the token will expire, YYYY-MM-DD format. Is automatically set when `rotation_configuration` is used.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the personal access token.\n"
                },
                "rotationConfiguration": {
                    "$ref": "#/types/gitlab:index/PersonalAccessTokenRotationConfiguration:PersonalAccessTokenRotationConfiguration",
                    "description": "The configuration for when to rotate a token automatically. Will not rotate a token until `pulumi up` is run.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The scopes of the personal access token. valid values are: `api`, `read_user`, `read_api`, `read_repository`, `write_repository`, `read_registry`, `write_registry`, `sudo`, `admin_mode`, `create_runner`, `manage_runner`, `ai_features`, `k8s_proxy`, `read_service_ping`\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID of the user.\n"
                }
            },
            "requiredInputs": [
                "scopes",
                "userId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PersonalAccessToken resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "True if the token is active.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Time the token has been created, RFC3339 format.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "When the token will expire, YYYY-MM-DD format. Is automatically set when `rotation_configuration` is used.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the personal access token.\n"
                    },
                    "revoked": {
                        "type": "boolean",
                        "description": "True if the token is revoked.\n"
                    },
                    "rotationConfiguration": {
                        "$ref": "#/types/gitlab:index/PersonalAccessTokenRotationConfiguration:PersonalAccessTokenRotationConfiguration",
                        "description": "The configuration for when to rotate a token automatically. Will not rotate a token until `pulumi up` is run.\n"
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The scopes of the personal access token. valid values are: `api`, `read_user`, `read_api`, `read_repository`, `write_repository`, `read_registry`, `write_registry`, `sudo`, `admin_mode`, `create_runner`, `manage_runner`, `ai_features`, `k8s_proxy`, `read_service_ping`\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "The token of the personal access token. **Note**: the token is not available for imported resources.\n",
                        "secret": true
                    },
                    "userId": {
                        "type": "integer",
                        "description": "The ID of the user.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/pipelineSchedule:PipelineSchedule": {
            "description": "The `gitlab.PipelineSchedule` resource allows to manage the lifecycle of a scheduled pipeline.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/pipeline_schedules.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = new gitlab.PipelineSchedule(\"example\", {\n    project: \"12345\",\n    description: \"Used to schedule builds\",\n    ref: \"refs/heads/main\",\n    cron: \"0 1 * * *\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.PipelineSchedule(\"example\",\n    project=\"12345\",\n    description=\"Used to schedule builds\",\n    ref=\"refs/heads/main\",\n    cron=\"0 1 * * *\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new GitLab.PipelineSchedule(\"example\", new()\n    {\n        Project = \"12345\",\n        Description = \"Used to schedule builds\",\n        Ref = \"refs/heads/main\",\n        Cron = \"0 1 * * *\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewPipelineSchedule(ctx, \"example\", \u0026gitlab.PipelineScheduleArgs{\n\t\t\tProject:     pulumi.String(\"12345\"),\n\t\t\tDescription: pulumi.String(\"Used to schedule builds\"),\n\t\t\tRef:         pulumi.String(\"refs/heads/main\"),\n\t\t\tCron:        pulumi.String(\"0 1 * * *\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.PipelineSchedule;\nimport com.pulumi.gitlab.PipelineScheduleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new PipelineSchedule(\"example\", PipelineScheduleArgs.builder()\n            .project(\"12345\")\n            .description(\"Used to schedule builds\")\n            .ref(\"refs/heads/main\")\n            .cron(\"0 1 * * *\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: gitlab:PipelineSchedule\n    properties:\n      project: '12345'\n      description: Used to schedule builds\n      ref: refs/heads/main\n      cron: 0 1 * * *\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_pipeline_schedule`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_pipeline_schedule.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab pipeline schedules can be imported using an id made up of `{project_id}:{pipeline_schedule_id}`, e.g.\n\n```sh\n$ pulumi import gitlab:index/pipelineSchedule:PipelineSchedule test 1:3\n```\n\n",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "The activation of pipeline schedule. If false is set, the pipeline schedule will deactivated initially.\n"
                },
                "cron": {
                    "type": "string",
                    "description": "The cron (e.g. `0 1 * * *`).\n"
                },
                "cronTimezone": {
                    "type": "string",
                    "description": "The timezone.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the pipeline schedule.\n"
                },
                "owner": {
                    "type": "integer",
                    "description": "The ID of the user that owns the pipeline schedule.\n"
                },
                "pipelineScheduleId": {
                    "type": "integer",
                    "description": "The pipeline schedule id.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the schedule to.\n"
                },
                "ref": {
                    "type": "string",
                    "description": "The branch/tag name to be triggered. This must be the full branch reference, for example: `refs/heads/main`, not `main`.\n"
                },
                "takeOwnership": {
                    "type": "boolean"
                }
            },
            "required": [
                "active",
                "cron",
                "cronTimezone",
                "description",
                "owner",
                "pipelineScheduleId",
                "project",
                "ref",
                "takeOwnership"
            ],
            "inputProperties": {
                "active": {
                    "type": "boolean",
                    "description": "The activation of pipeline schedule. If false is set, the pipeline schedule will deactivated initially.\n"
                },
                "cron": {
                    "type": "string",
                    "description": "The cron (e.g. `0 1 * * *`).\n"
                },
                "cronTimezone": {
                    "type": "string",
                    "description": "The timezone.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the pipeline schedule.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the schedule to.\n"
                },
                "ref": {
                    "type": "string",
                    "description": "The branch/tag name to be triggered. This must be the full branch reference, for example: `refs/heads/main`, not `main`.\n"
                },
                "takeOwnership": {
                    "type": "boolean"
                }
            },
            "requiredInputs": [
                "cron",
                "description",
                "project",
                "ref"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PipelineSchedule resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "The activation of pipeline schedule. If false is set, the pipeline schedule will deactivated initially.\n"
                    },
                    "cron": {
                        "type": "string",
                        "description": "The cron (e.g. `0 1 * * *`).\n"
                    },
                    "cronTimezone": {
                        "type": "string",
                        "description": "The timezone.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the pipeline schedule.\n"
                    },
                    "owner": {
                        "type": "integer",
                        "description": "The ID of the user that owns the pipeline schedule.\n"
                    },
                    "pipelineScheduleId": {
                        "type": "integer",
                        "description": "The pipeline schedule id.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project to add the schedule to.\n"
                    },
                    "ref": {
                        "type": "string",
                        "description": "The branch/tag name to be triggered. This must be the full branch reference, for example: `refs/heads/main`, not `main`.\n"
                    },
                    "takeOwnership": {
                        "type": "boolean"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/pipelineScheduleVariable:PipelineScheduleVariable": {
            "description": "The `gitlab.PipelineScheduleVariable` resource allows to manage the lifecycle of a variable for a pipeline schedule.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/pipeline_schedules.html#pipeline-schedule-variables)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = new gitlab.PipelineSchedule(\"example\", {\n    project: \"12345\",\n    description: \"Used to schedule builds\",\n    ref: \"master\",\n    cron: \"0 1 * * *\",\n});\nconst examplePipelineScheduleVariable = new gitlab.PipelineScheduleVariable(\"example\", {\n    project: example.project,\n    pipelineScheduleId: example.pipelineScheduleId,\n    key: \"EXAMPLE_KEY\",\n    value: \"example\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.PipelineSchedule(\"example\",\n    project=\"12345\",\n    description=\"Used to schedule builds\",\n    ref=\"master\",\n    cron=\"0 1 * * *\")\nexample_pipeline_schedule_variable = gitlab.PipelineScheduleVariable(\"example\",\n    project=example.project,\n    pipeline_schedule_id=example.pipeline_schedule_id,\n    key=\"EXAMPLE_KEY\",\n    value=\"example\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new GitLab.PipelineSchedule(\"example\", new()\n    {\n        Project = \"12345\",\n        Description = \"Used to schedule builds\",\n        Ref = \"master\",\n        Cron = \"0 1 * * *\",\n    });\n\n    var examplePipelineScheduleVariable = new GitLab.PipelineScheduleVariable(\"example\", new()\n    {\n        Project = example.Project,\n        PipelineScheduleId = example.PipelineScheduleId,\n        Key = \"EXAMPLE_KEY\",\n        Value = \"example\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := gitlab.NewPipelineSchedule(ctx, \"example\", \u0026gitlab.PipelineScheduleArgs{\n\t\t\tProject:     pulumi.String(\"12345\"),\n\t\t\tDescription: pulumi.String(\"Used to schedule builds\"),\n\t\t\tRef:         pulumi.String(\"master\"),\n\t\t\tCron:        pulumi.String(\"0 1 * * *\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewPipelineScheduleVariable(ctx, \"example\", \u0026gitlab.PipelineScheduleVariableArgs{\n\t\t\tProject:            example.Project,\n\t\t\tPipelineScheduleId: example.PipelineScheduleId,\n\t\t\tKey:                pulumi.String(\"EXAMPLE_KEY\"),\n\t\t\tValue:              pulumi.String(\"example\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.PipelineSchedule;\nimport com.pulumi.gitlab.PipelineScheduleArgs;\nimport com.pulumi.gitlab.PipelineScheduleVariable;\nimport com.pulumi.gitlab.PipelineScheduleVariableArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new PipelineSchedule(\"example\", PipelineScheduleArgs.builder()\n            .project(\"12345\")\n            .description(\"Used to schedule builds\")\n            .ref(\"master\")\n            .cron(\"0 1 * * *\")\n            .build());\n\n        var examplePipelineScheduleVariable = new PipelineScheduleVariable(\"examplePipelineScheduleVariable\", PipelineScheduleVariableArgs.builder()\n            .project(example.project())\n            .pipelineScheduleId(example.pipelineScheduleId())\n            .key(\"EXAMPLE_KEY\")\n            .value(\"example\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: gitlab:PipelineSchedule\n    properties:\n      project: '12345'\n      description: Used to schedule builds\n      ref: master\n      cron: 0 1 * * *\n  examplePipelineScheduleVariable:\n    type: gitlab:PipelineScheduleVariable\n    name: example\n    properties:\n      project: ${example.project}\n      pipelineScheduleId: ${example.pipelineScheduleId}\n      key: EXAMPLE_KEY\n      value: example\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_pipeline_schedule_variable`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_pipeline_schedule_variable.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nPipeline schedule variables can be imported using an id made up of `project_id:pipeline_schedule_id:key`, e.g.\n\n```sh\n$ pulumi import gitlab:index/pipelineScheduleVariable:PipelineScheduleVariable example 123456789:13:mykey\n```\n\n",
            "properties": {
                "key": {
                    "type": "string",
                    "description": "Name of the variable.\n"
                },
                "pipelineScheduleId": {
                    "type": "integer",
                    "description": "The id of the pipeline schedule.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The id of the project to add the schedule to.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value of the variable.\n"
                },
                "variableType": {
                    "type": "string",
                    "description": "The type of a variable. Available types are: `env_var`, `file`. Default is `env_var`.\n"
                }
            },
            "required": [
                "key",
                "pipelineScheduleId",
                "project",
                "value",
                "variableType"
            ],
            "inputProperties": {
                "key": {
                    "type": "string",
                    "description": "Name of the variable.\n",
                    "willReplaceOnChanges": true
                },
                "pipelineScheduleId": {
                    "type": "integer",
                    "description": "The id of the pipeline schedule.\n",
                    "willReplaceOnChanges": true
                },
                "project": {
                    "type": "string",
                    "description": "The id of the project to add the schedule to.\n",
                    "willReplaceOnChanges": true
                },
                "value": {
                    "type": "string",
                    "description": "Value of the variable.\n"
                },
                "variableType": {
                    "type": "string",
                    "description": "The type of a variable. Available types are: `env_var`, `file`. Default is `env_var`.\n"
                }
            },
            "requiredInputs": [
                "key",
                "pipelineScheduleId",
                "project",
                "value"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PipelineScheduleVariable resources.\n",
                "properties": {
                    "key": {
                        "type": "string",
                        "description": "Name of the variable.\n",
                        "willReplaceOnChanges": true
                    },
                    "pipelineScheduleId": {
                        "type": "integer",
                        "description": "The id of the pipeline schedule.\n",
                        "willReplaceOnChanges": true
                    },
                    "project": {
                        "type": "string",
                        "description": "The id of the project to add the schedule to.\n",
                        "willReplaceOnChanges": true
                    },
                    "value": {
                        "type": "string",
                        "description": "Value of the variable.\n"
                    },
                    "variableType": {
                        "type": "string",
                        "description": "The type of a variable. Available types are: `env_var`, `file`. Default is `env_var`.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/pipelineTrigger:PipelineTrigger": {
            "description": "The `gitlab.PipelineTrigger` resource allows to manage the lifecycle of a pipeline trigger.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/pipeline_triggers.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = new gitlab.PipelineTrigger(\"example\", {\n    project: \"12345\",\n    description: \"Used to trigger builds\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.PipelineTrigger(\"example\",\n    project=\"12345\",\n    description=\"Used to trigger builds\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new GitLab.PipelineTrigger(\"example\", new()\n    {\n        Project = \"12345\",\n        Description = \"Used to trigger builds\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewPipelineTrigger(ctx, \"example\", \u0026gitlab.PipelineTriggerArgs{\n\t\t\tProject:     pulumi.String(\"12345\"),\n\t\t\tDescription: pulumi.String(\"Used to trigger builds\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.PipelineTrigger;\nimport com.pulumi.gitlab.PipelineTriggerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new PipelineTrigger(\"example\", PipelineTriggerArgs.builder()\n            .project(\"12345\")\n            .description(\"Used to trigger builds\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: gitlab:PipelineTrigger\n    properties:\n      project: '12345'\n      description: Used to trigger builds\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_pipeline_trigger`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_pipeline_trigger.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab pipeline triggers can be imported using an id made up of `{project_id}:{pipeline_trigger_id}`, e.g.\n\n```sh\n$ pulumi import gitlab:index/pipelineTrigger:PipelineTrigger test 1:3\n```\n\n",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "The description of the pipeline trigger.\n"
                },
                "pipelineTriggerId": {
                    "type": "integer",
                    "description": "The pipeline trigger id.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the trigger to.\n"
                },
                "token": {
                    "type": "string",
                    "description": "The pipeline trigger token. This value is not available during import.\n",
                    "secret": true
                }
            },
            "required": [
                "description",
                "pipelineTriggerId",
                "project",
                "token"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "The description of the pipeline trigger.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the trigger to.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "description",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PipelineTrigger resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "The description of the pipeline trigger.\n"
                    },
                    "pipelineTriggerId": {
                        "type": "integer",
                        "description": "The pipeline trigger id.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project to add the trigger to.\n",
                        "willReplaceOnChanges": true
                    },
                    "token": {
                        "type": "string",
                        "description": "The pipeline trigger token. This value is not available during import.\n",
                        "secret": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/project:Project": {
            "description": "## Example Usage\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_project`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_project.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\n```sh\n$ pulumi import gitlab:index/project:Project You can import a project state using `\u003cresource\u003e \u003cid\u003e`. The\n```\n\n`id` can be whatever the [get single project api][get_single_project] takes for\n\nits `:id` value, so for example:\n\n```sh\n$ pulumi import gitlab:index/project:Project example richardc/example\n```\n\nNOTE: the `import_url_username` and `import_url_password` cannot be imported.\n\n",
            "properties": {
                "allowMergeOnSkippedPipeline": {
                    "type": "boolean",
                    "description": "Set to true if you want to treat skipped pipelines as if they finished with success.\n"
                },
                "allowPipelineTriggerApproveDeployment": {
                    "type": "boolean",
                    "description": "Set whether or not a pipeline triggerer is allowed to approve deployments. Premium and Ultimate only.\n"
                },
                "analyticsAccessLevel": {
                    "type": "string",
                    "description": "Set the analytics access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "approvalsBeforeMerge": {
                    "type": "integer",
                    "description": "Number of merge request approvals required for merging. Default is 0.\nThis field **does not** work well in combination with the `gitlab.ProjectApprovalRule` resource\nand is most likely gonna be deprecated in a future GitLab version (see [this upstream epic](https://gitlab.com/groups/gitlab-org/-/epics/7572)).\nIn the meantime we recommend against using this attribute and use `gitlab.ProjectApprovalRule` instead.\n"
                },
                "archiveOnDestroy": {
                    "type": "boolean",
                    "description": "Set to `true` to archive the project instead of deleting on destroy. If set to `true` it will entire omit the `DELETE` operation.\n"
                },
                "archived": {
                    "type": "boolean",
                    "description": "Whether the project is in read-only mode (archived). Repositories can be archived/unarchived by toggling this parameter.\n"
                },
                "autoCancelPendingPipelines": {
                    "type": "string",
                    "description": "Auto-cancel pending pipelines. This isn’t a boolean, but enabled/disabled.\n"
                },
                "autoDevopsDeployStrategy": {
                    "type": "string",
                    "description": "Auto Deploy strategy. Valid values are `continuous`, `manual`, `timed_incremental`.\n"
                },
                "autoDevopsEnabled": {
                    "type": "boolean",
                    "description": "Enable Auto DevOps for this project.\n"
                },
                "autocloseReferencedIssues": {
                    "type": "boolean",
                    "description": "Set whether auto-closing referenced issues on default branch.\n"
                },
                "avatar": {
                    "type": "string",
                    "description": "A local path to the avatar image to upload. **Note**: not available for imported resources.\n"
                },
                "avatarHash": {
                    "type": "string",
                    "description": "The hash of the avatar image. Use `filesha256(\"path/to/avatar.png\")` whenever possible. **Note**: this is used to trigger an update of the avatar. If it's not given, but an avatar is given, the avatar will be updated each time.\n"
                },
                "avatarUrl": {
                    "type": "string",
                    "description": "The URL of the avatar image.\n"
                },
                "buildCoverageRegex": {
                    "type": "string",
                    "description": "Test coverage parsing for the project. This is deprecated feature in GitLab 15.0.\n",
                    "deprecationMessage": "build_coverage_regex is removed in GitLab 15.0."
                },
                "buildGitStrategy": {
                    "type": "string",
                    "description": "The Git strategy. Defaults to fetch. Valid values are `clone`, `fetch`.\n"
                },
                "buildTimeout": {
                    "type": "integer",
                    "description": "The maximum amount of time, in seconds, that a job can run.\n"
                },
                "buildsAccessLevel": {
                    "type": "string",
                    "description": "Set the builds access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "ciConfigPath": {
                    "type": "string",
                    "description": "Custom Path to CI config file.\n"
                },
                "ciDefaultGitDepth": {
                    "type": "integer",
                    "description": "Default number of revisions for shallow cloning.\n"
                },
                "ciForwardDeploymentEnabled": {
                    "type": "boolean",
                    "description": "When a new deployment job starts, skip older deployment jobs that are still pending.\n"
                },
                "ciPipelineVariablesMinimumOverrideRole": {
                    "type": "string",
                    "description": "The minimum role required to set variables when running pipelines and jobs. Introduced in GitLab 17.1. Valid values are `developer`, `maintainer`, `owner`, `no_one_allowed`\n"
                },
                "ciRestrictPipelineCancellationRole": {
                    "type": "string",
                    "description": "The role required to cancel a pipeline or job. Introduced in GitLab 16.8. Premium and Ultimate only. Valid values are `developer`, `maintainer`, `no one`\n"
                },
                "ciSeparatedCaches": {
                    "type": "boolean",
                    "description": "Use separate caches for protected branches.\n"
                },
                "containerExpirationPolicy": {
                    "$ref": "#/types/gitlab:index/ProjectContainerExpirationPolicy:ProjectContainerExpirationPolicy",
                    "description": "Set the image cleanup policy for this project. **Note**: this field is sometimes named `container_expiration_policy_attributes` in the GitLab Upstream API.\n"
                },
                "containerRegistryAccessLevel": {
                    "type": "string",
                    "description": "Set visibility of container registry, for this project. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "containerRegistryEnabled": {
                    "type": "boolean",
                    "description": "Enable container registry for the project.\n",
                    "deprecationMessage": "Use `container_registry_access_level` instead."
                },
                "defaultBranch": {
                    "type": "string",
                    "description": "The default branch for the project.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description of the project.\n"
                },
                "emailsEnabled": {
                    "type": "boolean",
                    "description": "Enable email notifications.\n"
                },
                "emptyRepo": {
                    "type": "boolean",
                    "description": "Whether the project is empty.\n"
                },
                "environmentsAccessLevel": {
                    "type": "string",
                    "description": "Set the environments access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "externalAuthorizationClassificationLabel": {
                    "type": "string",
                    "description": "The classification label for the project.\n"
                },
                "featureFlagsAccessLevel": {
                    "type": "string",
                    "description": "Set the feature flags access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "forkedFromProjectId": {
                    "type": "integer",
                    "description": "The id of the project to fork. During create the project is forked and during an update the fork relation is changed.\n"
                },
                "forkingAccessLevel": {
                    "type": "string",
                    "description": "Set the forking access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "groupRunnersEnabled": {
                    "type": "boolean",
                    "description": "Enable group runners for this project.\n"
                },
                "groupWithProjectTemplatesId": {
                    "type": "integer",
                    "description": "For group-level custom templates, specifies ID of group from which all the custom project templates are sourced. Leave empty for instance-level templates. Requires use*custom*template to be true (enterprise edition).\n"
                },
                "httpUrlToRepo": {
                    "type": "string",
                    "description": "URL that can be provided to `git clone` to clone the\n"
                },
                "importUrl": {
                    "type": "string",
                    "description": "Git URL to a repository to be imported. Together with `mirror = true` it will setup a Pull Mirror. This can also be used together with `forked_from_project_id` to setup a Pull Mirror for a fork. The fork takes precedence over the import. Make sure to provide the credentials in `import_url_username` and `import_url_password`. GitLab never returns the credentials, thus the provider cannot detect configuration drift in the credentials. They can also not be imported using `pulumi import`. See the examples section for how to properly use it.\n"
                },
                "importUrlPassword": {
                    "type": "string",
                    "description": "The password for the `import_url`. The value of this field is used to construct a valid `import_url` and is only related to the provider. This field cannot be imported using `pulumi import`. See the examples section for how to properly use it.\n",
                    "secret": true
                },
                "importUrlUsername": {
                    "type": "string",
                    "description": "The username for the `import_url`. The value of this field is used to construct a valid `import_url` and is only related to the provider. This field cannot be imported using `pulumi import`.  See the examples section for how to properly use it.\n"
                },
                "infrastructureAccessLevel": {
                    "type": "string",
                    "description": "Set the infrastructure access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "initializeWithReadme": {
                    "type": "boolean",
                    "description": "Create main branch with first commit containing a README.md file. Must be set to `true` if importing an uninitialized project with a different `default_branch`.\n"
                },
                "issuesAccessLevel": {
                    "type": "string",
                    "description": "Set the issues access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "issuesEnabled": {
                    "type": "boolean",
                    "description": "Enable issue tracking for the project.\n"
                },
                "issuesTemplate": {
                    "type": "string",
                    "description": "Sets the template for new issues in the project.\n"
                },
                "keepLatestArtifact": {
                    "type": "boolean",
                    "description": "Disable or enable the ability to keep the latest artifact for this project.\n"
                },
                "lfsEnabled": {
                    "type": "boolean",
                    "description": "Enable LFS for the project.\n"
                },
                "mergeCommitTemplate": {
                    "type": "string",
                    "description": "Template used to create merge commit message in merge requests. (Introduced in GitLab 14.5.)\n"
                },
                "mergeMethod": {
                    "type": "string",
                    "description": "Set the merge method. Valid values are `merge`, `rebase_merge`, `ff`.\n"
                },
                "mergePipelinesEnabled": {
                    "type": "boolean",
                    "description": "Enable or disable merge pipelines.\n"
                },
                "mergeRequestsAccessLevel": {
                    "type": "string",
                    "description": "Set the merge requests access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "mergeRequestsEnabled": {
                    "type": "boolean",
                    "description": "Enable merge requests for the project.\n"
                },
                "mergeRequestsTemplate": {
                    "type": "string",
                    "description": "Sets the template for new merge requests in the project.\n"
                },
                "mergeTrainsEnabled": {
                    "type": "boolean",
                    "description": "Enable or disable merge trains. Requires `merge_pipelines_enabled` to be set to `true` to take effect.\n"
                },
                "mirror": {
                    "type": "boolean",
                    "description": "Enable project pull mirror.\n"
                },
                "mirrorOverwritesDivergedBranches": {
                    "type": "boolean",
                    "description": "Enable overwrite diverged branches for a mirrored project.\n"
                },
                "mirrorTriggerBuilds": {
                    "type": "boolean",
                    "description": "Enable trigger builds on pushes for a mirrored project.\n"
                },
                "modelExperimentsAccessLevel": {
                    "type": "string",
                    "description": "Set visibility of machine learning model experiments. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "modelRegistryAccessLevel": {
                    "type": "string",
                    "description": "Set visibility of machine learning model registry. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "monitorAccessLevel": {
                    "type": "string",
                    "description": "Set the monitor access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "mrDefaultTargetSelf": {
                    "type": "boolean",
                    "description": "For forked projects, target merge requests to this project. If false, the target will be the upstream project.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the project.\n"
                },
                "namespaceId": {
                    "type": "integer",
                    "description": "The namespace (group or user) of the project. Defaults to your user.\n"
                },
                "onlyAllowMergeIfAllDiscussionsAreResolved": {
                    "type": "boolean",
                    "description": "Set to true if you want allow merges only if all discussions are resolved.\n"
                },
                "onlyAllowMergeIfPipelineSucceeds": {
                    "type": "boolean",
                    "description": "Set to true if you want allow merges only if a pipeline succeeds.\n"
                },
                "onlyMirrorProtectedBranches": {
                    "type": "boolean",
                    "description": "Enable only mirror protected branches for a mirrored project.\n"
                },
                "packagesEnabled": {
                    "type": "boolean",
                    "description": "Enable packages repository for the project.\n"
                },
                "pagesAccessLevel": {
                    "type": "string",
                    "description": "Enable pages access control. Valid values are `public`, `private`, `enabled`, `disabled`.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path of the repository.\n"
                },
                "pathWithNamespace": {
                    "type": "string",
                    "description": "The path of the repository with namespace.\n"
                },
                "pipelinesEnabled": {
                    "type": "boolean",
                    "description": "Enable pipelines for the project. The `pipelines_enabled` field is being sent as `jobs_enabled` in the GitLab API calls.\n",
                    "deprecationMessage": "Deprecated in favor of `builds_access_level`"
                },
                "preReceiveSecretDetectionEnabled": {
                    "type": "boolean",
                    "description": "Whether Secret Push Detection is enabled. Requires GitLab Ultimate and at least GitLab 17.3.\n"
                },
                "printingMergeRequestLinkEnabled": {
                    "type": "boolean",
                    "description": "Show link to create/view merge request when pushing from the command line\n"
                },
                "publicBuilds": {
                    "type": "boolean",
                    "description": "If true, jobs can be viewed by non-project members.\n",
                    "deprecationMessage": "The `public_builds` attribute has been deprecated in favor of `public_jobs` and will be removed in the next major version of the provider."
                },
                "publicJobs": {
                    "type": "boolean",
                    "description": "If true, jobs can be viewed by non-project members.\n"
                },
                "pushRules": {
                    "$ref": "#/types/gitlab:index/ProjectPushRules:ProjectPushRules",
                    "description": "Push rules for the project.\n"
                },
                "releasesAccessLevel": {
                    "type": "string",
                    "description": "Set the releases access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "removeSourceBranchAfterMerge": {
                    "type": "boolean",
                    "description": "Enable `Delete source branch` option by default for all new merge requests.\n"
                },
                "repositoryAccessLevel": {
                    "type": "string",
                    "description": "Set the repository access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "repositoryStorage": {
                    "type": "string",
                    "description": "Which storage shard the repository is on. (administrator only)\n"
                },
                "requestAccessEnabled": {
                    "type": "boolean",
                    "description": "Allow users to request member access.\n"
                },
                "requirementsAccessLevel": {
                    "type": "string",
                    "description": "Set the requirements access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "resolveOutdatedDiffDiscussions": {
                    "type": "boolean",
                    "description": "Automatically resolve merge request diffs discussions on lines changed with a push.\n"
                },
                "restrictUserDefinedVariables": {
                    "type": "boolean",
                    "description": "Allow only users with the Maintainer role to pass user-defined variables when triggering a pipeline.\n"
                },
                "runnersToken": {
                    "type": "string",
                    "description": "Registration token to use during runner setup.\n",
                    "secret": true
                },
                "securityAndComplianceAccessLevel": {
                    "type": "string",
                    "description": "Set the security and compliance access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "sharedRunnersEnabled": {
                    "type": "boolean",
                    "description": "Enable shared runners for this project.\n"
                },
                "skipWaitForDefaultBranchProtection": {
                    "type": "boolean",
                    "description": "If `true`, the default behavior to wait for the default branch protection to be created is skipped.\nThis is necessary if the current user is not an admin and the default branch protection is disabled on an instance-level.\nThere is currently no known way to determine if the default branch protection is disabled on an instance-level for non-admin users.\nThis attribute is only used during resource creation, thus changes are suppressed and the attribute cannot be imported.\n"
                },
                "snippetsAccessLevel": {
                    "type": "string",
                    "description": "Set the snippets access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "snippetsEnabled": {
                    "type": "boolean",
                    "description": "Enable snippets for the project.\n"
                },
                "squashCommitTemplate": {
                    "type": "string",
                    "description": "Template used to create squash commit message in merge requests. (Introduced in GitLab 14.6.)\n"
                },
                "squashOption": {
                    "type": "string",
                    "description": "Squash commits when merge request. Valid values are `never`, `always`, `default_on`, or `default_off`. The default value is `default_off`. [GitLab \u003e= 14.1]\n"
                },
                "sshUrlToRepo": {
                    "type": "string",
                    "description": "URL that can be provided to `git clone` to clone the\n"
                },
                "suggestionCommitMessage": {
                    "type": "string",
                    "description": "The commit message used to apply merge request suggestions.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of tags for a project; put array of tags, that should be finally assigned to a project. Use topics instead.\n"
                },
                "templateName": {
                    "type": "string",
                    "description": "When used without use*custom*template, name of a built-in project template. When used with use*custom*template, name of a custom project template. This option is mutually exclusive with `template_project_id`.\n"
                },
                "templateProjectId": {
                    "type": "integer",
                    "description": "When used with use*custom*template, project ID of a custom project template. This is preferable to using template*name since template*name may be ambiguous (enterprise edition). This option is mutually exclusive with `template_name`. See `gitlab.GroupProjectFileTemplate` to set a project as a template project. If a project has not been set as a template, using it here will result in an error.\n"
                },
                "topics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of topics for the project.\n"
                },
                "useCustomTemplate": {
                    "type": "boolean",
                    "description": "Use either custom instance or group (with group*with*project*templates*id) project template (enterprise edition).\n\t\u003e When using a custom template, [Group Tokens won't work](https://docs.gitlab.com/15.7/ee/user/project/settings/import_export_troubleshooting.html#import-using-the-rest-api-fails-when-using-a-group-access-token). You must use a real user's Personal Access Token.\n"
                },
                "visibilityLevel": {
                    "type": "string",
                    "description": "Set to `public` to create a public project. Valid values are `private`, `internal`, `public`.\n"
                },
                "webUrl": {
                    "type": "string",
                    "description": "URL that can be used to find the project in a browser.\n"
                },
                "wikiAccessLevel": {
                    "type": "string",
                    "description": "Set the wiki access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "wikiEnabled": {
                    "type": "boolean",
                    "description": "Enable wiki for the project.\n"
                }
            },
            "required": [
                "allowMergeOnSkippedPipeline",
                "allowPipelineTriggerApproveDeployment",
                "analyticsAccessLevel",
                "autoCancelPendingPipelines",
                "autoDevopsDeployStrategy",
                "autoDevopsEnabled",
                "autocloseReferencedIssues",
                "avatarHash",
                "avatarUrl",
                "buildGitStrategy",
                "buildTimeout",
                "buildsAccessLevel",
                "ciDefaultGitDepth",
                "ciForwardDeploymentEnabled",
                "ciPipelineVariablesMinimumOverrideRole",
                "ciRestrictPipelineCancellationRole",
                "ciSeparatedCaches",
                "containerExpirationPolicy",
                "containerRegistryAccessLevel",
                "containerRegistryEnabled",
                "defaultBranch",
                "emailsEnabled",
                "emptyRepo",
                "environmentsAccessLevel",
                "featureFlagsAccessLevel",
                "forkingAccessLevel",
                "groupRunnersEnabled",
                "httpUrlToRepo",
                "infrastructureAccessLevel",
                "issuesAccessLevel",
                "issuesEnabled",
                "keepLatestArtifact",
                "lfsEnabled",
                "mergeMethod",
                "mergePipelinesEnabled",
                "mergeRequestsAccessLevel",
                "mergeRequestsEnabled",
                "mergeTrainsEnabled",
                "mirrorOverwritesDivergedBranches",
                "mirrorTriggerBuilds",
                "modelExperimentsAccessLevel",
                "modelRegistryAccessLevel",
                "monitorAccessLevel",
                "name",
                "namespaceId",
                "onlyAllowMergeIfAllDiscussionsAreResolved",
                "onlyAllowMergeIfPipelineSucceeds",
                "onlyMirrorProtectedBranches",
                "packagesEnabled",
                "pagesAccessLevel",
                "pathWithNamespace",
                "pipelinesEnabled",
                "preReceiveSecretDetectionEnabled",
                "printingMergeRequestLinkEnabled",
                "publicBuilds",
                "publicJobs",
                "pushRules",
                "releasesAccessLevel",
                "removeSourceBranchAfterMerge",
                "repositoryAccessLevel",
                "repositoryStorage",
                "requestAccessEnabled",
                "requirementsAccessLevel",
                "runnersToken",
                "securityAndComplianceAccessLevel",
                "sharedRunnersEnabled",
                "snippetsAccessLevel",
                "snippetsEnabled",
                "squashOption",
                "sshUrlToRepo",
                "tags",
                "topics",
                "visibilityLevel",
                "webUrl",
                "wikiAccessLevel",
                "wikiEnabled"
            ],
            "inputProperties": {
                "allowMergeOnSkippedPipeline": {
                    "type": "boolean",
                    "description": "Set to true if you want to treat skipped pipelines as if they finished with success.\n"
                },
                "allowPipelineTriggerApproveDeployment": {
                    "type": "boolean",
                    "description": "Set whether or not a pipeline triggerer is allowed to approve deployments. Premium and Ultimate only.\n"
                },
                "analyticsAccessLevel": {
                    "type": "string",
                    "description": "Set the analytics access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "approvalsBeforeMerge": {
                    "type": "integer",
                    "description": "Number of merge request approvals required for merging. Default is 0.\nThis field **does not** work well in combination with the `gitlab.ProjectApprovalRule` resource\nand is most likely gonna be deprecated in a future GitLab version (see [this upstream epic](https://gitlab.com/groups/gitlab-org/-/epics/7572)).\nIn the meantime we recommend against using this attribute and use `gitlab.ProjectApprovalRule` instead.\n"
                },
                "archiveOnDestroy": {
                    "type": "boolean",
                    "description": "Set to `true` to archive the project instead of deleting on destroy. If set to `true` it will entire omit the `DELETE` operation.\n"
                },
                "archived": {
                    "type": "boolean",
                    "description": "Whether the project is in read-only mode (archived). Repositories can be archived/unarchived by toggling this parameter.\n"
                },
                "autoCancelPendingPipelines": {
                    "type": "string",
                    "description": "Auto-cancel pending pipelines. This isn’t a boolean, but enabled/disabled.\n"
                },
                "autoDevopsDeployStrategy": {
                    "type": "string",
                    "description": "Auto Deploy strategy. Valid values are `continuous`, `manual`, `timed_incremental`.\n"
                },
                "autoDevopsEnabled": {
                    "type": "boolean",
                    "description": "Enable Auto DevOps for this project.\n"
                },
                "autocloseReferencedIssues": {
                    "type": "boolean",
                    "description": "Set whether auto-closing referenced issues on default branch.\n"
                },
                "avatar": {
                    "type": "string",
                    "description": "A local path to the avatar image to upload. **Note**: not available for imported resources.\n"
                },
                "avatarHash": {
                    "type": "string",
                    "description": "The hash of the avatar image. Use `filesha256(\"path/to/avatar.png\")` whenever possible. **Note**: this is used to trigger an update of the avatar. If it's not given, but an avatar is given, the avatar will be updated each time.\n"
                },
                "buildCoverageRegex": {
                    "type": "string",
                    "description": "Test coverage parsing for the project. This is deprecated feature in GitLab 15.0.\n",
                    "deprecationMessage": "build_coverage_regex is removed in GitLab 15.0."
                },
                "buildGitStrategy": {
                    "type": "string",
                    "description": "The Git strategy. Defaults to fetch. Valid values are `clone`, `fetch`.\n"
                },
                "buildTimeout": {
                    "type": "integer",
                    "description": "The maximum amount of time, in seconds, that a job can run.\n"
                },
                "buildsAccessLevel": {
                    "type": "string",
                    "description": "Set the builds access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "ciConfigPath": {
                    "type": "string",
                    "description": "Custom Path to CI config file.\n"
                },
                "ciDefaultGitDepth": {
                    "type": "integer",
                    "description": "Default number of revisions for shallow cloning.\n"
                },
                "ciForwardDeploymentEnabled": {
                    "type": "boolean",
                    "description": "When a new deployment job starts, skip older deployment jobs that are still pending.\n"
                },
                "ciPipelineVariablesMinimumOverrideRole": {
                    "type": "string",
                    "description": "The minimum role required to set variables when running pipelines and jobs. Introduced in GitLab 17.1. Valid values are `developer`, `maintainer`, `owner`, `no_one_allowed`\n"
                },
                "ciRestrictPipelineCancellationRole": {
                    "type": "string",
                    "description": "The role required to cancel a pipeline or job. Introduced in GitLab 16.8. Premium and Ultimate only. Valid values are `developer`, `maintainer`, `no one`\n"
                },
                "ciSeparatedCaches": {
                    "type": "boolean",
                    "description": "Use separate caches for protected branches.\n"
                },
                "containerExpirationPolicy": {
                    "$ref": "#/types/gitlab:index/ProjectContainerExpirationPolicy:ProjectContainerExpirationPolicy",
                    "description": "Set the image cleanup policy for this project. **Note**: this field is sometimes named `container_expiration_policy_attributes` in the GitLab Upstream API.\n"
                },
                "containerRegistryAccessLevel": {
                    "type": "string",
                    "description": "Set visibility of container registry, for this project. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "containerRegistryEnabled": {
                    "type": "boolean",
                    "description": "Enable container registry for the project.\n",
                    "deprecationMessage": "Use `container_registry_access_level` instead."
                },
                "defaultBranch": {
                    "type": "string",
                    "description": "The default branch for the project.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description of the project.\n"
                },
                "emailsEnabled": {
                    "type": "boolean",
                    "description": "Enable email notifications.\n"
                },
                "environmentsAccessLevel": {
                    "type": "string",
                    "description": "Set the environments access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "externalAuthorizationClassificationLabel": {
                    "type": "string",
                    "description": "The classification label for the project.\n"
                },
                "featureFlagsAccessLevel": {
                    "type": "string",
                    "description": "Set the feature flags access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "forkedFromProjectId": {
                    "type": "integer",
                    "description": "The id of the project to fork. During create the project is forked and during an update the fork relation is changed.\n"
                },
                "forkingAccessLevel": {
                    "type": "string",
                    "description": "Set the forking access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "groupRunnersEnabled": {
                    "type": "boolean",
                    "description": "Enable group runners for this project.\n"
                },
                "groupWithProjectTemplatesId": {
                    "type": "integer",
                    "description": "For group-level custom templates, specifies ID of group from which all the custom project templates are sourced. Leave empty for instance-level templates. Requires use*custom*template to be true (enterprise edition).\n"
                },
                "importUrl": {
                    "type": "string",
                    "description": "Git URL to a repository to be imported. Together with `mirror = true` it will setup a Pull Mirror. This can also be used together with `forked_from_project_id` to setup a Pull Mirror for a fork. The fork takes precedence over the import. Make sure to provide the credentials in `import_url_username` and `import_url_password`. GitLab never returns the credentials, thus the provider cannot detect configuration drift in the credentials. They can also not be imported using `pulumi import`. See the examples section for how to properly use it.\n"
                },
                "importUrlPassword": {
                    "type": "string",
                    "description": "The password for the `import_url`. The value of this field is used to construct a valid `import_url` and is only related to the provider. This field cannot be imported using `pulumi import`. See the examples section for how to properly use it.\n",
                    "secret": true
                },
                "importUrlUsername": {
                    "type": "string",
                    "description": "The username for the `import_url`. The value of this field is used to construct a valid `import_url` and is only related to the provider. This field cannot be imported using `pulumi import`.  See the examples section for how to properly use it.\n"
                },
                "infrastructureAccessLevel": {
                    "type": "string",
                    "description": "Set the infrastructure access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "initializeWithReadme": {
                    "type": "boolean",
                    "description": "Create main branch with first commit containing a README.md file. Must be set to `true` if importing an uninitialized project with a different `default_branch`.\n"
                },
                "issuesAccessLevel": {
                    "type": "string",
                    "description": "Set the issues access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "issuesEnabled": {
                    "type": "boolean",
                    "description": "Enable issue tracking for the project.\n"
                },
                "issuesTemplate": {
                    "type": "string",
                    "description": "Sets the template for new issues in the project.\n"
                },
                "keepLatestArtifact": {
                    "type": "boolean",
                    "description": "Disable or enable the ability to keep the latest artifact for this project.\n"
                },
                "lfsEnabled": {
                    "type": "boolean",
                    "description": "Enable LFS for the project.\n"
                },
                "mergeCommitTemplate": {
                    "type": "string",
                    "description": "Template used to create merge commit message in merge requests. (Introduced in GitLab 14.5.)\n"
                },
                "mergeMethod": {
                    "type": "string",
                    "description": "Set the merge method. Valid values are `merge`, `rebase_merge`, `ff`.\n"
                },
                "mergePipelinesEnabled": {
                    "type": "boolean",
                    "description": "Enable or disable merge pipelines.\n"
                },
                "mergeRequestsAccessLevel": {
                    "type": "string",
                    "description": "Set the merge requests access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "mergeRequestsEnabled": {
                    "type": "boolean",
                    "description": "Enable merge requests for the project.\n"
                },
                "mergeRequestsTemplate": {
                    "type": "string",
                    "description": "Sets the template for new merge requests in the project.\n"
                },
                "mergeTrainsEnabled": {
                    "type": "boolean",
                    "description": "Enable or disable merge trains. Requires `merge_pipelines_enabled` to be set to `true` to take effect.\n"
                },
                "mirror": {
                    "type": "boolean",
                    "description": "Enable project pull mirror.\n"
                },
                "mirrorOverwritesDivergedBranches": {
                    "type": "boolean",
                    "description": "Enable overwrite diverged branches for a mirrored project.\n"
                },
                "mirrorTriggerBuilds": {
                    "type": "boolean",
                    "description": "Enable trigger builds on pushes for a mirrored project.\n"
                },
                "modelExperimentsAccessLevel": {
                    "type": "string",
                    "description": "Set visibility of machine learning model experiments. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "modelRegistryAccessLevel": {
                    "type": "string",
                    "description": "Set visibility of machine learning model registry. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "monitorAccessLevel": {
                    "type": "string",
                    "description": "Set the monitor access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "mrDefaultTargetSelf": {
                    "type": "boolean",
                    "description": "For forked projects, target merge requests to this project. If false, the target will be the upstream project.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the project.\n"
                },
                "namespaceId": {
                    "type": "integer",
                    "description": "The namespace (group or user) of the project. Defaults to your user.\n"
                },
                "onlyAllowMergeIfAllDiscussionsAreResolved": {
                    "type": "boolean",
                    "description": "Set to true if you want allow merges only if all discussions are resolved.\n"
                },
                "onlyAllowMergeIfPipelineSucceeds": {
                    "type": "boolean",
                    "description": "Set to true if you want allow merges only if a pipeline succeeds.\n"
                },
                "onlyMirrorProtectedBranches": {
                    "type": "boolean",
                    "description": "Enable only mirror protected branches for a mirrored project.\n"
                },
                "packagesEnabled": {
                    "type": "boolean",
                    "description": "Enable packages repository for the project.\n"
                },
                "pagesAccessLevel": {
                    "type": "string",
                    "description": "Enable pages access control. Valid values are `public`, `private`, `enabled`, `disabled`.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path of the repository.\n"
                },
                "pipelinesEnabled": {
                    "type": "boolean",
                    "description": "Enable pipelines for the project. The `pipelines_enabled` field is being sent as `jobs_enabled` in the GitLab API calls.\n",
                    "deprecationMessage": "Deprecated in favor of `builds_access_level`"
                },
                "preReceiveSecretDetectionEnabled": {
                    "type": "boolean",
                    "description": "Whether Secret Push Detection is enabled. Requires GitLab Ultimate and at least GitLab 17.3.\n"
                },
                "printingMergeRequestLinkEnabled": {
                    "type": "boolean",
                    "description": "Show link to create/view merge request when pushing from the command line\n"
                },
                "publicBuilds": {
                    "type": "boolean",
                    "description": "If true, jobs can be viewed by non-project members.\n",
                    "deprecationMessage": "The `public_builds` attribute has been deprecated in favor of `public_jobs` and will be removed in the next major version of the provider."
                },
                "publicJobs": {
                    "type": "boolean",
                    "description": "If true, jobs can be viewed by non-project members.\n"
                },
                "pushRules": {
                    "$ref": "#/types/gitlab:index/ProjectPushRules:ProjectPushRules",
                    "description": "Push rules for the project.\n"
                },
                "releasesAccessLevel": {
                    "type": "string",
                    "description": "Set the releases access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "removeSourceBranchAfterMerge": {
                    "type": "boolean",
                    "description": "Enable `Delete source branch` option by default for all new merge requests.\n"
                },
                "repositoryAccessLevel": {
                    "type": "string",
                    "description": "Set the repository access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "repositoryStorage": {
                    "type": "string",
                    "description": "Which storage shard the repository is on. (administrator only)\n"
                },
                "requestAccessEnabled": {
                    "type": "boolean",
                    "description": "Allow users to request member access.\n"
                },
                "requirementsAccessLevel": {
                    "type": "string",
                    "description": "Set the requirements access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "resolveOutdatedDiffDiscussions": {
                    "type": "boolean",
                    "description": "Automatically resolve merge request diffs discussions on lines changed with a push.\n"
                },
                "restrictUserDefinedVariables": {
                    "type": "boolean",
                    "description": "Allow only users with the Maintainer role to pass user-defined variables when triggering a pipeline.\n"
                },
                "securityAndComplianceAccessLevel": {
                    "type": "string",
                    "description": "Set the security and compliance access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "sharedRunnersEnabled": {
                    "type": "boolean",
                    "description": "Enable shared runners for this project.\n"
                },
                "skipWaitForDefaultBranchProtection": {
                    "type": "boolean",
                    "description": "If `true`, the default behavior to wait for the default branch protection to be created is skipped.\nThis is necessary if the current user is not an admin and the default branch protection is disabled on an instance-level.\nThere is currently no known way to determine if the default branch protection is disabled on an instance-level for non-admin users.\nThis attribute is only used during resource creation, thus changes are suppressed and the attribute cannot be imported.\n"
                },
                "snippetsAccessLevel": {
                    "type": "string",
                    "description": "Set the snippets access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "snippetsEnabled": {
                    "type": "boolean",
                    "description": "Enable snippets for the project.\n"
                },
                "squashCommitTemplate": {
                    "type": "string",
                    "description": "Template used to create squash commit message in merge requests. (Introduced in GitLab 14.6.)\n"
                },
                "squashOption": {
                    "type": "string",
                    "description": "Squash commits when merge request. Valid values are `never`, `always`, `default_on`, or `default_off`. The default value is `default_off`. [GitLab \u003e= 14.1]\n"
                },
                "suggestionCommitMessage": {
                    "type": "string",
                    "description": "The commit message used to apply merge request suggestions.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of tags for a project; put array of tags, that should be finally assigned to a project. Use topics instead.\n"
                },
                "templateName": {
                    "type": "string",
                    "description": "When used without use*custom*template, name of a built-in project template. When used with use*custom*template, name of a custom project template. This option is mutually exclusive with `template_project_id`.\n",
                    "willReplaceOnChanges": true
                },
                "templateProjectId": {
                    "type": "integer",
                    "description": "When used with use*custom*template, project ID of a custom project template. This is preferable to using template*name since template*name may be ambiguous (enterprise edition). This option is mutually exclusive with `template_name`. See `gitlab.GroupProjectFileTemplate` to set a project as a template project. If a project has not been set as a template, using it here will result in an error.\n",
                    "willReplaceOnChanges": true
                },
                "topics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of topics for the project.\n"
                },
                "useCustomTemplate": {
                    "type": "boolean",
                    "description": "Use either custom instance or group (with group*with*project*templates*id) project template (enterprise edition).\n\t\u003e When using a custom template, [Group Tokens won't work](https://docs.gitlab.com/15.7/ee/user/project/settings/import_export_troubleshooting.html#import-using-the-rest-api-fails-when-using-a-group-access-token). You must use a real user's Personal Access Token.\n"
                },
                "visibilityLevel": {
                    "type": "string",
                    "description": "Set to `public` to create a public project. Valid values are `private`, `internal`, `public`.\n"
                },
                "wikiAccessLevel": {
                    "type": "string",
                    "description": "Set the wiki access level. Valid values are `disabled`, `private`, `enabled`.\n"
                },
                "wikiEnabled": {
                    "type": "boolean",
                    "description": "Enable wiki for the project.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Project resources.\n",
                "properties": {
                    "allowMergeOnSkippedPipeline": {
                        "type": "boolean",
                        "description": "Set to true if you want to treat skipped pipelines as if they finished with success.\n"
                    },
                    "allowPipelineTriggerApproveDeployment": {
                        "type": "boolean",
                        "description": "Set whether or not a pipeline triggerer is allowed to approve deployments. Premium and Ultimate only.\n"
                    },
                    "analyticsAccessLevel": {
                        "type": "string",
                        "description": "Set the analytics access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "approvalsBeforeMerge": {
                        "type": "integer",
                        "description": "Number of merge request approvals required for merging. Default is 0.\nThis field **does not** work well in combination with the `gitlab.ProjectApprovalRule` resource\nand is most likely gonna be deprecated in a future GitLab version (see [this upstream epic](https://gitlab.com/groups/gitlab-org/-/epics/7572)).\nIn the meantime we recommend against using this attribute and use `gitlab.ProjectApprovalRule` instead.\n"
                    },
                    "archiveOnDestroy": {
                        "type": "boolean",
                        "description": "Set to `true` to archive the project instead of deleting on destroy. If set to `true` it will entire omit the `DELETE` operation.\n"
                    },
                    "archived": {
                        "type": "boolean",
                        "description": "Whether the project is in read-only mode (archived). Repositories can be archived/unarchived by toggling this parameter.\n"
                    },
                    "autoCancelPendingPipelines": {
                        "type": "string",
                        "description": "Auto-cancel pending pipelines. This isn’t a boolean, but enabled/disabled.\n"
                    },
                    "autoDevopsDeployStrategy": {
                        "type": "string",
                        "description": "Auto Deploy strategy. Valid values are `continuous`, `manual`, `timed_incremental`.\n"
                    },
                    "autoDevopsEnabled": {
                        "type": "boolean",
                        "description": "Enable Auto DevOps for this project.\n"
                    },
                    "autocloseReferencedIssues": {
                        "type": "boolean",
                        "description": "Set whether auto-closing referenced issues on default branch.\n"
                    },
                    "avatar": {
                        "type": "string",
                        "description": "A local path to the avatar image to upload. **Note**: not available for imported resources.\n"
                    },
                    "avatarHash": {
                        "type": "string",
                        "description": "The hash of the avatar image. Use `filesha256(\"path/to/avatar.png\")` whenever possible. **Note**: this is used to trigger an update of the avatar. If it's not given, but an avatar is given, the avatar will be updated each time.\n"
                    },
                    "avatarUrl": {
                        "type": "string",
                        "description": "The URL of the avatar image.\n"
                    },
                    "buildCoverageRegex": {
                        "type": "string",
                        "description": "Test coverage parsing for the project. This is deprecated feature in GitLab 15.0.\n",
                        "deprecationMessage": "build_coverage_regex is removed in GitLab 15.0."
                    },
                    "buildGitStrategy": {
                        "type": "string",
                        "description": "The Git strategy. Defaults to fetch. Valid values are `clone`, `fetch`.\n"
                    },
                    "buildTimeout": {
                        "type": "integer",
                        "description": "The maximum amount of time, in seconds, that a job can run.\n"
                    },
                    "buildsAccessLevel": {
                        "type": "string",
                        "description": "Set the builds access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "ciConfigPath": {
                        "type": "string",
                        "description": "Custom Path to CI config file.\n"
                    },
                    "ciDefaultGitDepth": {
                        "type": "integer",
                        "description": "Default number of revisions for shallow cloning.\n"
                    },
                    "ciForwardDeploymentEnabled": {
                        "type": "boolean",
                        "description": "When a new deployment job starts, skip older deployment jobs that are still pending.\n"
                    },
                    "ciPipelineVariablesMinimumOverrideRole": {
                        "type": "string",
                        "description": "The minimum role required to set variables when running pipelines and jobs. Introduced in GitLab 17.1. Valid values are `developer`, `maintainer`, `owner`, `no_one_allowed`\n"
                    },
                    "ciRestrictPipelineCancellationRole": {
                        "type": "string",
                        "description": "The role required to cancel a pipeline or job. Introduced in GitLab 16.8. Premium and Ultimate only. Valid values are `developer`, `maintainer`, `no one`\n"
                    },
                    "ciSeparatedCaches": {
                        "type": "boolean",
                        "description": "Use separate caches for protected branches.\n"
                    },
                    "containerExpirationPolicy": {
                        "$ref": "#/types/gitlab:index/ProjectContainerExpirationPolicy:ProjectContainerExpirationPolicy",
                        "description": "Set the image cleanup policy for this project. **Note**: this field is sometimes named `container_expiration_policy_attributes` in the GitLab Upstream API.\n"
                    },
                    "containerRegistryAccessLevel": {
                        "type": "string",
                        "description": "Set visibility of container registry, for this project. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "containerRegistryEnabled": {
                        "type": "boolean",
                        "description": "Enable container registry for the project.\n",
                        "deprecationMessage": "Use `container_registry_access_level` instead."
                    },
                    "defaultBranch": {
                        "type": "string",
                        "description": "The default branch for the project.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description of the project.\n"
                    },
                    "emailsEnabled": {
                        "type": "boolean",
                        "description": "Enable email notifications.\n"
                    },
                    "emptyRepo": {
                        "type": "boolean",
                        "description": "Whether the project is empty.\n"
                    },
                    "environmentsAccessLevel": {
                        "type": "string",
                        "description": "Set the environments access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "externalAuthorizationClassificationLabel": {
                        "type": "string",
                        "description": "The classification label for the project.\n"
                    },
                    "featureFlagsAccessLevel": {
                        "type": "string",
                        "description": "Set the feature flags access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "forkedFromProjectId": {
                        "type": "integer",
                        "description": "The id of the project to fork. During create the project is forked and during an update the fork relation is changed.\n"
                    },
                    "forkingAccessLevel": {
                        "type": "string",
                        "description": "Set the forking access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "groupRunnersEnabled": {
                        "type": "boolean",
                        "description": "Enable group runners for this project.\n"
                    },
                    "groupWithProjectTemplatesId": {
                        "type": "integer",
                        "description": "For group-level custom templates, specifies ID of group from which all the custom project templates are sourced. Leave empty for instance-level templates. Requires use*custom*template to be true (enterprise edition).\n"
                    },
                    "httpUrlToRepo": {
                        "type": "string",
                        "description": "URL that can be provided to `git clone` to clone the\n"
                    },
                    "importUrl": {
                        "type": "string",
                        "description": "Git URL to a repository to be imported. Together with `mirror = true` it will setup a Pull Mirror. This can also be used together with `forked_from_project_id` to setup a Pull Mirror for a fork. The fork takes precedence over the import. Make sure to provide the credentials in `import_url_username` and `import_url_password`. GitLab never returns the credentials, thus the provider cannot detect configuration drift in the credentials. They can also not be imported using `pulumi import`. See the examples section for how to properly use it.\n"
                    },
                    "importUrlPassword": {
                        "type": "string",
                        "description": "The password for the `import_url`. The value of this field is used to construct a valid `import_url` and is only related to the provider. This field cannot be imported using `pulumi import`. See the examples section for how to properly use it.\n",
                        "secret": true
                    },
                    "importUrlUsername": {
                        "type": "string",
                        "description": "The username for the `import_url`. The value of this field is used to construct a valid `import_url` and is only related to the provider. This field cannot be imported using `pulumi import`.  See the examples section for how to properly use it.\n"
                    },
                    "infrastructureAccessLevel": {
                        "type": "string",
                        "description": "Set the infrastructure access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "initializeWithReadme": {
                        "type": "boolean",
                        "description": "Create main branch with first commit containing a README.md file. Must be set to `true` if importing an uninitialized project with a different `default_branch`.\n"
                    },
                    "issuesAccessLevel": {
                        "type": "string",
                        "description": "Set the issues access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "issuesEnabled": {
                        "type": "boolean",
                        "description": "Enable issue tracking for the project.\n"
                    },
                    "issuesTemplate": {
                        "type": "string",
                        "description": "Sets the template for new issues in the project.\n"
                    },
                    "keepLatestArtifact": {
                        "type": "boolean",
                        "description": "Disable or enable the ability to keep the latest artifact for this project.\n"
                    },
                    "lfsEnabled": {
                        "type": "boolean",
                        "description": "Enable LFS for the project.\n"
                    },
                    "mergeCommitTemplate": {
                        "type": "string",
                        "description": "Template used to create merge commit message in merge requests. (Introduced in GitLab 14.5.)\n"
                    },
                    "mergeMethod": {
                        "type": "string",
                        "description": "Set the merge method. Valid values are `merge`, `rebase_merge`, `ff`.\n"
                    },
                    "mergePipelinesEnabled": {
                        "type": "boolean",
                        "description": "Enable or disable merge pipelines.\n"
                    },
                    "mergeRequestsAccessLevel": {
                        "type": "string",
                        "description": "Set the merge requests access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "mergeRequestsEnabled": {
                        "type": "boolean",
                        "description": "Enable merge requests for the project.\n"
                    },
                    "mergeRequestsTemplate": {
                        "type": "string",
                        "description": "Sets the template for new merge requests in the project.\n"
                    },
                    "mergeTrainsEnabled": {
                        "type": "boolean",
                        "description": "Enable or disable merge trains. Requires `merge_pipelines_enabled` to be set to `true` to take effect.\n"
                    },
                    "mirror": {
                        "type": "boolean",
                        "description": "Enable project pull mirror.\n"
                    },
                    "mirrorOverwritesDivergedBranches": {
                        "type": "boolean",
                        "description": "Enable overwrite diverged branches for a mirrored project.\n"
                    },
                    "mirrorTriggerBuilds": {
                        "type": "boolean",
                        "description": "Enable trigger builds on pushes for a mirrored project.\n"
                    },
                    "modelExperimentsAccessLevel": {
                        "type": "string",
                        "description": "Set visibility of machine learning model experiments. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "modelRegistryAccessLevel": {
                        "type": "string",
                        "description": "Set visibility of machine learning model registry. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "monitorAccessLevel": {
                        "type": "string",
                        "description": "Set the monitor access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "mrDefaultTargetSelf": {
                        "type": "boolean",
                        "description": "For forked projects, target merge requests to this project. If false, the target will be the upstream project.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the project.\n"
                    },
                    "namespaceId": {
                        "type": "integer",
                        "description": "The namespace (group or user) of the project. Defaults to your user.\n"
                    },
                    "onlyAllowMergeIfAllDiscussionsAreResolved": {
                        "type": "boolean",
                        "description": "Set to true if you want allow merges only if all discussions are resolved.\n"
                    },
                    "onlyAllowMergeIfPipelineSucceeds": {
                        "type": "boolean",
                        "description": "Set to true if you want allow merges only if a pipeline succeeds.\n"
                    },
                    "onlyMirrorProtectedBranches": {
                        "type": "boolean",
                        "description": "Enable only mirror protected branches for a mirrored project.\n"
                    },
                    "packagesEnabled": {
                        "type": "boolean",
                        "description": "Enable packages repository for the project.\n"
                    },
                    "pagesAccessLevel": {
                        "type": "string",
                        "description": "Enable pages access control. Valid values are `public`, `private`, `enabled`, `disabled`.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path of the repository.\n"
                    },
                    "pathWithNamespace": {
                        "type": "string",
                        "description": "The path of the repository with namespace.\n"
                    },
                    "pipelinesEnabled": {
                        "type": "boolean",
                        "description": "Enable pipelines for the project. The `pipelines_enabled` field is being sent as `jobs_enabled` in the GitLab API calls.\n",
                        "deprecationMessage": "Deprecated in favor of `builds_access_level`"
                    },
                    "preReceiveSecretDetectionEnabled": {
                        "type": "boolean",
                        "description": "Whether Secret Push Detection is enabled. Requires GitLab Ultimate and at least GitLab 17.3.\n"
                    },
                    "printingMergeRequestLinkEnabled": {
                        "type": "boolean",
                        "description": "Show link to create/view merge request when pushing from the command line\n"
                    },
                    "publicBuilds": {
                        "type": "boolean",
                        "description": "If true, jobs can be viewed by non-project members.\n",
                        "deprecationMessage": "The `public_builds` attribute has been deprecated in favor of `public_jobs` and will be removed in the next major version of the provider."
                    },
                    "publicJobs": {
                        "type": "boolean",
                        "description": "If true, jobs can be viewed by non-project members.\n"
                    },
                    "pushRules": {
                        "$ref": "#/types/gitlab:index/ProjectPushRules:ProjectPushRules",
                        "description": "Push rules for the project.\n"
                    },
                    "releasesAccessLevel": {
                        "type": "string",
                        "description": "Set the releases access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "removeSourceBranchAfterMerge": {
                        "type": "boolean",
                        "description": "Enable `Delete source branch` option by default for all new merge requests.\n"
                    },
                    "repositoryAccessLevel": {
                        "type": "string",
                        "description": "Set the repository access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "repositoryStorage": {
                        "type": "string",
                        "description": "Which storage shard the repository is on. (administrator only)\n"
                    },
                    "requestAccessEnabled": {
                        "type": "boolean",
                        "description": "Allow users to request member access.\n"
                    },
                    "requirementsAccessLevel": {
                        "type": "string",
                        "description": "Set the requirements access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "resolveOutdatedDiffDiscussions": {
                        "type": "boolean",
                        "description": "Automatically resolve merge request diffs discussions on lines changed with a push.\n"
                    },
                    "restrictUserDefinedVariables": {
                        "type": "boolean",
                        "description": "Allow only users with the Maintainer role to pass user-defined variables when triggering a pipeline.\n"
                    },
                    "runnersToken": {
                        "type": "string",
                        "description": "Registration token to use during runner setup.\n",
                        "secret": true
                    },
                    "securityAndComplianceAccessLevel": {
                        "type": "string",
                        "description": "Set the security and compliance access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "sharedRunnersEnabled": {
                        "type": "boolean",
                        "description": "Enable shared runners for this project.\n"
                    },
                    "skipWaitForDefaultBranchProtection": {
                        "type": "boolean",
                        "description": "If `true`, the default behavior to wait for the default branch protection to be created is skipped.\nThis is necessary if the current user is not an admin and the default branch protection is disabled on an instance-level.\nThere is currently no known way to determine if the default branch protection is disabled on an instance-level for non-admin users.\nThis attribute is only used during resource creation, thus changes are suppressed and the attribute cannot be imported.\n"
                    },
                    "snippetsAccessLevel": {
                        "type": "string",
                        "description": "Set the snippets access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "snippetsEnabled": {
                        "type": "boolean",
                        "description": "Enable snippets for the project.\n"
                    },
                    "squashCommitTemplate": {
                        "type": "string",
                        "description": "Template used to create squash commit message in merge requests. (Introduced in GitLab 14.6.)\n"
                    },
                    "squashOption": {
                        "type": "string",
                        "description": "Squash commits when merge request. Valid values are `never`, `always`, `default_on`, or `default_off`. The default value is `default_off`. [GitLab \u003e= 14.1]\n"
                    },
                    "sshUrlToRepo": {
                        "type": "string",
                        "description": "URL that can be provided to `git clone` to clone the\n"
                    },
                    "suggestionCommitMessage": {
                        "type": "string",
                        "description": "The commit message used to apply merge request suggestions.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of tags for a project; put array of tags, that should be finally assigned to a project. Use topics instead.\n"
                    },
                    "templateName": {
                        "type": "string",
                        "description": "When used without use*custom*template, name of a built-in project template. When used with use*custom*template, name of a custom project template. This option is mutually exclusive with `template_project_id`.\n",
                        "willReplaceOnChanges": true
                    },
                    "templateProjectId": {
                        "type": "integer",
                        "description": "When used with use*custom*template, project ID of a custom project template. This is preferable to using template*name since template*name may be ambiguous (enterprise edition). This option is mutually exclusive with `template_name`. See `gitlab.GroupProjectFileTemplate` to set a project as a template project. If a project has not been set as a template, using it here will result in an error.\n",
                        "willReplaceOnChanges": true
                    },
                    "topics": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of topics for the project.\n"
                    },
                    "useCustomTemplate": {
                        "type": "boolean",
                        "description": "Use either custom instance or group (with group*with*project*templates*id) project template (enterprise edition).\n\t\u003e When using a custom template, [Group Tokens won't work](https://docs.gitlab.com/15.7/ee/user/project/settings/import_export_troubleshooting.html#import-using-the-rest-api-fails-when-using-a-group-access-token). You must use a real user's Personal Access Token.\n"
                    },
                    "visibilityLevel": {
                        "type": "string",
                        "description": "Set to `public` to create a public project. Valid values are `private`, `internal`, `public`.\n"
                    },
                    "webUrl": {
                        "type": "string",
                        "description": "URL that can be used to find the project in a browser.\n"
                    },
                    "wikiAccessLevel": {
                        "type": "string",
                        "description": "Set the wiki access level. Valid values are `disabled`, `private`, `enabled`.\n"
                    },
                    "wikiEnabled": {
                        "type": "boolean",
                        "description": "Enable wiki for the project.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectAccessToken:ProjectAccessToken": {
            "description": "The `gitlab.ProjectAccessToken` resource allows to manage the lifecycle of a project access token.\n\n\u003e Observability scopes are in beta and may not work on all instances. See more details in [the documentation](https://docs.gitlab.com/ee/operations/tracing.html)\n\n\u003e Use `rotation_configuration` to automatically rotate tokens instead of using `timestamp()` as timestamp will cause changes with every plan. `pulumi up` must still be run to rotate the token.\n\n\u003e Due to [Automatic reuse detection](https://docs.gitlab.com/ee/api/project_access_tokens.html#automatic-reuse-detection) it's possible that a new Project Access Token will immediately be revoked. Check if an old process using the old token is running if this happens.\n\n**Upstream API**: [GitLab API docs](https://docs.gitlab.com/ee/api/project_access_tokens.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = new gitlab.ProjectAccessToken(\"example\", {\n    project: \"25\",\n    name: \"Example project access token\",\n    expiresAt: \"2020-03-14\",\n    accessLevel: \"reporter\",\n    scopes: [\"api\"],\n});\nconst exampleProjectVariable = new gitlab.ProjectVariable(\"example\", {\n    project: exampleGitlabProject.id,\n    key: \"pat\",\n    value: example.token,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.ProjectAccessToken(\"example\",\n    project=\"25\",\n    name=\"Example project access token\",\n    expires_at=\"2020-03-14\",\n    access_level=\"reporter\",\n    scopes=[\"api\"])\nexample_project_variable = gitlab.ProjectVariable(\"example\",\n    project=example_gitlab_project[\"id\"],\n    key=\"pat\",\n    value=example.token)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new GitLab.ProjectAccessToken(\"example\", new()\n    {\n        Project = \"25\",\n        Name = \"Example project access token\",\n        ExpiresAt = \"2020-03-14\",\n        AccessLevel = \"reporter\",\n        Scopes = new[]\n        {\n            \"api\",\n        },\n    });\n\n    var exampleProjectVariable = new GitLab.ProjectVariable(\"example\", new()\n    {\n        Project = exampleGitlabProject.Id,\n        Key = \"pat\",\n        Value = example.Token,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := gitlab.NewProjectAccessToken(ctx, \"example\", \u0026gitlab.ProjectAccessTokenArgs{\n\t\t\tProject:     pulumi.String(\"25\"),\n\t\t\tName:        pulumi.String(\"Example project access token\"),\n\t\t\tExpiresAt:   pulumi.String(\"2020-03-14\"),\n\t\t\tAccessLevel: pulumi.String(\"reporter\"),\n\t\t\tScopes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"api\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectVariable(ctx, \"example\", \u0026gitlab.ProjectVariableArgs{\n\t\t\tProject: pulumi.Any(exampleGitlabProject.Id),\n\t\t\tKey:     pulumi.String(\"pat\"),\n\t\t\tValue:   example.Token,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ProjectAccessToken;\nimport com.pulumi.gitlab.ProjectAccessTokenArgs;\nimport com.pulumi.gitlab.ProjectVariable;\nimport com.pulumi.gitlab.ProjectVariableArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ProjectAccessToken(\"example\", ProjectAccessTokenArgs.builder()\n            .project(\"25\")\n            .name(\"Example project access token\")\n            .expiresAt(\"2020-03-14\")\n            .accessLevel(\"reporter\")\n            .scopes(\"api\")\n            .build());\n\n        var exampleProjectVariable = new ProjectVariable(\"exampleProjectVariable\", ProjectVariableArgs.builder()\n            .project(exampleGitlabProject.id())\n            .key(\"pat\")\n            .value(example.token())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: gitlab:ProjectAccessToken\n    properties:\n      project: '25'\n      name: Example project access token\n      expiresAt: 2020-03-14\n      accessLevel: reporter\n      scopes:\n        - api\n  exampleProjectVariable:\n    type: gitlab:ProjectVariable\n    name: example\n    properties:\n      project: ${exampleGitlabProject.id}\n      key: pat\n      value: ${example.token}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_project_access_token`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_project_access_token.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nA GitLab Project Access Token can be imported using a key composed of `\u003cproject-id\u003e:\u003ctoken-id\u003e`, e.g.\n\n```sh\n$ pulumi import gitlab:index/projectAccessToken:ProjectAccessToken example \"12345:1\"\n```\n\nNOTE: the `token` resource attribute is not available for imported resources as this information cannot be read from the GitLab API.\n\n",
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "The access level for the project access token. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`. Default is `maintainer`.\n"
                },
                "active": {
                    "type": "boolean",
                    "description": "True if the token is active.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Time the token has been created, RFC3339 format.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "When the token will expire, YYYY-MM-DD format. Is automatically set when `rotation_configuration` is used.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the project access token.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project.\n"
                },
                "revoked": {
                    "type": "boolean",
                    "description": "True if the token is revoked.\n"
                },
                "rotationConfiguration": {
                    "$ref": "#/types/gitlab:index/ProjectAccessTokenRotationConfiguration:ProjectAccessTokenRotationConfiguration",
                    "description": "The configuration for when to rotate a token automatically. Will not rotate a token until `pulumi up` is run.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The scopes of the project access token. valid values are: `api`, `read_api`, `read_registry`, `write_registry`, `read_repository`, `write_repository`, `create_runner`, `manage_runner`, `ai_features`, `k8s_proxy`, `read_observability`, `write_observability`\n"
                },
                "token": {
                    "type": "string",
                    "description": "The token of the project access token. **Note**: the token is not available for imported resources.\n",
                    "secret": true
                },
                "userId": {
                    "type": "integer",
                    "description": "The user_id associated to the token.\n"
                }
            },
            "required": [
                "accessLevel",
                "active",
                "createdAt",
                "expiresAt",
                "name",
                "project",
                "revoked",
                "scopes",
                "token",
                "userId"
            ],
            "inputProperties": {
                "accessLevel": {
                    "type": "string",
                    "description": "The access level for the project access token. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`. Default is `maintainer`.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "When the token will expire, YYYY-MM-DD format. Is automatically set when `rotation_configuration` is used.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the project access token.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project.\n"
                },
                "rotationConfiguration": {
                    "$ref": "#/types/gitlab:index/ProjectAccessTokenRotationConfiguration:ProjectAccessTokenRotationConfiguration",
                    "description": "The configuration for when to rotate a token automatically. Will not rotate a token until `pulumi up` is run.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The scopes of the project access token. valid values are: `api`, `read_api`, `read_registry`, `write_registry`, `read_repository`, `write_repository`, `create_runner`, `manage_runner`, `ai_features`, `k8s_proxy`, `read_observability`, `write_observability`\n"
                }
            },
            "requiredInputs": [
                "project",
                "scopes"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectAccessToken resources.\n",
                "properties": {
                    "accessLevel": {
                        "type": "string",
                        "description": "The access level for the project access token. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`. Default is `maintainer`.\n"
                    },
                    "active": {
                        "type": "boolean",
                        "description": "True if the token is active.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Time the token has been created, RFC3339 format.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "When the token will expire, YYYY-MM-DD format. Is automatically set when `rotation_configuration` is used.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the project access token.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or full path of the project.\n"
                    },
                    "revoked": {
                        "type": "boolean",
                        "description": "True if the token is revoked.\n"
                    },
                    "rotationConfiguration": {
                        "$ref": "#/types/gitlab:index/ProjectAccessTokenRotationConfiguration:ProjectAccessTokenRotationConfiguration",
                        "description": "The configuration for when to rotate a token automatically. Will not rotate a token until `pulumi up` is run.\n"
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The scopes of the project access token. valid values are: `api`, `read_api`, `read_registry`, `write_registry`, `read_repository`, `write_repository`, `create_runner`, `manage_runner`, `ai_features`, `k8s_proxy`, `read_observability`, `write_observability`\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "The token of the project access token. **Note**: the token is not available for imported resources.\n",
                        "secret": true
                    },
                    "userId": {
                        "type": "integer",
                        "description": "The user_id associated to the token.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectApprovalRule:ProjectApprovalRule": {
            "description": "## Example Usage\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_project_approval_rule`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_project_approval_rule.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab project approval rules can be imported using a key composed of `\u003cproject-id\u003e:\u003crule-id\u003e`, e.g.\n\n```sh\n$ pulumi import gitlab:index/projectApprovalRule:ProjectApprovalRule example \"12345:6\"\n```\n\n",
            "properties": {
                "appliesToAllProtectedBranches": {
                    "type": "boolean",
                    "description": "Whether the rule is applied to all protected branches. If set to 'true', the value of `protected_branch_ids` is ignored. Default is 'false'.\n"
                },
                "approvalsRequired": {
                    "type": "integer",
                    "description": "The number of approvals required for this rule.\n"
                },
                "disableImportingDefaultAnyApproverRuleOnCreate": {
                    "type": "boolean",
                    "description": "When this flag is set, the default `any_approver` rule will not be imported if present.\n"
                },
                "groupIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A list of group IDs whose members can approve of the merge request.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the approval rule.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the approval rules.\n"
                },
                "protectedBranchIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A list of protected branch IDs (not branch names) for which the rule applies.\n"
                },
                "reportType": {
                    "type": "string",
                    "description": "Report type is required when the rule_type is `report_approver`. Valid values are `code_coverage`.\n"
                },
                "ruleType": {
                    "type": "string",
                    "description": "String, defaults to 'regular'. The type of rule. `any_approver` is a pre-configured default rule with `approvals_required` at `0`. Valid values are `regular`, `any_approver`, `report_approver`.\n"
                },
                "userIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A list of specific User IDs to add to the list of approvers.\n"
                }
            },
            "required": [
                "approvalsRequired",
                "name",
                "project",
                "reportType",
                "ruleType"
            ],
            "inputProperties": {
                "appliesToAllProtectedBranches": {
                    "type": "boolean",
                    "description": "Whether the rule is applied to all protected branches. If set to 'true', the value of `protected_branch_ids` is ignored. Default is 'false'.\n"
                },
                "approvalsRequired": {
                    "type": "integer",
                    "description": "The number of approvals required for this rule.\n"
                },
                "disableImportingDefaultAnyApproverRuleOnCreate": {
                    "type": "boolean",
                    "description": "When this flag is set, the default `any_approver` rule will not be imported if present.\n"
                },
                "groupIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A list of group IDs whose members can approve of the merge request.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the approval rule.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the approval rules.\n",
                    "willReplaceOnChanges": true
                },
                "protectedBranchIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A list of protected branch IDs (not branch names) for which the rule applies.\n"
                },
                "reportType": {
                    "type": "string",
                    "description": "Report type is required when the rule_type is `report_approver`. Valid values are `code_coverage`.\n",
                    "willReplaceOnChanges": true
                },
                "ruleType": {
                    "type": "string",
                    "description": "String, defaults to 'regular'. The type of rule. `any_approver` is a pre-configured default rule with `approvals_required` at `0`. Valid values are `regular`, `any_approver`, `report_approver`.\n",
                    "willReplaceOnChanges": true
                },
                "userIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A list of specific User IDs to add to the list of approvers.\n"
                }
            },
            "requiredInputs": [
                "approvalsRequired",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectApprovalRule resources.\n",
                "properties": {
                    "appliesToAllProtectedBranches": {
                        "type": "boolean",
                        "description": "Whether the rule is applied to all protected branches. If set to 'true', the value of `protected_branch_ids` is ignored. Default is 'false'.\n"
                    },
                    "approvalsRequired": {
                        "type": "integer",
                        "description": "The number of approvals required for this rule.\n"
                    },
                    "disableImportingDefaultAnyApproverRuleOnCreate": {
                        "type": "boolean",
                        "description": "When this flag is set, the default `any_approver` rule will not be imported if present.\n"
                    },
                    "groupIds": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "A list of group IDs whose members can approve of the merge request.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the approval rule.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project to add the approval rules.\n",
                        "willReplaceOnChanges": true
                    },
                    "protectedBranchIds": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "A list of protected branch IDs (not branch names) for which the rule applies.\n"
                    },
                    "reportType": {
                        "type": "string",
                        "description": "Report type is required when the rule_type is `report_approver`. Valid values are `code_coverage`.\n",
                        "willReplaceOnChanges": true
                    },
                    "ruleType": {
                        "type": "string",
                        "description": "String, defaults to 'regular'. The type of rule. `any_approver` is a pre-configured default rule with `approvals_required` at `0`. Valid values are `regular`, `any_approver`, `report_approver`.\n",
                        "willReplaceOnChanges": true
                    },
                    "userIds": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "A list of specific User IDs to add to the list of approvers.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectBadge:ProjectBadge": {
            "description": "The `gitlab.ProjectBadge` resource allows to manage the lifecycle of project badges.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/user/project/badges.html#project-badges)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = new gitlab.Project(\"foo\", {name: \"foo-project\"});\nconst example = new gitlab.ProjectBadge(\"example\", {\n    project: foo.id,\n    linkUrl: \"https://example.com/badge-123\",\n    imageUrl: \"https://example.com/badge-123.svg\",\n    name: \"badge-123\",\n});\n// Pipeline status badges with placeholders will be enabled\nconst gitlabPipeline = new gitlab.ProjectBadge(\"gitlab_pipeline\", {\n    project: foo.id,\n    linkUrl: \"https://gitlab.example.com/%{project_path}/-/pipelines?ref=%{default_branch}\",\n    imageUrl: \"https://gitlab.example.com/%{project_path}/badges/%{default_branch}/pipeline.svg\",\n    name: \"badge-pipeline\",\n});\n// Test coverage report badges with placeholders will be enabled\nconst gitlabCoverage = new gitlab.ProjectBadge(\"gitlab_coverage\", {\n    project: foo.id,\n    linkUrl: \"https://gitlab.example.com/%{project_path}/-/jobs\",\n    imageUrl: \"https://gitlab.example.com/%{project_path}/badges/%{default_branch}/coverage.svg\",\n    name: \"badge-coverage\",\n});\n// Latest release badges with placeholders will be enabled\nconst gitlabRelease = new gitlab.ProjectBadge(\"gitlab_release\", {\n    project: foo.id,\n    linkUrl: \"https://gitlab.example.com/%{project_path}/-/releases\",\n    imageUrl: \"https://gitlab.example.com/%{project_path}/-/badges/release.svg\",\n    name: \"badge-release\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.Project(\"foo\", name=\"foo-project\")\nexample = gitlab.ProjectBadge(\"example\",\n    project=foo.id,\n    link_url=\"https://example.com/badge-123\",\n    image_url=\"https://example.com/badge-123.svg\",\n    name=\"badge-123\")\n# Pipeline status badges with placeholders will be enabled\ngitlab_pipeline = gitlab.ProjectBadge(\"gitlab_pipeline\",\n    project=foo.id,\n    link_url=\"https://gitlab.example.com/%{project_path}/-/pipelines?ref=%{default_branch}\",\n    image_url=\"https://gitlab.example.com/%{project_path}/badges/%{default_branch}/pipeline.svg\",\n    name=\"badge-pipeline\")\n# Test coverage report badges with placeholders will be enabled\ngitlab_coverage = gitlab.ProjectBadge(\"gitlab_coverage\",\n    project=foo.id,\n    link_url=\"https://gitlab.example.com/%{project_path}/-/jobs\",\n    image_url=\"https://gitlab.example.com/%{project_path}/badges/%{default_branch}/coverage.svg\",\n    name=\"badge-coverage\")\n# Latest release badges with placeholders will be enabled\ngitlab_release = gitlab.ProjectBadge(\"gitlab_release\",\n    project=foo.id,\n    link_url=\"https://gitlab.example.com/%{project_path}/-/releases\",\n    image_url=\"https://gitlab.example.com/%{project_path}/-/badges/release.svg\",\n    name=\"badge-release\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = new GitLab.Project(\"foo\", new()\n    {\n        Name = \"foo-project\",\n    });\n\n    var example = new GitLab.ProjectBadge(\"example\", new()\n    {\n        Project = foo.Id,\n        LinkUrl = \"https://example.com/badge-123\",\n        ImageUrl = \"https://example.com/badge-123.svg\",\n        Name = \"badge-123\",\n    });\n\n    // Pipeline status badges with placeholders will be enabled\n    var gitlabPipeline = new GitLab.ProjectBadge(\"gitlab_pipeline\", new()\n    {\n        Project = foo.Id,\n        LinkUrl = \"https://gitlab.example.com/%{project_path}/-/pipelines?ref=%{default_branch}\",\n        ImageUrl = \"https://gitlab.example.com/%{project_path}/badges/%{default_branch}/pipeline.svg\",\n        Name = \"badge-pipeline\",\n    });\n\n    // Test coverage report badges with placeholders will be enabled\n    var gitlabCoverage = new GitLab.ProjectBadge(\"gitlab_coverage\", new()\n    {\n        Project = foo.Id,\n        LinkUrl = \"https://gitlab.example.com/%{project_path}/-/jobs\",\n        ImageUrl = \"https://gitlab.example.com/%{project_path}/badges/%{default_branch}/coverage.svg\",\n        Name = \"badge-coverage\",\n    });\n\n    // Latest release badges with placeholders will be enabled\n    var gitlabRelease = new GitLab.ProjectBadge(\"gitlab_release\", new()\n    {\n        Project = foo.Id,\n        LinkUrl = \"https://gitlab.example.com/%{project_path}/-/releases\",\n        ImageUrl = \"https://gitlab.example.com/%{project_path}/-/badges/release.svg\",\n        Name = \"badge-release\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfoo, err := gitlab.NewProject(ctx, \"foo\", \u0026gitlab.ProjectArgs{\n\t\t\tName: pulumi.String(\"foo-project\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectBadge(ctx, \"example\", \u0026gitlab.ProjectBadgeArgs{\n\t\t\tProject:  foo.ID(),\n\t\t\tLinkUrl:  pulumi.String(\"https://example.com/badge-123\"),\n\t\t\tImageUrl: pulumi.String(\"https://example.com/badge-123.svg\"),\n\t\t\tName:     pulumi.String(\"badge-123\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Pipeline status badges with placeholders will be enabled\n\t\t_, err = gitlab.NewProjectBadge(ctx, \"gitlab_pipeline\", \u0026gitlab.ProjectBadgeArgs{\n\t\t\tProject:  foo.ID(),\n\t\t\tLinkUrl:  pulumi.String(\"https://gitlab.example.com/%{project_path}/-/pipelines?ref=%{default_branch}\"),\n\t\t\tImageUrl: pulumi.String(\"https://gitlab.example.com/%{project_path}/badges/%{default_branch}/pipeline.svg\"),\n\t\t\tName:     pulumi.String(\"badge-pipeline\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Test coverage report badges with placeholders will be enabled\n\t\t_, err = gitlab.NewProjectBadge(ctx, \"gitlab_coverage\", \u0026gitlab.ProjectBadgeArgs{\n\t\t\tProject:  foo.ID(),\n\t\t\tLinkUrl:  pulumi.String(\"https://gitlab.example.com/%{project_path}/-/jobs\"),\n\t\t\tImageUrl: pulumi.String(\"https://gitlab.example.com/%{project_path}/badges/%{default_branch}/coverage.svg\"),\n\t\t\tName:     pulumi.String(\"badge-coverage\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Latest release badges with placeholders will be enabled\n\t\t_, err = gitlab.NewProjectBadge(ctx, \"gitlab_release\", \u0026gitlab.ProjectBadgeArgs{\n\t\t\tProject:  foo.ID(),\n\t\t\tLinkUrl:  pulumi.String(\"https://gitlab.example.com/%{project_path}/-/releases\"),\n\t\t\tImageUrl: pulumi.String(\"https://gitlab.example.com/%{project_path}/-/badges/release.svg\"),\n\t\t\tName:     pulumi.String(\"badge-release\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ProjectBadge;\nimport com.pulumi.gitlab.ProjectBadgeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var foo = new Project(\"foo\", ProjectArgs.builder()\n            .name(\"foo-project\")\n            .build());\n\n        var example = new ProjectBadge(\"example\", ProjectBadgeArgs.builder()\n            .project(foo.id())\n            .linkUrl(\"https://example.com/badge-123\")\n            .imageUrl(\"https://example.com/badge-123.svg\")\n            .name(\"badge-123\")\n            .build());\n\n        // Pipeline status badges with placeholders will be enabled\n        var gitlabPipeline = new ProjectBadge(\"gitlabPipeline\", ProjectBadgeArgs.builder()\n            .project(foo.id())\n            .linkUrl(\"https://gitlab.example.com/%{project_path}/-/pipelines?ref=%{default_branch}\")\n            .imageUrl(\"https://gitlab.example.com/%{project_path}/badges/%{default_branch}/pipeline.svg\")\n            .name(\"badge-pipeline\")\n            .build());\n\n        // Test coverage report badges with placeholders will be enabled\n        var gitlabCoverage = new ProjectBadge(\"gitlabCoverage\", ProjectBadgeArgs.builder()\n            .project(foo.id())\n            .linkUrl(\"https://gitlab.example.com/%{project_path}/-/jobs\")\n            .imageUrl(\"https://gitlab.example.com/%{project_path}/badges/%{default_branch}/coverage.svg\")\n            .name(\"badge-coverage\")\n            .build());\n\n        // Latest release badges with placeholders will be enabled\n        var gitlabRelease = new ProjectBadge(\"gitlabRelease\", ProjectBadgeArgs.builder()\n            .project(foo.id())\n            .linkUrl(\"https://gitlab.example.com/%{project_path}/-/releases\")\n            .imageUrl(\"https://gitlab.example.com/%{project_path}/-/badges/release.svg\")\n            .name(\"badge-release\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  foo:\n    type: gitlab:Project\n    properties:\n      name: foo-project\n  example:\n    type: gitlab:ProjectBadge\n    properties:\n      project: ${foo.id}\n      linkUrl: https://example.com/badge-123\n      imageUrl: https://example.com/badge-123.svg\n      name: badge-123\n  # Pipeline status badges with placeholders will be enabled\n  gitlabPipeline:\n    type: gitlab:ProjectBadge\n    name: gitlab_pipeline\n    properties:\n      project: ${foo.id}\n      linkUrl: https://gitlab.example.com/%{project_path}/-/pipelines?ref=%{default_branch}\n      imageUrl: https://gitlab.example.com/%{project_path}/badges/%{default_branch}/pipeline.svg\n      name: badge-pipeline\n  # Test coverage report badges with placeholders will be enabled\n  gitlabCoverage:\n    type: gitlab:ProjectBadge\n    name: gitlab_coverage\n    properties:\n      project: ${foo.id}\n      linkUrl: https://gitlab.example.com/%{project_path}/-/jobs\n      imageUrl: https://gitlab.example.com/%{project_path}/badges/%{default_branch}/coverage.svg\n      name: badge-coverage\n  # Latest release badges with placeholders will be enabled\n  gitlabRelease:\n    type: gitlab:ProjectBadge\n    name: gitlab_release\n    properties:\n      project: ${foo.id}\n      linkUrl: https://gitlab.example.com/%{project_path}/-/releases\n      imageUrl: https://gitlab.example.com/%{project_path}/-/badges/release.svg\n      name: badge-release\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_project_badge`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_project_badge.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab project badges can be imported using an id made up of `{project_id}:{badge_id}`, e.g.\n\n```sh\n$ pulumi import gitlab:index/projectBadge:ProjectBadge foo 1:3\n```\n\n",
            "properties": {
                "imageUrl": {
                    "type": "string",
                    "description": "The image url which will be presented on project overview.\n"
                },
                "linkUrl": {
                    "type": "string",
                    "description": "The url linked with the badge.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the badge.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The id of the project to add the badge to.\n"
                },
                "renderedImageUrl": {
                    "type": "string",
                    "description": "The image_url argument rendered (in case of use of placeholders).\n"
                },
                "renderedLinkUrl": {
                    "type": "string",
                    "description": "The link_url argument rendered (in case of use of placeholders).\n"
                }
            },
            "required": [
                "imageUrl",
                "linkUrl",
                "name",
                "project",
                "renderedImageUrl",
                "renderedLinkUrl"
            ],
            "inputProperties": {
                "imageUrl": {
                    "type": "string",
                    "description": "The image url which will be presented on project overview.\n"
                },
                "linkUrl": {
                    "type": "string",
                    "description": "The url linked with the badge.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the badge.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The id of the project to add the badge to.\n"
                }
            },
            "requiredInputs": [
                "imageUrl",
                "linkUrl",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectBadge resources.\n",
                "properties": {
                    "imageUrl": {
                        "type": "string",
                        "description": "The image url which will be presented on project overview.\n"
                    },
                    "linkUrl": {
                        "type": "string",
                        "description": "The url linked with the badge.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the badge.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The id of the project to add the badge to.\n"
                    },
                    "renderedImageUrl": {
                        "type": "string",
                        "description": "The image_url argument rendered (in case of use of placeholders).\n"
                    },
                    "renderedLinkUrl": {
                        "type": "string",
                        "description": "The link_url argument rendered (in case of use of placeholders).\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectCluster:ProjectCluster": {
            "description": "The `gitlab.ProjectCluster` resource allows to manage the lifecycle of a project cluster.\n\n\u003e This is deprecated GitLab feature since 14.5\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/project_clusters.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = new gitlab.Project(\"foo\", {name: \"foo-project\"});\nconst bar = new gitlab.ProjectCluster(\"bar\", {\n    project: foo.id,\n    name: \"bar-cluster\",\n    domain: \"example.com\",\n    enabled: true,\n    kubernetesApiUrl: \"https://124.124.124\",\n    kubernetesToken: \"some-token\",\n    kubernetesCaCert: \"some-cert\",\n    kubernetesNamespace: \"namespace\",\n    kubernetesAuthorizationType: \"rbac\",\n    environmentScope: \"*\",\n    managementProjectId: \"123456\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.Project(\"foo\", name=\"foo-project\")\nbar = gitlab.ProjectCluster(\"bar\",\n    project=foo.id,\n    name=\"bar-cluster\",\n    domain=\"example.com\",\n    enabled=True,\n    kubernetes_api_url=\"https://124.124.124\",\n    kubernetes_token=\"some-token\",\n    kubernetes_ca_cert=\"some-cert\",\n    kubernetes_namespace=\"namespace\",\n    kubernetes_authorization_type=\"rbac\",\n    environment_scope=\"*\",\n    management_project_id=\"123456\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = new GitLab.Project(\"foo\", new()\n    {\n        Name = \"foo-project\",\n    });\n\n    var bar = new GitLab.ProjectCluster(\"bar\", new()\n    {\n        Project = foo.Id,\n        Name = \"bar-cluster\",\n        Domain = \"example.com\",\n        Enabled = true,\n        KubernetesApiUrl = \"https://124.124.124\",\n        KubernetesToken = \"some-token\",\n        KubernetesCaCert = \"some-cert\",\n        KubernetesNamespace = \"namespace\",\n        KubernetesAuthorizationType = \"rbac\",\n        EnvironmentScope = \"*\",\n        ManagementProjectId = \"123456\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfoo, err := gitlab.NewProject(ctx, \"foo\", \u0026gitlab.ProjectArgs{\n\t\t\tName: pulumi.String(\"foo-project\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectCluster(ctx, \"bar\", \u0026gitlab.ProjectClusterArgs{\n\t\t\tProject:                     foo.ID(),\n\t\t\tName:                        pulumi.String(\"bar-cluster\"),\n\t\t\tDomain:                      pulumi.String(\"example.com\"),\n\t\t\tEnabled:                     pulumi.Bool(true),\n\t\t\tKubernetesApiUrl:            pulumi.String(\"https://124.124.124\"),\n\t\t\tKubernetesToken:             pulumi.String(\"some-token\"),\n\t\t\tKubernetesCaCert:            pulumi.String(\"some-cert\"),\n\t\t\tKubernetesNamespace:         pulumi.String(\"namespace\"),\n\t\t\tKubernetesAuthorizationType: pulumi.String(\"rbac\"),\n\t\t\tEnvironmentScope:            pulumi.String(\"*\"),\n\t\t\tManagementProjectId:         pulumi.String(\"123456\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ProjectCluster;\nimport com.pulumi.gitlab.ProjectClusterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var foo = new Project(\"foo\", ProjectArgs.builder()\n            .name(\"foo-project\")\n            .build());\n\n        var bar = new ProjectCluster(\"bar\", ProjectClusterArgs.builder()\n            .project(foo.id())\n            .name(\"bar-cluster\")\n            .domain(\"example.com\")\n            .enabled(true)\n            .kubernetesApiUrl(\"https://124.124.124\")\n            .kubernetesToken(\"some-token\")\n            .kubernetesCaCert(\"some-cert\")\n            .kubernetesNamespace(\"namespace\")\n            .kubernetesAuthorizationType(\"rbac\")\n            .environmentScope(\"*\")\n            .managementProjectId(\"123456\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  foo:\n    type: gitlab:Project\n    properties:\n      name: foo-project\n  bar:\n    type: gitlab:ProjectCluster\n    properties:\n      project: ${foo.id}\n      name: bar-cluster\n      domain: example.com\n      enabled: true\n      kubernetesApiUrl: https://124.124.124\n      kubernetesToken: some-token\n      kubernetesCaCert: some-cert\n      kubernetesNamespace: namespace\n      kubernetesAuthorizationType: rbac\n      environmentScope: '*'\n      managementProjectId: '123456'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_project_cluster`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_project_cluster.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab project clusters can be imported using an id made up of `projectid:clusterid`, e.g.\n\n```sh\n$ pulumi import gitlab:index/projectCluster:ProjectCluster bar 123:321\n```\n\n",
            "properties": {
                "clusterType": {
                    "type": "string",
                    "description": "Cluster type.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Create time.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The base domain of the cluster.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Determines if cluster is active or not. Defaults to `true`. This attribute cannot be read.\n"
                },
                "environmentScope": {
                    "type": "string",
                    "description": "The associated environment to the cluster. Defaults to `*`.\n"
                },
                "kubernetesApiUrl": {
                    "type": "string",
                    "description": "The URL to access the Kubernetes API.\n"
                },
                "kubernetesAuthorizationType": {
                    "type": "string",
                    "description": "The cluster authorization type. Valid values are `rbac`, `abac`, `unknown_authorization`. Defaults to `rbac`.\n"
                },
                "kubernetesCaCert": {
                    "type": "string",
                    "description": "TLS certificate (needed if API is using a self-signed TLS certificate).\n"
                },
                "kubernetesNamespace": {
                    "type": "string",
                    "description": "The unique namespace related to the project.\n"
                },
                "kubernetesToken": {
                    "type": "string",
                    "description": "The token to authenticate against Kubernetes.\n",
                    "secret": true
                },
                "managed": {
                    "type": "boolean",
                    "description": "Determines if cluster is managed by gitlab or not. Defaults to `true`. This attribute cannot be read.\n"
                },
                "managementProjectId": {
                    "type": "string",
                    "description": "The ID of the management project for the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of cluster.\n"
                },
                "platformType": {
                    "type": "string",
                    "description": "Platform type.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The id of the project to add the cluster to.\n"
                },
                "providerType": {
                    "type": "string",
                    "description": "Provider type.\n"
                }
            },
            "required": [
                "clusterType",
                "createdAt",
                "kubernetesApiUrl",
                "kubernetesToken",
                "name",
                "platformType",
                "project",
                "providerType"
            ],
            "inputProperties": {
                "domain": {
                    "type": "string",
                    "description": "The base domain of the cluster.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Determines if cluster is active or not. Defaults to `true`. This attribute cannot be read.\n",
                    "willReplaceOnChanges": true
                },
                "environmentScope": {
                    "type": "string",
                    "description": "The associated environment to the cluster. Defaults to `*`.\n"
                },
                "kubernetesApiUrl": {
                    "type": "string",
                    "description": "The URL to access the Kubernetes API.\n"
                },
                "kubernetesAuthorizationType": {
                    "type": "string",
                    "description": "The cluster authorization type. Valid values are `rbac`, `abac`, `unknown_authorization`. Defaults to `rbac`.\n",
                    "willReplaceOnChanges": true
                },
                "kubernetesCaCert": {
                    "type": "string",
                    "description": "TLS certificate (needed if API is using a self-signed TLS certificate).\n"
                },
                "kubernetesNamespace": {
                    "type": "string",
                    "description": "The unique namespace related to the project.\n"
                },
                "kubernetesToken": {
                    "type": "string",
                    "description": "The token to authenticate against Kubernetes.\n",
                    "secret": true
                },
                "managed": {
                    "type": "boolean",
                    "description": "Determines if cluster is managed by gitlab or not. Defaults to `true`. This attribute cannot be read.\n",
                    "willReplaceOnChanges": true
                },
                "managementProjectId": {
                    "type": "string",
                    "description": "The ID of the management project for the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of cluster.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The id of the project to add the cluster to.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "kubernetesApiUrl",
                "kubernetesToken",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectCluster resources.\n",
                "properties": {
                    "clusterType": {
                        "type": "string",
                        "description": "Cluster type.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Create time.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The base domain of the cluster.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Determines if cluster is active or not. Defaults to `true`. This attribute cannot be read.\n",
                        "willReplaceOnChanges": true
                    },
                    "environmentScope": {
                        "type": "string",
                        "description": "The associated environment to the cluster. Defaults to `*`.\n"
                    },
                    "kubernetesApiUrl": {
                        "type": "string",
                        "description": "The URL to access the Kubernetes API.\n"
                    },
                    "kubernetesAuthorizationType": {
                        "type": "string",
                        "description": "The cluster authorization type. Valid values are `rbac`, `abac`, `unknown_authorization`. Defaults to `rbac`.\n",
                        "willReplaceOnChanges": true
                    },
                    "kubernetesCaCert": {
                        "type": "string",
                        "description": "TLS certificate (needed if API is using a self-signed TLS certificate).\n"
                    },
                    "kubernetesNamespace": {
                        "type": "string",
                        "description": "The unique namespace related to the project.\n"
                    },
                    "kubernetesToken": {
                        "type": "string",
                        "description": "The token to authenticate against Kubernetes.\n",
                        "secret": true
                    },
                    "managed": {
                        "type": "boolean",
                        "description": "Determines if cluster is managed by gitlab or not. Defaults to `true`. This attribute cannot be read.\n",
                        "willReplaceOnChanges": true
                    },
                    "managementProjectId": {
                        "type": "string",
                        "description": "The ID of the management project for the cluster.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of cluster.\n"
                    },
                    "platformType": {
                        "type": "string",
                        "description": "Platform type.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The id of the project to add the cluster to.\n",
                        "willReplaceOnChanges": true
                    },
                    "providerType": {
                        "type": "string",
                        "description": "Provider type.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectComplianceFramework:ProjectComplianceFramework": {
            "description": "The `gitlab.ProjectComplianceFramework` resource allows to manage the lifecycle of a compliance framework on a project.\n\n\u003e This resource requires a GitLab Enterprise instance with a Premium license to set the compliance framework on a project.\n\n**Upstream API**: [GitLab GraphQL API docs](https://docs.gitlab.com/ee/api/graphql/reference/#mutationprojectsetcomplianceframework)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst sample = new gitlab.ComplianceFramework(\"sample\", {\n    namespacePath: \"top-level-group\",\n    name: \"HIPAA\",\n    description: \"A HIPAA Compliance Framework\",\n    color: \"#87BEEF\",\n    \"default\": false,\n    pipelineConfigurationFullPath: \".hipaa.yml@top-level-group/compliance-frameworks\",\n});\nconst sampleProjectComplianceFramework = new gitlab.ProjectComplianceFramework(\"sample\", {\n    complianceFrameworkId: sample.frameworkId,\n    project: \"12345678\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nsample = gitlab.ComplianceFramework(\"sample\",\n    namespace_path=\"top-level-group\",\n    name=\"HIPAA\",\n    description=\"A HIPAA Compliance Framework\",\n    color=\"#87BEEF\",\n    default=False,\n    pipeline_configuration_full_path=\".hipaa.yml@top-level-group/compliance-frameworks\")\nsample_project_compliance_framework = gitlab.ProjectComplianceFramework(\"sample\",\n    compliance_framework_id=sample.framework_id,\n    project=\"12345678\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var sample = new GitLab.ComplianceFramework(\"sample\", new()\n    {\n        NamespacePath = \"top-level-group\",\n        Name = \"HIPAA\",\n        Description = \"A HIPAA Compliance Framework\",\n        Color = \"#87BEEF\",\n        Default = false,\n        PipelineConfigurationFullPath = \".hipaa.yml@top-level-group/compliance-frameworks\",\n    });\n\n    var sampleProjectComplianceFramework = new GitLab.ProjectComplianceFramework(\"sample\", new()\n    {\n        ComplianceFrameworkId = sample.FrameworkId,\n        Project = \"12345678\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tsample, err := gitlab.NewComplianceFramework(ctx, \"sample\", \u0026gitlab.ComplianceFrameworkArgs{\n\t\t\tNamespacePath:                 pulumi.String(\"top-level-group\"),\n\t\t\tName:                          pulumi.String(\"HIPAA\"),\n\t\t\tDescription:                   pulumi.String(\"A HIPAA Compliance Framework\"),\n\t\t\tColor:                         pulumi.String(\"#87BEEF\"),\n\t\t\tDefault:                       pulumi.Bool(false),\n\t\t\tPipelineConfigurationFullPath: pulumi.String(\".hipaa.yml@top-level-group/compliance-frameworks\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectComplianceFramework(ctx, \"sample\", \u0026gitlab.ProjectComplianceFrameworkArgs{\n\t\t\tComplianceFrameworkId: sample.FrameworkId,\n\t\t\tProject:               pulumi.String(\"12345678\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ComplianceFramework;\nimport com.pulumi.gitlab.ComplianceFrameworkArgs;\nimport com.pulumi.gitlab.ProjectComplianceFramework;\nimport com.pulumi.gitlab.ProjectComplianceFrameworkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var sample = new ComplianceFramework(\"sample\", ComplianceFrameworkArgs.builder()\n            .namespacePath(\"top-level-group\")\n            .name(\"HIPAA\")\n            .description(\"A HIPAA Compliance Framework\")\n            .color(\"#87BEEF\")\n            .default_(false)\n            .pipelineConfigurationFullPath(\".hipaa.yml@top-level-group/compliance-frameworks\")\n            .build());\n\n        var sampleProjectComplianceFramework = new ProjectComplianceFramework(\"sampleProjectComplianceFramework\", ProjectComplianceFrameworkArgs.builder()\n            .complianceFrameworkId(sample.frameworkId())\n            .project(\"12345678\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  sample:\n    type: gitlab:ComplianceFramework\n    properties:\n      namespacePath: top-level-group\n      name: HIPAA\n      description: A HIPAA Compliance Framework\n      color: '#87BEEF'\n      default: false\n      pipelineConfigurationFullPath: .hipaa.yml@top-level-group/compliance-frameworks\n  sampleProjectComplianceFramework:\n    type: gitlab:ProjectComplianceFramework\n    name: sample\n    properties:\n      complianceFrameworkId: ${sample.frameworkId}\n      project: '12345678'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_project_compliance_framework`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_project_compliance_framework.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitlab project compliance frameworks can be imported with a key composed of `\u003cproject_id\u003e`, e.g.\n\n```sh\n$ pulumi import gitlab:index/projectComplianceFramework:ProjectComplianceFramework sample \"42\"\n```\n\n",
            "properties": {
                "complianceFrameworkId": {
                    "type": "string",
                    "description": "Globally unique ID of the compliance framework to assign to the project.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project to change the compliance framework of.\n"
                }
            },
            "required": [
                "complianceFrameworkId",
                "project"
            ],
            "inputProperties": {
                "complianceFrameworkId": {
                    "type": "string",
                    "description": "Globally unique ID of the compliance framework to assign to the project.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project to change the compliance framework of.\n"
                }
            },
            "requiredInputs": [
                "complianceFrameworkId",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectComplianceFramework resources.\n",
                "properties": {
                    "complianceFrameworkId": {
                        "type": "string",
                        "description": "Globally unique ID of the compliance framework to assign to the project.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or full path of the project to change the compliance framework of.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectComplianceFrameworks:ProjectComplianceFrameworks": {
            "description": "The `gitlab.ProjectComplianceFrameworks` resource allows to manage the lifecycle of compliance frameworks on a project.\n\n\u003e This resource requires a GitLab Enterprise instance with a Premium license to set the compliance frameworks on a project.\n\n**Upstream API**: [GitLab GraphQL API docs](https://docs.gitlab.com/ee/api/graphql/reference/#mutationprojectupdatecomplianceframeworks)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst alpha = new gitlab.ComplianceFramework(\"alpha\", {\n    namespacePath: \"top-level-group\",\n    name: \"HIPAA\",\n    description: \"A HIPAA Compliance Framework\",\n    color: \"#87BEEF\",\n    \"default\": false,\n});\nconst beta = new gitlab.ComplianceFramework(\"beta\", {\n    namespacePath: \"top-level-group\",\n    name: \"SOC\",\n    description: \"A SOC Compliance Framework\",\n    color: \"#223344\",\n    \"default\": false,\n});\nconst sample = new gitlab.ProjectComplianceFrameworks(\"sample\", {\n    complianceFrameworkIds: [\n        alpha.frameworkId,\n        beta.frameworkId,\n    ],\n    project: \"12345678\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nalpha = gitlab.ComplianceFramework(\"alpha\",\n    namespace_path=\"top-level-group\",\n    name=\"HIPAA\",\n    description=\"A HIPAA Compliance Framework\",\n    color=\"#87BEEF\",\n    default=False)\nbeta = gitlab.ComplianceFramework(\"beta\",\n    namespace_path=\"top-level-group\",\n    name=\"SOC\",\n    description=\"A SOC Compliance Framework\",\n    color=\"#223344\",\n    default=False)\nsample = gitlab.ProjectComplianceFrameworks(\"sample\",\n    compliance_framework_ids=[\n        alpha.framework_id,\n        beta.framework_id,\n    ],\n    project=\"12345678\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var alpha = new GitLab.ComplianceFramework(\"alpha\", new()\n    {\n        NamespacePath = \"top-level-group\",\n        Name = \"HIPAA\",\n        Description = \"A HIPAA Compliance Framework\",\n        Color = \"#87BEEF\",\n        Default = false,\n    });\n\n    var beta = new GitLab.ComplianceFramework(\"beta\", new()\n    {\n        NamespacePath = \"top-level-group\",\n        Name = \"SOC\",\n        Description = \"A SOC Compliance Framework\",\n        Color = \"#223344\",\n        Default = false,\n    });\n\n    var sample = new GitLab.ProjectComplianceFrameworks(\"sample\", new()\n    {\n        ComplianceFrameworkIds = new[]\n        {\n            alpha.FrameworkId,\n            beta.FrameworkId,\n        },\n        Project = \"12345678\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\talpha, err := gitlab.NewComplianceFramework(ctx, \"alpha\", \u0026gitlab.ComplianceFrameworkArgs{\n\t\t\tNamespacePath: pulumi.String(\"top-level-group\"),\n\t\t\tName:          pulumi.String(\"HIPAA\"),\n\t\t\tDescription:   pulumi.String(\"A HIPAA Compliance Framework\"),\n\t\t\tColor:         pulumi.String(\"#87BEEF\"),\n\t\t\tDefault:       pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tbeta, err := gitlab.NewComplianceFramework(ctx, \"beta\", \u0026gitlab.ComplianceFrameworkArgs{\n\t\t\tNamespacePath: pulumi.String(\"top-level-group\"),\n\t\t\tName:          pulumi.String(\"SOC\"),\n\t\t\tDescription:   pulumi.String(\"A SOC Compliance Framework\"),\n\t\t\tColor:         pulumi.String(\"#223344\"),\n\t\t\tDefault:       pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectComplianceFrameworks(ctx, \"sample\", \u0026gitlab.ProjectComplianceFrameworksArgs{\n\t\t\tComplianceFrameworkIds: pulumi.StringArray{\n\t\t\t\talpha.FrameworkId,\n\t\t\t\tbeta.FrameworkId,\n\t\t\t},\n\t\t\tProject: pulumi.String(\"12345678\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ComplianceFramework;\nimport com.pulumi.gitlab.ComplianceFrameworkArgs;\nimport com.pulumi.gitlab.ProjectComplianceFrameworks;\nimport com.pulumi.gitlab.ProjectComplianceFrameworksArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var alpha = new ComplianceFramework(\"alpha\", ComplianceFrameworkArgs.builder()\n            .namespacePath(\"top-level-group\")\n            .name(\"HIPAA\")\n            .description(\"A HIPAA Compliance Framework\")\n            .color(\"#87BEEF\")\n            .default_(false)\n            .build());\n\n        var beta = new ComplianceFramework(\"beta\", ComplianceFrameworkArgs.builder()\n            .namespacePath(\"top-level-group\")\n            .name(\"SOC\")\n            .description(\"A SOC Compliance Framework\")\n            .color(\"#223344\")\n            .default_(false)\n            .build());\n\n        var sample = new ProjectComplianceFrameworks(\"sample\", ProjectComplianceFrameworksArgs.builder()\n            .complianceFrameworkIds(            \n                alpha.frameworkId(),\n                beta.frameworkId())\n            .project(\"12345678\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  alpha:\n    type: gitlab:ComplianceFramework\n    properties:\n      namespacePath: top-level-group\n      name: HIPAA\n      description: A HIPAA Compliance Framework\n      color: '#87BEEF'\n      default: false\n  beta:\n    type: gitlab:ComplianceFramework\n    properties:\n      namespacePath: top-level-group\n      name: SOC\n      description: A SOC Compliance Framework\n      color: '#223344'\n      default: false\n  sample:\n    type: gitlab:ProjectComplianceFrameworks\n    properties:\n      complianceFrameworkIds:\n        - ${alpha.frameworkId}\n        - ${beta.frameworkId}\n      project: '12345678'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_project_compliance_frameworks`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_project_compliance_frameworks.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitlab project compliance frameworks can be imported with a key composed of `\u003cproject_id\u003e`, e.g.\n\n```sh\n$ pulumi import gitlab:index/projectComplianceFrameworks:ProjectComplianceFrameworks sample \"42\"\n```\n\n",
            "properties": {
                "complianceFrameworkIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Globally unique IDs of the compliance frameworks to assign to the project.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project to change the compliance frameworks of.\n"
                }
            },
            "required": [
                "complianceFrameworkIds",
                "project"
            ],
            "inputProperties": {
                "complianceFrameworkIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Globally unique IDs of the compliance frameworks to assign to the project.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project to change the compliance frameworks of.\n"
                }
            },
            "requiredInputs": [
                "complianceFrameworkIds",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectComplianceFrameworks resources.\n",
                "properties": {
                    "complianceFrameworkIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Globally unique IDs of the compliance frameworks to assign to the project.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or full path of the project to change the compliance frameworks of.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectCustomAttribute:ProjectCustomAttribute": {
            "description": "The `gitlab.ProjectCustomAttribute` resource allows to manage custom attributes for a project.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/custom_attributes.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst attr = new gitlab.ProjectCustomAttribute(\"attr\", {\n    project: 42,\n    key: \"location\",\n    value: \"Greenland\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nattr = gitlab.ProjectCustomAttribute(\"attr\",\n    project=42,\n    key=\"location\",\n    value=\"Greenland\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var attr = new GitLab.ProjectCustomAttribute(\"attr\", new()\n    {\n        Project = 42,\n        Key = \"location\",\n        Value = \"Greenland\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewProjectCustomAttribute(ctx, \"attr\", \u0026gitlab.ProjectCustomAttributeArgs{\n\t\t\tProject: pulumi.Int(42),\n\t\t\tKey:     pulumi.String(\"location\"),\n\t\t\tValue:   pulumi.String(\"Greenland\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ProjectCustomAttribute;\nimport com.pulumi.gitlab.ProjectCustomAttributeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var attr = new ProjectCustomAttribute(\"attr\", ProjectCustomAttributeArgs.builder()\n            .project(\"42\")\n            .key(\"location\")\n            .value(\"Greenland\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  attr:\n    type: gitlab:ProjectCustomAttribute\n    properties:\n      project: '42'\n      key: location\n      value: Greenland\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_project_custom_attribute`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_project_custom_attribute.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nYou can import a project custom attribute using an id made up of `{project-id}:{key}`, e.g.\n\n```sh\n$ pulumi import gitlab:index/projectCustomAttribute:ProjectCustomAttribute attr 42:location\n```\n\n",
            "properties": {
                "key": {
                    "type": "string",
                    "description": "Key for the Custom Attribute.\n"
                },
                "project": {
                    "type": "integer",
                    "description": "The id of the project.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value for the Custom Attribute.\n"
                }
            },
            "required": [
                "key",
                "project",
                "value"
            ],
            "inputProperties": {
                "key": {
                    "type": "string",
                    "description": "Key for the Custom Attribute.\n"
                },
                "project": {
                    "type": "integer",
                    "description": "The id of the project.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value for the Custom Attribute.\n"
                }
            },
            "requiredInputs": [
                "key",
                "project",
                "value"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectCustomAttribute resources.\n",
                "properties": {
                    "key": {
                        "type": "string",
                        "description": "Key for the Custom Attribute.\n"
                    },
                    "project": {
                        "type": "integer",
                        "description": "The id of the project.\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "Value for the Custom Attribute.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectEnvironment:ProjectEnvironment": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst _this = new gitlab.Group(\"this\", {\n    name: \"example\",\n    path: \"example\",\n    description: \"An example group\",\n});\nconst thisProject = new gitlab.Project(\"this\", {\n    name: \"example\",\n    namespaceId: _this.id,\n    initializeWithReadme: true,\n});\nconst thisProjectEnvironment = new gitlab.ProjectEnvironment(\"this\", {\n    project: thisProject.id,\n    name: \"example\",\n    externalUrl: \"www.example.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nthis = gitlab.Group(\"this\",\n    name=\"example\",\n    path=\"example\",\n    description=\"An example group\")\nthis_project = gitlab.Project(\"this\",\n    name=\"example\",\n    namespace_id=this.id,\n    initialize_with_readme=True)\nthis_project_environment = gitlab.ProjectEnvironment(\"this\",\n    project=this_project.id,\n    name=\"example\",\n    external_url=\"www.example.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @this = new GitLab.Group(\"this\", new()\n    {\n        Name = \"example\",\n        Path = \"example\",\n        Description = \"An example group\",\n    });\n\n    var thisProject = new GitLab.Project(\"this\", new()\n    {\n        Name = \"example\",\n        NamespaceId = @this.Id,\n        InitializeWithReadme = true,\n    });\n\n    var thisProjectEnvironment = new GitLab.ProjectEnvironment(\"this\", new()\n    {\n        Project = thisProject.Id,\n        Name = \"example\",\n        ExternalUrl = \"www.example.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tthis, err := gitlab.NewGroup(ctx, \"this\", \u0026gitlab.GroupArgs{\n\t\t\tName:        pulumi.String(\"example\"),\n\t\t\tPath:        pulumi.String(\"example\"),\n\t\t\tDescription: pulumi.String(\"An example group\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tthisProject, err := gitlab.NewProject(ctx, \"this\", \u0026gitlab.ProjectArgs{\n\t\t\tName:                 pulumi.String(\"example\"),\n\t\t\tNamespaceId:          this.ID(),\n\t\t\tInitializeWithReadme: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectEnvironment(ctx, \"this\", \u0026gitlab.ProjectEnvironmentArgs{\n\t\t\tProject:     thisProject.ID(),\n\t\t\tName:        pulumi.String(\"example\"),\n\t\t\tExternalUrl: pulumi.String(\"www.example.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Group;\nimport com.pulumi.gitlab.GroupArgs;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ProjectEnvironment;\nimport com.pulumi.gitlab.ProjectEnvironmentArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var this_ = new Group(\"this\", GroupArgs.builder()\n            .name(\"example\")\n            .path(\"example\")\n            .description(\"An example group\")\n            .build());\n\n        var thisProject = new Project(\"thisProject\", ProjectArgs.builder()\n            .name(\"example\")\n            .namespaceId(this_.id())\n            .initializeWithReadme(true)\n            .build());\n\n        var thisProjectEnvironment = new ProjectEnvironment(\"thisProjectEnvironment\", ProjectEnvironmentArgs.builder()\n            .project(thisProject.id())\n            .name(\"example\")\n            .externalUrl(\"www.example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  this:\n    type: gitlab:Group\n    properties:\n      name: example\n      path: example\n      description: An example group\n  thisProject:\n    type: gitlab:Project\n    name: this\n    properties:\n      name: example\n      namespaceId: ${this.id}\n      initializeWithReadme: true\n  thisProjectEnvironment:\n    type: gitlab:ProjectEnvironment\n    name: this\n    properties:\n      project: ${thisProject.id}\n      name: example\n      externalUrl: www.example.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_project_environment`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_project_environment.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab project environments can be imported using an id made up of `projectId:environmenId`, e.g.\n\n```sh\n$ pulumi import gitlab:index/projectEnvironment:ProjectEnvironment bar 123:321\n```\n\n",
            "properties": {
                "clusterAgentId": {
                    "type": "integer",
                    "description": "The cluster agent to associate with this environment.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "The ISO8601 date/time that this environment was created at in UTC.\n"
                },
                "externalUrl": {
                    "type": "string",
                    "description": "Place to link to for this environment.\n"
                },
                "fluxResourcePath": {
                    "type": "string",
                    "description": "The Flux resource path to associate with this environment.\n"
                },
                "kubernetesNamespace": {
                    "type": "string",
                    "description": "The Kubernetes namespace to associate with this environment.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the environment.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project to environment is created for.\n"
                },
                "slug": {
                    "type": "string",
                    "description": "The name of the environment in lowercase, shortened to 63 bytes, and with everything except 0-9 and a-z replaced with -. No leading / trailing -. Use in URLs, host names and domain names.\n"
                },
                "state": {
                    "type": "string",
                    "description": "State the environment is in. Valid values are `available`, `stopped`.\n"
                },
                "stopBeforeDestroy": {
                    "type": "boolean",
                    "description": "Determines whether the environment is attempted to be stopped before the environment is deleted.\n"
                },
                "tier": {
                    "type": "string",
                    "description": "The tier of the new environment. Valid values are `production`, `staging`, `testing`, `development`, `other`.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "The ISO8601 date/time that this environment was last updated at in UTC.\n"
                }
            },
            "required": [
                "createdAt",
                "name",
                "project",
                "slug",
                "state",
                "tier",
                "updatedAt"
            ],
            "inputProperties": {
                "clusterAgentId": {
                    "type": "integer",
                    "description": "The cluster agent to associate with this environment.\n"
                },
                "externalUrl": {
                    "type": "string",
                    "description": "Place to link to for this environment.\n"
                },
                "fluxResourcePath": {
                    "type": "string",
                    "description": "The Flux resource path to associate with this environment.\n"
                },
                "kubernetesNamespace": {
                    "type": "string",
                    "description": "The Kubernetes namespace to associate with this environment.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the environment.\n",
                    "willReplaceOnChanges": true
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project to environment is created for.\n",
                    "willReplaceOnChanges": true
                },
                "stopBeforeDestroy": {
                    "type": "boolean",
                    "description": "Determines whether the environment is attempted to be stopped before the environment is deleted.\n"
                },
                "tier": {
                    "type": "string",
                    "description": "The tier of the new environment. Valid values are `production`, `staging`, `testing`, `development`, `other`.\n"
                }
            },
            "requiredInputs": [
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectEnvironment resources.\n",
                "properties": {
                    "clusterAgentId": {
                        "type": "integer",
                        "description": "The cluster agent to associate with this environment.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "The ISO8601 date/time that this environment was created at in UTC.\n"
                    },
                    "externalUrl": {
                        "type": "string",
                        "description": "Place to link to for this environment.\n"
                    },
                    "fluxResourcePath": {
                        "type": "string",
                        "description": "The Flux resource path to associate with this environment.\n"
                    },
                    "kubernetesNamespace": {
                        "type": "string",
                        "description": "The Kubernetes namespace to associate with this environment.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the environment.\n",
                        "willReplaceOnChanges": true
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or full path of the project to environment is created for.\n",
                        "willReplaceOnChanges": true
                    },
                    "slug": {
                        "type": "string",
                        "description": "The name of the environment in lowercase, shortened to 63 bytes, and with everything except 0-9 and a-z replaced with -. No leading / trailing -. Use in URLs, host names and domain names.\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "State the environment is in. Valid values are `available`, `stopped`.\n"
                    },
                    "stopBeforeDestroy": {
                        "type": "boolean",
                        "description": "Determines whether the environment is attempted to be stopped before the environment is deleted.\n"
                    },
                    "tier": {
                        "type": "string",
                        "description": "The tier of the new environment. Valid values are `production`, `staging`, `testing`, `development`, `other`.\n"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "The ISO8601 date/time that this environment was last updated at in UTC.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectFreezePeriod:ProjectFreezePeriod": {
            "description": "The `gitlab.ProjectFreezePeriod` resource allows to manage the lifecycle of a freeze period for a project.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/freeze_periods.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst schedule = new gitlab.ProjectFreezePeriod(\"schedule\", {\n    project: foo.id,\n    freezeStart: \"0 23 * * 5\",\n    freezeEnd: \"0 7 * * 1\",\n    cronTimezone: \"UTC\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nschedule = gitlab.ProjectFreezePeriod(\"schedule\",\n    project=foo[\"id\"],\n    freeze_start=\"0 23 * * 5\",\n    freeze_end=\"0 7 * * 1\",\n    cron_timezone=\"UTC\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var schedule = new GitLab.ProjectFreezePeriod(\"schedule\", new()\n    {\n        Project = foo.Id,\n        FreezeStart = \"0 23 * * 5\",\n        FreezeEnd = \"0 7 * * 1\",\n        CronTimezone = \"UTC\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewProjectFreezePeriod(ctx, \"schedule\", \u0026gitlab.ProjectFreezePeriodArgs{\n\t\t\tProject:      pulumi.Any(foo.Id),\n\t\t\tFreezeStart:  pulumi.String(\"0 23 * * 5\"),\n\t\t\tFreezeEnd:    pulumi.String(\"0 7 * * 1\"),\n\t\t\tCronTimezone: pulumi.String(\"UTC\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ProjectFreezePeriod;\nimport com.pulumi.gitlab.ProjectFreezePeriodArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var schedule = new ProjectFreezePeriod(\"schedule\", ProjectFreezePeriodArgs.builder()\n            .project(foo.id())\n            .freezeStart(\"0 23 * * 5\")\n            .freezeEnd(\"0 7 * * 1\")\n            .cronTimezone(\"UTC\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  schedule:\n    type: gitlab:ProjectFreezePeriod\n    properties:\n      project: ${foo.id}\n      freezeStart: 0 23 * * 5\n      freezeEnd: 0 7 * * 1\n      cronTimezone: UTC\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_project_freeze_period`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_project_freeze_period.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab project freeze periods can be imported using an id made up of `project_id:freeze_period_id`, e.g.\n\n```sh\n$ pulumi import gitlab:index/projectFreezePeriod:ProjectFreezePeriod schedule \"12345:1337\"\n```\n\n",
            "properties": {
                "cronTimezone": {
                    "type": "string",
                    "description": "The timezone.\n"
                },
                "freezeEnd": {
                    "type": "string",
                    "description": "End of the Freeze Period in cron format (e.g. `0 2 * * *`).\n"
                },
                "freezeStart": {
                    "type": "string",
                    "description": "Start of the Freeze Period in cron format (e.g. `0 1 * * *`).\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the project to add the schedule to.\n"
                }
            },
            "required": [
                "freezeEnd",
                "freezeStart",
                "project"
            ],
            "inputProperties": {
                "cronTimezone": {
                    "type": "string",
                    "description": "The timezone.\n"
                },
                "freezeEnd": {
                    "type": "string",
                    "description": "End of the Freeze Period in cron format (e.g. `0 2 * * *`).\n"
                },
                "freezeStart": {
                    "type": "string",
                    "description": "Start of the Freeze Period in cron format (e.g. `0 1 * * *`).\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the project to add the schedule to.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "freezeEnd",
                "freezeStart",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectFreezePeriod resources.\n",
                "properties": {
                    "cronTimezone": {
                        "type": "string",
                        "description": "The timezone.\n"
                    },
                    "freezeEnd": {
                        "type": "string",
                        "description": "End of the Freeze Period in cron format (e.g. `0 2 * * *`).\n"
                    },
                    "freezeStart": {
                        "type": "string",
                        "description": "Start of the Freeze Period in cron format (e.g. `0 1 * * *`).\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the project to add the schedule to.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectHook:ProjectHook": {
            "description": "The `gitlab.ProjectHook` resource allows to manage the lifecycle of a project hook.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/projects.html#hooks)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = new gitlab.ProjectHook(\"example\", {\n    project: \"example/hooked\",\n    url: \"https://example.com/hook/example\",\n    mergeRequestsEvents: true,\n});\n// Using Custom Headers\n// Values of headers can't be imported\nconst customHeaders = new gitlab.ProjectHook(\"custom_headers\", {\n    project: \"example/hooked\",\n    url: \"https://example.com/hook/example\",\n    mergeRequestsEvents: true,\n    customHeaders: [\n        {\n            key: \"X-Custom-Header\",\n            value: \"example\",\n        },\n        {\n            key: \"X-Custom-Header-Second\",\n            value: \"example-second\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.ProjectHook(\"example\",\n    project=\"example/hooked\",\n    url=\"https://example.com/hook/example\",\n    merge_requests_events=True)\n# Using Custom Headers\n# Values of headers can't be imported\ncustom_headers = gitlab.ProjectHook(\"custom_headers\",\n    project=\"example/hooked\",\n    url=\"https://example.com/hook/example\",\n    merge_requests_events=True,\n    custom_headers=[\n        {\n            \"key\": \"X-Custom-Header\",\n            \"value\": \"example\",\n        },\n        {\n            \"key\": \"X-Custom-Header-Second\",\n            \"value\": \"example-second\",\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new GitLab.ProjectHook(\"example\", new()\n    {\n        Project = \"example/hooked\",\n        Url = \"https://example.com/hook/example\",\n        MergeRequestsEvents = true,\n    });\n\n    // Using Custom Headers\n    // Values of headers can't be imported\n    var customHeaders = new GitLab.ProjectHook(\"custom_headers\", new()\n    {\n        Project = \"example/hooked\",\n        Url = \"https://example.com/hook/example\",\n        MergeRequestsEvents = true,\n        CustomHeaders = new[]\n        {\n            new GitLab.Inputs.ProjectHookCustomHeaderArgs\n            {\n                Key = \"X-Custom-Header\",\n                Value = \"example\",\n            },\n            new GitLab.Inputs.ProjectHookCustomHeaderArgs\n            {\n                Key = \"X-Custom-Header-Second\",\n                Value = \"example-second\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewProjectHook(ctx, \"example\", \u0026gitlab.ProjectHookArgs{\n\t\t\tProject:             pulumi.String(\"example/hooked\"),\n\t\t\tUrl:                 pulumi.String(\"https://example.com/hook/example\"),\n\t\t\tMergeRequestsEvents: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Using Custom Headers\n\t\t// Values of headers can't be imported\n\t\t_, err = gitlab.NewProjectHook(ctx, \"custom_headers\", \u0026gitlab.ProjectHookArgs{\n\t\t\tProject:             pulumi.String(\"example/hooked\"),\n\t\t\tUrl:                 pulumi.String(\"https://example.com/hook/example\"),\n\t\t\tMergeRequestsEvents: pulumi.Bool(true),\n\t\t\tCustomHeaders: gitlab.ProjectHookCustomHeaderArray{\n\t\t\t\t\u0026gitlab.ProjectHookCustomHeaderArgs{\n\t\t\t\t\tKey:   pulumi.String(\"X-Custom-Header\"),\n\t\t\t\t\tValue: pulumi.String(\"example\"),\n\t\t\t\t},\n\t\t\t\t\u0026gitlab.ProjectHookCustomHeaderArgs{\n\t\t\t\t\tKey:   pulumi.String(\"X-Custom-Header-Second\"),\n\t\t\t\t\tValue: pulumi.String(\"example-second\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ProjectHook;\nimport com.pulumi.gitlab.ProjectHookArgs;\nimport com.pulumi.gitlab.inputs.ProjectHookCustomHeaderArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ProjectHook(\"example\", ProjectHookArgs.builder()\n            .project(\"example/hooked\")\n            .url(\"https://example.com/hook/example\")\n            .mergeRequestsEvents(true)\n            .build());\n\n        // Using Custom Headers\n        // Values of headers can't be imported\n        var customHeaders = new ProjectHook(\"customHeaders\", ProjectHookArgs.builder()\n            .project(\"example/hooked\")\n            .url(\"https://example.com/hook/example\")\n            .mergeRequestsEvents(true)\n            .customHeaders(            \n                ProjectHookCustomHeaderArgs.builder()\n                    .key(\"X-Custom-Header\")\n                    .value(\"example\")\n                    .build(),\n                ProjectHookCustomHeaderArgs.builder()\n                    .key(\"X-Custom-Header-Second\")\n                    .value(\"example-second\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: gitlab:ProjectHook\n    properties:\n      project: example/hooked\n      url: https://example.com/hook/example\n      mergeRequestsEvents: true\n  # Using Custom Headers\n  # Values of headers can't be imported\n  customHeaders:\n    type: gitlab:ProjectHook\n    name: custom_headers\n    properties:\n      project: example/hooked\n      url: https://example.com/hook/example\n      mergeRequestsEvents: true\n      customHeaders:\n        - key: X-Custom-Header\n          value: example\n        - key: X-Custom-Header-Second\n          value: example-second\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_project_hook`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_project_hook.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nA GitLab Project Hook can be imported using a key composed of `\u003cproject-id\u003e:\u003chook-id\u003e`, e.g.\n\n```sh\n$ pulumi import gitlab:index/projectHook:ProjectHook example \"12345:1\"\n```\n\nNOTE: the `token` resource attribute is not available for imported resources as this information cannot be read from the GitLab API.\n\n",
            "properties": {
                "confidentialIssuesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for confidential issues events.\n"
                },
                "confidentialNoteEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for confidential note events.\n"
                },
                "customHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/ProjectHookCustomHeader:ProjectHookCustomHeader"
                    },
                    "description": "Custom headers for the project webhook.\n"
                },
                "customWebhookTemplate": {
                    "type": "string",
                    "description": "Custom webhook template.\n"
                },
                "deploymentEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for deployment events.\n"
                },
                "enableSslVerification": {
                    "type": "boolean",
                    "description": "Enable SSL verification when invoking the hook.\n"
                },
                "hookId": {
                    "type": "integer",
                    "description": "The id of the project hook.\n"
                },
                "issuesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for issues events.\n"
                },
                "jobEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for job events.\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for merge requests events.\n"
                },
                "noteEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for note events.\n"
                },
                "pipelineEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for pipeline events.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the hook to.\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "The id of the project for the hook.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for push events.\n"
                },
                "pushEventsBranchFilter": {
                    "type": "string",
                    "description": "Invoke the hook for push events on matching branches only.\n"
                },
                "releasesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for release events.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for tag push events.\n"
                },
                "token": {
                    "type": "string",
                    "description": "A token to present when invoking the hook. The token is not available for imported resources.\n",
                    "secret": true
                },
                "url": {
                    "type": "string",
                    "description": "The url of the hook to invoke. Forces re-creation to preserve `token`.\n"
                },
                "wikiPageEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for wiki page events.\n"
                }
            },
            "required": [
                "confidentialIssuesEvents",
                "confidentialNoteEvents",
                "customWebhookTemplate",
                "deploymentEvents",
                "enableSslVerification",
                "hookId",
                "issuesEvents",
                "jobEvents",
                "mergeRequestsEvents",
                "noteEvents",
                "pipelineEvents",
                "project",
                "projectId",
                "pushEvents",
                "pushEventsBranchFilter",
                "releasesEvents",
                "tagPushEvents",
                "token",
                "url",
                "wikiPageEvents"
            ],
            "inputProperties": {
                "confidentialIssuesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for confidential issues events.\n"
                },
                "confidentialNoteEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for confidential note events.\n"
                },
                "customHeaders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/ProjectHookCustomHeader:ProjectHookCustomHeader"
                    },
                    "description": "Custom headers for the project webhook.\n"
                },
                "customWebhookTemplate": {
                    "type": "string",
                    "description": "Custom webhook template.\n"
                },
                "deploymentEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for deployment events.\n"
                },
                "enableSslVerification": {
                    "type": "boolean",
                    "description": "Enable SSL verification when invoking the hook.\n"
                },
                "issuesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for issues events.\n"
                },
                "jobEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for job events.\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for merge requests events.\n"
                },
                "noteEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for note events.\n"
                },
                "pipelineEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for pipeline events.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the hook to.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for push events.\n"
                },
                "pushEventsBranchFilter": {
                    "type": "string",
                    "description": "Invoke the hook for push events on matching branches only.\n"
                },
                "releasesEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for release events.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for tag push events.\n"
                },
                "token": {
                    "type": "string",
                    "description": "A token to present when invoking the hook. The token is not available for imported resources.\n",
                    "secret": true
                },
                "url": {
                    "type": "string",
                    "description": "The url of the hook to invoke. Forces re-creation to preserve `token`.\n"
                },
                "wikiPageEvents": {
                    "type": "boolean",
                    "description": "Invoke the hook for wiki page events.\n"
                }
            },
            "requiredInputs": [
                "project",
                "url"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectHook resources.\n",
                "properties": {
                    "confidentialIssuesEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for confidential issues events.\n"
                    },
                    "confidentialNoteEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for confidential note events.\n"
                    },
                    "customHeaders": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/ProjectHookCustomHeader:ProjectHookCustomHeader"
                        },
                        "description": "Custom headers for the project webhook.\n"
                    },
                    "customWebhookTemplate": {
                        "type": "string",
                        "description": "Custom webhook template.\n"
                    },
                    "deploymentEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for deployment events.\n"
                    },
                    "enableSslVerification": {
                        "type": "boolean",
                        "description": "Enable SSL verification when invoking the hook.\n"
                    },
                    "hookId": {
                        "type": "integer",
                        "description": "The id of the project hook.\n"
                    },
                    "issuesEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for issues events.\n"
                    },
                    "jobEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for job events.\n"
                    },
                    "mergeRequestsEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for merge requests events.\n"
                    },
                    "noteEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for note events.\n"
                    },
                    "pipelineEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for pipeline events.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project to add the hook to.\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "The id of the project for the hook.\n"
                    },
                    "pushEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for push events.\n"
                    },
                    "pushEventsBranchFilter": {
                        "type": "string",
                        "description": "Invoke the hook for push events on matching branches only.\n"
                    },
                    "releasesEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for release events.\n"
                    },
                    "tagPushEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for tag push events.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "A token to present when invoking the hook. The token is not available for imported resources.\n",
                        "secret": true
                    },
                    "url": {
                        "type": "string",
                        "description": "The url of the hook to invoke. Forces re-creation to preserve `token`.\n"
                    },
                    "wikiPageEvents": {
                        "type": "boolean",
                        "description": "Invoke the hook for wiki page events.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectIssue:ProjectIssue": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = new gitlab.Project(\"foo\", {\n    name: \"example project\",\n    description: \"Lorem Ipsum\",\n    visibilityLevel: \"public\",\n});\nconst welcomeIssue = new gitlab.ProjectIssue(\"welcome_issue\", {\n    project: foo.id,\n    title: \"Welcome!\",\n    description: pulumi.interpolate`  Welcome to the ${foo.name} project!\n\n`,\n    discussionLocked: true,\n});\nexport const welcomeIssueWebUrl = webUrl;\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.Project(\"foo\",\n    name=\"example project\",\n    description=\"Lorem Ipsum\",\n    visibility_level=\"public\")\nwelcome_issue = gitlab.ProjectIssue(\"welcome_issue\",\n    project=foo.id,\n    title=\"Welcome!\",\n    description=foo.name.apply(lambda name: f\"\"\"  Welcome to the {name} project!\n\n\"\"\"),\n    discussion_locked=True)\npulumi.export(\"welcomeIssueWebUrl\", web_url)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = new GitLab.Project(\"foo\", new()\n    {\n        Name = \"example project\",\n        Description = \"Lorem Ipsum\",\n        VisibilityLevel = \"public\",\n    });\n\n    var welcomeIssue = new GitLab.ProjectIssue(\"welcome_issue\", new()\n    {\n        Project = foo.Id,\n        Title = \"Welcome!\",\n        Description = foo.Name.Apply(name =\u003e @$\"  Welcome to the {name} project!\n\n\"),\n        DiscussionLocked = true,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"welcomeIssueWebUrl\"] = webUrl,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfoo, err := gitlab.NewProject(ctx, \"foo\", \u0026gitlab.ProjectArgs{\n\t\t\tName:            pulumi.String(\"example project\"),\n\t\t\tDescription:     pulumi.String(\"Lorem Ipsum\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectIssue(ctx, \"welcome_issue\", \u0026gitlab.ProjectIssueArgs{\n\t\t\tProject: foo.ID(),\n\t\t\tTitle:   pulumi.String(\"Welcome!\"),\n\t\t\tDescription: foo.Name.ApplyT(func(name string) (string, error) {\n\t\t\t\treturn fmt.Sprintf(\"  Welcome to the %v project!\\n\\n\", name), nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t\tDiscussionLocked: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"welcomeIssueWebUrl\", webUrl)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ProjectIssue;\nimport com.pulumi.gitlab.ProjectIssueArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var foo = new Project(\"foo\", ProjectArgs.builder()\n            .name(\"example project\")\n            .description(\"Lorem Ipsum\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var welcomeIssue = new ProjectIssue(\"welcomeIssue\", ProjectIssueArgs.builder()\n            .project(foo.id())\n            .title(\"Welcome!\")\n            .description(foo.name().applyValue(name -\u003e \"\"\"\n  Welcome to the %s project!\n\n\", name)))\n            .discussionLocked(true)\n            .build());\n\n        ctx.export(\"welcomeIssueWebUrl\", webUrl);\n    }\n}\n```\n```yaml\nresources:\n  foo:\n    type: gitlab:Project\n    properties:\n      name: example project\n      description: Lorem Ipsum\n      visibilityLevel: public\n  welcomeIssue:\n    type: gitlab:ProjectIssue\n    name: welcome_issue\n    properties:\n      project: ${foo.id}\n      title: Welcome!\n      description: |2+\n          Welcome to the ${foo.name} project!\n\n      discussionLocked: true\noutputs:\n  welcomeIssueWebUrl: ${webUrl}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_project_issue`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_project_issue.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nYou can import this resource with an id made up of `{project-id}:{issue-id}`, e.g.\n\n```sh\n$ pulumi import gitlab:index/projectIssue:ProjectIssue welcome_issue 42:1\n```\n\n",
            "properties": {
                "assigneeIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "The IDs of the users to assign the issue to.\n"
                },
                "authorId": {
                    "type": "integer",
                    "description": "The ID of the author of the issue. Use `gitlab.User` data source to get more information about the user.\n"
                },
                "closedAt": {
                    "type": "string",
                    "description": "When the issue was closed. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n"
                },
                "closedByUserId": {
                    "type": "integer",
                    "description": "The ID of the user that closed the issue. Use `gitlab.User` data source to get more information about the user.\n"
                },
                "confidential": {
                    "type": "boolean",
                    "description": "Set an issue to be confidential.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "When the issue was created. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z. Requires administrator or project/group owner rights.\n"
                },
                "deleteOnDestroy": {
                    "type": "boolean",
                    "description": "Whether the issue is deleted instead of closed during destroy.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of an issue. Limited to 1,048,576 characters.\n"
                },
                "discussionLocked": {
                    "type": "boolean",
                    "description": "Whether the issue is locked for discussions or not.\n"
                },
                "discussionToResolve": {
                    "type": "string",
                    "description": "The ID of a discussion to resolve. This fills out the issue with a default description and mark the discussion as resolved. Use in combination with merge*request*to*resolve*discussions_of.\n"
                },
                "downvotes": {
                    "type": "integer",
                    "description": "The number of downvotes the issue has received.\n"
                },
                "dueDate": {
                    "type": "string",
                    "description": "The due date. Date time string in the format YYYY-MM-DD, for example 2016-03-11.\n"
                },
                "epicId": {
                    "type": "integer",
                    "description": "ID of the epic to add the issue to. Valid values are greater than or equal to 0.\n"
                },
                "epicIssueId": {
                    "type": "integer",
                    "description": "The ID of the epic issue.\n"
                },
                "externalId": {
                    "type": "string",
                    "description": "The external ID of the issue.\n"
                },
                "humanTimeEstimate": {
                    "type": "string",
                    "description": "The human-readable time estimate of the issue.\n"
                },
                "humanTotalTimeSpent": {
                    "type": "string",
                    "description": "The human-readable total time spent of the issue.\n"
                },
                "iid": {
                    "type": "integer",
                    "description": "The internal ID of the project's issue.\n"
                },
                "issueId": {
                    "type": "integer",
                    "description": "The instance-wide ID of the issue.\n"
                },
                "issueLinkId": {
                    "type": "integer",
                    "description": "The ID of the issue link.\n"
                },
                "issueType": {
                    "type": "string",
                    "description": "The type of issue. Valid values are: `issue`, `incident`, `test_case`.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The labels of an issue.\n"
                },
                "links": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The links of the issue.\n"
                },
                "mergeRequestToResolveDiscussionsOf": {
                    "type": "integer",
                    "description": "The IID of a merge request in which to resolve all issues. This fills out the issue with a default description and mark all discussions as resolved. When passing a description or title, these values take precedence over the default values.\n"
                },
                "mergeRequestsCount": {
                    "type": "integer",
                    "description": "The number of merge requests associated with the issue.\n"
                },
                "milestoneId": {
                    "type": "integer",
                    "description": "The global ID of a milestone to assign issue. To find the milestone_id associated with a milestone, view an issue with the milestone assigned and use the API to retrieve the issue's details.\n"
                },
                "movedToId": {
                    "type": "integer",
                    "description": "The ID of the issue that was moved to.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or ID of the project.\n"
                },
                "references": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The references of the issue.\n"
                },
                "state": {
                    "type": "string",
                    "description": "The state of the issue. Valid values are: `opened`, `closed`.\n"
                },
                "subscribed": {
                    "type": "boolean",
                    "description": "Whether the authenticated user is subscribed to the issue or not.\n"
                },
                "taskCompletionStatuses": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/ProjectIssueTaskCompletionStatus:ProjectIssueTaskCompletionStatus"
                    },
                    "description": "The task completion status. It's always a one element list.\n"
                },
                "timeEstimate": {
                    "type": "integer",
                    "description": "The time estimate of the issue.\n"
                },
                "title": {
                    "type": "string",
                    "description": "The title of the issue.\n"
                },
                "totalTimeSpent": {
                    "type": "integer",
                    "description": "The total time spent of the issue.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "When the issue was updated. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n"
                },
                "upvotes": {
                    "type": "integer",
                    "description": "The number of upvotes the issue has received.\n"
                },
                "userNotesCount": {
                    "type": "integer",
                    "description": "The number of user notes on the issue.\n"
                },
                "webUrl": {
                    "type": "string",
                    "description": "The web URL of the issue.\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "The weight of the issue. Valid values are greater than or equal to 0.\n"
                }
            },
            "required": [
                "authorId",
                "closedAt",
                "closedByUserId",
                "createdAt",
                "downvotes",
                "epicId",
                "epicIssueId",
                "externalId",
                "humanTimeEstimate",
                "humanTotalTimeSpent",
                "iid",
                "issueId",
                "issueLinkId",
                "links",
                "mergeRequestsCount",
                "movedToId",
                "project",
                "references",
                "subscribed",
                "taskCompletionStatuses",
                "timeEstimate",
                "title",
                "totalTimeSpent",
                "updatedAt",
                "upvotes",
                "userNotesCount",
                "webUrl",
                "weight"
            ],
            "inputProperties": {
                "assigneeIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "The IDs of the users to assign the issue to.\n"
                },
                "confidential": {
                    "type": "boolean",
                    "description": "Set an issue to be confidential.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "When the issue was created. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z. Requires administrator or project/group owner rights.\n",
                    "willReplaceOnChanges": true
                },
                "deleteOnDestroy": {
                    "type": "boolean",
                    "description": "Whether the issue is deleted instead of closed during destroy.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of an issue. Limited to 1,048,576 characters.\n"
                },
                "discussionLocked": {
                    "type": "boolean",
                    "description": "Whether the issue is locked for discussions or not.\n"
                },
                "discussionToResolve": {
                    "type": "string",
                    "description": "The ID of a discussion to resolve. This fills out the issue with a default description and mark the discussion as resolved. Use in combination with merge*request*to*resolve*discussions_of.\n"
                },
                "dueDate": {
                    "type": "string",
                    "description": "The due date. Date time string in the format YYYY-MM-DD, for example 2016-03-11.\n"
                },
                "epicIssueId": {
                    "type": "integer",
                    "description": "The ID of the epic issue.\n"
                },
                "iid": {
                    "type": "integer",
                    "description": "The internal ID of the project's issue.\n",
                    "willReplaceOnChanges": true
                },
                "issueType": {
                    "type": "string",
                    "description": "The type of issue. Valid values are: `issue`, `incident`, `test_case`.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The labels of an issue.\n"
                },
                "mergeRequestToResolveDiscussionsOf": {
                    "type": "integer",
                    "description": "The IID of a merge request in which to resolve all issues. This fills out the issue with a default description and mark all discussions as resolved. When passing a description or title, these values take precedence over the default values.\n"
                },
                "milestoneId": {
                    "type": "integer",
                    "description": "The global ID of a milestone to assign issue. To find the milestone_id associated with a milestone, view an issue with the milestone assigned and use the API to retrieve the issue's details.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or ID of the project.\n",
                    "willReplaceOnChanges": true
                },
                "state": {
                    "type": "string",
                    "description": "The state of the issue. Valid values are: `opened`, `closed`.\n"
                },
                "title": {
                    "type": "string",
                    "description": "The title of the issue.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "When the issue was updated. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "The weight of the issue. Valid values are greater than or equal to 0.\n"
                }
            },
            "requiredInputs": [
                "project",
                "title"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectIssue resources.\n",
                "properties": {
                    "assigneeIds": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "The IDs of the users to assign the issue to.\n"
                    },
                    "authorId": {
                        "type": "integer",
                        "description": "The ID of the author of the issue. Use `gitlab.User` data source to get more information about the user.\n"
                    },
                    "closedAt": {
                        "type": "string",
                        "description": "When the issue was closed. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n"
                    },
                    "closedByUserId": {
                        "type": "integer",
                        "description": "The ID of the user that closed the issue. Use `gitlab.User` data source to get more information about the user.\n"
                    },
                    "confidential": {
                        "type": "boolean",
                        "description": "Set an issue to be confidential.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "When the issue was created. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z. Requires administrator or project/group owner rights.\n",
                        "willReplaceOnChanges": true
                    },
                    "deleteOnDestroy": {
                        "type": "boolean",
                        "description": "Whether the issue is deleted instead of closed during destroy.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of an issue. Limited to 1,048,576 characters.\n"
                    },
                    "discussionLocked": {
                        "type": "boolean",
                        "description": "Whether the issue is locked for discussions or not.\n"
                    },
                    "discussionToResolve": {
                        "type": "string",
                        "description": "The ID of a discussion to resolve. This fills out the issue with a default description and mark the discussion as resolved. Use in combination with merge*request*to*resolve*discussions_of.\n"
                    },
                    "downvotes": {
                        "type": "integer",
                        "description": "The number of downvotes the issue has received.\n"
                    },
                    "dueDate": {
                        "type": "string",
                        "description": "The due date. Date time string in the format YYYY-MM-DD, for example 2016-03-11.\n"
                    },
                    "epicId": {
                        "type": "integer",
                        "description": "ID of the epic to add the issue to. Valid values are greater than or equal to 0.\n"
                    },
                    "epicIssueId": {
                        "type": "integer",
                        "description": "The ID of the epic issue.\n"
                    },
                    "externalId": {
                        "type": "string",
                        "description": "The external ID of the issue.\n"
                    },
                    "humanTimeEstimate": {
                        "type": "string",
                        "description": "The human-readable time estimate of the issue.\n"
                    },
                    "humanTotalTimeSpent": {
                        "type": "string",
                        "description": "The human-readable total time spent of the issue.\n"
                    },
                    "iid": {
                        "type": "integer",
                        "description": "The internal ID of the project's issue.\n",
                        "willReplaceOnChanges": true
                    },
                    "issueId": {
                        "type": "integer",
                        "description": "The instance-wide ID of the issue.\n"
                    },
                    "issueLinkId": {
                        "type": "integer",
                        "description": "The ID of the issue link.\n"
                    },
                    "issueType": {
                        "type": "string",
                        "description": "The type of issue. Valid values are: `issue`, `incident`, `test_case`.\n"
                    },
                    "labels": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The labels of an issue.\n"
                    },
                    "links": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "The links of the issue.\n"
                    },
                    "mergeRequestToResolveDiscussionsOf": {
                        "type": "integer",
                        "description": "The IID of a merge request in which to resolve all issues. This fills out the issue with a default description and mark all discussions as resolved. When passing a description or title, these values take precedence over the default values.\n"
                    },
                    "mergeRequestsCount": {
                        "type": "integer",
                        "description": "The number of merge requests associated with the issue.\n"
                    },
                    "milestoneId": {
                        "type": "integer",
                        "description": "The global ID of a milestone to assign issue. To find the milestone_id associated with a milestone, view an issue with the milestone assigned and use the API to retrieve the issue's details.\n"
                    },
                    "movedToId": {
                        "type": "integer",
                        "description": "The ID of the issue that was moved to.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or ID of the project.\n",
                        "willReplaceOnChanges": true
                    },
                    "references": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "The references of the issue.\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "The state of the issue. Valid values are: `opened`, `closed`.\n"
                    },
                    "subscribed": {
                        "type": "boolean",
                        "description": "Whether the authenticated user is subscribed to the issue or not.\n"
                    },
                    "taskCompletionStatuses": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/ProjectIssueTaskCompletionStatus:ProjectIssueTaskCompletionStatus"
                        },
                        "description": "The task completion status. It's always a one element list.\n"
                    },
                    "timeEstimate": {
                        "type": "integer",
                        "description": "The time estimate of the issue.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "The title of the issue.\n"
                    },
                    "totalTimeSpent": {
                        "type": "integer",
                        "description": "The total time spent of the issue.\n"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "When the issue was updated. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n"
                    },
                    "upvotes": {
                        "type": "integer",
                        "description": "The number of upvotes the issue has received.\n"
                    },
                    "userNotesCount": {
                        "type": "integer",
                        "description": "The number of user notes on the issue.\n"
                    },
                    "webUrl": {
                        "type": "string",
                        "description": "The web URL of the issue.\n"
                    },
                    "weight": {
                        "type": "integer",
                        "description": "The weight of the issue. Valid values are greater than or equal to 0.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectIssueBoard:ProjectIssueBoard": {
            "description": "The `gitlab.ProjectIssueBoard` resource allows to manage the lifecycle of a Project Issue Board.\n\n\u003e **NOTE:** If the board lists are changed all lists will be recreated.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/boards.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nresources:\n  example:\n    type: gitlab:Project\n    properties:\n      name: example project\n      description: Lorem Ipsum\n      visibilityLevel: public\n  exampleUser:\n    type: gitlab:User\n    name: example\n    properties:\n      name: example\n      username: example\n      email: example@example.com\n      password: example1$$$\n  exampleProjectMembership:\n    type: gitlab:ProjectMembership\n    name: example\n    properties:\n      projectId: ${example.id}\n      userId: ${exampleUser.id}\n      accessLevel: developer\n  exampleProjectMilestone:\n    type: gitlab:ProjectMilestone\n    name: example\n    properties:\n      project: ${example.id}\n      title: m1\n  this:\n    type: gitlab:ProjectIssueBoard\n    properties:\n      project: ${example.id}\n      name: Test Issue Board\n      lists:\n        - assigneeId: ${exampleUser.id}\n        - milestoneId: ${exampleProjectMilestone.milestoneId}\n    options:\n      dependson:\n        - ${exampleProjectMembership}\n  listSyntax:\n    type: gitlab:ProjectIssueBoard\n    name: list_syntax\n    properties:\n      project: ${example.id}\n      name: Test Issue Board with list syntax\n      lists:\n        - assigneeId: ${exampleUser.id}\n        - milestoneId: ${exampleProjectMilestone.milestoneId}\n    options:\n      dependson:\n        - ${exampleProjectMembership}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_project_issue_board`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_project_issue_board.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nYou can import this resource with an id made up of `{project-id}:{issue-board-id}`, e.g.\n\n```sh\n$ pulumi import gitlab:index/projectIssueBoard:ProjectIssueBoard kanban 42:1\n```\n\n",
            "properties": {
                "assigneeId": {
                    "type": "integer",
                    "description": "The assignee the board should be scoped to. Requires a GitLab EE license.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of label names which the board should be scoped to. Requires a GitLab EE license.\n"
                },
                "lists": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/ProjectIssueBoardList:ProjectIssueBoardList"
                    },
                    "description": "The list of issue board lists\n"
                },
                "milestoneId": {
                    "type": "integer",
                    "description": "The milestone the board should be scoped to. Requires a GitLab EE license.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the board.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project maintained by the authenticated user.\n"
                },
                "weight": {
                    "type": "integer",
                    "description": "The weight range from 0 to 9, to which the board should be scoped to. Requires a GitLab EE license.\n"
                }
            },
            "required": [
                "name",
                "project"
            ],
            "inputProperties": {
                "assigneeId": {
                    "type": "integer",
                    "description": "The assignee the board should be scoped to. Requires a GitLab EE license.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of label names which the board should be scoped to. Requires a GitLab EE license.\n"
                },
                "lists": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/ProjectIssueBoardList:ProjectIssueBoardList"
                    },
                    "description": "The list of issue board lists\n"
                },
                "milestoneId": {
                    "type": "integer",
                    "description": "The milestone the board should be scoped to. Requires a GitLab EE license.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the board.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project maintained by the authenticated user.\n",
                    "willReplaceOnChanges": true
                },
                "weight": {
                    "type": "integer",
                    "description": "The weight range from 0 to 9, to which the board should be scoped to. Requires a GitLab EE license.\n"
                }
            },
            "requiredInputs": [
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectIssueBoard resources.\n",
                "properties": {
                    "assigneeId": {
                        "type": "integer",
                        "description": "The assignee the board should be scoped to. Requires a GitLab EE license.\n"
                    },
                    "labels": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of label names which the board should be scoped to. Requires a GitLab EE license.\n"
                    },
                    "lists": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/ProjectIssueBoardList:ProjectIssueBoardList"
                        },
                        "description": "The list of issue board lists\n"
                    },
                    "milestoneId": {
                        "type": "integer",
                        "description": "The milestone the board should be scoped to. Requires a GitLab EE license.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the board.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or full path of the project maintained by the authenticated user.\n",
                        "willReplaceOnChanges": true
                    },
                    "weight": {
                        "type": "integer",
                        "description": "The weight range from 0 to 9, to which the board should be scoped to. Requires a GitLab EE license.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectJobTokenScope:ProjectJobTokenScope": {
            "description": "The `gitlab.ProjectJobTokenScope` resource allows to manage the CI/CD Job Token scope in a project.\nAny projects added to the CI/CD Job Token scope outside of TF will be untouched by the resource.\n\n\u003e Conflicts with the use of `gitlab.ProjectJobTokenScopes` when used on the same project. Use one or the other to ensure the desired state.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/project_job_token_scopes.html)\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_project_job_token_scope`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_project_job_token_scope.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab project job token scopes can be imported using an id made up of `projectId:targetProjectId`, e.g.\n\n```sh\n$ pulumi import gitlab:index/projectJobTokenScope:ProjectJobTokenScope bar 123:321\n```\n\n",
            "properties": {
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project.\n"
                },
                "targetProjectId": {
                    "type": "integer",
                    "description": "The ID of the project that is in the CI/CD job token inbound allowlist.\n"
                }
            },
            "required": [
                "project",
                "targetProjectId"
            ],
            "inputProperties": {
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project.\n"
                },
                "targetProjectId": {
                    "type": "integer",
                    "description": "The ID of the project that is in the CI/CD job token inbound allowlist.\n"
                }
            },
            "requiredInputs": [
                "project",
                "targetProjectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectJobTokenScope resources.\n",
                "properties": {
                    "project": {
                        "type": "string",
                        "description": "The ID or full path of the project.\n"
                    },
                    "targetProjectId": {
                        "type": "integer",
                        "description": "The ID of the project that is in the CI/CD job token inbound allowlist.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectJobTokenScopes:ProjectJobTokenScopes": {
            "description": "The `gitlab.ProjectJobTokenScopes` resource allows to manage the CI/CD Job Token scopes in a project.\nAny project not within the defined set in this attribute will be removed, which allows this resource to be used as an explicit deny.\n\n\u003e Conflicts with the use of `gitlab.ProjectJobTokenScope` when used on the same project. Use one or the other to ensure the desired state.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/project_job_token_scopes.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst allowedSingleProject = new gitlab.ProjectJobTokenScopes(\"allowed_single_project\", {\n    project: \"111\",\n    targetProjectIds: [123],\n});\nconst allowedMultipleProject = new gitlab.ProjectJobTokenScopes(\"allowed_multiple_project\", {\n    project: \"111\",\n    targetProjectIds: [\n        123,\n        456,\n        789,\n    ],\n});\nconst allowedMultipleGroups = new gitlab.ProjectJobTokenScopes(\"allowed_multiple_groups\", {\n    projectId: 111,\n    targetProjectIds: [],\n    targetGroupIds: [\n        321,\n        654,\n    ],\n});\n// This will remove all job token scopes, even if added outside of TF.\nconst explicitDeny = new gitlab.ProjectJobTokenScopes(\"explicit_deny\", {\n    project: \"111\",\n    targetProjectIds: [],\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nallowed_single_project = gitlab.ProjectJobTokenScopes(\"allowed_single_project\",\n    project=\"111\",\n    target_project_ids=[123])\nallowed_multiple_project = gitlab.ProjectJobTokenScopes(\"allowed_multiple_project\",\n    project=\"111\",\n    target_project_ids=[\n        123,\n        456,\n        789,\n    ])\nallowed_multiple_groups = gitlab.ProjectJobTokenScopes(\"allowed_multiple_groups\",\n    project_id=111,\n    target_project_ids=[],\n    target_group_ids=[\n        321,\n        654,\n    ])\n# This will remove all job token scopes, even if added outside of TF.\nexplicit_deny = gitlab.ProjectJobTokenScopes(\"explicit_deny\",\n    project=\"111\",\n    target_project_ids=[])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var allowedSingleProject = new GitLab.ProjectJobTokenScopes(\"allowed_single_project\", new()\n    {\n        Project = \"111\",\n        TargetProjectIds = new[]\n        {\n            123,\n        },\n    });\n\n    var allowedMultipleProject = new GitLab.ProjectJobTokenScopes(\"allowed_multiple_project\", new()\n    {\n        Project = \"111\",\n        TargetProjectIds = new[]\n        {\n            123,\n            456,\n            789,\n        },\n    });\n\n    var allowedMultipleGroups = new GitLab.ProjectJobTokenScopes(\"allowed_multiple_groups\", new()\n    {\n        ProjectId = 111,\n        TargetProjectIds = new[] {},\n        TargetGroupIds = new[]\n        {\n            321,\n            654,\n        },\n    });\n\n    // This will remove all job token scopes, even if added outside of TF.\n    var explicitDeny = new GitLab.ProjectJobTokenScopes(\"explicit_deny\", new()\n    {\n        Project = \"111\",\n        TargetProjectIds = new[] {},\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewProjectJobTokenScopes(ctx, \"allowed_single_project\", \u0026gitlab.ProjectJobTokenScopesArgs{\n\t\t\tProject: pulumi.String(\"111\"),\n\t\t\tTargetProjectIds: pulumi.IntArray{\n\t\t\t\tpulumi.Int(123),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectJobTokenScopes(ctx, \"allowed_multiple_project\", \u0026gitlab.ProjectJobTokenScopesArgs{\n\t\t\tProject: pulumi.String(\"111\"),\n\t\t\tTargetProjectIds: pulumi.IntArray{\n\t\t\t\tpulumi.Int(123),\n\t\t\t\tpulumi.Int(456),\n\t\t\t\tpulumi.Int(789),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectJobTokenScopes(ctx, \"allowed_multiple_groups\", \u0026gitlab.ProjectJobTokenScopesArgs{\n\t\t\tProjectId:        pulumi.Int(111),\n\t\t\tTargetProjectIds: pulumi.IntArray{},\n\t\t\tTargetGroupIds: pulumi.IntArray{\n\t\t\t\tpulumi.Int(321),\n\t\t\t\tpulumi.Int(654),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// This will remove all job token scopes, even if added outside of TF.\n\t\t_, err = gitlab.NewProjectJobTokenScopes(ctx, \"explicit_deny\", \u0026gitlab.ProjectJobTokenScopesArgs{\n\t\t\tProject:          pulumi.String(\"111\"),\n\t\t\tTargetProjectIds: pulumi.IntArray{},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ProjectJobTokenScopes;\nimport com.pulumi.gitlab.ProjectJobTokenScopesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var allowedSingleProject = new ProjectJobTokenScopes(\"allowedSingleProject\", ProjectJobTokenScopesArgs.builder()\n            .project(\"111\")\n            .targetProjectIds(123)\n            .build());\n\n        var allowedMultipleProject = new ProjectJobTokenScopes(\"allowedMultipleProject\", ProjectJobTokenScopesArgs.builder()\n            .project(\"111\")\n            .targetProjectIds(            \n                123,\n                456,\n                789)\n            .build());\n\n        var allowedMultipleGroups = new ProjectJobTokenScopes(\"allowedMultipleGroups\", ProjectJobTokenScopesArgs.builder()\n            .projectId(111)\n            .targetProjectIds()\n            .targetGroupIds(            \n                321,\n                654)\n            .build());\n\n        // This will remove all job token scopes, even if added outside of TF.\n        var explicitDeny = new ProjectJobTokenScopes(\"explicitDeny\", ProjectJobTokenScopesArgs.builder()\n            .project(\"111\")\n            .targetProjectIds()\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  allowedSingleProject:\n    type: gitlab:ProjectJobTokenScopes\n    name: allowed_single_project\n    properties:\n      project: '111'\n      targetProjectIds:\n        - 123\n  allowedMultipleProject:\n    type: gitlab:ProjectJobTokenScopes\n    name: allowed_multiple_project\n    properties:\n      project: '111'\n      targetProjectIds:\n        - 123\n        - 456\n        - 789\n  allowedMultipleGroups:\n    type: gitlab:ProjectJobTokenScopes\n    name: allowed_multiple_groups\n    properties:\n      projectId: 111\n      targetProjectIds: []\n      targetGroupIds:\n        - 321\n        - 654\n  # This will remove all job token scopes, even if added outside of TF.\n  explicitDeny:\n    type: gitlab:ProjectJobTokenScopes\n    name: explicit_deny\n    properties:\n      project: '111'\n      targetProjectIds: []\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_project_job_token_scopes`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_project_job_token_scopes.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab project job token scopes can be imported using an id made up of just the `project_id`\n\n```sh\n$ pulumi import gitlab:index/projectJobTokenScopes:ProjectJobTokenScopes bar 123\n```\n\n",
            "properties": {
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project.\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "The ID of the project.\n",
                    "deprecationMessage": "`project_id` has been deprecated. Use `project` instead."
                },
                "targetGroupIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A set of group IDs that are in the CI/CD job token inbound allowlist.\n"
                },
                "targetProjectIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A set of project IDs that are in the CI/CD job token inbound allowlist.\n"
                }
            },
            "required": [
                "project",
                "projectId",
                "targetGroupIds",
                "targetProjectIds"
            ],
            "inputProperties": {
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project.\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "The ID of the project.\n",
                    "deprecationMessage": "`project_id` has been deprecated. Use `project` instead."
                },
                "targetGroupIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A set of group IDs that are in the CI/CD job token inbound allowlist.\n"
                },
                "targetProjectIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "A set of project IDs that are in the CI/CD job token inbound allowlist.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectJobTokenScopes resources.\n",
                "properties": {
                    "project": {
                        "type": "string",
                        "description": "The ID or full path of the project.\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "The ID of the project.\n",
                        "deprecationMessage": "`project_id` has been deprecated. Use `project` instead."
                    },
                    "targetGroupIds": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "A set of group IDs that are in the CI/CD job token inbound allowlist.\n"
                    },
                    "targetProjectIds": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "A set of project IDs that are in the CI/CD job token inbound allowlist.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectLabel:ProjectLabel": {
            "description": "The `gitlab.ProjectLabel` resource allows to manage the lifecycle of a project label.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/labels.html#project-labels)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst fixme = new gitlab.ProjectLabel(\"fixme\", {\n    project: \"example\",\n    name: \"fixme\",\n    description: \"issue with failing tests\",\n    color: \"#ffcc00\",\n});\n// Scoped label\nconst devopsCreate = new gitlab.ProjectLabel(\"devops_create\", {\n    project: example.id,\n    name: \"devops::create\",\n    description: \"issue for creating infrastructure resources\",\n    color: \"#ffa500\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfixme = gitlab.ProjectLabel(\"fixme\",\n    project=\"example\",\n    name=\"fixme\",\n    description=\"issue with failing tests\",\n    color=\"#ffcc00\")\n# Scoped label\ndevops_create = gitlab.ProjectLabel(\"devops_create\",\n    project=example[\"id\"],\n    name=\"devops::create\",\n    description=\"issue for creating infrastructure resources\",\n    color=\"#ffa500\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var fixme = new GitLab.ProjectLabel(\"fixme\", new()\n    {\n        Project = \"example\",\n        Name = \"fixme\",\n        Description = \"issue with failing tests\",\n        Color = \"#ffcc00\",\n    });\n\n    // Scoped label\n    var devopsCreate = new GitLab.ProjectLabel(\"devops_create\", new()\n    {\n        Project = example.Id,\n        Name = \"devops::create\",\n        Description = \"issue for creating infrastructure resources\",\n        Color = \"#ffa500\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewProjectLabel(ctx, \"fixme\", \u0026gitlab.ProjectLabelArgs{\n\t\t\tProject:     pulumi.String(\"example\"),\n\t\t\tName:        pulumi.String(\"fixme\"),\n\t\t\tDescription: pulumi.String(\"issue with failing tests\"),\n\t\t\tColor:       pulumi.String(\"#ffcc00\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Scoped label\n\t\t_, err = gitlab.NewProjectLabel(ctx, \"devops_create\", \u0026gitlab.ProjectLabelArgs{\n\t\t\tProject:     pulumi.Any(example.Id),\n\t\t\tName:        pulumi.String(\"devops::create\"),\n\t\t\tDescription: pulumi.String(\"issue for creating infrastructure resources\"),\n\t\t\tColor:       pulumi.String(\"#ffa500\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ProjectLabel;\nimport com.pulumi.gitlab.ProjectLabelArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var fixme = new ProjectLabel(\"fixme\", ProjectLabelArgs.builder()\n            .project(\"example\")\n            .name(\"fixme\")\n            .description(\"issue with failing tests\")\n            .color(\"#ffcc00\")\n            .build());\n\n        // Scoped label\n        var devopsCreate = new ProjectLabel(\"devopsCreate\", ProjectLabelArgs.builder()\n            .project(example.id())\n            .name(\"devops::create\")\n            .description(\"issue for creating infrastructure resources\")\n            .color(\"#ffa500\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  fixme:\n    type: gitlab:ProjectLabel\n    properties:\n      project: example\n      name: fixme\n      description: issue with failing tests\n      color: '#ffcc00'\n  # Scoped label\n  devopsCreate:\n    type: gitlab:ProjectLabel\n    name: devops_create\n    properties:\n      project: ${example.id}\n      name: devops::create\n      description: issue for creating infrastructure resources\n      color: '#ffa500'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_project_label`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_project_label.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitlab Project labels can be imported using an id made up of `{project_id}:{group_label_id}`, e.g.\n\n```sh\n$ pulumi import gitlab:index/projectLabel:ProjectLabel example 12345:fixme\n```\n\n",
            "properties": {
                "color": {
                    "type": "string",
                    "description": "The color of the label given in 6-digit hex notation with leading '#' sign (e.g. #FFAABB) or one of the [CSS color names](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords).\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the label.\n"
                },
                "labelId": {
                    "type": "integer",
                    "description": "The id of the project label.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the label.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the label to.\n"
                }
            },
            "required": [
                "color",
                "labelId",
                "name",
                "project"
            ],
            "inputProperties": {
                "color": {
                    "type": "string",
                    "description": "The color of the label given in 6-digit hex notation with leading '#' sign (e.g. #FFAABB) or one of the [CSS color names](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords).\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the label.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the label.\n",
                    "willReplaceOnChanges": true
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project to add the label to.\n"
                }
            },
            "requiredInputs": [
                "color",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectLabel resources.\n",
                "properties": {
                    "color": {
                        "type": "string",
                        "description": "The color of the label given in 6-digit hex notation with leading '#' sign (e.g. #FFAABB) or one of the [CSS color names](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords).\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the label.\n"
                    },
                    "labelId": {
                        "type": "integer",
                        "description": "The id of the project label.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the label.\n",
                        "willReplaceOnChanges": true
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project to add the label to.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectLevelMrApprovals:ProjectLevelMrApprovals": {
            "description": "The `gitlab_project_level_mr_approval_rule` resource allows to manage the lifecycle of a Merge Request-level approval rule.\n\n\u003e This resource requires a GitLab Enterprise instance.\n\t\t\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/merge_request_approvals.html#merge-request-level-mr-approvals)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = new gitlab.Project(\"foo\", {\n    name: \"Example\",\n    description: \"My example project\",\n});\nconst fooProjectLevelMrApprovals = new gitlab.ProjectLevelMrApprovals(\"foo\", {\n    project: foo.id,\n    resetApprovalsOnPush: true,\n    disableOverridingApproversPerMergeRequest: false,\n    mergeRequestsAuthorApproval: false,\n    mergeRequestsDisableCommittersApproval: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.Project(\"foo\",\n    name=\"Example\",\n    description=\"My example project\")\nfoo_project_level_mr_approvals = gitlab.ProjectLevelMrApprovals(\"foo\",\n    project=foo.id,\n    reset_approvals_on_push=True,\n    disable_overriding_approvers_per_merge_request=False,\n    merge_requests_author_approval=False,\n    merge_requests_disable_committers_approval=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = new GitLab.Project(\"foo\", new()\n    {\n        Name = \"Example\",\n        Description = \"My example project\",\n    });\n\n    var fooProjectLevelMrApprovals = new GitLab.ProjectLevelMrApprovals(\"foo\", new()\n    {\n        Project = foo.Id,\n        ResetApprovalsOnPush = true,\n        DisableOverridingApproversPerMergeRequest = false,\n        MergeRequestsAuthorApproval = false,\n        MergeRequestsDisableCommittersApproval = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfoo, err := gitlab.NewProject(ctx, \"foo\", \u0026gitlab.ProjectArgs{\n\t\t\tName:        pulumi.String(\"Example\"),\n\t\t\tDescription: pulumi.String(\"My example project\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectLevelMrApprovals(ctx, \"foo\", \u0026gitlab.ProjectLevelMrApprovalsArgs{\n\t\t\tProject:              foo.ID(),\n\t\t\tResetApprovalsOnPush: pulumi.Bool(true),\n\t\t\tDisableOverridingApproversPerMergeRequest: pulumi.Bool(false),\n\t\t\tMergeRequestsAuthorApproval:               pulumi.Bool(false),\n\t\t\tMergeRequestsDisableCommittersApproval:    pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ProjectLevelMrApprovals;\nimport com.pulumi.gitlab.ProjectLevelMrApprovalsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var foo = new Project(\"foo\", ProjectArgs.builder()\n            .name(\"Example\")\n            .description(\"My example project\")\n            .build());\n\n        var fooProjectLevelMrApprovals = new ProjectLevelMrApprovals(\"fooProjectLevelMrApprovals\", ProjectLevelMrApprovalsArgs.builder()\n            .project(foo.id())\n            .resetApprovalsOnPush(true)\n            .disableOverridingApproversPerMergeRequest(false)\n            .mergeRequestsAuthorApproval(false)\n            .mergeRequestsDisableCommittersApproval(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  foo:\n    type: gitlab:Project\n    properties:\n      name: Example\n      description: My example project\n  fooProjectLevelMrApprovals:\n    type: gitlab:ProjectLevelMrApprovals\n    name: foo\n    properties:\n      project: ${foo.id}\n      resetApprovalsOnPush: true\n      disableOverridingApproversPerMergeRequest: false\n      mergeRequestsAuthorApproval: false\n      mergeRequestsDisableCommittersApproval: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_project_level_mr_approvals`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_project_level_mr_approvals.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\n```sh\n$ pulumi import gitlab:index/projectLevelMrApprovals:ProjectLevelMrApprovals You can import an approval configuration state using `\u003cresource\u003e \u003cproject_id\u003e`.\n```\n\n#\n\nFor example:\n\n```sh\n$ pulumi import gitlab:index/projectLevelMrApprovals:ProjectLevelMrApprovals foo 1234\n```\n\n",
            "properties": {
                "disableOverridingApproversPerMergeRequest": {
                    "type": "boolean",
                    "description": "Set to `true` to disable overriding approvers per merge request.\n"
                },
                "mergeRequestsAuthorApproval": {
                    "type": "boolean",
                    "description": "Set to `true` to allow merge requests authors to approve their own merge requests.\n"
                },
                "mergeRequestsDisableCommittersApproval": {
                    "type": "boolean",
                    "description": "Set to `true` to disable merge request committers from approving their own merge requests.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of a project to change MR approval configuration.\n"
                },
                "requirePasswordToApprove": {
                    "type": "boolean",
                    "description": "Set to `true` to require authentication to approve merge requests.\n"
                },
                "resetApprovalsOnPush": {
                    "type": "boolean",
                    "description": "Set to `true` to remove all approvals in a merge request when new commits are pushed to its source branch. Default is `true`.\n"
                },
                "selectiveCodeOwnerRemovals": {
                    "type": "boolean",
                    "description": "Reset approvals from Code Owners if their files changed. Can be enabled only if reset*approvals*on_push is disabled.\n"
                }
            },
            "required": [
                "disableOverridingApproversPerMergeRequest",
                "mergeRequestsAuthorApproval",
                "mergeRequestsDisableCommittersApproval",
                "project",
                "requirePasswordToApprove",
                "resetApprovalsOnPush",
                "selectiveCodeOwnerRemovals"
            ],
            "inputProperties": {
                "disableOverridingApproversPerMergeRequest": {
                    "type": "boolean",
                    "description": "Set to `true` to disable overriding approvers per merge request.\n"
                },
                "mergeRequestsAuthorApproval": {
                    "type": "boolean",
                    "description": "Set to `true` to allow merge requests authors to approve their own merge requests.\n"
                },
                "mergeRequestsDisableCommittersApproval": {
                    "type": "boolean",
                    "description": "Set to `true` to disable merge request committers from approving their own merge requests.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of a project to change MR approval configuration.\n"
                },
                "requirePasswordToApprove": {
                    "type": "boolean",
                    "description": "Set to `true` to require authentication to approve merge requests.\n"
                },
                "resetApprovalsOnPush": {
                    "type": "boolean",
                    "description": "Set to `true` to remove all approvals in a merge request when new commits are pushed to its source branch. Default is `true`.\n"
                },
                "selectiveCodeOwnerRemovals": {
                    "type": "boolean",
                    "description": "Reset approvals from Code Owners if their files changed. Can be enabled only if reset*approvals*on_push is disabled.\n"
                }
            },
            "requiredInputs": [
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectLevelMrApprovals resources.\n",
                "properties": {
                    "disableOverridingApproversPerMergeRequest": {
                        "type": "boolean",
                        "description": "Set to `true` to disable overriding approvers per merge request.\n"
                    },
                    "mergeRequestsAuthorApproval": {
                        "type": "boolean",
                        "description": "Set to `true` to allow merge requests authors to approve their own merge requests.\n"
                    },
                    "mergeRequestsDisableCommittersApproval": {
                        "type": "boolean",
                        "description": "Set to `true` to disable merge request committers from approving their own merge requests.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of a project to change MR approval configuration.\n"
                    },
                    "requirePasswordToApprove": {
                        "type": "boolean",
                        "description": "Set to `true` to require authentication to approve merge requests.\n"
                    },
                    "resetApprovalsOnPush": {
                        "type": "boolean",
                        "description": "Set to `true` to remove all approvals in a merge request when new commits are pushed to its source branch. Default is `true`.\n"
                    },
                    "selectiveCodeOwnerRemovals": {
                        "type": "boolean",
                        "description": "Reset approvals from Code Owners if their files changed. Can be enabled only if reset*approvals*on_push is disabled.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectLevelNotifications:ProjectLevelNotifications": {
            "description": "The `gitlab.ProjectLevelNotifications` resource allows to manage notifications for a project.\n\n\u003e While the API supports both groups and projects, this resource only supports projects currently.\n\t\t\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/notification_settings.html#group--project-level-notification-settings)\n",
            "properties": {
                "closeIssue": {
                    "type": "boolean",
                    "description": "Enable notifications for closed issues. Can only be used when `level` is `custom`.\n"
                },
                "closeMergeRequest": {
                    "type": "boolean",
                    "description": "Enable notifications for closed merge requests. Can only be used when `level` is `custom`.\n"
                },
                "failedPipeline": {
                    "type": "boolean",
                    "description": "Enable notifications for failed pipelines. Can only be used when `level` is `custom`.\n"
                },
                "fixedPipeline": {
                    "type": "boolean",
                    "description": "Enable notifications for fixed pipelines. Can only be used when `level` is `custom`.\n"
                },
                "issueDue": {
                    "type": "boolean",
                    "description": "Enable notifications for due issues. Can only be used when `level` is `custom`.\n"
                },
                "level": {
                    "type": "string",
                    "description": "The level of the notification. Valid values are: `disabled`, `participating`, `watch`, `global`, `mention`, `custom`.\n"
                },
                "mergeMergeRequest": {
                    "type": "boolean",
                    "description": "Enable notifications for merged merge requests. Can only be used when `level` is `custom`.\n"
                },
                "mergeWhenPipelineSucceeds": {
                    "type": "boolean",
                    "description": "Enable notifications for merged merge requests when the pipeline succeeds. Can only be used when `level` is `custom`.\n"
                },
                "movedProject": {
                    "type": "boolean",
                    "description": "Enable notifications for moved projects. Can only be used when `level` is `custom`.\n"
                },
                "newIssue": {
                    "type": "boolean",
                    "description": "Enable notifications for new issues. Can only be used when `level` is `custom`.\n"
                },
                "newMergeRequest": {
                    "type": "boolean",
                    "description": "Enable notifications for new merge requests. Can only be used when `level` is `custom`.\n"
                },
                "newNote": {
                    "type": "boolean",
                    "description": "Enable notifications for new notes on merge requests. Can only be used when `level` is `custom`.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of a project where notifications will be configured.\n"
                },
                "pushToMergeRequest": {
                    "type": "boolean",
                    "description": "Enable notifications for push to merge request branches. Can only be used when `level` is `custom`.\n"
                },
                "reassignIssue": {
                    "type": "boolean",
                    "description": "Enable notifications for issue reassignments. Can only be used when `level` is `custom`.\n"
                },
                "reassignMergeRequest": {
                    "type": "boolean",
                    "description": "Enable notifications for merge request reassignments. Can only be used when `level` is `custom`.\n"
                },
                "reopenIssue": {
                    "type": "boolean",
                    "description": "Enable notifications for reopened issues. Can only be used when `level` is `custom`.\n"
                },
                "reopenMergeRequest": {
                    "type": "boolean",
                    "description": "Enable notifications for reopened merge requests. Can only be used when `level` is `custom`.\n"
                },
                "successPipeline": {
                    "type": "boolean",
                    "description": "Enable notifications for successful pipelines. Can only be used when `level` is `custom`.\n"
                }
            },
            "required": [
                "closeIssue",
                "closeMergeRequest",
                "failedPipeline",
                "fixedPipeline",
                "issueDue",
                "level",
                "mergeMergeRequest",
                "mergeWhenPipelineSucceeds",
                "movedProject",
                "newIssue",
                "newMergeRequest",
                "newNote",
                "project",
                "pushToMergeRequest",
                "reassignIssue",
                "reassignMergeRequest",
                "reopenIssue",
                "reopenMergeRequest",
                "successPipeline"
            ],
            "inputProperties": {
                "closeIssue": {
                    "type": "boolean",
                    "description": "Enable notifications for closed issues. Can only be used when `level` is `custom`.\n"
                },
                "closeMergeRequest": {
                    "type": "boolean",
                    "description": "Enable notifications for closed merge requests. Can only be used when `level` is `custom`.\n"
                },
                "failedPipeline": {
                    "type": "boolean",
                    "description": "Enable notifications for failed pipelines. Can only be used when `level` is `custom`.\n"
                },
                "fixedPipeline": {
                    "type": "boolean",
                    "description": "Enable notifications for fixed pipelines. Can only be used when `level` is `custom`.\n"
                },
                "issueDue": {
                    "type": "boolean",
                    "description": "Enable notifications for due issues. Can only be used when `level` is `custom`.\n"
                },
                "level": {
                    "type": "string",
                    "description": "The level of the notification. Valid values are: `disabled`, `participating`, `watch`, `global`, `mention`, `custom`.\n"
                },
                "mergeMergeRequest": {
                    "type": "boolean",
                    "description": "Enable notifications for merged merge requests. Can only be used when `level` is `custom`.\n"
                },
                "mergeWhenPipelineSucceeds": {
                    "type": "boolean",
                    "description": "Enable notifications for merged merge requests when the pipeline succeeds. Can only be used when `level` is `custom`.\n"
                },
                "movedProject": {
                    "type": "boolean",
                    "description": "Enable notifications for moved projects. Can only be used when `level` is `custom`.\n"
                },
                "newIssue": {
                    "type": "boolean",
                    "description": "Enable notifications for new issues. Can only be used when `level` is `custom`.\n"
                },
                "newMergeRequest": {
                    "type": "boolean",
                    "description": "Enable notifications for new merge requests. Can only be used when `level` is `custom`.\n"
                },
                "newNote": {
                    "type": "boolean",
                    "description": "Enable notifications for new notes on merge requests. Can only be used when `level` is `custom`.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of a project where notifications will be configured.\n"
                },
                "pushToMergeRequest": {
                    "type": "boolean",
                    "description": "Enable notifications for push to merge request branches. Can only be used when `level` is `custom`.\n"
                },
                "reassignIssue": {
                    "type": "boolean",
                    "description": "Enable notifications for issue reassignments. Can only be used when `level` is `custom`.\n"
                },
                "reassignMergeRequest": {
                    "type": "boolean",
                    "description": "Enable notifications for merge request reassignments. Can only be used when `level` is `custom`.\n"
                },
                "reopenIssue": {
                    "type": "boolean",
                    "description": "Enable notifications for reopened issues. Can only be used when `level` is `custom`.\n"
                },
                "reopenMergeRequest": {
                    "type": "boolean",
                    "description": "Enable notifications for reopened merge requests. Can only be used when `level` is `custom`.\n"
                },
                "successPipeline": {
                    "type": "boolean",
                    "description": "Enable notifications for successful pipelines. Can only be used when `level` is `custom`.\n"
                }
            },
            "requiredInputs": [
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectLevelNotifications resources.\n",
                "properties": {
                    "closeIssue": {
                        "type": "boolean",
                        "description": "Enable notifications for closed issues. Can only be used when `level` is `custom`.\n"
                    },
                    "closeMergeRequest": {
                        "type": "boolean",
                        "description": "Enable notifications for closed merge requests. Can only be used when `level` is `custom`.\n"
                    },
                    "failedPipeline": {
                        "type": "boolean",
                        "description": "Enable notifications for failed pipelines. Can only be used when `level` is `custom`.\n"
                    },
                    "fixedPipeline": {
                        "type": "boolean",
                        "description": "Enable notifications for fixed pipelines. Can only be used when `level` is `custom`.\n"
                    },
                    "issueDue": {
                        "type": "boolean",
                        "description": "Enable notifications for due issues. Can only be used when `level` is `custom`.\n"
                    },
                    "level": {
                        "type": "string",
                        "description": "The level of the notification. Valid values are: `disabled`, `participating`, `watch`, `global`, `mention`, `custom`.\n"
                    },
                    "mergeMergeRequest": {
                        "type": "boolean",
                        "description": "Enable notifications for merged merge requests. Can only be used when `level` is `custom`.\n"
                    },
                    "mergeWhenPipelineSucceeds": {
                        "type": "boolean",
                        "description": "Enable notifications for merged merge requests when the pipeline succeeds. Can only be used when `level` is `custom`.\n"
                    },
                    "movedProject": {
                        "type": "boolean",
                        "description": "Enable notifications for moved projects. Can only be used when `level` is `custom`.\n"
                    },
                    "newIssue": {
                        "type": "boolean",
                        "description": "Enable notifications for new issues. Can only be used when `level` is `custom`.\n"
                    },
                    "newMergeRequest": {
                        "type": "boolean",
                        "description": "Enable notifications for new merge requests. Can only be used when `level` is `custom`.\n"
                    },
                    "newNote": {
                        "type": "boolean",
                        "description": "Enable notifications for new notes on merge requests. Can only be used when `level` is `custom`.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of a project where notifications will be configured.\n"
                    },
                    "pushToMergeRequest": {
                        "type": "boolean",
                        "description": "Enable notifications for push to merge request branches. Can only be used when `level` is `custom`.\n"
                    },
                    "reassignIssue": {
                        "type": "boolean",
                        "description": "Enable notifications for issue reassignments. Can only be used when `level` is `custom`.\n"
                    },
                    "reassignMergeRequest": {
                        "type": "boolean",
                        "description": "Enable notifications for merge request reassignments. Can only be used when `level` is `custom`.\n"
                    },
                    "reopenIssue": {
                        "type": "boolean",
                        "description": "Enable notifications for reopened issues. Can only be used when `level` is `custom`.\n"
                    },
                    "reopenMergeRequest": {
                        "type": "boolean",
                        "description": "Enable notifications for reopened merge requests. Can only be used when `level` is `custom`.\n"
                    },
                    "successPipeline": {
                        "type": "boolean",
                        "description": "Enable notifications for successful pipelines. Can only be used when `level` is `custom`.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectMembership:ProjectMembership": {
            "description": "The `gitlab.ProjectMembership` resource allows to manage the lifecycle of a users project membership.\n\n\u003e If a project should grant membership to an entire group use the `gitlab.ProjectShareGroup` resource instead.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/members.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst test = new gitlab.ProjectMembership(\"test\", {\n    project: \"12345\",\n    userId: 1337,\n    accessLevel: \"guest\",\n});\nconst example = new gitlab.ProjectMembership(\"example\", {\n    project: \"67890\",\n    userId: 1234,\n    accessLevel: \"guest\",\n    expiresAt: \"2022-12-31\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\ntest = gitlab.ProjectMembership(\"test\",\n    project=\"12345\",\n    user_id=1337,\n    access_level=\"guest\")\nexample = gitlab.ProjectMembership(\"example\",\n    project=\"67890\",\n    user_id=1234,\n    access_level=\"guest\",\n    expires_at=\"2022-12-31\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new GitLab.ProjectMembership(\"test\", new()\n    {\n        Project = \"12345\",\n        UserId = 1337,\n        AccessLevel = \"guest\",\n    });\n\n    var example = new GitLab.ProjectMembership(\"example\", new()\n    {\n        Project = \"67890\",\n        UserId = 1234,\n        AccessLevel = \"guest\",\n        ExpiresAt = \"2022-12-31\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewProjectMembership(ctx, \"test\", \u0026gitlab.ProjectMembershipArgs{\n\t\t\tProject:     pulumi.String(\"12345\"),\n\t\t\tUserId:      pulumi.Int(1337),\n\t\t\tAccessLevel: pulumi.String(\"guest\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectMembership(ctx, \"example\", \u0026gitlab.ProjectMembershipArgs{\n\t\t\tProject:     pulumi.String(\"67890\"),\n\t\t\tUserId:      pulumi.Int(1234),\n\t\t\tAccessLevel: pulumi.String(\"guest\"),\n\t\t\tExpiresAt:   pulumi.String(\"2022-12-31\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ProjectMembership;\nimport com.pulumi.gitlab.ProjectMembershipArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new ProjectMembership(\"test\", ProjectMembershipArgs.builder()\n            .project(\"12345\")\n            .userId(1337)\n            .accessLevel(\"guest\")\n            .build());\n\n        var example = new ProjectMembership(\"example\", ProjectMembershipArgs.builder()\n            .project(\"67890\")\n            .userId(1234)\n            .accessLevel(\"guest\")\n            .expiresAt(\"2022-12-31\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: gitlab:ProjectMembership\n    properties:\n      project: '12345'\n      userId: 1337\n      accessLevel: guest\n  example:\n    type: gitlab:ProjectMembership\n    properties:\n      project: '67890'\n      userId: 1234\n      accessLevel: guest\n      expiresAt: 2022-12-31\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_project_membership`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_project_membership.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab project membership can be imported using an id made up of `project_id:user_id`, e.g.\n\n```sh\n$ pulumi import gitlab:index/projectMembership:ProjectMembership test \"12345:1337\"\n```\n\n",
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "The access level for the member. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "Expiration date for the project membership. Format: `YYYY-MM-DD`\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the project.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The id of the user.\n"
                }
            },
            "required": [
                "accessLevel",
                "project",
                "userId"
            ],
            "inputProperties": {
                "accessLevel": {
                    "type": "string",
                    "description": "The access level for the member. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "Expiration date for the project membership. Format: `YYYY-MM-DD`\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the project.\n",
                    "willReplaceOnChanges": true
                },
                "userId": {
                    "type": "integer",
                    "description": "The id of the user.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "accessLevel",
                "project",
                "userId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectMembership resources.\n",
                "properties": {
                    "accessLevel": {
                        "type": "string",
                        "description": "The access level for the member. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "Expiration date for the project membership. Format: `YYYY-MM-DD`\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the project.\n",
                        "willReplaceOnChanges": true
                    },
                    "userId": {
                        "type": "integer",
                        "description": "The id of the user.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectMilestone:ProjectMilestone": {
            "description": "The `gitlab.ProjectMilestone` resource allows to manage the lifecycle of a project milestone.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/milestones.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\n// Create a project for the milestone to use\nconst example = new gitlab.Project(\"example\", {\n    name: \"example\",\n    description: \"An example project\",\n    namespaceId: exampleGitlabGroup.id,\n});\nconst exampleProjectMilestone = new gitlab.ProjectMilestone(\"example\", {\n    project: example.id,\n    title: \"example\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\n# Create a project for the milestone to use\nexample = gitlab.Project(\"example\",\n    name=\"example\",\n    description=\"An example project\",\n    namespace_id=example_gitlab_group[\"id\"])\nexample_project_milestone = gitlab.ProjectMilestone(\"example\",\n    project=example.id,\n    title=\"example\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create a project for the milestone to use\n    var example = new GitLab.Project(\"example\", new()\n    {\n        Name = \"example\",\n        Description = \"An example project\",\n        NamespaceId = exampleGitlabGroup.Id,\n    });\n\n    var exampleProjectMilestone = new GitLab.ProjectMilestone(\"example\", new()\n    {\n        Project = example.Id,\n        Title = \"example\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Create a project for the milestone to use\n\t\texample, err := gitlab.NewProject(ctx, \"example\", \u0026gitlab.ProjectArgs{\n\t\t\tName:        pulumi.String(\"example\"),\n\t\t\tDescription: pulumi.String(\"An example project\"),\n\t\t\tNamespaceId: pulumi.Any(exampleGitlabGroup.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectMilestone(ctx, \"example\", \u0026gitlab.ProjectMilestoneArgs{\n\t\t\tProject: example.ID(),\n\t\t\tTitle:   pulumi.String(\"example\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ProjectMilestone;\nimport com.pulumi.gitlab.ProjectMilestoneArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Create a project for the milestone to use\n        var example = new Project(\"example\", ProjectArgs.builder()\n            .name(\"example\")\n            .description(\"An example project\")\n            .namespaceId(exampleGitlabGroup.id())\n            .build());\n\n        var exampleProjectMilestone = new ProjectMilestone(\"exampleProjectMilestone\", ProjectMilestoneArgs.builder()\n            .project(example.id())\n            .title(\"example\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a project for the milestone to use\n  example:\n    type: gitlab:Project\n    properties:\n      name: example\n      description: An example project\n      namespaceId: ${exampleGitlabGroup.id}\n  exampleProjectMilestone:\n    type: gitlab:ProjectMilestone\n    name: example\n    properties:\n      project: ${example.id}\n      title: example\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_project_milestone`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_project_milestone.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitlab project milestone can be imported with a key composed of `\u003cproject\u003e:\u003cmilestone_id\u003e`, e.g.\n\n```sh\n$ pulumi import gitlab:index/projectMilestone:ProjectMilestone example \"12345:11\"\n```\n\n",
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "The time of creation of the milestone. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the milestone.\n"
                },
                "dueDate": {
                    "type": "string",
                    "description": "The due date of the milestone. Date time string in the format YYYY-MM-DD, for example 2016-03-11.\n"
                },
                "expired": {
                    "type": "boolean",
                    "description": "Bool, true if milestone expired.\n"
                },
                "iid": {
                    "type": "integer",
                    "description": "The ID of the project's milestone.\n"
                },
                "milestoneId": {
                    "type": "integer",
                    "description": "The instance-wide ID of the project’s milestone.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "The project ID of milestone.\n"
                },
                "startDate": {
                    "type": "string",
                    "description": "The start date of the milestone. Date time string in the format YYYY-MM-DD, for example 2016-03-11.\n"
                },
                "state": {
                    "type": "string",
                    "description": "The state of the milestone. Valid values are: `active`, `closed`.\n"
                },
                "title": {
                    "type": "string",
                    "description": "The title of a milestone.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "The last update time of the milestone. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n"
                },
                "webUrl": {
                    "type": "string",
                    "description": "The web URL of the milestone.\n"
                }
            },
            "required": [
                "createdAt",
                "expired",
                "iid",
                "milestoneId",
                "project",
                "projectId",
                "title",
                "updatedAt",
                "webUrl"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "The description of the milestone.\n"
                },
                "dueDate": {
                    "type": "string",
                    "description": "The due date of the milestone. Date time string in the format YYYY-MM-DD, for example 2016-03-11.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n",
                    "willReplaceOnChanges": true
                },
                "startDate": {
                    "type": "string",
                    "description": "The start date of the milestone. Date time string in the format YYYY-MM-DD, for example 2016-03-11.\n"
                },
                "state": {
                    "type": "string",
                    "description": "The state of the milestone. Valid values are: `active`, `closed`.\n"
                },
                "title": {
                    "type": "string",
                    "description": "The title of a milestone.\n"
                }
            },
            "requiredInputs": [
                "project",
                "title"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectMilestone resources.\n",
                "properties": {
                    "createdAt": {
                        "type": "string",
                        "description": "The time of creation of the milestone. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the milestone.\n"
                    },
                    "dueDate": {
                        "type": "string",
                        "description": "The due date of the milestone. Date time string in the format YYYY-MM-DD, for example 2016-03-11.\n"
                    },
                    "expired": {
                        "type": "boolean",
                        "description": "Bool, true if milestone expired.\n"
                    },
                    "iid": {
                        "type": "integer",
                        "description": "The ID of the project's milestone.\n"
                    },
                    "milestoneId": {
                        "type": "integer",
                        "description": "The instance-wide ID of the project’s milestone.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n",
                        "willReplaceOnChanges": true
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "The project ID of milestone.\n"
                    },
                    "startDate": {
                        "type": "string",
                        "description": "The start date of the milestone. Date time string in the format YYYY-MM-DD, for example 2016-03-11.\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "The state of the milestone. Valid values are: `active`, `closed`.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "The title of a milestone.\n"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "The last update time of the milestone. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n"
                    },
                    "webUrl": {
                        "type": "string",
                        "description": "The web URL of the milestone.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectMirror:ProjectMirror": {
            "description": "The `gitlab.ProjectMirror` resource allows to manage the lifecycle of a project mirror.\n\nThis is for *pushing* changes to a remote repository. *Pull Mirroring* can be configured using a combination of the\nimport_url, mirror, and mirror_trigger_builds properties on the gitlab.Project resource.\n\n\u003e **Warning** By default, the provider sets the `keep_divergent_refs` argument to `True`.\n   If you manually set `keep_divergent_refs` to `False`, GitLab mirroring removes branches in the target that aren't in the source.\n   This action can result in unexpected branch deletions.\n\n\u003e **Destroy Behavior** GitLab 14.10 introduced an API endpoint to delete a project mirror.\n   Therefore, for GitLab 14.10 and newer the project mirror will be destroyed when the resource is destroyed.\n   For older versions, the mirror will be disabled and the resource will be destroyed.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/remote_mirrors.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = new gitlab.ProjectMirror(\"foo\", {\n    project: \"1\",\n    url: \"https://username:password@github.com/org/repository.git\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.ProjectMirror(\"foo\",\n    project=\"1\",\n    url=\"https://username:password@github.com/org/repository.git\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = new GitLab.ProjectMirror(\"foo\", new()\n    {\n        Project = \"1\",\n        Url = \"https://username:password@github.com/org/repository.git\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewProjectMirror(ctx, \"foo\", \u0026gitlab.ProjectMirrorArgs{\n\t\t\tProject: pulumi.String(\"1\"),\n\t\t\tUrl:     pulumi.String(\"https://username:password@github.com/org/repository.git\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ProjectMirror;\nimport com.pulumi.gitlab.ProjectMirrorArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var foo = new ProjectMirror(\"foo\", ProjectMirrorArgs.builder()\n            .project(\"1\")\n            .url(\"https://username:password@github.com/org/repository.git\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  foo:\n    type: gitlab:ProjectMirror\n    properties:\n      project: '1'\n      url: https://username:password@github.com/org/repository.git\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_project_mirror`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_project_mirror.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab project mirror can be imported using an id made up of `project_id:mirror_id`, e.g.\n\n```sh\n$ pulumi import gitlab:index/projectMirror:ProjectMirror foo \"12345:1337\"\n```\n\n",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Determines if the mirror is enabled.\n"
                },
                "keepDivergentRefs": {
                    "type": "boolean",
                    "description": "Determines if divergent refs are skipped.\n"
                },
                "mirrorId": {
                    "type": "integer",
                    "description": "Mirror ID.\n"
                },
                "onlyProtectedBranches": {
                    "type": "boolean",
                    "description": "Determines if only protected branches are mirrored.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The id of the project.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL of the remote repository to be mirrored.\n",
                    "secret": true
                }
            },
            "required": [
                "mirrorId",
                "project",
                "url"
            ],
            "inputProperties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Determines if the mirror is enabled.\n"
                },
                "keepDivergentRefs": {
                    "type": "boolean",
                    "description": "Determines if divergent refs are skipped.\n"
                },
                "onlyProtectedBranches": {
                    "type": "boolean",
                    "description": "Determines if only protected branches are mirrored.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The id of the project.\n",
                    "willReplaceOnChanges": true
                },
                "url": {
                    "type": "string",
                    "description": "The URL of the remote repository to be mirrored.\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "project",
                "url"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectMirror resources.\n",
                "properties": {
                    "enabled": {
                        "type": "boolean",
                        "description": "Determines if the mirror is enabled.\n"
                    },
                    "keepDivergentRefs": {
                        "type": "boolean",
                        "description": "Determines if divergent refs are skipped.\n"
                    },
                    "mirrorId": {
                        "type": "integer",
                        "description": "Mirror ID.\n"
                    },
                    "onlyProtectedBranches": {
                        "type": "boolean",
                        "description": "Determines if only protected branches are mirrored.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The id of the project.\n",
                        "willReplaceOnChanges": true
                    },
                    "url": {
                        "type": "string",
                        "description": "The URL of the remote repository to be mirrored.\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectProtectedEnvironment:ProjectProtectedEnvironment": {
            "description": "The `gitlab.ProjectProtectedEnvironment` resource allows to manage the lifecycle of a protected environment in a project.\n\n\u003e In order to use a user or group in the `deploy_access_levels` configuration,\n   you need to make sure that users have access to the project and groups must have this project shared.\n   You may use the `gitlab.ProjectMembership` and `gitlab_project_shared_group` resources to achieve this.\n   Unfortunately, the GitLab API does not complain about users and groups without access to the project and just ignores those.\n   In case this happens you will get perpetual state diffs.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/protected_environments.html)\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_project_protected_environment`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_project_protected_environment.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab protected environments can be imported using an id made up of `projectId:environmentName`, e.g.\n\n```sh\n$ pulumi import gitlab:index/projectProtectedEnvironment:ProjectProtectedEnvironment bar 123:production\n```\n\n",
            "properties": {
                "approvalRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/ProjectProtectedEnvironmentApprovalRule:ProjectProtectedEnvironmentApprovalRule"
                    },
                    "description": "Array of approval rules to deploy, with each described by a hash. Elements in the `approval_rules` should be one of `user_id`, `group_id` or `access_level`.\n"
                },
                "deployAccessLevels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/ProjectProtectedEnvironmentDeployAccessLevel:ProjectProtectedEnvironmentDeployAccessLevel"
                    },
                    "description": "Array of access levels allowed to deploy, with each described by a hash.  Elements in the `deploy_access_levels` should be one of `user_id`, `group_id` or `access_level`.\n"
                },
                "environment": {
                    "type": "string",
                    "description": "The name of the environment.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project which the protected environment is created against.\n"
                }
            },
            "required": [
                "approvalRules",
                "environment",
                "project"
            ],
            "inputProperties": {
                "approvalRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/ProjectProtectedEnvironmentApprovalRule:ProjectProtectedEnvironmentApprovalRule"
                    },
                    "description": "Array of approval rules to deploy, with each described by a hash. Elements in the `approval_rules` should be one of `user_id`, `group_id` or `access_level`.\n"
                },
                "deployAccessLevels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/ProjectProtectedEnvironmentDeployAccessLevel:ProjectProtectedEnvironmentDeployAccessLevel"
                    },
                    "description": "Array of access levels allowed to deploy, with each described by a hash.  Elements in the `deploy_access_levels` should be one of `user_id`, `group_id` or `access_level`.\n"
                },
                "environment": {
                    "type": "string",
                    "description": "The name of the environment.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project which the protected environment is created against.\n"
                }
            },
            "requiredInputs": [
                "environment",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectProtectedEnvironment resources.\n",
                "properties": {
                    "approvalRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/ProjectProtectedEnvironmentApprovalRule:ProjectProtectedEnvironmentApprovalRule"
                        },
                        "description": "Array of approval rules to deploy, with each described by a hash. Elements in the `approval_rules` should be one of `user_id`, `group_id` or `access_level`.\n"
                    },
                    "deployAccessLevels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/ProjectProtectedEnvironmentDeployAccessLevel:ProjectProtectedEnvironmentDeployAccessLevel"
                        },
                        "description": "Array of access levels allowed to deploy, with each described by a hash.  Elements in the `deploy_access_levels` should be one of `user_id`, `group_id` or `access_level`.\n"
                    },
                    "environment": {
                        "type": "string",
                        "description": "The name of the environment.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or full path of the project which the protected environment is created against.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectPushRules:ProjectPushRules": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst sample = new gitlab.ProjectPushRules(\"sample\", {\n    project: \"42\",\n    authorEmailRegex: \"@gitlab.com$\",\n    branchNameRegex: \"(feat|fix)\\\\/*\",\n    commitCommitterCheck: true,\n    commitCommitterNameCheck: true,\n    commitMessageNegativeRegex: \"ssh\\\\:\\\\/\\\\/\",\n    commitMessageRegex: \"(feat|fix):.*\",\n    denyDeleteTag: false,\n    fileNameRegex: \"(jar|exe)$\",\n    maxFileSize: 4,\n    memberCheck: true,\n    preventSecrets: true,\n    rejectUnsignedCommits: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nsample = gitlab.ProjectPushRules(\"sample\",\n    project=\"42\",\n    author_email_regex=\"@gitlab.com$\",\n    branch_name_regex=\"(feat|fix)\\\\/*\",\n    commit_committer_check=True,\n    commit_committer_name_check=True,\n    commit_message_negative_regex=\"ssh\\\\:\\\\/\\\\/\",\n    commit_message_regex=\"(feat|fix):.*\",\n    deny_delete_tag=False,\n    file_name_regex=\"(jar|exe)$\",\n    max_file_size=4,\n    member_check=True,\n    prevent_secrets=True,\n    reject_unsigned_commits=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var sample = new GitLab.ProjectPushRules(\"sample\", new()\n    {\n        Project = \"42\",\n        AuthorEmailRegex = \"@gitlab.com$\",\n        BranchNameRegex = \"(feat|fix)\\\\/*\",\n        CommitCommitterCheck = true,\n        CommitCommitterNameCheck = true,\n        CommitMessageNegativeRegex = \"ssh\\\\:\\\\/\\\\/\",\n        CommitMessageRegex = \"(feat|fix):.*\",\n        DenyDeleteTag = false,\n        FileNameRegex = \"(jar|exe)$\",\n        MaxFileSize = 4,\n        MemberCheck = true,\n        PreventSecrets = true,\n        RejectUnsignedCommits = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewProjectPushRules(ctx, \"sample\", \u0026gitlab.ProjectPushRulesArgs{\n\t\t\tProject:                    pulumi.String(\"42\"),\n\t\t\tAuthorEmailRegex:           pulumi.String(\"@gitlab.com$\"),\n\t\t\tBranchNameRegex:            pulumi.String(\"(feat|fix)\\\\/*\"),\n\t\t\tCommitCommitterCheck:       pulumi.Bool(true),\n\t\t\tCommitCommitterNameCheck:   pulumi.Bool(true),\n\t\t\tCommitMessageNegativeRegex: pulumi.String(\"ssh\\\\:\\\\/\\\\/\"),\n\t\t\tCommitMessageRegex:         pulumi.String(\"(feat|fix):.*\"),\n\t\t\tDenyDeleteTag:              pulumi.Bool(false),\n\t\t\tFileNameRegex:              pulumi.String(\"(jar|exe)$\"),\n\t\t\tMaxFileSize:                pulumi.Int(4),\n\t\t\tMemberCheck:                pulumi.Bool(true),\n\t\t\tPreventSecrets:             pulumi.Bool(true),\n\t\t\tRejectUnsignedCommits:      pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ProjectPushRules;\nimport com.pulumi.gitlab.ProjectPushRulesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var sample = new ProjectPushRules(\"sample\", ProjectPushRulesArgs.builder()\n            .project(42)\n            .authorEmailRegex(\"@gitlab.com$\")\n            .branchNameRegex(\"(feat|fix)\\\\/*\")\n            .commitCommitterCheck(true)\n            .commitCommitterNameCheck(true)\n            .commitMessageNegativeRegex(\"ssh\\\\:\\\\/\\\\/\")\n            .commitMessageRegex(\"(feat|fix):.*\")\n            .denyDeleteTag(false)\n            .fileNameRegex(\"(jar|exe)$\")\n            .maxFileSize(4)\n            .memberCheck(true)\n            .preventSecrets(true)\n            .rejectUnsignedCommits(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  sample:\n    type: gitlab:ProjectPushRules\n    properties:\n      project: 42\n      authorEmailRegex: '@gitlab.com$'\n      branchNameRegex: (feat|fix)\\/*\n      commitCommitterCheck: true\n      commitCommitterNameCheck: true\n      commitMessageNegativeRegex: ssh\\:\\/\\/\n      commitMessageRegex: (feat|fix):.*\n      denyDeleteTag: false\n      fileNameRegex: (jar|exe)$\n      maxFileSize: 4\n      memberCheck: true\n      preventSecrets: true\n      rejectUnsignedCommits: false\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_project_push_rules`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_project_push_rules.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitlab project push rules can be imported with a key composed of `\u003cproject_id\u003e`, e.g.\n\n```sh\n$ pulumi import gitlab:index/projectPushRules:ProjectPushRules sample \"42\"\n```\n\n",
            "properties": {
                "authorEmailRegex": {
                    "type": "string",
                    "description": "All commit author emails must match this regex, e.g. `@my-company.com$`.\n"
                },
                "branchNameRegex": {
                    "type": "string",
                    "description": "All branch names must match this regex, e.g. `(feature|hotfix)\\/*`.\n"
                },
                "commitCommitterCheck": {
                    "type": "boolean",
                    "description": "Users can only push commits to this repository that were committed with one of their own verified emails.\n"
                },
                "commitCommitterNameCheck": {
                    "type": "boolean",
                    "description": "Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.\n"
                },
                "commitMessageNegativeRegex": {
                    "type": "string",
                    "description": "No commit message is allowed to match this regex, e.g. `ssh\\:\\/\\/`.\n"
                },
                "commitMessageRegex": {
                    "type": "string",
                    "description": "All commit messages must match this regex, e.g. `Fixed \\d+\\..*`.\n"
                },
                "denyDeleteTag": {
                    "type": "boolean",
                    "description": "Deny deleting a tag.\n"
                },
                "fileNameRegex": {
                    "type": "string",
                    "description": "All committed filenames must not match this regex, e.g. `(jar|exe)$`.\n"
                },
                "maxFileSize": {
                    "type": "integer",
                    "description": "Maximum file size (MB).\n"
                },
                "memberCheck": {
                    "type": "boolean",
                    "description": "Restrict commits by author (email) to existing GitLab users.\n"
                },
                "preventSecrets": {
                    "type": "boolean",
                    "description": "GitLab will reject any files that are likely to contain secrets.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the project.\n"
                },
                "rejectNonDcoCommits": {
                    "type": "boolean",
                    "description": "Reject commit when it’s not DCO certified.\n"
                },
                "rejectUnsignedCommits": {
                    "type": "boolean",
                    "description": "Reject commit when it’s not signed.\n"
                }
            },
            "required": [
                "authorEmailRegex",
                "branchNameRegex",
                "commitCommitterCheck",
                "commitCommitterNameCheck",
                "commitMessageNegativeRegex",
                "commitMessageRegex",
                "denyDeleteTag",
                "fileNameRegex",
                "maxFileSize",
                "memberCheck",
                "preventSecrets",
                "project",
                "rejectNonDcoCommits",
                "rejectUnsignedCommits"
            ],
            "inputProperties": {
                "authorEmailRegex": {
                    "type": "string",
                    "description": "All commit author emails must match this regex, e.g. `@my-company.com$`.\n"
                },
                "branchNameRegex": {
                    "type": "string",
                    "description": "All branch names must match this regex, e.g. `(feature|hotfix)\\/*`.\n"
                },
                "commitCommitterCheck": {
                    "type": "boolean",
                    "description": "Users can only push commits to this repository that were committed with one of their own verified emails.\n"
                },
                "commitCommitterNameCheck": {
                    "type": "boolean",
                    "description": "Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.\n"
                },
                "commitMessageNegativeRegex": {
                    "type": "string",
                    "description": "No commit message is allowed to match this regex, e.g. `ssh\\:\\/\\/`.\n"
                },
                "commitMessageRegex": {
                    "type": "string",
                    "description": "All commit messages must match this regex, e.g. `Fixed \\d+\\..*`.\n"
                },
                "denyDeleteTag": {
                    "type": "boolean",
                    "description": "Deny deleting a tag.\n"
                },
                "fileNameRegex": {
                    "type": "string",
                    "description": "All committed filenames must not match this regex, e.g. `(jar|exe)$`.\n"
                },
                "maxFileSize": {
                    "type": "integer",
                    "description": "Maximum file size (MB).\n"
                },
                "memberCheck": {
                    "type": "boolean",
                    "description": "Restrict commits by author (email) to existing GitLab users.\n"
                },
                "preventSecrets": {
                    "type": "boolean",
                    "description": "GitLab will reject any files that are likely to contain secrets.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the project.\n"
                },
                "rejectNonDcoCommits": {
                    "type": "boolean",
                    "description": "Reject commit when it’s not DCO certified.\n"
                },
                "rejectUnsignedCommits": {
                    "type": "boolean",
                    "description": "Reject commit when it’s not signed.\n"
                }
            },
            "requiredInputs": [
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectPushRules resources.\n",
                "properties": {
                    "authorEmailRegex": {
                        "type": "string",
                        "description": "All commit author emails must match this regex, e.g. `@my-company.com$`.\n"
                    },
                    "branchNameRegex": {
                        "type": "string",
                        "description": "All branch names must match this regex, e.g. `(feature|hotfix)\\/*`.\n"
                    },
                    "commitCommitterCheck": {
                        "type": "boolean",
                        "description": "Users can only push commits to this repository that were committed with one of their own verified emails.\n"
                    },
                    "commitCommitterNameCheck": {
                        "type": "boolean",
                        "description": "Users can only push commits to this repository if the commit author name is consistent with their GitLab account name.\n"
                    },
                    "commitMessageNegativeRegex": {
                        "type": "string",
                        "description": "No commit message is allowed to match this regex, e.g. `ssh\\:\\/\\/`.\n"
                    },
                    "commitMessageRegex": {
                        "type": "string",
                        "description": "All commit messages must match this regex, e.g. `Fixed \\d+\\..*`.\n"
                    },
                    "denyDeleteTag": {
                        "type": "boolean",
                        "description": "Deny deleting a tag.\n"
                    },
                    "fileNameRegex": {
                        "type": "string",
                        "description": "All committed filenames must not match this regex, e.g. `(jar|exe)$`.\n"
                    },
                    "maxFileSize": {
                        "type": "integer",
                        "description": "Maximum file size (MB).\n"
                    },
                    "memberCheck": {
                        "type": "boolean",
                        "description": "Restrict commits by author (email) to existing GitLab users.\n"
                    },
                    "preventSecrets": {
                        "type": "boolean",
                        "description": "GitLab will reject any files that are likely to contain secrets.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the project.\n"
                    },
                    "rejectNonDcoCommits": {
                        "type": "boolean",
                        "description": "Reject commit when it’s not DCO certified.\n"
                    },
                    "rejectUnsignedCommits": {
                        "type": "boolean",
                        "description": "Reject commit when it’s not signed.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectRunnerEnablement:ProjectRunnerEnablement": {
            "description": "The `gitlab.ProjectRunnerEnablement` resource allows to enable a runner in a project.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/runners.html#enable-a-runner-in-project)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = new gitlab.ProjectRunnerEnablement(\"foo\", {\n    project: \"5\",\n    runnerId: 7,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.ProjectRunnerEnablement(\"foo\",\n    project=\"5\",\n    runner_id=7)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = new GitLab.ProjectRunnerEnablement(\"foo\", new()\n    {\n        Project = \"5\",\n        RunnerId = 7,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewProjectRunnerEnablement(ctx, \"foo\", \u0026gitlab.ProjectRunnerEnablementArgs{\n\t\t\tProject:  pulumi.String(\"5\"),\n\t\t\tRunnerId: pulumi.Int(7),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ProjectRunnerEnablement;\nimport com.pulumi.gitlab.ProjectRunnerEnablementArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var foo = new ProjectRunnerEnablement(\"foo\", ProjectRunnerEnablementArgs.builder()\n            .project(5)\n            .runnerId(7)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  foo:\n    type: gitlab:ProjectRunnerEnablement\n    properties:\n      project: 5\n      runnerId: 7\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_project_runner_enablement`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_project_runner_enablement.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab project runners can be imported using an id made up of `project:runner_id`, e.g.\n\n```sh\n$ pulumi import gitlab:index/projectRunnerEnablement:ProjectRunnerEnablement foo 5:7\n```\n\n",
            "properties": {
                "project": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n"
                },
                "runnerId": {
                    "type": "integer",
                    "description": "The ID of a runner to enable for the project.\n"
                }
            },
            "required": [
                "project",
                "runnerId"
            ],
            "inputProperties": {
                "project": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n",
                    "willReplaceOnChanges": true
                },
                "runnerId": {
                    "type": "integer",
                    "description": "The ID of a runner to enable for the project.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "project",
                "runnerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectRunnerEnablement resources.\n",
                "properties": {
                    "project": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n",
                        "willReplaceOnChanges": true
                    },
                    "runnerId": {
                        "type": "integer",
                        "description": "The ID of a runner to enable for the project.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectSecurityPolicyAttachment:ProjectSecurityPolicyAttachment": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\n// This resource can be used to attach a security policy to a pre-existing project\nconst foo = new gitlab.ProjectSecurityPolicyAttachment(\"foo\", {\n    project: \"1234\",\n    policyProject: \"4567\",\n});\n// Or Terraform can create a new project, add a policy to that project,\n// then attach that policy project to other projects.\nconst my_policy_project = new gitlab.Project(\"my-policy-project\", {name: \"security-policy-project\"});\nconst policy_yml = new gitlab.RepositoryFile(\"policy-yml\", {\n    project: my_policy_project.id,\n    filePath: \".gitlab/security-policies/my-policy.yml\",\n    branch: \"master\",\n    encoding: \"text\",\n    content: `---\napproval_policy:\n- name: test\ndescription: test\nenabled: true\nrules:\n- type: any_merge_request\n    branch_type: protected\n    commits: any\napproval_settings:\n    block_branch_modification: true\n    prevent_pushing_and_force_pushing: true\n    prevent_approval_by_author: true\n    prevent_approval_by_commit_author: true\n    remove_approvals_with_new_commit: true\n    require_password_to_approve: false\nfallback_behavior:\n    fail: closed\nactions:\n- type: send_bot_message\n    enabled: true\n`,\n});\n// Multiple policies can be attached to a single project by repeating this resource or using a `for_each`\nconst my_policy = new gitlab.ProjectSecurityPolicyAttachment(\"my-policy\", {\n    project: \"1234\",\n    policyProject: my_policy_project.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\n# This resource can be used to attach a security policy to a pre-existing project\nfoo = gitlab.ProjectSecurityPolicyAttachment(\"foo\",\n    project=\"1234\",\n    policy_project=\"4567\")\n# Or Terraform can create a new project, add a policy to that project,\n# then attach that policy project to other projects.\nmy_policy_project = gitlab.Project(\"my-policy-project\", name=\"security-policy-project\")\npolicy_yml = gitlab.RepositoryFile(\"policy-yml\",\n    project=my_policy_project.id,\n    file_path=\".gitlab/security-policies/my-policy.yml\",\n    branch=\"master\",\n    encoding=\"text\",\n    content=\"\"\"---\napproval_policy:\n- name: test\ndescription: test\nenabled: true\nrules:\n- type: any_merge_request\n    branch_type: protected\n    commits: any\napproval_settings:\n    block_branch_modification: true\n    prevent_pushing_and_force_pushing: true\n    prevent_approval_by_author: true\n    prevent_approval_by_commit_author: true\n    remove_approvals_with_new_commit: true\n    require_password_to_approve: false\nfallback_behavior:\n    fail: closed\nactions:\n- type: send_bot_message\n    enabled: true\n\"\"\")\n# Multiple policies can be attached to a single project by repeating this resource or using a `for_each`\nmy_policy = gitlab.ProjectSecurityPolicyAttachment(\"my-policy\",\n    project=\"1234\",\n    policy_project=my_policy_project.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // This resource can be used to attach a security policy to a pre-existing project\n    var foo = new GitLab.ProjectSecurityPolicyAttachment(\"foo\", new()\n    {\n        Project = \"1234\",\n        PolicyProject = \"4567\",\n    });\n\n    // Or Terraform can create a new project, add a policy to that project,\n    // then attach that policy project to other projects.\n    var my_policy_project = new GitLab.Project(\"my-policy-project\", new()\n    {\n        Name = \"security-policy-project\",\n    });\n\n    var policy_yml = new GitLab.RepositoryFile(\"policy-yml\", new()\n    {\n        Project = my_policy_project.Id,\n        FilePath = \".gitlab/security-policies/my-policy.yml\",\n        Branch = \"master\",\n        Encoding = \"text\",\n        Content = @\"---\napproval_policy:\n- name: test\ndescription: test\nenabled: true\nrules:\n- type: any_merge_request\n    branch_type: protected\n    commits: any\napproval_settings:\n    block_branch_modification: true\n    prevent_pushing_and_force_pushing: true\n    prevent_approval_by_author: true\n    prevent_approval_by_commit_author: true\n    remove_approvals_with_new_commit: true\n    require_password_to_approve: false\nfallback_behavior:\n    fail: closed\nactions:\n- type: send_bot_message\n    enabled: true\n\",\n    });\n\n    // Multiple policies can be attached to a single project by repeating this resource or using a `for_each`\n    var my_policy = new GitLab.ProjectSecurityPolicyAttachment(\"my-policy\", new()\n    {\n        Project = \"1234\",\n        PolicyProject = my_policy_project.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// This resource can be used to attach a security policy to a pre-existing project\n\t\t_, err := gitlab.NewProjectSecurityPolicyAttachment(ctx, \"foo\", \u0026gitlab.ProjectSecurityPolicyAttachmentArgs{\n\t\t\tProject:       pulumi.String(\"1234\"),\n\t\t\tPolicyProject: pulumi.String(\"4567\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Or Terraform can create a new project, add a policy to that project,\n\t\t// then attach that policy project to other projects.\n\t\t_, err = gitlab.NewProject(ctx, \"my-policy-project\", \u0026gitlab.ProjectArgs{\n\t\t\tName: pulumi.String(\"security-policy-project\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewRepositoryFile(ctx, \"policy-yml\", \u0026gitlab.RepositoryFileArgs{\n\t\t\tProject:  my_policy_project.ID(),\n\t\t\tFilePath: pulumi.String(\".gitlab/security-policies/my-policy.yml\"),\n\t\t\tBranch:   pulumi.String(\"master\"),\n\t\t\tEncoding: pulumi.String(\"text\"),\n\t\t\tContent: pulumi.String(`---\napproval_policy:\n- name: test\ndescription: test\nenabled: true\nrules:\n- type: any_merge_request\n    branch_type: protected\n    commits: any\napproval_settings:\n    block_branch_modification: true\n    prevent_pushing_and_force_pushing: true\n    prevent_approval_by_author: true\n    prevent_approval_by_commit_author: true\n    remove_approvals_with_new_commit: true\n    require_password_to_approve: false\nfallback_behavior:\n    fail: closed\nactions:\n- type: send_bot_message\n    enabled: true\n`),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Multiple policies can be attached to a single project by repeating this resource or using a `for_each`\n\t\t_, err = gitlab.NewProjectSecurityPolicyAttachment(ctx, \"my-policy\", \u0026gitlab.ProjectSecurityPolicyAttachmentArgs{\n\t\t\tProject:       pulumi.String(\"1234\"),\n\t\t\tPolicyProject: my_policy_project.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ProjectSecurityPolicyAttachment;\nimport com.pulumi.gitlab.ProjectSecurityPolicyAttachmentArgs;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.RepositoryFile;\nimport com.pulumi.gitlab.RepositoryFileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // This resource can be used to attach a security policy to a pre-existing project\n        var foo = new ProjectSecurityPolicyAttachment(\"foo\", ProjectSecurityPolicyAttachmentArgs.builder()\n            .project(1234)\n            .policyProject(4567)\n            .build());\n\n        // Or Terraform can create a new project, add a policy to that project,\n        // then attach that policy project to other projects.\n        var my_policy_project = new Project(\"my-policy-project\", ProjectArgs.builder()\n            .name(\"security-policy-project\")\n            .build());\n\n        var policy_yml = new RepositoryFile(\"policy-yml\", RepositoryFileArgs.builder()\n            .project(my_policy_project.id())\n            .filePath(\".gitlab/security-policies/my-policy.yml\")\n            .branch(\"master\")\n            .encoding(\"text\")\n            .content(\"\"\"\n---\napproval_policy:\n- name: test\ndescription: test\nenabled: true\nrules:\n- type: any_merge_request\n    branch_type: protected\n    commits: any\napproval_settings:\n    block_branch_modification: true\n    prevent_pushing_and_force_pushing: true\n    prevent_approval_by_author: true\n    prevent_approval_by_commit_author: true\n    remove_approvals_with_new_commit: true\n    require_password_to_approve: false\nfallback_behavior:\n    fail: closed\nactions:\n- type: send_bot_message\n    enabled: true\n            \"\"\")\n            .build());\n\n        // Multiple policies can be attached to a single project by repeating this resource or using a `for_each`\n        var my_policy = new ProjectSecurityPolicyAttachment(\"my-policy\", ProjectSecurityPolicyAttachmentArgs.builder()\n            .project(1234)\n            .policyProject(my_policy_project.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # This resource can be used to attach a security policy to a pre-existing project\n  foo:\n    type: gitlab:ProjectSecurityPolicyAttachment\n    properties:\n      project: 1234\n      policyProject: 4567\n  # Or Terraform can create a new project, add a policy to that project,\n  # then attach that policy project to other projects.\n  my-policy-project:\n    type: gitlab:Project\n    properties:\n      name: security-policy-project\n  policy-yml:\n    type: gitlab:RepositoryFile\n    properties:\n      project: ${[\"my-policy-project\"].id}\n      filePath: .gitlab/security-policies/my-policy.yml\n      branch: master\n      encoding: text\n      content: |\n        ---\n        approval_policy:\n        - name: test\n        description: test\n        enabled: true\n        rules:\n        - type: any_merge_request\n            branch_type: protected\n            commits: any\n        approval_settings:\n            block_branch_modification: true\n            prevent_pushing_and_force_pushing: true\n            prevent_approval_by_author: true\n            prevent_approval_by_commit_author: true\n            remove_approvals_with_new_commit: true\n            require_password_to_approve: false\n        fallback_behavior:\n            fail: closed\n        actions:\n        - type: send_bot_message\n            enabled: true\n  # Multiple policies can be attached to a single project by repeating this resource or using a `for_each`\n  my-policy:\n    type: gitlab:ProjectSecurityPolicyAttachment\n    properties:\n      project: 1234\n      policyProject: ${[\"my-policy-project\"].id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_project_security_policy_attachment`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_project_security_policy_attachment.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab project security policy attachments can be imported using an id made up of `project:policy_project_id` where the policy project ID is the project ID of the policy project, e.g.\n\n```sh\n$ pulumi import gitlab:index/projectSecurityPolicyAttachment:ProjectSecurityPolicyAttachment foo 1:2\n```\n\n",
            "properties": {
                "policyProject": {
                    "type": "string",
                    "description": "The ID or Full Path of the security policy project.\n"
                },
                "policyProjectGraphqlId": {
                    "type": "string",
                    "description": "The GraphQL ID of the security policy project.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or Full Path of the project which will have the security policy project assigned to it.\n"
                },
                "projectGraphqlId": {
                    "type": "string",
                    "description": "The GraphQL ID of the project to which the security policty project will be attached.\n"
                }
            },
            "required": [
                "policyProject",
                "policyProjectGraphqlId",
                "project",
                "projectGraphqlId"
            ],
            "inputProperties": {
                "policyProject": {
                    "type": "string",
                    "description": "The ID or Full Path of the security policy project.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or Full Path of the project which will have the security policy project assigned to it.\n"
                }
            },
            "requiredInputs": [
                "policyProject",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectSecurityPolicyAttachment resources.\n",
                "properties": {
                    "policyProject": {
                        "type": "string",
                        "description": "The ID or Full Path of the security policy project.\n"
                    },
                    "policyProjectGraphqlId": {
                        "type": "string",
                        "description": "The GraphQL ID of the security policy project.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or Full Path of the project which will have the security policy project assigned to it.\n"
                    },
                    "projectGraphqlId": {
                        "type": "string",
                        "description": "The GraphQL ID of the project to which the security policty project will be attached.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectShareGroup:ProjectShareGroup": {
            "description": "The `gitlab.ProjectShareGroup` resource allows to manage the lifecycle of project shared with a group.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/projects.html#share-project-with-group)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst test = new gitlab.ProjectShareGroup(\"test\", {\n    project: \"12345\",\n    groupId: 1337,\n    groupAccess: \"guest\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\ntest = gitlab.ProjectShareGroup(\"test\",\n    project=\"12345\",\n    group_id=1337,\n    group_access=\"guest\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new GitLab.ProjectShareGroup(\"test\", new()\n    {\n        Project = \"12345\",\n        GroupId = 1337,\n        GroupAccess = \"guest\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewProjectShareGroup(ctx, \"test\", \u0026gitlab.ProjectShareGroupArgs{\n\t\t\tProject:     pulumi.String(\"12345\"),\n\t\t\tGroupId:     pulumi.Int(1337),\n\t\t\tGroupAccess: pulumi.String(\"guest\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ProjectShareGroup;\nimport com.pulumi.gitlab.ProjectShareGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new ProjectShareGroup(\"test\", ProjectShareGroupArgs.builder()\n            .project(\"12345\")\n            .groupId(1337)\n            .groupAccess(\"guest\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: gitlab:ProjectShareGroup\n    properties:\n      project: '12345'\n      groupId: 1337\n      groupAccess: guest\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_project_share_group`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_project_share_group.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab project group shares can be imported using an id made up of `projectid:groupid`, e.g.\n\n```sh\n$ pulumi import gitlab:index/projectShareGroup:ProjectShareGroup test 12345:1337\n```\n\n",
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "The access level to grant the group for the project. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`\n",
                    "deprecationMessage": "Use `group_access` instead of the `access_level` attribute."
                },
                "groupAccess": {
                    "type": "string",
                    "description": "The access level to grant the group for the project. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The id of the group.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the project.\n"
                }
            },
            "required": [
                "groupId",
                "project"
            ],
            "inputProperties": {
                "accessLevel": {
                    "type": "string",
                    "description": "The access level to grant the group for the project. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`\n",
                    "deprecationMessage": "Use `group_access` instead of the `access_level` attribute.",
                    "willReplaceOnChanges": true
                },
                "groupAccess": {
                    "type": "string",
                    "description": "The access level to grant the group for the project. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`\n",
                    "willReplaceOnChanges": true
                },
                "groupId": {
                    "type": "integer",
                    "description": "The id of the group.\n",
                    "willReplaceOnChanges": true
                },
                "project": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the project.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "groupId",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectShareGroup resources.\n",
                "properties": {
                    "accessLevel": {
                        "type": "string",
                        "description": "The access level to grant the group for the project. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`\n",
                        "deprecationMessage": "Use `group_access` instead of the `access_level` attribute.",
                        "willReplaceOnChanges": true
                    },
                    "groupAccess": {
                        "type": "string",
                        "description": "The access level to grant the group for the project. Valid values are: `no one`, `minimal`, `guest`, `reporter`, `developer`, `maintainer`, `owner`\n",
                        "willReplaceOnChanges": true
                    },
                    "groupId": {
                        "type": "integer",
                        "description": "The id of the group.\n",
                        "willReplaceOnChanges": true
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the project.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectTag:ProjectTag": {
            "description": "The `gitlab.ProjectTag` resource allows to manage the lifecycle of a tag in a project.\n\n**Upstream API**: [GitLab API docs](https://docs.gitlab.com/ee/api/tags.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\n// Create a project for the tag to use\nconst example = new gitlab.Project(\"example\", {\n    name: \"example\",\n    description: \"An example project\",\n    namespaceId: exampleGitlabGroup.id,\n});\nconst exampleProjectTag = new gitlab.ProjectTag(\"example\", {\n    name: \"example\",\n    ref: \"main\",\n    project: example.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\n# Create a project for the tag to use\nexample = gitlab.Project(\"example\",\n    name=\"example\",\n    description=\"An example project\",\n    namespace_id=example_gitlab_group[\"id\"])\nexample_project_tag = gitlab.ProjectTag(\"example\",\n    name=\"example\",\n    ref=\"main\",\n    project=example.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create a project for the tag to use\n    var example = new GitLab.Project(\"example\", new()\n    {\n        Name = \"example\",\n        Description = \"An example project\",\n        NamespaceId = exampleGitlabGroup.Id,\n    });\n\n    var exampleProjectTag = new GitLab.ProjectTag(\"example\", new()\n    {\n        Name = \"example\",\n        Ref = \"main\",\n        Project = example.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Create a project for the tag to use\n\t\texample, err := gitlab.NewProject(ctx, \"example\", \u0026gitlab.ProjectArgs{\n\t\t\tName:        pulumi.String(\"example\"),\n\t\t\tDescription: pulumi.String(\"An example project\"),\n\t\t\tNamespaceId: pulumi.Any(exampleGitlabGroup.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewProjectTag(ctx, \"example\", \u0026gitlab.ProjectTagArgs{\n\t\t\tName:    pulumi.String(\"example\"),\n\t\t\tRef:     pulumi.String(\"main\"),\n\t\t\tProject: example.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ProjectTag;\nimport com.pulumi.gitlab.ProjectTagArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Create a project for the tag to use\n        var example = new Project(\"example\", ProjectArgs.builder()\n            .name(\"example\")\n            .description(\"An example project\")\n            .namespaceId(exampleGitlabGroup.id())\n            .build());\n\n        var exampleProjectTag = new ProjectTag(\"exampleProjectTag\", ProjectTagArgs.builder()\n            .name(\"example\")\n            .ref(\"main\")\n            .project(example.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a project for the tag to use\n  example:\n    type: gitlab:Project\n    properties:\n      name: example\n      description: An example project\n      namespaceId: ${exampleGitlabGroup.id}\n  exampleProjectTag:\n    type: gitlab:ProjectTag\n    name: example\n    properties:\n      name: example\n      ref: main\n      project: ${example.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_project_tag`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_project_tag.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitlab project tags can be imported with a key composed of `\u003cproject_id\u003e:\u003ctag_name\u003e`, e.g.\n\n```sh\n$ pulumi import gitlab:index/projectTag:ProjectTag example \"12345:develop\"\n```\n\nNOTE: the `ref` attribute won't be available for imported `gitlab_project_tag` resources.\n\n",
            "properties": {
                "commits": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/ProjectTagCommit:ProjectTagCommit"
                    },
                    "description": "The commit associated with the tag.\n"
                },
                "message": {
                    "type": "string",
                    "description": "The message of the annotated tag.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of a tag.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n"
                },
                "protected": {
                    "type": "boolean",
                    "description": "Bool, true if tag has tag protection.\n"
                },
                "ref": {
                    "type": "string",
                    "description": "Create tag using commit SHA, another tag name, or branch name. This attribute is not available for imported resources.\n"
                },
                "releases": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/ProjectTagRelease:ProjectTagRelease"
                    },
                    "description": "The release associated with the tag.\n"
                },
                "target": {
                    "type": "string",
                    "description": "The unique id assigned to the commit by Gitlab.\n"
                }
            },
            "required": [
                "commits",
                "name",
                "project",
                "protected",
                "ref",
                "releases",
                "target"
            ],
            "inputProperties": {
                "message": {
                    "type": "string",
                    "description": "The message of the annotated tag.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of a tag.\n",
                    "willReplaceOnChanges": true
                },
                "project": {
                    "type": "string",
                    "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n",
                    "willReplaceOnChanges": true
                },
                "ref": {
                    "type": "string",
                    "description": "Create tag using commit SHA, another tag name, or branch name. This attribute is not available for imported resources.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "project",
                "ref"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectTag resources.\n",
                "properties": {
                    "commits": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/ProjectTagCommit:ProjectTagCommit"
                        },
                        "description": "The commit associated with the tag.\n"
                    },
                    "message": {
                        "type": "string",
                        "description": "The message of the annotated tag.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of a tag.\n",
                        "willReplaceOnChanges": true
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n",
                        "willReplaceOnChanges": true
                    },
                    "protected": {
                        "type": "boolean",
                        "description": "Bool, true if tag has tag protection.\n"
                    },
                    "ref": {
                        "type": "string",
                        "description": "Create tag using commit SHA, another tag name, or branch name. This attribute is not available for imported resources.\n",
                        "willReplaceOnChanges": true
                    },
                    "releases": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/ProjectTagRelease:ProjectTagRelease"
                        },
                        "description": "The release associated with the tag.\n"
                    },
                    "target": {
                        "type": "string",
                        "description": "The unique id assigned to the commit by Gitlab.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/projectVariable:ProjectVariable": {
            "description": "The `gitlab.ProjectVariable` resource allows to manage the lifecycle of a CI/CD variable for a project.\n\n\u003e **Important:** If your GitLab version is older than 13.4, you may see nondeterministic behavior when updating or deleting gitlab.ProjectVariable resources with non-unique keys, for example if there is another variable with the same key and different environment scope. See [this GitLab issue](https://gitlab.com/gitlab-org/gitlab/-/issues/9912).\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/project_level_variables.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = new gitlab.ProjectVariable(\"example\", {\n    project: \"12345\",\n    key: \"project_variable_key\",\n    value: \"project_variable_value\",\n    \"protected\": false,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.ProjectVariable(\"example\",\n    project=\"12345\",\n    key=\"project_variable_key\",\n    value=\"project_variable_value\",\n    protected=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new GitLab.ProjectVariable(\"example\", new()\n    {\n        Project = \"12345\",\n        Key = \"project_variable_key\",\n        Value = \"project_variable_value\",\n        Protected = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewProjectVariable(ctx, \"example\", \u0026gitlab.ProjectVariableArgs{\n\t\t\tProject:   pulumi.String(\"12345\"),\n\t\t\tKey:       pulumi.String(\"project_variable_key\"),\n\t\t\tValue:     pulumi.String(\"project_variable_value\"),\n\t\t\tProtected: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.ProjectVariable;\nimport com.pulumi.gitlab.ProjectVariableArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new ProjectVariable(\"example\", ProjectVariableArgs.builder()\n            .project(\"12345\")\n            .key(\"project_variable_key\")\n            .value(\"project_variable_value\")\n            .protected_(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: gitlab:ProjectVariable\n    properties:\n      project: '12345'\n      key: project_variable_key\n      value: project_variable_value\n      protected: false\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_project_variable`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_project_variable.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitLab project variables can be imported using an id made up of `project:key:environment_scope`, e.g.\n\n```sh\n$ pulumi import gitlab:index/projectVariable:ProjectVariable example '12345:project_variable_key:*'\n```\n\n",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "The description of the variable.\n"
                },
                "environmentScope": {
                    "type": "string",
                    "description": "The environment scope of the variable. Defaults to all environment (`*`). Note that in Community Editions of Gitlab, values other than `*` will cause inconsistent plans.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The name of the variable.\n"
                },
                "masked": {
                    "type": "boolean",
                    "description": "If set to `true`, the value of the variable will be hidden in job logs. The value must meet the [masking requirements](https://docs.gitlab.com/ee/ci/variables/#masked-variables). Defaults to `false`.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project.\n"
                },
                "protected": {
                    "type": "boolean",
                    "description": "If set to `true`, the variable will be passed only to pipelines running on protected branches and tags. Defaults to `false`.\n"
                },
                "raw": {
                    "type": "boolean",
                    "description": "Whether the variable is treated as a raw string. Default: false. When true, variables in the value are not expanded.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the variable.\n"
                },
                "variableType": {
                    "type": "string",
                    "description": "The type of a variable. Valid values are: `env_var`, `file`. Default is `env_var`.\n"
                }
            },
            "required": [
                "key",
                "project",
                "value"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "The description of the variable.\n"
                },
                "environmentScope": {
                    "type": "string",
                    "description": "The environment scope of the variable. Defaults to all environment (`*`). Note that in Community Editions of Gitlab, values other than `*` will cause inconsistent plans.\n",
                    "willReplaceOnChanges": true
                },
                "key": {
                    "type": "string",
                    "description": "The name of the variable.\n",
                    "willReplaceOnChanges": true
                },
                "masked": {
                    "type": "boolean",
                    "description": "If set to `true`, the value of the variable will be hidden in job logs. The value must meet the [masking requirements](https://docs.gitlab.com/ee/ci/variables/#masked-variables). Defaults to `false`.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or id of the project.\n",
                    "willReplaceOnChanges": true
                },
                "protected": {
                    "type": "boolean",
                    "description": "If set to `true`, the variable will be passed only to pipelines running on protected branches and tags. Defaults to `false`.\n"
                },
                "raw": {
                    "type": "boolean",
                    "description": "Whether the variable is treated as a raw string. Default: false. When true, variables in the value are not expanded.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the variable.\n"
                },
                "variableType": {
                    "type": "string",
                    "description": "The type of a variable. Valid values are: `env_var`, `file`. Default is `env_var`.\n"
                }
            },
            "requiredInputs": [
                "key",
                "project",
                "value"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectVariable resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "The description of the variable.\n"
                    },
                    "environmentScope": {
                        "type": "string",
                        "description": "The environment scope of the variable. Defaults to all environment (`*`). Note that in Community Editions of Gitlab, values other than `*` will cause inconsistent plans.\n",
                        "willReplaceOnChanges": true
                    },
                    "key": {
                        "type": "string",
                        "description": "The name of the variable.\n",
                        "willReplaceOnChanges": true
                    },
                    "masked": {
                        "type": "boolean",
                        "description": "If set to `true`, the value of the variable will be hidden in job logs. The value must meet the [masking requirements](https://docs.gitlab.com/ee/ci/variables/#masked-variables). Defaults to `false`.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project.\n",
                        "willReplaceOnChanges": true
                    },
                    "protected": {
                        "type": "boolean",
                        "description": "If set to `true`, the variable will be passed only to pipelines running on protected branches and tags. Defaults to `false`.\n"
                    },
                    "raw": {
                        "type": "boolean",
                        "description": "Whether the variable is treated as a raw string. Default: false. When true, variables in the value are not expanded.\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "The value of the variable.\n"
                    },
                    "variableType": {
                        "type": "string",
                        "description": "The type of a variable. Valid values are: `env_var`, `file`. Default is `env_var`.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/releaseLink:ReleaseLink": {
            "description": "The `gitlab.ReleaseLink` resource allows to manage the lifecycle of a release link.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/releases/links.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\n// Create a project\nconst example = new gitlab.Project(\"example\", {\n    name: \"example\",\n    description: \"An example project\",\n});\n// Can create release link only to a tag associated with a release\nconst exampleReleaseLink = new gitlab.ReleaseLink(\"example\", {\n    project: example.id,\n    tagName: \"tag_name_associated_with_release\",\n    name: \"test\",\n    url: \"https://test/\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\n# Create a project\nexample = gitlab.Project(\"example\",\n    name=\"example\",\n    description=\"An example project\")\n# Can create release link only to a tag associated with a release\nexample_release_link = gitlab.ReleaseLink(\"example\",\n    project=example.id,\n    tag_name=\"tag_name_associated_with_release\",\n    name=\"test\",\n    url=\"https://test/\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create a project\n    var example = new GitLab.Project(\"example\", new()\n    {\n        Name = \"example\",\n        Description = \"An example project\",\n    });\n\n    // Can create release link only to a tag associated with a release\n    var exampleReleaseLink = new GitLab.ReleaseLink(\"example\", new()\n    {\n        Project = example.Id,\n        TagName = \"tag_name_associated_with_release\",\n        Name = \"test\",\n        Url = \"https://test/\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Create a project\n\t\texample, err := gitlab.NewProject(ctx, \"example\", \u0026gitlab.ProjectArgs{\n\t\t\tName:        pulumi.String(\"example\"),\n\t\t\tDescription: pulumi.String(\"An example project\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Can create release link only to a tag associated with a release\n\t\t_, err = gitlab.NewReleaseLink(ctx, \"example\", \u0026gitlab.ReleaseLinkArgs{\n\t\t\tProject: example.ID(),\n\t\t\tTagName: pulumi.String(\"tag_name_associated_with_release\"),\n\t\t\tName:    pulumi.String(\"test\"),\n\t\t\tUrl:     pulumi.String(\"https://test/\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ReleaseLink;\nimport com.pulumi.gitlab.ReleaseLinkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Create a project\n        var example = new Project(\"example\", ProjectArgs.builder()\n            .name(\"example\")\n            .description(\"An example project\")\n            .build());\n\n        // Can create release link only to a tag associated with a release\n        var exampleReleaseLink = new ReleaseLink(\"exampleReleaseLink\", ReleaseLinkArgs.builder()\n            .project(example.id())\n            .tagName(\"tag_name_associated_with_release\")\n            .name(\"test\")\n            .url(\"https://test/\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a project\n  example:\n    type: gitlab:Project\n    properties:\n      name: example\n      description: An example project\n  # Can create release link only to a tag associated with a release\n  exampleReleaseLink:\n    type: gitlab:ReleaseLink\n    name: example\n    properties:\n      project: ${example.id}\n      tagName: tag_name_associated_with_release\n      name: test\n      url: https://test/\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_release_link`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_release_link.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nGitlab release link can be imported with a key composed of `\u003cproject\u003e:\u003ctag_name\u003e:\u003clink_id\u003e`, e.g.\n\n```sh\n$ pulumi import gitlab:index/releaseLink:ReleaseLink example \"12345:test:2\"\n```\n\n",
            "properties": {
                "directAssetUrl": {
                    "type": "string",
                    "description": "Full path for a [Direct Asset link](https://docs.gitlab.com/ee/user/project/releases/index.html#permanent-links-to-release-assets).\n"
                },
                "external": {
                    "type": "boolean",
                    "description": "External or internal link.\n"
                },
                "filepath": {
                    "type": "string",
                    "description": "Relative path for a [Direct Asset link](https://docs.gitlab.com/ee/user/project/releases/index.html#permanent-links-to-release-assets).\n"
                },
                "linkId": {
                    "type": "integer",
                    "description": "The ID of the link.\n"
                },
                "linkType": {
                    "type": "string",
                    "description": "The type of the link. Valid values are `other`, `runbook`, `image`, `package`. Defaults to other.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the link. Link names must be unique within the release.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or [URL-encoded path of the project](https://docs.gitlab.com/ee/api/index.html#namespaced-path-encoding).\n"
                },
                "tagName": {
                    "type": "string",
                    "description": "The tag associated with the Release.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL of the link. Link URLs must be unique within the release.\n"
                }
            },
            "required": [
                "directAssetUrl",
                "external",
                "linkId",
                "name",
                "project",
                "tagName",
                "url"
            ],
            "inputProperties": {
                "filepath": {
                    "type": "string",
                    "description": "Relative path for a [Direct Asset link](https://docs.gitlab.com/ee/user/project/releases/index.html#permanent-links-to-release-assets).\n"
                },
                "linkType": {
                    "type": "string",
                    "description": "The type of the link. Valid values are `other`, `runbook`, `image`, `package`. Defaults to other.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the link. Link names must be unique within the release.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or [URL-encoded path of the project](https://docs.gitlab.com/ee/api/index.html#namespaced-path-encoding).\n",
                    "willReplaceOnChanges": true
                },
                "tagName": {
                    "type": "string",
                    "description": "The tag associated with the Release.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL of the link. Link URLs must be unique within the release.\n"
                }
            },
            "requiredInputs": [
                "project",
                "tagName",
                "url"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ReleaseLink resources.\n",
                "properties": {
                    "directAssetUrl": {
                        "type": "string",
                        "description": "Full path for a [Direct Asset link](https://docs.gitlab.com/ee/user/project/releases/index.html#permanent-links-to-release-assets).\n"
                    },
                    "external": {
                        "type": "boolean",
                        "description": "External or internal link.\n"
                    },
                    "filepath": {
                        "type": "string",
                        "description": "Relative path for a [Direct Asset link](https://docs.gitlab.com/ee/user/project/releases/index.html#permanent-links-to-release-assets).\n"
                    },
                    "linkId": {
                        "type": "integer",
                        "description": "The ID of the link.\n"
                    },
                    "linkType": {
                        "type": "string",
                        "description": "The type of the link. Valid values are `other`, `runbook`, `image`, `package`. Defaults to other.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the link. Link names must be unique within the release.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or [URL-encoded path of the project](https://docs.gitlab.com/ee/api/index.html#namespaced-path-encoding).\n",
                        "willReplaceOnChanges": true
                    },
                    "tagName": {
                        "type": "string",
                        "description": "The tag associated with the Release.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "The URL of the link. Link URLs must be unique within the release.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/repositoryFile:RepositoryFile": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\nimport * as std from \"@pulumi/std\";\n\nconst _this = new gitlab.Group(\"this\", {\n    name: \"example\",\n    path: \"example\",\n    description: \"An example group\",\n});\nconst thisProject = new gitlab.Project(\"this\", {\n    name: \"example\",\n    namespaceId: _this.id,\n    initializeWithReadme: true,\n});\nconst thisRepositoryFile = new gitlab.RepositoryFile(\"this\", {\n    project: thisProject.id,\n    filePath: \"meow.txt\",\n    branch: \"main\",\n    content: std.base64encode({\n        input: \"Meow goes the cat\",\n    }).then(invoke =\u003e invoke.result),\n    authorEmail: \"terraform@example.com\",\n    authorName: \"Terraform\",\n    commitMessage: \"feature: add meow file\",\n});\nconst readme = new gitlab.RepositoryFile(\"readme\", {\n    project: thisProject.id,\n    filePath: \"readme.txt\",\n    branch: \"main\",\n    content: \"Meow goes the cat\",\n    authorEmail: \"terraform@example.com\",\n    authorName: \"Terraform\",\n    commitMessage: \"feature: add readme file\",\n});\nconst readmeForDogs = new gitlab.RepositoryFile(\"readme_for_dogs\", {\n    project: thisProject.id,\n    filePath: \"readme.txt\",\n    branch: \"main\",\n    content: \"Bark goes the dog\",\n    authorEmail: \"terraform@example.com\",\n    authorName: \"Terraform\",\n    commitMessage: \"feature: update readme file\",\n    overwriteOnCreate: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\nimport pulumi_std as std\n\nthis = gitlab.Group(\"this\",\n    name=\"example\",\n    path=\"example\",\n    description=\"An example group\")\nthis_project = gitlab.Project(\"this\",\n    name=\"example\",\n    namespace_id=this.id,\n    initialize_with_readme=True)\nthis_repository_file = gitlab.RepositoryFile(\"this\",\n    project=this_project.id,\n    file_path=\"meow.txt\",\n    branch=\"main\",\n    content=std.base64encode(input=\"Meow goes the cat\").result,\n    author_email=\"terraform@example.com\",\n    author_name=\"Terraform\",\n    commit_message=\"feature: add meow file\")\nreadme = gitlab.RepositoryFile(\"readme\",\n    project=this_project.id,\n    file_path=\"readme.txt\",\n    branch=\"main\",\n    content=\"Meow goes the cat\",\n    author_email=\"terraform@example.com\",\n    author_name=\"Terraform\",\n    commit_message=\"feature: add readme file\")\nreadme_for_dogs = gitlab.RepositoryFile(\"readme_for_dogs\",\n    project=this_project.id,\n    file_path=\"readme.txt\",\n    branch=\"main\",\n    content=\"Bark goes the dog\",\n    author_email=\"terraform@example.com\",\n    author_name=\"Terraform\",\n    commit_message=\"feature: update readme file\",\n    overwrite_on_create=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\nusing Std = Pulumi.Std;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @this = new GitLab.Group(\"this\", new()\n    {\n        Name = \"example\",\n        Path = \"example\",\n        Description = \"An example group\",\n    });\n\n    var thisProject = new GitLab.Project(\"this\", new()\n    {\n        Name = \"example\",\n        NamespaceId = @this.Id,\n        InitializeWithReadme = true,\n    });\n\n    var thisRepositoryFile = new GitLab.RepositoryFile(\"this\", new()\n    {\n        Project = thisProject.Id,\n        FilePath = \"meow.txt\",\n        Branch = \"main\",\n        Content = Std.Base64encode.Invoke(new()\n        {\n            Input = \"Meow goes the cat\",\n        }).Apply(invoke =\u003e invoke.Result),\n        AuthorEmail = \"terraform@example.com\",\n        AuthorName = \"Terraform\",\n        CommitMessage = \"feature: add meow file\",\n    });\n\n    var readme = new GitLab.RepositoryFile(\"readme\", new()\n    {\n        Project = thisProject.Id,\n        FilePath = \"readme.txt\",\n        Branch = \"main\",\n        Content = \"Meow goes the cat\",\n        AuthorEmail = \"terraform@example.com\",\n        AuthorName = \"Terraform\",\n        CommitMessage = \"feature: add readme file\",\n    });\n\n    var readmeForDogs = new GitLab.RepositoryFile(\"readme_for_dogs\", new()\n    {\n        Project = thisProject.Id,\n        FilePath = \"readme.txt\",\n        Branch = \"main\",\n        Content = \"Bark goes the dog\",\n        AuthorEmail = \"terraform@example.com\",\n        AuthorName = \"Terraform\",\n        CommitMessage = \"feature: update readme file\",\n        OverwriteOnCreate = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi-std/sdk/go/std\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tthis, err := gitlab.NewGroup(ctx, \"this\", \u0026gitlab.GroupArgs{\n\t\t\tName:        pulumi.String(\"example\"),\n\t\t\tPath:        pulumi.String(\"example\"),\n\t\t\tDescription: pulumi.String(\"An example group\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tthisProject, err := gitlab.NewProject(ctx, \"this\", \u0026gitlab.ProjectArgs{\n\t\t\tName:                 pulumi.String(\"example\"),\n\t\t\tNamespaceId:          this.ID(),\n\t\t\tInitializeWithReadme: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tinvokeBase64encode, err := std.Base64encode(ctx, \u0026std.Base64encodeArgs{\n\t\t\tInput: \"Meow goes the cat\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewRepositoryFile(ctx, \"this\", \u0026gitlab.RepositoryFileArgs{\n\t\t\tProject:       thisProject.ID(),\n\t\t\tFilePath:      pulumi.String(\"meow.txt\"),\n\t\t\tBranch:        pulumi.String(\"main\"),\n\t\t\tContent:       pulumi.String(invokeBase64encode.Result),\n\t\t\tAuthorEmail:   pulumi.String(\"terraform@example.com\"),\n\t\t\tAuthorName:    pulumi.String(\"Terraform\"),\n\t\t\tCommitMessage: pulumi.String(\"feature: add meow file\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewRepositoryFile(ctx, \"readme\", \u0026gitlab.RepositoryFileArgs{\n\t\t\tProject:       thisProject.ID(),\n\t\t\tFilePath:      pulumi.String(\"readme.txt\"),\n\t\t\tBranch:        pulumi.String(\"main\"),\n\t\t\tContent:       pulumi.String(\"Meow goes the cat\"),\n\t\t\tAuthorEmail:   pulumi.String(\"terraform@example.com\"),\n\t\t\tAuthorName:    pulumi.String(\"Terraform\"),\n\t\t\tCommitMessage: pulumi.String(\"feature: add readme file\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewRepositoryFile(ctx, \"readme_for_dogs\", \u0026gitlab.RepositoryFileArgs{\n\t\t\tProject:           thisProject.ID(),\n\t\t\tFilePath:          pulumi.String(\"readme.txt\"),\n\t\t\tBranch:            pulumi.String(\"main\"),\n\t\t\tContent:           pulumi.String(\"Bark goes the dog\"),\n\t\t\tAuthorEmail:       pulumi.String(\"terraform@example.com\"),\n\t\t\tAuthorName:        pulumi.String(\"Terraform\"),\n\t\t\tCommitMessage:     pulumi.String(\"feature: update readme file\"),\n\t\t\tOverwriteOnCreate: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Group;\nimport com.pulumi.gitlab.GroupArgs;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.RepositoryFile;\nimport com.pulumi.gitlab.RepositoryFileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var this_ = new Group(\"this\", GroupArgs.builder()\n            .name(\"example\")\n            .path(\"example\")\n            .description(\"An example group\")\n            .build());\n\n        var thisProject = new Project(\"thisProject\", ProjectArgs.builder()\n            .name(\"example\")\n            .namespaceId(this_.id())\n            .initializeWithReadme(true)\n            .build());\n\n        var thisRepositoryFile = new RepositoryFile(\"thisRepositoryFile\", RepositoryFileArgs.builder()\n            .project(thisProject.id())\n            .filePath(\"meow.txt\")\n            .branch(\"main\")\n            .content(StdFunctions.base64encode(Base64encodeArgs.builder()\n                .input(\"Meow goes the cat\")\n                .build()).result())\n            .authorEmail(\"terraform@example.com\")\n            .authorName(\"Terraform\")\n            .commitMessage(\"feature: add meow file\")\n            .build());\n\n        var readme = new RepositoryFile(\"readme\", RepositoryFileArgs.builder()\n            .project(thisProject.id())\n            .filePath(\"readme.txt\")\n            .branch(\"main\")\n            .content(\"Meow goes the cat\")\n            .authorEmail(\"terraform@example.com\")\n            .authorName(\"Terraform\")\n            .commitMessage(\"feature: add readme file\")\n            .build());\n\n        var readmeForDogs = new RepositoryFile(\"readmeForDogs\", RepositoryFileArgs.builder()\n            .project(thisProject.id())\n            .filePath(\"readme.txt\")\n            .branch(\"main\")\n            .content(\"Bark goes the dog\")\n            .authorEmail(\"terraform@example.com\")\n            .authorName(\"Terraform\")\n            .commitMessage(\"feature: update readme file\")\n            .overwriteOnCreate(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  this:\n    type: gitlab:Group\n    properties:\n      name: example\n      path: example\n      description: An example group\n  thisProject:\n    type: gitlab:Project\n    name: this\n    properties:\n      name: example\n      namespaceId: ${this.id}\n      initializeWithReadme: true\n  thisRepositoryFile:\n    type: gitlab:RepositoryFile\n    name: this\n    properties:\n      project: ${thisProject.id}\n      filePath: meow.txt\n      branch: main\n      content:\n        fn::invoke:\n          Function: std:base64encode\n          Arguments:\n            input: Meow goes the cat\n          Return: result\n      authorEmail: terraform@example.com\n      authorName: Terraform\n      commitMessage: 'feature: add meow file'\n  readme:\n    type: gitlab:RepositoryFile\n    properties:\n      project: ${thisProject.id}\n      filePath: readme.txt\n      branch: main\n      content: Meow goes the cat\n      authorEmail: terraform@example.com\n      authorName: Terraform\n      commitMessage: 'feature: add readme file'\n  readmeForDogs:\n    type: gitlab:RepositoryFile\n    name: readme_for_dogs\n    properties:\n      project: ${thisProject.id}\n      filePath: readme.txt\n      branch: main\n      content: Bark goes the dog\n      authorEmail: terraform@example.com\n      authorName: Terraform\n      commitMessage: 'feature: update readme file'\n      overwriteOnCreate: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_repository_file`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_repository_file.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nA Repository File can be imported using an id made up of `\u003cproject-id\u003e:\u003cbranch-name\u003e:\u003cfile-path\u003e`, e.g.\n\n```sh\n$ pulumi import gitlab:index/repositoryFile:RepositoryFile this 1:main:foo/bar.txt\n```\n\n",
            "properties": {
                "authorEmail": {
                    "type": "string",
                    "description": "Email of the commit author.\n"
                },
                "authorName": {
                    "type": "string",
                    "description": "Name of the commit author.\n"
                },
                "blobId": {
                    "type": "string",
                    "description": "The blob id.\n"
                },
                "branch": {
                    "type": "string",
                    "description": "Name of the branch to which to commit to.\n"
                },
                "commitId": {
                    "type": "string",
                    "description": "The commit id.\n"
                },
                "commitMessage": {
                    "type": "string",
                    "description": "Commit message.\n"
                },
                "content": {
                    "type": "string",
                    "description": "File content.\n"
                },
                "contentSha256": {
                    "type": "string",
                    "description": "File content sha256 digest.\n"
                },
                "createCommitMessage": {
                    "type": "string",
                    "description": "Create commit message.\n"
                },
                "deleteCommitMessage": {
                    "type": "string",
                    "description": "Delete Commit message.\n"
                },
                "encoding": {
                    "type": "string",
                    "description": "The file content encoding. Default value is `base64`. Valid values are: `base64`, `text`.\n"
                },
                "executeFilemode": {
                    "type": "boolean",
                    "description": "Enables or disables the execute flag on the file. **Note**: requires GitLab 14.10 or newer.\n"
                },
                "fileName": {
                    "type": "string",
                    "description": "The filename.\n"
                },
                "filePath": {
                    "type": "string",
                    "description": "The full path of the file. It must be relative to the root of the project without a leading slash `/` or `./`.\n"
                },
                "lastCommitId": {
                    "type": "string",
                    "description": "The last known commit id.\n"
                },
                "overwriteOnCreate": {
                    "type": "boolean",
                    "description": "Enable overwriting existing files, defaults to `false`. This attribute is only used during `create` and must be use carefully. We suggest to use `imports` whenever possible and limit the use of this attribute for when the project was imported on the same `apply`. This attribute is not supported during a resource import.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or ID of the project.\n"
                },
                "ref": {
                    "type": "string",
                    "description": "The name of branch, tag or commit.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "The file size.\n"
                },
                "startBranch": {
                    "type": "string",
                    "description": "Name of the branch to start the new commit from.\n"
                },
                "updateCommitMessage": {
                    "type": "string",
                    "description": "Update commit message.\n"
                }
            },
            "required": [
                "blobId",
                "branch",
                "commitId",
                "content",
                "contentSha256",
                "fileName",
                "filePath",
                "lastCommitId",
                "project",
                "ref",
                "size"
            ],
            "inputProperties": {
                "authorEmail": {
                    "type": "string",
                    "description": "Email of the commit author.\n"
                },
                "authorName": {
                    "type": "string",
                    "description": "Name of the commit author.\n"
                },
                "branch": {
                    "type": "string",
                    "description": "Name of the branch to which to commit to.\n",
                    "willReplaceOnChanges": true
                },
                "commitMessage": {
                    "type": "string",
                    "description": "Commit message.\n"
                },
                "content": {
                    "type": "string",
                    "description": "File content.\n"
                },
                "createCommitMessage": {
                    "type": "string",
                    "description": "Create commit message.\n"
                },
                "deleteCommitMessage": {
                    "type": "string",
                    "description": "Delete Commit message.\n"
                },
                "encoding": {
                    "type": "string",
                    "description": "The file content encoding. Default value is `base64`. Valid values are: `base64`, `text`.\n"
                },
                "executeFilemode": {
                    "type": "boolean",
                    "description": "Enables or disables the execute flag on the file. **Note**: requires GitLab 14.10 or newer.\n"
                },
                "filePath": {
                    "type": "string",
                    "description": "The full path of the file. It must be relative to the root of the project without a leading slash `/` or `./`.\n",
                    "willReplaceOnChanges": true
                },
                "overwriteOnCreate": {
                    "type": "boolean",
                    "description": "Enable overwriting existing files, defaults to `false`. This attribute is only used during `create` and must be use carefully. We suggest to use `imports` whenever possible and limit the use of this attribute for when the project was imported on the same `apply`. This attribute is not supported during a resource import.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The name or ID of the project.\n",
                    "willReplaceOnChanges": true
                },
                "startBranch": {
                    "type": "string",
                    "description": "Name of the branch to start the new commit from.\n"
                },
                "updateCommitMessage": {
                    "type": "string",
                    "description": "Update commit message.\n"
                }
            },
            "requiredInputs": [
                "branch",
                "content",
                "filePath",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RepositoryFile resources.\n",
                "properties": {
                    "authorEmail": {
                        "type": "string",
                        "description": "Email of the commit author.\n"
                    },
                    "authorName": {
                        "type": "string",
                        "description": "Name of the commit author.\n"
                    },
                    "blobId": {
                        "type": "string",
                        "description": "The blob id.\n"
                    },
                    "branch": {
                        "type": "string",
                        "description": "Name of the branch to which to commit to.\n",
                        "willReplaceOnChanges": true
                    },
                    "commitId": {
                        "type": "string",
                        "description": "The commit id.\n"
                    },
                    "commitMessage": {
                        "type": "string",
                        "description": "Commit message.\n"
                    },
                    "content": {
                        "type": "string",
                        "description": "File content.\n"
                    },
                    "contentSha256": {
                        "type": "string",
                        "description": "File content sha256 digest.\n"
                    },
                    "createCommitMessage": {
                        "type": "string",
                        "description": "Create commit message.\n"
                    },
                    "deleteCommitMessage": {
                        "type": "string",
                        "description": "Delete Commit message.\n"
                    },
                    "encoding": {
                        "type": "string",
                        "description": "The file content encoding. Default value is `base64`. Valid values are: `base64`, `text`.\n"
                    },
                    "executeFilemode": {
                        "type": "boolean",
                        "description": "Enables or disables the execute flag on the file. **Note**: requires GitLab 14.10 or newer.\n"
                    },
                    "fileName": {
                        "type": "string",
                        "description": "The filename.\n"
                    },
                    "filePath": {
                        "type": "string",
                        "description": "The full path of the file. It must be relative to the root of the project without a leading slash `/` or `./`.\n",
                        "willReplaceOnChanges": true
                    },
                    "lastCommitId": {
                        "type": "string",
                        "description": "The last known commit id.\n"
                    },
                    "overwriteOnCreate": {
                        "type": "boolean",
                        "description": "Enable overwriting existing files, defaults to `false`. This attribute is only used during `create` and must be use carefully. We suggest to use `imports` whenever possible and limit the use of this attribute for when the project was imported on the same `apply`. This attribute is not supported during a resource import.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or ID of the project.\n",
                        "willReplaceOnChanges": true
                    },
                    "ref": {
                        "type": "string",
                        "description": "The name of branch, tag or commit.\n"
                    },
                    "size": {
                        "type": "integer",
                        "description": "The file size.\n"
                    },
                    "startBranch": {
                        "type": "string",
                        "description": "Name of the branch to start the new commit from.\n"
                    },
                    "updateCommitMessage": {
                        "type": "string",
                        "description": "Update commit message.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/runner:Runner": {
            "description": "The `gitlab.Runner` resource allows to manage the lifecycle of a runner.\n\nA runner can either be registered at an instance level or group level.\nThe runner will be registered at a group level if the token used is from a group, or at an instance level if the token used is for the instance.\n\n~ \u003e Using this resource will register a runner using the deprecated `registration_token` flow. To use the new `authentication_token` flow instead,\nuse the `gitlab.UserRunner` resource!\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/runners.html#register-a-new-runner)\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_runner`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_runner.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nA GitLab Runner can be imported using the runner's ID, eg\n\n```sh\n$ pulumi import gitlab:index/runner:Runner this 1\n```\n\n",
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "The access_level of the runner. Valid values are: `not_protected`, `ref_protected`.\n"
                },
                "authenticationToken": {
                    "type": "string",
                    "description": "The authentication token used for building a config.toml file. This value is not present when imported.\n",
                    "secret": true
                },
                "description": {
                    "type": "string",
                    "description": "The runner's description.\n"
                },
                "locked": {
                    "type": "boolean",
                    "description": "Whether the runner should be locked for current project.\n"
                },
                "maintenanceNote": {
                    "type": "string",
                    "description": "Free-form maintenance notes for the runner (1024 characters).\n"
                },
                "maximumTimeout": {
                    "type": "integer",
                    "description": "Maximum timeout set when this runner handles the job.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Whether the runner should ignore new jobs.\n"
                },
                "registrationToken": {
                    "type": "string",
                    "description": "The registration token used to register the runner.\n",
                    "secret": true
                },
                "runUntagged": {
                    "type": "boolean",
                    "description": "Whether the runner should handle untagged jobs.\n"
                },
                "status": {
                    "type": "string",
                    "description": "The status of runners to show, one of: online and offline. active and paused are also possible values\n\t\t\t              which were deprecated in GitLab 14.8 and will be removed in GitLab 16.0.\n"
                },
                "tagLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of runner’s tags.\n"
                }
            },
            "required": [
                "accessLevel",
                "authenticationToken",
                "locked",
                "paused",
                "registrationToken",
                "runUntagged",
                "status"
            ],
            "inputProperties": {
                "accessLevel": {
                    "type": "string",
                    "description": "The access_level of the runner. Valid values are: `not_protected`, `ref_protected`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The runner's description.\n"
                },
                "locked": {
                    "type": "boolean",
                    "description": "Whether the runner should be locked for current project.\n"
                },
                "maintenanceNote": {
                    "type": "string",
                    "description": "Free-form maintenance notes for the runner (1024 characters).\n"
                },
                "maximumTimeout": {
                    "type": "integer",
                    "description": "Maximum timeout set when this runner handles the job.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Whether the runner should ignore new jobs.\n"
                },
                "registrationToken": {
                    "type": "string",
                    "description": "The registration token used to register the runner.\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                },
                "runUntagged": {
                    "type": "boolean",
                    "description": "Whether the runner should handle untagged jobs.\n"
                },
                "tagLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of runner’s tags.\n"
                }
            },
            "requiredInputs": [
                "registrationToken"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Runner resources.\n",
                "properties": {
                    "accessLevel": {
                        "type": "string",
                        "description": "The access_level of the runner. Valid values are: `not_protected`, `ref_protected`.\n"
                    },
                    "authenticationToken": {
                        "type": "string",
                        "description": "The authentication token used for building a config.toml file. This value is not present when imported.\n",
                        "secret": true
                    },
                    "description": {
                        "type": "string",
                        "description": "The runner's description.\n"
                    },
                    "locked": {
                        "type": "boolean",
                        "description": "Whether the runner should be locked for current project.\n"
                    },
                    "maintenanceNote": {
                        "type": "string",
                        "description": "Free-form maintenance notes for the runner (1024 characters).\n"
                    },
                    "maximumTimeout": {
                        "type": "integer",
                        "description": "Maximum timeout set when this runner handles the job.\n"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "Whether the runner should ignore new jobs.\n"
                    },
                    "registrationToken": {
                        "type": "string",
                        "description": "The registration token used to register the runner.\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "runUntagged": {
                        "type": "boolean",
                        "description": "Whether the runner should handle untagged jobs.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "The status of runners to show, one of: online and offline. active and paused are also possible values\n\t\t\t              which were deprecated in GitLab 14.8 and will be removed in GitLab 16.0.\n"
                    },
                    "tagLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of runner’s tags.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/serviceCustomIssueTracker:ServiceCustomIssueTracker": {
            "description": "The `gitlab.ServiceCustomIssueTracker` resource allows to manage the lifecycle of a project integration with Custom Issue Tracker.\n\n\u003e This resource is deprecated. use `gitlab.IntegrationCustomIssueTracker`instead!\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/integrations.html#custom-issue-tracker)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst awesomeProject = new gitlab.Project(\"awesome_project\", {\n    name: \"awesome_project\",\n    description: \"My awesome project.\",\n    visibilityLevel: \"public\",\n});\nconst tracker = new gitlab.ServiceCustomIssueTracker(\"tracker\", {\n    project: awesomeProject.id,\n    projectUrl: \"https://customtracker.com/issues\",\n    issuesUrl: \"https://customtracker.com/TEST-:id\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nawesome_project = gitlab.Project(\"awesome_project\",\n    name=\"awesome_project\",\n    description=\"My awesome project.\",\n    visibility_level=\"public\")\ntracker = gitlab.ServiceCustomIssueTracker(\"tracker\",\n    project=awesome_project.id,\n    project_url=\"https://customtracker.com/issues\",\n    issues_url=\"https://customtracker.com/TEST-:id\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var awesomeProject = new GitLab.Project(\"awesome_project\", new()\n    {\n        Name = \"awesome_project\",\n        Description = \"My awesome project.\",\n        VisibilityLevel = \"public\",\n    });\n\n    var tracker = new GitLab.ServiceCustomIssueTracker(\"tracker\", new()\n    {\n        Project = awesomeProject.Id,\n        ProjectUrl = \"https://customtracker.com/issues\",\n        IssuesUrl = \"https://customtracker.com/TEST-:id\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tawesomeProject, err := gitlab.NewProject(ctx, \"awesome_project\", \u0026gitlab.ProjectArgs{\n\t\t\tName:            pulumi.String(\"awesome_project\"),\n\t\t\tDescription:     pulumi.String(\"My awesome project.\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewServiceCustomIssueTracker(ctx, \"tracker\", \u0026gitlab.ServiceCustomIssueTrackerArgs{\n\t\t\tProject:    awesomeProject.ID(),\n\t\t\tProjectUrl: pulumi.String(\"https://customtracker.com/issues\"),\n\t\t\tIssuesUrl:  pulumi.String(\"https://customtracker.com/TEST-:id\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ServiceCustomIssueTracker;\nimport com.pulumi.gitlab.ServiceCustomIssueTrackerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var awesomeProject = new Project(\"awesomeProject\", ProjectArgs.builder()\n            .name(\"awesome_project\")\n            .description(\"My awesome project.\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var tracker = new ServiceCustomIssueTracker(\"tracker\", ServiceCustomIssueTrackerArgs.builder()\n            .project(awesomeProject.id())\n            .projectUrl(\"https://customtracker.com/issues\")\n            .issuesUrl(\"https://customtracker.com/TEST-:id\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  awesomeProject:\n    type: gitlab:Project\n    name: awesome_project\n    properties:\n      name: awesome_project\n      description: My awesome project.\n      visibilityLevel: public\n  tracker:\n    type: gitlab:ServiceCustomIssueTracker\n    properties:\n      project: ${awesomeProject.id}\n      projectUrl: https://customtracker.com/issues\n      issuesUrl: https://customtracker.com/TEST-:id\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_service_custom_issue_tracker`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_service_custom_issue_tracker.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nYou can import a gitlab_service_custom_issue_tracker state using the project ID, e.g.\n\n```sh\n$ pulumi import gitlab:index/serviceCustomIssueTracker:ServiceCustomIssueTracker tracker 1\n```\n\n",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "Whether the integration is active.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "The ISO8601 date/time that this integration was activated at in UTC.\n"
                },
                "issuesUrl": {
                    "type": "string",
                    "description": "The URL to view an issue in the external issue tracker. Must contain :id.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project for the custom issue tracker.\n"
                },
                "projectUrl": {
                    "type": "string",
                    "description": "The URL to the project in the external issue tracker.\n"
                },
                "slug": {
                    "type": "string",
                    "description": "The name of the integration in lowercase, shortened to 63 bytes, and with everything except 0-9 and a-z replaced with -. No leading / trailing -. Use in URLs, host names and domain names.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "The ISO8601 date/time that this integration was last updated at in UTC.\n"
                }
            },
            "required": [
                "active",
                "createdAt",
                "issuesUrl",
                "project",
                "projectUrl",
                "slug",
                "updatedAt"
            ],
            "inputProperties": {
                "issuesUrl": {
                    "type": "string",
                    "description": "The URL to view an issue in the external issue tracker. Must contain :id.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The ID or full path of the project for the custom issue tracker.\n"
                },
                "projectUrl": {
                    "type": "string",
                    "description": "The URL to the project in the external issue tracker.\n"
                }
            },
            "requiredInputs": [
                "issuesUrl",
                "project",
                "projectUrl"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ServiceCustomIssueTracker resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "Whether the integration is active.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "The ISO8601 date/time that this integration was activated at in UTC.\n"
                    },
                    "issuesUrl": {
                        "type": "string",
                        "description": "The URL to view an issue in the external issue tracker. Must contain :id.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or full path of the project for the custom issue tracker.\n"
                    },
                    "projectUrl": {
                        "type": "string",
                        "description": "The URL to the project in the external issue tracker.\n"
                    },
                    "slug": {
                        "type": "string",
                        "description": "The name of the integration in lowercase, shortened to 63 bytes, and with everything except 0-9 and a-z replaced with -. No leading / trailing -. Use in URLs, host names and domain names.\n"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "The ISO8601 date/time that this integration was last updated at in UTC.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/serviceEmailsOnPush:ServiceEmailsOnPush": {
            "description": "The `gitlab.ServiceEmailsOnPush` resource allows to manage the lifecycle of a project integration with Emails on Push Service.\n\n\u003e This resource is deprecated. Please use `gitlab.IntegrationEmailsOnPush` instead!\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/integrations.html#emails-on-push)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst awesomeProject = new gitlab.Project(\"awesome_project\", {\n    name: \"awesome_project\",\n    description: \"My awesome project.\",\n    visibilityLevel: \"public\",\n});\nconst emails = new gitlab.ServiceEmailsOnPush(\"emails\", {\n    project: awesomeProject.id,\n    recipients: \"myrecipient@example.com myotherrecipient@example.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nawesome_project = gitlab.Project(\"awesome_project\",\n    name=\"awesome_project\",\n    description=\"My awesome project.\",\n    visibility_level=\"public\")\nemails = gitlab.ServiceEmailsOnPush(\"emails\",\n    project=awesome_project.id,\n    recipients=\"myrecipient@example.com myotherrecipient@example.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var awesomeProject = new GitLab.Project(\"awesome_project\", new()\n    {\n        Name = \"awesome_project\",\n        Description = \"My awesome project.\",\n        VisibilityLevel = \"public\",\n    });\n\n    var emails = new GitLab.ServiceEmailsOnPush(\"emails\", new()\n    {\n        Project = awesomeProject.Id,\n        Recipients = \"myrecipient@example.com myotherrecipient@example.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tawesomeProject, err := gitlab.NewProject(ctx, \"awesome_project\", \u0026gitlab.ProjectArgs{\n\t\t\tName:            pulumi.String(\"awesome_project\"),\n\t\t\tDescription:     pulumi.String(\"My awesome project.\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewServiceEmailsOnPush(ctx, \"emails\", \u0026gitlab.ServiceEmailsOnPushArgs{\n\t\t\tProject:    awesomeProject.ID(),\n\t\t\tRecipients: pulumi.String(\"myrecipient@example.com myotherrecipient@example.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ServiceEmailsOnPush;\nimport com.pulumi.gitlab.ServiceEmailsOnPushArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var awesomeProject = new Project(\"awesomeProject\", ProjectArgs.builder()\n            .name(\"awesome_project\")\n            .description(\"My awesome project.\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var emails = new ServiceEmailsOnPush(\"emails\", ServiceEmailsOnPushArgs.builder()\n            .project(awesomeProject.id())\n            .recipients(\"myrecipient@example.com myotherrecipient@example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  awesomeProject:\n    type: gitlab:Project\n    name: awesome_project\n    properties:\n      name: awesome_project\n      description: My awesome project.\n      visibilityLevel: public\n  emails:\n    type: gitlab:ServiceEmailsOnPush\n    properties:\n      project: ${awesomeProject.id}\n      recipients: myrecipient@example.com myotherrecipient@example.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_service_emails_on_push`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_service_emails_on_push.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nYou can import a gitlab_service_emails_on_push state using the project ID, e.g.\n\n```sh\n$ pulumi import gitlab:index/serviceEmailsOnPush:ServiceEmailsOnPush emails 1\n```\n\n",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "Whether the integration is active.\n"
                },
                "branchesToBeNotified": {
                    "type": "string",
                    "description": "Branches to send notifications for. Valid options are `all`, `default`, `protected`, `default_and_protected`. Notifications are always fired for tag pushes.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "The ISO8601 date/time that this integration was activated at in UTC.\n"
                },
                "disableDiffs": {
                    "type": "boolean",
                    "description": "Disable code diffs.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID or full-path of the project you want to activate integration on.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for push events.\n"
                },
                "recipients": {
                    "type": "string",
                    "description": "Emails separated by whitespace.\n"
                },
                "sendFromCommitterEmail": {
                    "type": "boolean",
                    "description": "Send from committer.\n"
                },
                "slug": {
                    "type": "string",
                    "description": "The name of the integration in lowercase, shortened to 63 bytes, and with everything except 0-9 and a-z replaced with -. No leading / trailing -. Use in URLs, host names and domain names.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for tag push events.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Title of the integration.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "The ISO8601 date/time that this integration was last updated at in UTC.\n"
                }
            },
            "required": [
                "active",
                "createdAt",
                "project",
                "recipients",
                "slug",
                "title",
                "updatedAt"
            ],
            "inputProperties": {
                "branchesToBeNotified": {
                    "type": "string",
                    "description": "Branches to send notifications for. Valid options are `all`, `default`, `protected`, `default_and_protected`. Notifications are always fired for tag pushes.\n"
                },
                "disableDiffs": {
                    "type": "boolean",
                    "description": "Disable code diffs.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID or full-path of the project you want to activate integration on.\n",
                    "willReplaceOnChanges": true
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for push events.\n"
                },
                "recipients": {
                    "type": "string",
                    "description": "Emails separated by whitespace.\n"
                },
                "sendFromCommitterEmail": {
                    "type": "boolean",
                    "description": "Send from committer.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for tag push events.\n"
                }
            },
            "requiredInputs": [
                "project",
                "recipients"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ServiceEmailsOnPush resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "Whether the integration is active.\n"
                    },
                    "branchesToBeNotified": {
                        "type": "string",
                        "description": "Branches to send notifications for. Valid options are `all`, `default`, `protected`, `default_and_protected`. Notifications are always fired for tag pushes.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "The ISO8601 date/time that this integration was activated at in UTC.\n"
                    },
                    "disableDiffs": {
                        "type": "boolean",
                        "description": "Disable code diffs.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "ID or full-path of the project you want to activate integration on.\n",
                        "willReplaceOnChanges": true
                    },
                    "pushEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for push events.\n"
                    },
                    "recipients": {
                        "type": "string",
                        "description": "Emails separated by whitespace.\n"
                    },
                    "sendFromCommitterEmail": {
                        "type": "boolean",
                        "description": "Send from committer.\n"
                    },
                    "slug": {
                        "type": "string",
                        "description": "The name of the integration in lowercase, shortened to 63 bytes, and with everything except 0-9 and a-z replaced with -. No leading / trailing -. Use in URLs, host names and domain names.\n"
                    },
                    "tagPushEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for tag push events.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "Title of the integration.\n"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "The ISO8601 date/time that this integration was last updated at in UTC.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/serviceExternalWiki:ServiceExternalWiki": {
            "description": "The `gitlab.ServiceExternalWiki` resource allows to manage the lifecycle of a project integration with External Wiki Service.\n\n\u003e This resource is deprecated. use `gitlab.IntegrationExternalWiki`instead!\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/integrations.html#external-wiki)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst awesomeProject = new gitlab.Project(\"awesome_project\", {\n    name: \"awesome_project\",\n    description: \"My awesome project.\",\n    visibilityLevel: \"public\",\n});\nconst wiki = new gitlab.ServiceExternalWiki(\"wiki\", {\n    project: awesomeProject.id,\n    externalWikiUrl: \"https://MyAwesomeExternalWikiURL.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nawesome_project = gitlab.Project(\"awesome_project\",\n    name=\"awesome_project\",\n    description=\"My awesome project.\",\n    visibility_level=\"public\")\nwiki = gitlab.ServiceExternalWiki(\"wiki\",\n    project=awesome_project.id,\n    external_wiki_url=\"https://MyAwesomeExternalWikiURL.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var awesomeProject = new GitLab.Project(\"awesome_project\", new()\n    {\n        Name = \"awesome_project\",\n        Description = \"My awesome project.\",\n        VisibilityLevel = \"public\",\n    });\n\n    var wiki = new GitLab.ServiceExternalWiki(\"wiki\", new()\n    {\n        Project = awesomeProject.Id,\n        ExternalWikiUrl = \"https://MyAwesomeExternalWikiURL.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tawesomeProject, err := gitlab.NewProject(ctx, \"awesome_project\", \u0026gitlab.ProjectArgs{\n\t\t\tName:            pulumi.String(\"awesome_project\"),\n\t\t\tDescription:     pulumi.String(\"My awesome project.\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewServiceExternalWiki(ctx, \"wiki\", \u0026gitlab.ServiceExternalWikiArgs{\n\t\t\tProject:         awesomeProject.ID(),\n\t\t\tExternalWikiUrl: pulumi.String(\"https://MyAwesomeExternalWikiURL.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ServiceExternalWiki;\nimport com.pulumi.gitlab.ServiceExternalWikiArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var awesomeProject = new Project(\"awesomeProject\", ProjectArgs.builder()\n            .name(\"awesome_project\")\n            .description(\"My awesome project.\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var wiki = new ServiceExternalWiki(\"wiki\", ServiceExternalWikiArgs.builder()\n            .project(awesomeProject.id())\n            .externalWikiUrl(\"https://MyAwesomeExternalWikiURL.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  awesomeProject:\n    type: gitlab:Project\n    name: awesome_project\n    properties:\n      name: awesome_project\n      description: My awesome project.\n      visibilityLevel: public\n  wiki:\n    type: gitlab:ServiceExternalWiki\n    properties:\n      project: ${awesomeProject.id}\n      externalWikiUrl: https://MyAwesomeExternalWikiURL.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_service_external_wiki`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_service_external_wiki.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nYou can import a gitlab_service_external_wiki state using the project ID, e.g.\n\n```sh\n$ pulumi import gitlab:index/serviceExternalWiki:ServiceExternalWiki wiki 1\n```\n\n",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "Whether the integration is active.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "The ISO8601 date/time that this integration was activated at in UTC.\n"
                },
                "externalWikiUrl": {
                    "type": "string",
                    "description": "The URL of the external wiki.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n"
                },
                "slug": {
                    "type": "string",
                    "description": "The name of the integration in lowercase, shortened to 63 bytes, and with everything except 0-9 and a-z replaced with -. No leading / trailing -. Use in URLs, host names and domain names.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Title of the integration.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "The ISO8601 date/time that this integration was last updated at in UTC.\n"
                }
            },
            "required": [
                "active",
                "createdAt",
                "externalWikiUrl",
                "project",
                "slug",
                "title",
                "updatedAt"
            ],
            "inputProperties": {
                "externalWikiUrl": {
                    "type": "string",
                    "description": "The URL of the external wiki.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "externalWikiUrl",
                "project"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ServiceExternalWiki resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "Whether the integration is active.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "The ISO8601 date/time that this integration was activated at in UTC.\n"
                    },
                    "externalWikiUrl": {
                        "type": "string",
                        "description": "The URL of the external wiki.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "ID of the project you want to activate integration on.\n",
                        "willReplaceOnChanges": true
                    },
                    "slug": {
                        "type": "string",
                        "description": "The name of the integration in lowercase, shortened to 63 bytes, and with everything except 0-9 and a-z replaced with -. No leading / trailing -. Use in URLs, host names and domain names.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "Title of the integration.\n"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "The ISO8601 date/time that this integration was last updated at in UTC.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/serviceGithub:ServiceGithub": {
            "description": "The `gitlab.ServiceGithub` resource allows to manage the lifecycle of a project integration with GitHub.\n\n\u003e This resource requires a GitLab Enterprise instance.\n\n\u003e This resource is deprecated. use `gitlab.IntegrationGithub`instead!\n\t\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/integrations.html#github)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst awesomeProject = new gitlab.Project(\"awesome_project\", {\n    name: \"awesome_project\",\n    description: \"My awesome project.\",\n    visibilityLevel: \"public\",\n});\nconst github = new gitlab.ServiceGithub(\"github\", {\n    project: awesomeProject.id,\n    token: \"REDACTED\",\n    repositoryUrl: \"https://github.com/gitlabhq/terraform-provider-gitlab\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nawesome_project = gitlab.Project(\"awesome_project\",\n    name=\"awesome_project\",\n    description=\"My awesome project.\",\n    visibility_level=\"public\")\ngithub = gitlab.ServiceGithub(\"github\",\n    project=awesome_project.id,\n    token=\"REDACTED\",\n    repository_url=\"https://github.com/gitlabhq/terraform-provider-gitlab\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var awesomeProject = new GitLab.Project(\"awesome_project\", new()\n    {\n        Name = \"awesome_project\",\n        Description = \"My awesome project.\",\n        VisibilityLevel = \"public\",\n    });\n\n    var github = new GitLab.ServiceGithub(\"github\", new()\n    {\n        Project = awesomeProject.Id,\n        Token = \"REDACTED\",\n        RepositoryUrl = \"https://github.com/gitlabhq/terraform-provider-gitlab\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tawesomeProject, err := gitlab.NewProject(ctx, \"awesome_project\", \u0026gitlab.ProjectArgs{\n\t\t\tName:            pulumi.String(\"awesome_project\"),\n\t\t\tDescription:     pulumi.String(\"My awesome project.\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewServiceGithub(ctx, \"github\", \u0026gitlab.ServiceGithubArgs{\n\t\t\tProject:       awesomeProject.ID(),\n\t\t\tToken:         pulumi.String(\"REDACTED\"),\n\t\t\tRepositoryUrl: pulumi.String(\"https://github.com/gitlabhq/terraform-provider-gitlab\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ServiceGithub;\nimport com.pulumi.gitlab.ServiceGithubArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var awesomeProject = new Project(\"awesomeProject\", ProjectArgs.builder()\n            .name(\"awesome_project\")\n            .description(\"My awesome project.\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var github = new ServiceGithub(\"github\", ServiceGithubArgs.builder()\n            .project(awesomeProject.id())\n            .token(\"REDACTED\")\n            .repositoryUrl(\"https://github.com/gitlabhq/terraform-provider-gitlab\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  awesomeProject:\n    type: gitlab:Project\n    name: awesome_project\n    properties:\n      name: awesome_project\n      description: My awesome project.\n      visibilityLevel: public\n  github:\n    type: gitlab:ServiceGithub\n    properties:\n      project: ${awesomeProject.id}\n      token: REDACTED\n      repositoryUrl: https://github.com/gitlabhq/terraform-provider-gitlab\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_service_github`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_service_github.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\n```sh\n$ pulumi import gitlab:index/serviceGithub:ServiceGithub You can import a gitlab_service_github state using `\u003cresource\u003e \u003cproject_id\u003e`:\n```\n\n```sh\n$ pulumi import gitlab:index/serviceGithub:ServiceGithub github 1\n```\n\n",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "Whether the integration is active.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Create time.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n"
                },
                "repositoryUrl": {
                    "type": "string"
                },
                "staticContext": {
                    "type": "boolean",
                    "description": "Append instance name instead of branch to the status. Must enable to set a GitLab status check as *required* in GitHub. See [Static / dynamic status check names] to learn more.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Title.\n"
                },
                "token": {
                    "type": "string",
                    "description": "A GitHub personal access token with at least `repo:status` scope.\n",
                    "secret": true
                },
                "updatedAt": {
                    "type": "string",
                    "description": "Update time.\n"
                }
            },
            "required": [
                "active",
                "createdAt",
                "project",
                "repositoryUrl",
                "title",
                "token",
                "updatedAt"
            ],
            "inputProperties": {
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n",
                    "willReplaceOnChanges": true
                },
                "repositoryUrl": {
                    "type": "string"
                },
                "staticContext": {
                    "type": "boolean",
                    "description": "Append instance name instead of branch to the status. Must enable to set a GitLab status check as *required* in GitHub. See [Static / dynamic status check names] to learn more.\n"
                },
                "token": {
                    "type": "string",
                    "description": "A GitHub personal access token with at least `repo:status` scope.\n",
                    "secret": true
                }
            },
            "requiredInputs": [
                "project",
                "repositoryUrl",
                "token"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ServiceGithub resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "Whether the integration is active.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Create time.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "ID of the project you want to activate integration on.\n",
                        "willReplaceOnChanges": true
                    },
                    "repositoryUrl": {
                        "type": "string"
                    },
                    "staticContext": {
                        "type": "boolean",
                        "description": "Append instance name instead of branch to the status. Must enable to set a GitLab status check as *required* in GitHub. See [Static / dynamic status check names] to learn more.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "Title.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "A GitHub personal access token with at least `repo:status` scope.\n",
                        "secret": true
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "Update time.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/serviceJira:ServiceJira": {
            "description": "The `gitlab.ServiceJira` resource allows to manage the lifecycle of a project integration with Jira.\n\n\u003e This resource is deprecated. use `gitlab.IntegrationJira`instead!\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/integrations.html#jira)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst awesomeProject = new gitlab.Project(\"awesome_project\", {\n    name: \"awesome_project\",\n    description: \"My awesome project.\",\n    visibilityLevel: \"public\",\n});\nconst jira = new gitlab.ServiceJira(\"jira\", {\n    project: awesomeProject.id,\n    url: \"https://jira.example.com\",\n    username: \"user\",\n    password: \"mypass\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nawesome_project = gitlab.Project(\"awesome_project\",\n    name=\"awesome_project\",\n    description=\"My awesome project.\",\n    visibility_level=\"public\")\njira = gitlab.ServiceJira(\"jira\",\n    project=awesome_project.id,\n    url=\"https://jira.example.com\",\n    username=\"user\",\n    password=\"mypass\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var awesomeProject = new GitLab.Project(\"awesome_project\", new()\n    {\n        Name = \"awesome_project\",\n        Description = \"My awesome project.\",\n        VisibilityLevel = \"public\",\n    });\n\n    var jira = new GitLab.ServiceJira(\"jira\", new()\n    {\n        Project = awesomeProject.Id,\n        Url = \"https://jira.example.com\",\n        Username = \"user\",\n        Password = \"mypass\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tawesomeProject, err := gitlab.NewProject(ctx, \"awesome_project\", \u0026gitlab.ProjectArgs{\n\t\t\tName:            pulumi.String(\"awesome_project\"),\n\t\t\tDescription:     pulumi.String(\"My awesome project.\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewServiceJira(ctx, \"jira\", \u0026gitlab.ServiceJiraArgs{\n\t\t\tProject:  awesomeProject.ID(),\n\t\t\tUrl:      pulumi.String(\"https://jira.example.com\"),\n\t\t\tUsername: pulumi.String(\"user\"),\n\t\t\tPassword: pulumi.String(\"mypass\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ServiceJira;\nimport com.pulumi.gitlab.ServiceJiraArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var awesomeProject = new Project(\"awesomeProject\", ProjectArgs.builder()\n            .name(\"awesome_project\")\n            .description(\"My awesome project.\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var jira = new ServiceJira(\"jira\", ServiceJiraArgs.builder()\n            .project(awesomeProject.id())\n            .url(\"https://jira.example.com\")\n            .username(\"user\")\n            .password(\"mypass\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  awesomeProject:\n    type: gitlab:Project\n    name: awesome_project\n    properties:\n      name: awesome_project\n      description: My awesome project.\n      visibilityLevel: public\n  jira:\n    type: gitlab:ServiceJira\n    properties:\n      project: ${awesomeProject.id}\n      url: https://jira.example.com\n      username: user\n      password: mypass\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_service_jira`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_service_jira.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nYou can import a gitlab_service_jira state using the project ID, e.g.\n\n```sh\n$ pulumi import gitlab:index/serviceJira:ServiceJira jira 1\n```\n\n",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "Whether the integration is active.\n"
                },
                "apiUrl": {
                    "type": "string",
                    "description": "The base URL to the Jira instance API. Web URL value is used if not set. For example, https://jira-api.example.com.\n"
                },
                "commentOnEventEnabled": {
                    "type": "boolean",
                    "description": "Enable comments inside Jira issues on each GitLab event (commit / merge request)\n"
                },
                "commitEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for commit events\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Create time.\n"
                },
                "issuesEnabled": {
                    "type": "boolean",
                    "description": "Enable viewing Jira issues in GitLab.\n"
                },
                "jiraAuthType": {
                    "type": "integer",
                    "description": "The authentication method to be used with Jira. 0 means Basic Authentication. 1 means Jira personal access token. Defaults to 0.\n"
                },
                "jiraIssuePrefix": {
                    "type": "string",
                    "description": "Prefix to match Jira issue keys.\n"
                },
                "jiraIssueRegex": {
                    "type": "string",
                    "description": "Regular expression to match Jira issue keys.\n"
                },
                "jiraIssueTransitionAutomatic": {
                    "type": "boolean",
                    "description": "Enable automatic issue transitions. Takes precedence over jira*issue*transition_id if enabled. Defaults to false.\n"
                },
                "jiraIssueTransitionId": {
                    "type": "string",
                    "description": "The ID of a transition that moves issues to a closed state. You can find this number under the JIRA workflow administration (Administration \u003e Issues \u003e Workflows) by selecting View under Operations of the desired workflow of your project. By default, this ID is set to 2. *Note**: importing this field is only supported since GitLab 15.2.\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for merge request events\n"
                },
                "password": {
                    "type": "string",
                    "description": "The Jira API token, password, or personal access token to be used with Jira. When your authentication method is basic (jira*auth*type is 0), use an API token for Jira Cloud or a password for Jira Data Center or Jira Server. When your authentication method is a Jira personal access token (jira*auth*type is 1), use the personal access token.\n",
                    "secret": true
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n"
                },
                "projectKey": {
                    "type": "string",
                    "description": "The short identifier for your JIRA project, all uppercase, e.g., PROJ.\n"
                },
                "projectKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Keys of Jira projects. When issues_enabled is true, this setting specifies which Jira projects to view issues from in GitLab.\n"
                },
                "title": {
                    "type": "string",
                    "description": "Title.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "Update time.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL to the JIRA project which is being linked to this GitLab project. For example, https://jira.example.com.\n"
                },
                "useInheritedSettings": {
                    "type": "boolean",
                    "description": "Indicates whether or not to inherit default settings. Defaults to false.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The email or username to be used with Jira. For Jira Cloud use an email, for Jira Data Center and Jira Server use a username. Required when using Basic authentication (jira*auth*type is 0).\n"
                }
            },
            "required": [
                "active",
                "apiUrl",
                "commitEvents",
                "createdAt",
                "mergeRequestsEvents",
                "password",
                "project",
                "title",
                "updatedAt",
                "url"
            ],
            "inputProperties": {
                "apiUrl": {
                    "type": "string",
                    "description": "The base URL to the Jira instance API. Web URL value is used if not set. For example, https://jira-api.example.com.\n"
                },
                "commentOnEventEnabled": {
                    "type": "boolean",
                    "description": "Enable comments inside Jira issues on each GitLab event (commit / merge request)\n"
                },
                "commitEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for commit events\n"
                },
                "issuesEnabled": {
                    "type": "boolean",
                    "description": "Enable viewing Jira issues in GitLab.\n"
                },
                "jiraAuthType": {
                    "type": "integer",
                    "description": "The authentication method to be used with Jira. 0 means Basic Authentication. 1 means Jira personal access token. Defaults to 0.\n"
                },
                "jiraIssuePrefix": {
                    "type": "string",
                    "description": "Prefix to match Jira issue keys.\n"
                },
                "jiraIssueRegex": {
                    "type": "string",
                    "description": "Regular expression to match Jira issue keys.\n"
                },
                "jiraIssueTransitionAutomatic": {
                    "type": "boolean",
                    "description": "Enable automatic issue transitions. Takes precedence over jira*issue*transition_id if enabled. Defaults to false.\n"
                },
                "jiraIssueTransitionId": {
                    "type": "string",
                    "description": "The ID of a transition that moves issues to a closed state. You can find this number under the JIRA workflow administration (Administration \u003e Issues \u003e Workflows) by selecting View under Operations of the desired workflow of your project. By default, this ID is set to 2. *Note**: importing this field is only supported since GitLab 15.2.\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for merge request events\n"
                },
                "password": {
                    "type": "string",
                    "description": "The Jira API token, password, or personal access token to be used with Jira. When your authentication method is basic (jira*auth*type is 0), use an API token for Jira Cloud or a password for Jira Data Center or Jira Server. When your authentication method is a Jira personal access token (jira*auth*type is 1), use the personal access token.\n",
                    "secret": true
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n",
                    "willReplaceOnChanges": true
                },
                "projectKey": {
                    "type": "string",
                    "description": "The short identifier for your JIRA project, all uppercase, e.g., PROJ.\n"
                },
                "projectKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Keys of Jira projects. When issues_enabled is true, this setting specifies which Jira projects to view issues from in GitLab.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The URL to the JIRA project which is being linked to this GitLab project. For example, https://jira.example.com.\n"
                },
                "useInheritedSettings": {
                    "type": "boolean",
                    "description": "Indicates whether or not to inherit default settings. Defaults to false.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The email or username to be used with Jira. For Jira Cloud use an email, for Jira Data Center and Jira Server use a username. Required when using Basic authentication (jira*auth*type is 0).\n"
                }
            },
            "requiredInputs": [
                "password",
                "project",
                "url"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ServiceJira resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "Whether the integration is active.\n"
                    },
                    "apiUrl": {
                        "type": "string",
                        "description": "The base URL to the Jira instance API. Web URL value is used if not set. For example, https://jira-api.example.com.\n"
                    },
                    "commentOnEventEnabled": {
                        "type": "boolean",
                        "description": "Enable comments inside Jira issues on each GitLab event (commit / merge request)\n"
                    },
                    "commitEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for commit events\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Create time.\n"
                    },
                    "issuesEnabled": {
                        "type": "boolean",
                        "description": "Enable viewing Jira issues in GitLab.\n"
                    },
                    "jiraAuthType": {
                        "type": "integer",
                        "description": "The authentication method to be used with Jira. 0 means Basic Authentication. 1 means Jira personal access token. Defaults to 0.\n"
                    },
                    "jiraIssuePrefix": {
                        "type": "string",
                        "description": "Prefix to match Jira issue keys.\n"
                    },
                    "jiraIssueRegex": {
                        "type": "string",
                        "description": "Regular expression to match Jira issue keys.\n"
                    },
                    "jiraIssueTransitionAutomatic": {
                        "type": "boolean",
                        "description": "Enable automatic issue transitions. Takes precedence over jira*issue*transition_id if enabled. Defaults to false.\n"
                    },
                    "jiraIssueTransitionId": {
                        "type": "string",
                        "description": "The ID of a transition that moves issues to a closed state. You can find this number under the JIRA workflow administration (Administration \u003e Issues \u003e Workflows) by selecting View under Operations of the desired workflow of your project. By default, this ID is set to 2. *Note**: importing this field is only supported since GitLab 15.2.\n"
                    },
                    "mergeRequestsEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for merge request events\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "The Jira API token, password, or personal access token to be used with Jira. When your authentication method is basic (jira*auth*type is 0), use an API token for Jira Cloud or a password for Jira Data Center or Jira Server. When your authentication method is a Jira personal access token (jira*auth*type is 1), use the personal access token.\n",
                        "secret": true
                    },
                    "project": {
                        "type": "string",
                        "description": "ID of the project you want to activate integration on.\n",
                        "willReplaceOnChanges": true
                    },
                    "projectKey": {
                        "type": "string",
                        "description": "The short identifier for your JIRA project, all uppercase, e.g., PROJ.\n"
                    },
                    "projectKeys": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Keys of Jira projects. When issues_enabled is true, this setting specifies which Jira projects to view issues from in GitLab.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "Title.\n"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "Update time.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "The URL to the JIRA project which is being linked to this GitLab project. For example, https://jira.example.com.\n"
                    },
                    "useInheritedSettings": {
                        "type": "boolean",
                        "description": "Indicates whether or not to inherit default settings. Defaults to false.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "The email or username to be used with Jira. For Jira Cloud use an email, for Jira Data Center and Jira Server use a username. Required when using Basic authentication (jira*auth*type is 0).\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/serviceMicrosoftTeams:ServiceMicrosoftTeams": {
            "description": "The `gitlab.ServiceMicrosoftTeams` resource allows to manage the lifecycle of a project integration with Microsoft Teams.\n\n\u003e This resource is deprecated. use `gitlab.IntegrationMicrosoftTeams`instead!\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/integrations.html#microsoft-teams)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst awesomeProject = new gitlab.Project(\"awesome_project\", {\n    name: \"awesome_project\",\n    description: \"My awesome project.\",\n    visibilityLevel: \"public\",\n});\nconst teams = new gitlab.ServiceMicrosoftTeams(\"teams\", {\n    project: awesomeProject.id,\n    webhook: \"https://testurl.com/?token=XYZ\",\n    pushEvents: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nawesome_project = gitlab.Project(\"awesome_project\",\n    name=\"awesome_project\",\n    description=\"My awesome project.\",\n    visibility_level=\"public\")\nteams = gitlab.ServiceMicrosoftTeams(\"teams\",\n    project=awesome_project.id,\n    webhook=\"https://testurl.com/?token=XYZ\",\n    push_events=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var awesomeProject = new GitLab.Project(\"awesome_project\", new()\n    {\n        Name = \"awesome_project\",\n        Description = \"My awesome project.\",\n        VisibilityLevel = \"public\",\n    });\n\n    var teams = new GitLab.ServiceMicrosoftTeams(\"teams\", new()\n    {\n        Project = awesomeProject.Id,\n        Webhook = \"https://testurl.com/?token=XYZ\",\n        PushEvents = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tawesomeProject, err := gitlab.NewProject(ctx, \"awesome_project\", \u0026gitlab.ProjectArgs{\n\t\t\tName:            pulumi.String(\"awesome_project\"),\n\t\t\tDescription:     pulumi.String(\"My awesome project.\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewServiceMicrosoftTeams(ctx, \"teams\", \u0026gitlab.ServiceMicrosoftTeamsArgs{\n\t\t\tProject:    awesomeProject.ID(),\n\t\t\tWebhook:    pulumi.String(\"https://testurl.com/?token=XYZ\"),\n\t\t\tPushEvents: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ServiceMicrosoftTeams;\nimport com.pulumi.gitlab.ServiceMicrosoftTeamsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var awesomeProject = new Project(\"awesomeProject\", ProjectArgs.builder()\n            .name(\"awesome_project\")\n            .description(\"My awesome project.\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var teams = new ServiceMicrosoftTeams(\"teams\", ServiceMicrosoftTeamsArgs.builder()\n            .project(awesomeProject.id())\n            .webhook(\"https://testurl.com/?token=XYZ\")\n            .pushEvents(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  awesomeProject:\n    type: gitlab:Project\n    name: awesome_project\n    properties:\n      name: awesome_project\n      description: My awesome project.\n      visibilityLevel: public\n  teams:\n    type: gitlab:ServiceMicrosoftTeams\n    properties:\n      project: ${awesomeProject.id}\n      webhook: https://testurl.com/?token=XYZ\n      pushEvents: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_service_microsoft_teams`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_service_microsoft_teams.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nYou can import a gitlab_service_microsoft_teams state using the project ID, e.g.\n\n```sh\n$ pulumi import gitlab:index/serviceMicrosoftTeams:ServiceMicrosoftTeams teams 1\n```\n\n",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "Whether the integration is active.\n"
                },
                "branchesToBeNotified": {
                    "type": "string",
                    "description": "Branches to send notifications for. Valid options are “all”, “default”, “protected”, and “default*and*protected”. The default value is “default”\n"
                },
                "confidentialIssuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential issue events\n"
                },
                "confidentialNoteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential note events\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Create time.\n"
                },
                "issuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for issue events\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for merge request events\n"
                },
                "noteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for note events\n"
                },
                "notifyOnlyBrokenPipelines": {
                    "type": "boolean",
                    "description": "Send notifications for broken pipelines\n"
                },
                "pipelineEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for pipeline events\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for push events\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for tag push events\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "Update time.\n"
                },
                "webhook": {
                    "type": "string",
                    "description": "The Microsoft Teams webhook (Example, https://outlook.office.com/webhook/...). This value cannot be imported.\n"
                },
                "wikiPageEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for wiki page events\n"
                }
            },
            "required": [
                "active",
                "createdAt",
                "project",
                "updatedAt",
                "webhook"
            ],
            "inputProperties": {
                "branchesToBeNotified": {
                    "type": "string",
                    "description": "Branches to send notifications for. Valid options are “all”, “default”, “protected”, and “default*and*protected”. The default value is “default”\n"
                },
                "confidentialIssuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential issue events\n"
                },
                "confidentialNoteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential note events\n"
                },
                "issuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for issue events\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for merge request events\n"
                },
                "noteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for note events\n"
                },
                "notifyOnlyBrokenPipelines": {
                    "type": "boolean",
                    "description": "Send notifications for broken pipelines\n"
                },
                "pipelineEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for pipeline events\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n",
                    "willReplaceOnChanges": true
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for push events\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for tag push events\n"
                },
                "webhook": {
                    "type": "string",
                    "description": "The Microsoft Teams webhook (Example, https://outlook.office.com/webhook/...). This value cannot be imported.\n"
                },
                "wikiPageEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for wiki page events\n"
                }
            },
            "requiredInputs": [
                "project",
                "webhook"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ServiceMicrosoftTeams resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "Whether the integration is active.\n"
                    },
                    "branchesToBeNotified": {
                        "type": "string",
                        "description": "Branches to send notifications for. Valid options are “all”, “default”, “protected”, and “default*and*protected”. The default value is “default”\n"
                    },
                    "confidentialIssuesEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for confidential issue events\n"
                    },
                    "confidentialNoteEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for confidential note events\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Create time.\n"
                    },
                    "issuesEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for issue events\n"
                    },
                    "mergeRequestsEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for merge request events\n"
                    },
                    "noteEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for note events\n"
                    },
                    "notifyOnlyBrokenPipelines": {
                        "type": "boolean",
                        "description": "Send notifications for broken pipelines\n"
                    },
                    "pipelineEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for pipeline events\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "ID of the project you want to activate integration on.\n",
                        "willReplaceOnChanges": true
                    },
                    "pushEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for push events\n"
                    },
                    "tagPushEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for tag push events\n"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "Update time.\n"
                    },
                    "webhook": {
                        "type": "string",
                        "description": "The Microsoft Teams webhook (Example, https://outlook.office.com/webhook/...). This value cannot be imported.\n"
                    },
                    "wikiPageEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for wiki page events\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/servicePipelinesEmail:ServicePipelinesEmail": {
            "description": "The `gitlab.ServicePipelinesEmail` resource allows to manage the lifecycle of a project integration with Pipeline Emails Service.\n\n\u003e This resource is deprecated. use `gitlab.IntegrationPipelinesEmail`instead!\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/integrations.html#pipeline-emails)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst awesomeProject = new gitlab.Project(\"awesome_project\", {\n    name: \"awesome_project\",\n    description: \"My awesome project.\",\n    visibilityLevel: \"public\",\n});\nconst email = new gitlab.ServicePipelinesEmail(\"email\", {\n    project: awesomeProject.id,\n    recipients: [\"gitlab@user.create\"],\n    notifyOnlyBrokenPipelines: true,\n    branchesToBeNotified: \"all\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nawesome_project = gitlab.Project(\"awesome_project\",\n    name=\"awesome_project\",\n    description=\"My awesome project.\",\n    visibility_level=\"public\")\nemail = gitlab.ServicePipelinesEmail(\"email\",\n    project=awesome_project.id,\n    recipients=[\"gitlab@user.create\"],\n    notify_only_broken_pipelines=True,\n    branches_to_be_notified=\"all\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var awesomeProject = new GitLab.Project(\"awesome_project\", new()\n    {\n        Name = \"awesome_project\",\n        Description = \"My awesome project.\",\n        VisibilityLevel = \"public\",\n    });\n\n    var email = new GitLab.ServicePipelinesEmail(\"email\", new()\n    {\n        Project = awesomeProject.Id,\n        Recipients = new[]\n        {\n            \"gitlab@user.create\",\n        },\n        NotifyOnlyBrokenPipelines = true,\n        BranchesToBeNotified = \"all\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tawesomeProject, err := gitlab.NewProject(ctx, \"awesome_project\", \u0026gitlab.ProjectArgs{\n\t\t\tName:            pulumi.String(\"awesome_project\"),\n\t\t\tDescription:     pulumi.String(\"My awesome project.\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewServicePipelinesEmail(ctx, \"email\", \u0026gitlab.ServicePipelinesEmailArgs{\n\t\t\tProject: awesomeProject.ID(),\n\t\t\tRecipients: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"gitlab@user.create\"),\n\t\t\t},\n\t\t\tNotifyOnlyBrokenPipelines: pulumi.Bool(true),\n\t\t\tBranchesToBeNotified:      pulumi.String(\"all\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ServicePipelinesEmail;\nimport com.pulumi.gitlab.ServicePipelinesEmailArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var awesomeProject = new Project(\"awesomeProject\", ProjectArgs.builder()\n            .name(\"awesome_project\")\n            .description(\"My awesome project.\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var email = new ServicePipelinesEmail(\"email\", ServicePipelinesEmailArgs.builder()\n            .project(awesomeProject.id())\n            .recipients(\"gitlab@user.create\")\n            .notifyOnlyBrokenPipelines(true)\n            .branchesToBeNotified(\"all\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  awesomeProject:\n    type: gitlab:Project\n    name: awesome_project\n    properties:\n      name: awesome_project\n      description: My awesome project.\n      visibilityLevel: public\n  email:\n    type: gitlab:ServicePipelinesEmail\n    properties:\n      project: ${awesomeProject.id}\n      recipients:\n        - gitlab@user.create\n      notifyOnlyBrokenPipelines: true\n      branchesToBeNotified: all\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_service_pipelines_email`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_service_pipelines_email.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nYou can import a gitlab_service_pipelines_email state using the project ID, e.g.\n\n```sh\n$ pulumi import gitlab:index/servicePipelinesEmail:ServicePipelinesEmail email 1\n```\n\n",
            "properties": {
                "branchesToBeNotified": {
                    "type": "string",
                    "description": "Branches to send notifications for. Valid options are `all`, `default`, `protected`, and `default_and_protected`. Default is `default`\n"
                },
                "notifyOnlyBrokenPipelines": {
                    "type": "boolean",
                    "description": "Notify only broken pipelines. Default is true.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n"
                },
                "recipients": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ") email addresses where notifications are sent.\n"
                }
            },
            "required": [
                "project",
                "recipients"
            ],
            "inputProperties": {
                "branchesToBeNotified": {
                    "type": "string",
                    "description": "Branches to send notifications for. Valid options are `all`, `default`, `protected`, and `default_and_protected`. Default is `default`\n"
                },
                "notifyOnlyBrokenPipelines": {
                    "type": "boolean",
                    "description": "Notify only broken pipelines. Default is true.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n",
                    "willReplaceOnChanges": true
                },
                "recipients": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": ") email addresses where notifications are sent.\n"
                }
            },
            "requiredInputs": [
                "project",
                "recipients"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ServicePipelinesEmail resources.\n",
                "properties": {
                    "branchesToBeNotified": {
                        "type": "string",
                        "description": "Branches to send notifications for. Valid options are `all`, `default`, `protected`, and `default_and_protected`. Default is `default`\n"
                    },
                    "notifyOnlyBrokenPipelines": {
                        "type": "boolean",
                        "description": "Notify only broken pipelines. Default is true.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "ID of the project you want to activate integration on.\n",
                        "willReplaceOnChanges": true
                    },
                    "recipients": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": ") email addresses where notifications are sent.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/serviceSlack:ServiceSlack": {
            "description": "The `gitlab.ServiceSlack` resource allows to manage the lifecycle of a project integration with Slack.\n\n\u003e This resource is deprecated. use `gitlab.IntegrationSlack`instead!\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/integrations.html#slack-notifications)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst awesomeProject = new gitlab.Project(\"awesome_project\", {\n    name: \"awesome_project\",\n    description: \"My awesome project.\",\n    visibilityLevel: \"public\",\n});\nconst slack = new gitlab.ServiceSlack(\"slack\", {\n    project: awesomeProject.id,\n    webhook: \"https://webhook.com\",\n    username: \"myuser\",\n    pushEvents: true,\n    pushChannel: \"push_chan\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nawesome_project = gitlab.Project(\"awesome_project\",\n    name=\"awesome_project\",\n    description=\"My awesome project.\",\n    visibility_level=\"public\")\nslack = gitlab.ServiceSlack(\"slack\",\n    project=awesome_project.id,\n    webhook=\"https://webhook.com\",\n    username=\"myuser\",\n    push_events=True,\n    push_channel=\"push_chan\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var awesomeProject = new GitLab.Project(\"awesome_project\", new()\n    {\n        Name = \"awesome_project\",\n        Description = \"My awesome project.\",\n        VisibilityLevel = \"public\",\n    });\n\n    var slack = new GitLab.ServiceSlack(\"slack\", new()\n    {\n        Project = awesomeProject.Id,\n        Webhook = \"https://webhook.com\",\n        Username = \"myuser\",\n        PushEvents = true,\n        PushChannel = \"push_chan\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tawesomeProject, err := gitlab.NewProject(ctx, \"awesome_project\", \u0026gitlab.ProjectArgs{\n\t\t\tName:            pulumi.String(\"awesome_project\"),\n\t\t\tDescription:     pulumi.String(\"My awesome project.\"),\n\t\t\tVisibilityLevel: pulumi.String(\"public\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewServiceSlack(ctx, \"slack\", \u0026gitlab.ServiceSlackArgs{\n\t\t\tProject:     awesomeProject.ID(),\n\t\t\tWebhook:     pulumi.String(\"https://webhook.com\"),\n\t\t\tUsername:    pulumi.String(\"myuser\"),\n\t\t\tPushEvents:  pulumi.Bool(true),\n\t\t\tPushChannel: pulumi.String(\"push_chan\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.ServiceSlack;\nimport com.pulumi.gitlab.ServiceSlackArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var awesomeProject = new Project(\"awesomeProject\", ProjectArgs.builder()\n            .name(\"awesome_project\")\n            .description(\"My awesome project.\")\n            .visibilityLevel(\"public\")\n            .build());\n\n        var slack = new ServiceSlack(\"slack\", ServiceSlackArgs.builder()\n            .project(awesomeProject.id())\n            .webhook(\"https://webhook.com\")\n            .username(\"myuser\")\n            .pushEvents(true)\n            .pushChannel(\"push_chan\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  awesomeProject:\n    type: gitlab:Project\n    name: awesome_project\n    properties:\n      name: awesome_project\n      description: My awesome project.\n      visibilityLevel: public\n  slack:\n    type: gitlab:ServiceSlack\n    properties:\n      project: ${awesomeProject.id}\n      webhook: https://webhook.com\n      username: myuser\n      pushEvents: true\n      pushChannel: push_chan\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_service_slack`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_service_slack.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nYou can import a gitlab_service_slack.slack state using the project ID, e.g.\n\n```sh\n$ pulumi import gitlab:index/serviceSlack:ServiceSlack email 1\n```\n\n",
            "properties": {
                "branchesToBeNotified": {
                    "type": "string",
                    "description": "Branches to send notifications for. Valid options are \"all\", \"default\", \"protected\", and \"default*and*protected\".\n"
                },
                "confidentialIssueChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive confidential issue events notifications.\n"
                },
                "confidentialIssuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential issues events.\n"
                },
                "confidentialNoteChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive confidential note events notifications.\n"
                },
                "confidentialNoteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential note events.\n"
                },
                "issueChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive issue events notifications.\n"
                },
                "issuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for issues events.\n"
                },
                "jobEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for job events. **ATTENTION**: This attribute is currently not being submitted to the GitLab API, due to https://github.com/xanzy/go-gitlab/issues/1354.\n"
                },
                "mergeRequestChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive merge request events notifications.\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for merge requests events.\n"
                },
                "noteChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive note events notifications.\n"
                },
                "noteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for note events.\n"
                },
                "notifyOnlyBrokenPipelines": {
                    "type": "boolean",
                    "description": "Send notifications for broken pipelines.\n"
                },
                "notifyOnlyDefaultBranch": {
                    "type": "boolean",
                    "description": "This parameter has been replaced with `branches_to_be_notified`.\n",
                    "deprecationMessage": "use 'branches_to_be_notified' argument instead"
                },
                "pipelineChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive pipeline events notifications.\n"
                },
                "pipelineEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for pipeline events.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n"
                },
                "pushChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive push events notifications.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for push events.\n"
                },
                "tagPushChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive tag push events notifications.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for tag push events.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username to use.\n"
                },
                "webhook": {
                    "type": "string",
                    "description": "Webhook URL (Example, https://hooks.slack.com/services/...). This value cannot be imported.\n"
                },
                "wikiPageChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive wiki page events notifications.\n"
                },
                "wikiPageEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for wiki page events.\n"
                }
            },
            "required": [
                "branchesToBeNotified",
                "confidentialIssuesEvents",
                "confidentialNoteChannel",
                "confidentialNoteEvents",
                "issuesEvents",
                "jobEvents",
                "mergeRequestsEvents",
                "noteEvents",
                "notifyOnlyBrokenPipelines",
                "notifyOnlyDefaultBranch",
                "pipelineEvents",
                "project",
                "pushEvents",
                "tagPushEvents",
                "webhook",
                "wikiPageEvents"
            ],
            "inputProperties": {
                "branchesToBeNotified": {
                    "type": "string",
                    "description": "Branches to send notifications for. Valid options are \"all\", \"default\", \"protected\", and \"default*and*protected\".\n"
                },
                "confidentialIssueChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive confidential issue events notifications.\n"
                },
                "confidentialIssuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential issues events.\n"
                },
                "confidentialNoteChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive confidential note events notifications.\n"
                },
                "confidentialNoteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for confidential note events.\n"
                },
                "issueChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive issue events notifications.\n"
                },
                "issuesEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for issues events.\n"
                },
                "mergeRequestChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive merge request events notifications.\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for merge requests events.\n"
                },
                "noteChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive note events notifications.\n"
                },
                "noteEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for note events.\n"
                },
                "notifyOnlyBrokenPipelines": {
                    "type": "boolean",
                    "description": "Send notifications for broken pipelines.\n"
                },
                "notifyOnlyDefaultBranch": {
                    "type": "boolean",
                    "description": "This parameter has been replaced with `branches_to_be_notified`.\n",
                    "deprecationMessage": "use 'branches_to_be_notified' argument instead"
                },
                "pipelineChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive pipeline events notifications.\n"
                },
                "pipelineEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for pipeline events.\n"
                },
                "project": {
                    "type": "string",
                    "description": "ID of the project you want to activate integration on.\n",
                    "willReplaceOnChanges": true
                },
                "pushChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive push events notifications.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for push events.\n"
                },
                "tagPushChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive tag push events notifications.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for tag push events.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username to use.\n"
                },
                "webhook": {
                    "type": "string",
                    "description": "Webhook URL (Example, https://hooks.slack.com/services/...). This value cannot be imported.\n"
                },
                "wikiPageChannel": {
                    "type": "string",
                    "description": "The name of the channel to receive wiki page events notifications.\n"
                },
                "wikiPageEvents": {
                    "type": "boolean",
                    "description": "Enable notifications for wiki page events.\n"
                }
            },
            "requiredInputs": [
                "project",
                "webhook"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ServiceSlack resources.\n",
                "properties": {
                    "branchesToBeNotified": {
                        "type": "string",
                        "description": "Branches to send notifications for. Valid options are \"all\", \"default\", \"protected\", and \"default*and*protected\".\n"
                    },
                    "confidentialIssueChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive confidential issue events notifications.\n"
                    },
                    "confidentialIssuesEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for confidential issues events.\n"
                    },
                    "confidentialNoteChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive confidential note events notifications.\n"
                    },
                    "confidentialNoteEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for confidential note events.\n"
                    },
                    "issueChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive issue events notifications.\n"
                    },
                    "issuesEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for issues events.\n"
                    },
                    "jobEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for job events. **ATTENTION**: This attribute is currently not being submitted to the GitLab API, due to https://github.com/xanzy/go-gitlab/issues/1354.\n"
                    },
                    "mergeRequestChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive merge request events notifications.\n"
                    },
                    "mergeRequestsEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for merge requests events.\n"
                    },
                    "noteChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive note events notifications.\n"
                    },
                    "noteEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for note events.\n"
                    },
                    "notifyOnlyBrokenPipelines": {
                        "type": "boolean",
                        "description": "Send notifications for broken pipelines.\n"
                    },
                    "notifyOnlyDefaultBranch": {
                        "type": "boolean",
                        "description": "This parameter has been replaced with `branches_to_be_notified`.\n",
                        "deprecationMessage": "use 'branches_to_be_notified' argument instead"
                    },
                    "pipelineChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive pipeline events notifications.\n"
                    },
                    "pipelineEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for pipeline events.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "ID of the project you want to activate integration on.\n",
                        "willReplaceOnChanges": true
                    },
                    "pushChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive push events notifications.\n"
                    },
                    "pushEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for push events.\n"
                    },
                    "tagPushChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive tag push events notifications.\n"
                    },
                    "tagPushEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for tag push events.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Username to use.\n"
                    },
                    "webhook": {
                        "type": "string",
                        "description": "Webhook URL (Example, https://hooks.slack.com/services/...). This value cannot be imported.\n"
                    },
                    "wikiPageChannel": {
                        "type": "string",
                        "description": "The name of the channel to receive wiki page events notifications.\n"
                    },
                    "wikiPageEvents": {
                        "type": "boolean",
                        "description": "Enable notifications for wiki page events.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/systemHook:SystemHook": {
            "description": "The `gitlab.SystemHook` resource allows to manage the lifecycle of a system hook.\n\n\u003e This resource requires GitLab 14.9\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/system_hooks.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = new gitlab.SystemHook(\"example\", {\n    url: \"https://example.com/hook-%d\",\n    token: \"secret-token\",\n    pushEvents: true,\n    tagPushEvents: true,\n    mergeRequestsEvents: true,\n    repositoryUpdateEvents: true,\n    enableSslVerification: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.SystemHook(\"example\",\n    url=\"https://example.com/hook-%d\",\n    token=\"secret-token\",\n    push_events=True,\n    tag_push_events=True,\n    merge_requests_events=True,\n    repository_update_events=True,\n    enable_ssl_verification=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new GitLab.SystemHook(\"example\", new()\n    {\n        Url = \"https://example.com/hook-%d\",\n        Token = \"secret-token\",\n        PushEvents = true,\n        TagPushEvents = true,\n        MergeRequestsEvents = true,\n        RepositoryUpdateEvents = true,\n        EnableSslVerification = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewSystemHook(ctx, \"example\", \u0026gitlab.SystemHookArgs{\n\t\t\tUrl:                    pulumi.String(\"https://example.com/hook-%d\"),\n\t\t\tToken:                  pulumi.String(\"secret-token\"),\n\t\t\tPushEvents:             pulumi.Bool(true),\n\t\t\tTagPushEvents:          pulumi.Bool(true),\n\t\t\tMergeRequestsEvents:    pulumi.Bool(true),\n\t\t\tRepositoryUpdateEvents: pulumi.Bool(true),\n\t\t\tEnableSslVerification:  pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.SystemHook;\nimport com.pulumi.gitlab.SystemHookArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new SystemHook(\"example\", SystemHookArgs.builder()\n            .url(\"https://example.com/hook-%d\")\n            .token(\"secret-token\")\n            .pushEvents(true)\n            .tagPushEvents(true)\n            .mergeRequestsEvents(true)\n            .repositoryUpdateEvents(true)\n            .enableSslVerification(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: gitlab:SystemHook\n    properties:\n      url: https://example.com/hook-%d\n      token: secret-token\n      pushEvents: true\n      tagPushEvents: true\n      mergeRequestsEvents: true\n      repositoryUpdateEvents: true\n      enableSslVerification: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_system_hook`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_system_hook.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nYou can import a system hook using the hook id `{hook-id}`, e.g.\n\n```sh\n$ pulumi import gitlab:index/systemHook:SystemHook example 42\n```\n\nNOTE: the `token` attribute won't be available for imported resources.\n\n",
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "The date and time the hook was created in ISO8601 format.\n"
                },
                "enableSslVerification": {
                    "type": "boolean",
                    "description": "Do SSL verification when triggering the hook.\n"
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Trigger hook on merge requests events.\n"
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "When true, the hook fires on push events.\n"
                },
                "repositoryUpdateEvents": {
                    "type": "boolean",
                    "description": "Trigger hook on repository update events.\n"
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "When true, the hook fires on new tags being pushed.\n"
                },
                "token": {
                    "type": "string",
                    "description": "Secret token to validate received payloads; this isn’t returned in the response. This attribute is not available for imported resources.\n",
                    "secret": true
                },
                "url": {
                    "type": "string",
                    "description": "The hook URL.\n"
                }
            },
            "required": [
                "createdAt",
                "url"
            ],
            "inputProperties": {
                "enableSslVerification": {
                    "type": "boolean",
                    "description": "Do SSL verification when triggering the hook.\n",
                    "willReplaceOnChanges": true
                },
                "mergeRequestsEvents": {
                    "type": "boolean",
                    "description": "Trigger hook on merge requests events.\n",
                    "willReplaceOnChanges": true
                },
                "pushEvents": {
                    "type": "boolean",
                    "description": "When true, the hook fires on push events.\n",
                    "willReplaceOnChanges": true
                },
                "repositoryUpdateEvents": {
                    "type": "boolean",
                    "description": "Trigger hook on repository update events.\n",
                    "willReplaceOnChanges": true
                },
                "tagPushEvents": {
                    "type": "boolean",
                    "description": "When true, the hook fires on new tags being pushed.\n",
                    "willReplaceOnChanges": true
                },
                "token": {
                    "type": "string",
                    "description": "Secret token to validate received payloads; this isn’t returned in the response. This attribute is not available for imported resources.\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                },
                "url": {
                    "type": "string",
                    "description": "The hook URL.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "url"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SystemHook resources.\n",
                "properties": {
                    "createdAt": {
                        "type": "string",
                        "description": "The date and time the hook was created in ISO8601 format.\n"
                    },
                    "enableSslVerification": {
                        "type": "boolean",
                        "description": "Do SSL verification when triggering the hook.\n",
                        "willReplaceOnChanges": true
                    },
                    "mergeRequestsEvents": {
                        "type": "boolean",
                        "description": "Trigger hook on merge requests events.\n",
                        "willReplaceOnChanges": true
                    },
                    "pushEvents": {
                        "type": "boolean",
                        "description": "When true, the hook fires on push events.\n",
                        "willReplaceOnChanges": true
                    },
                    "repositoryUpdateEvents": {
                        "type": "boolean",
                        "description": "Trigger hook on repository update events.\n",
                        "willReplaceOnChanges": true
                    },
                    "tagPushEvents": {
                        "type": "boolean",
                        "description": "When true, the hook fires on new tags being pushed.\n",
                        "willReplaceOnChanges": true
                    },
                    "token": {
                        "type": "string",
                        "description": "Secret token to validate received payloads; this isn’t returned in the response. This attribute is not available for imported resources.\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "url": {
                        "type": "string",
                        "description": "The hook URL.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/tagProtection:TagProtection": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst tagProtect = new gitlab.TagProtection(\"TagProtect\", {\n    project: \"12345\",\n    tag: \"TagProtected\",\n    createAccessLevel: \"developer\",\n    allowedToCreates: [\n        {\n            userId: 42,\n        },\n        {\n            groupId: 43,\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\ntag_protect = gitlab.TagProtection(\"TagProtect\",\n    project=\"12345\",\n    tag=\"TagProtected\",\n    create_access_level=\"developer\",\n    allowed_to_creates=[\n        {\n            \"user_id\": 42,\n        },\n        {\n            \"group_id\": 43,\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var tagProtect = new GitLab.TagProtection(\"TagProtect\", new()\n    {\n        Project = \"12345\",\n        Tag = \"TagProtected\",\n        CreateAccessLevel = \"developer\",\n        AllowedToCreates = new[]\n        {\n            new GitLab.Inputs.TagProtectionAllowedToCreateArgs\n            {\n                UserId = 42,\n            },\n            new GitLab.Inputs.TagProtectionAllowedToCreateArgs\n            {\n                GroupId = 43,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewTagProtection(ctx, \"TagProtect\", \u0026gitlab.TagProtectionArgs{\n\t\t\tProject:           pulumi.String(\"12345\"),\n\t\t\tTag:               pulumi.String(\"TagProtected\"),\n\t\t\tCreateAccessLevel: pulumi.String(\"developer\"),\n\t\t\tAllowedToCreates: gitlab.TagProtectionAllowedToCreateArray{\n\t\t\t\t\u0026gitlab.TagProtectionAllowedToCreateArgs{\n\t\t\t\t\tUserId: pulumi.Int(42),\n\t\t\t\t},\n\t\t\t\t\u0026gitlab.TagProtectionAllowedToCreateArgs{\n\t\t\t\t\tGroupId: pulumi.Int(43),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.TagProtection;\nimport com.pulumi.gitlab.TagProtectionArgs;\nimport com.pulumi.gitlab.inputs.TagProtectionAllowedToCreateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var tagProtect = new TagProtection(\"tagProtect\", TagProtectionArgs.builder()\n            .project(\"12345\")\n            .tag(\"TagProtected\")\n            .createAccessLevel(\"developer\")\n            .allowedToCreates(            \n                TagProtectionAllowedToCreateArgs.builder()\n                    .userId(42)\n                    .build(),\n                TagProtectionAllowedToCreateArgs.builder()\n                    .groupId(43)\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  tagProtect:\n    type: gitlab:TagProtection\n    name: TagProtect\n    properties:\n      project: '12345'\n      tag: TagProtected\n      createAccessLevel: developer\n      allowedToCreates:\n        - userId: 42\n        - groupId: 43\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_tag_protection`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_tag_protection.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nTag protections can be imported using an id made up of `project_id:tag_name`, e.g.\n\n```sh\n$ pulumi import gitlab:index/tagProtection:TagProtection example 123456789:v1.0.0\n```\n\n",
            "properties": {
                "allowedToCreates": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/TagProtectionAllowedToCreate:TagProtectionAllowedToCreate"
                    },
                    "description": "Array of access levels/user(s)/group(s) allowed to create protected tags.\n"
                },
                "createAccessLevel": {
                    "type": "string",
                    "description": "Access levels allowed to create. Default value of `maintainer`. The default value is always sent if not provided in the configuration. Valid values are: `no one`, `developer`, `maintainer`.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The id of the project.\n"
                },
                "tag": {
                    "type": "string",
                    "description": "Name of the tag or wildcard.\n"
                }
            },
            "required": [
                "createAccessLevel",
                "project",
                "tag"
            ],
            "inputProperties": {
                "allowedToCreates": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/gitlab:index/TagProtectionAllowedToCreate:TagProtectionAllowedToCreate"
                    },
                    "description": "Array of access levels/user(s)/group(s) allowed to create protected tags.\n"
                },
                "createAccessLevel": {
                    "type": "string",
                    "description": "Access levels allowed to create. Default value of `maintainer`. The default value is always sent if not provided in the configuration. Valid values are: `no one`, `developer`, `maintainer`.\n"
                },
                "project": {
                    "type": "string",
                    "description": "The id of the project.\n"
                },
                "tag": {
                    "type": "string",
                    "description": "Name of the tag or wildcard.\n"
                }
            },
            "requiredInputs": [
                "project",
                "tag"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TagProtection resources.\n",
                "properties": {
                    "allowedToCreates": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/TagProtectionAllowedToCreate:TagProtectionAllowedToCreate"
                        },
                        "description": "Array of access levels/user(s)/group(s) allowed to create protected tags.\n"
                    },
                    "createAccessLevel": {
                        "type": "string",
                        "description": "Access levels allowed to create. Default value of `maintainer`. The default value is always sent if not provided in the configuration. Valid values are: `no one`, `developer`, `maintainer`.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The id of the project.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "Name of the tag or wildcard.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/topic:Topic": {
            "description": "The `gitlab.Topic` resource allows to manage the lifecycle of topics that are then assignable to projects.\n\n\u003e Topics are the successors for project tags. Aside from avoiding terminology collisions with Git tags, they are more descriptive and better searchable.\n\n\u003e Deleting a topic was implemented in GitLab 14.9. For older versions of GitLab set `soft_destroy = true` to empty out a topic instead of deleting it.\n\n**Upstream API**: [GitLab REST API docs for topics](https://docs.gitlab.com/ee/api/topics.html)\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_topic`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_topic.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\n```sh\n$ pulumi import gitlab:index/topic:Topic You can import a topic to terraform state using `\u003cresource\u003e \u003cid\u003e`.\n```\n\nThe `id` must be an integer for the id of the topic you want to import,\n\nfor example:\n\n```sh\n$ pulumi import gitlab:index/topic:Topic functional_programming 1\n```\n\n",
            "properties": {
                "avatar": {
                    "type": "string",
                    "description": "A local path to the avatar image to upload. **Note**: not available for imported resources.\n"
                },
                "avatarHash": {
                    "type": "string",
                    "description": "The hash of the avatar image. Use `filesha256(\"path/to/avatar.png\")` whenever possible. **Note**: this is used to trigger an update of the avatar. If it's not given, but an avatar is given, the avatar will be updated each time.\n"
                },
                "avatarUrl": {
                    "type": "string",
                    "description": "The URL of the avatar image.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A text describing the topic.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The topic's name.\n"
                },
                "softDestroy": {
                    "type": "boolean",
                    "description": "Empty the topics fields instead of deleting it.\n",
                    "deprecationMessage": "GitLab 14.9 introduced the proper deletion of topics. This field is no longer needed."
                },
                "title": {
                    "type": "string",
                    "description": "The topic's description. Requires at least GitLab 15.0 for which it's a required argument.\n"
                }
            },
            "required": [
                "avatarHash",
                "avatarUrl",
                "name"
            ],
            "inputProperties": {
                "avatar": {
                    "type": "string",
                    "description": "A local path to the avatar image to upload. **Note**: not available for imported resources.\n"
                },
                "avatarHash": {
                    "type": "string",
                    "description": "The hash of the avatar image. Use `filesha256(\"path/to/avatar.png\")` whenever possible. **Note**: this is used to trigger an update of the avatar. If it's not given, but an avatar is given, the avatar will be updated each time.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A text describing the topic.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The topic's name.\n"
                },
                "softDestroy": {
                    "type": "boolean",
                    "description": "Empty the topics fields instead of deleting it.\n",
                    "deprecationMessage": "GitLab 14.9 introduced the proper deletion of topics. This field is no longer needed."
                },
                "title": {
                    "type": "string",
                    "description": "The topic's description. Requires at least GitLab 15.0 for which it's a required argument.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Topic resources.\n",
                "properties": {
                    "avatar": {
                        "type": "string",
                        "description": "A local path to the avatar image to upload. **Note**: not available for imported resources.\n"
                    },
                    "avatarHash": {
                        "type": "string",
                        "description": "The hash of the avatar image. Use `filesha256(\"path/to/avatar.png\")` whenever possible. **Note**: this is used to trigger an update of the avatar. If it's not given, but an avatar is given, the avatar will be updated each time.\n"
                    },
                    "avatarUrl": {
                        "type": "string",
                        "description": "The URL of the avatar image.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A text describing the topic.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The topic's name.\n"
                    },
                    "softDestroy": {
                        "type": "boolean",
                        "description": "Empty the topics fields instead of deleting it.\n",
                        "deprecationMessage": "GitLab 14.9 introduced the proper deletion of topics. This field is no longer needed."
                    },
                    "title": {
                        "type": "string",
                        "description": "The topic's description. Requires at least GitLab 15.0 for which it's a required argument.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/user:User": {
            "description": "The `gitlab.User` resource allows to manage the lifecycle of a user.\n\n\u003e the provider needs to be configured with admin-level access for this resource to work.\n\n\u003e You must specify either password or reset_password.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/users.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = new gitlab.User(\"example\", {\n    name: \"Example Foo\",\n    username: \"example\",\n    password: \"superPassword\",\n    email: \"gitlab@user.create\",\n    isAdmin: true,\n    projectsLimit: 4,\n    canCreateGroup: false,\n    isExternal: true,\n    resetPassword: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.User(\"example\",\n    name=\"Example Foo\",\n    username=\"example\",\n    password=\"superPassword\",\n    email=\"gitlab@user.create\",\n    is_admin=True,\n    projects_limit=4,\n    can_create_group=False,\n    is_external=True,\n    reset_password=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new GitLab.User(\"example\", new()\n    {\n        Name = \"Example Foo\",\n        Username = \"example\",\n        Password = \"superPassword\",\n        Email = \"gitlab@user.create\",\n        IsAdmin = true,\n        ProjectsLimit = 4,\n        CanCreateGroup = false,\n        IsExternal = true,\n        ResetPassword = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewUser(ctx, \"example\", \u0026gitlab.UserArgs{\n\t\t\tName:           pulumi.String(\"Example Foo\"),\n\t\t\tUsername:       pulumi.String(\"example\"),\n\t\t\tPassword:       pulumi.String(\"superPassword\"),\n\t\t\tEmail:          pulumi.String(\"gitlab@user.create\"),\n\t\t\tIsAdmin:        pulumi.Bool(true),\n\t\t\tProjectsLimit:  pulumi.Int(4),\n\t\t\tCanCreateGroup: pulumi.Bool(false),\n\t\t\tIsExternal:     pulumi.Bool(true),\n\t\t\tResetPassword:  pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.User;\nimport com.pulumi.gitlab.UserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new User(\"example\", UserArgs.builder()\n            .name(\"Example Foo\")\n            .username(\"example\")\n            .password(\"superPassword\")\n            .email(\"gitlab@user.create\")\n            .isAdmin(true)\n            .projectsLimit(4)\n            .canCreateGroup(false)\n            .isExternal(true)\n            .resetPassword(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: gitlab:User\n    properties:\n      name: Example Foo\n      username: example\n      password: superPassword\n      email: gitlab@user.create\n      isAdmin: true\n      projectsLimit: 4\n      canCreateGroup: false\n      isExternal: true\n      resetPassword: false\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_user`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_user.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\n```sh\n$ pulumi import gitlab:index/user:User You can import a user to terraform state using `\u003cresource\u003e \u003cid\u003e`.\n```\n\nThe `id` must be an integer for the id of the user you want to import,\n\nfor example:\n\n```sh\n$ pulumi import gitlab:index/user:User example 42\n```\n\n",
            "properties": {
                "canCreateGroup": {
                    "type": "boolean",
                    "description": "Boolean, defaults to false. Whether to allow the user to create groups.\n"
                },
                "email": {
                    "type": "string",
                    "description": "The e-mail address of the user.\n"
                },
                "externUid": {
                    "type": "string",
                    "description": "String, a specific external authentication provider UID.\n"
                },
                "externalProvider": {
                    "type": "string",
                    "description": "String, the external provider.\n"
                },
                "isAdmin": {
                    "type": "boolean",
                    "description": "Boolean, defaults to false.  Whether to enable administrative privileges\n"
                },
                "isExternal": {
                    "type": "boolean",
                    "description": "Boolean, defaults to false. Whether a user has access only to some internal or private projects. External users can only access projects to which they are explicitly granted access.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the user.\n"
                },
                "namespaceId": {
                    "type": "integer",
                    "description": "The ID of the user's namespace. Available since GitLab 14.10.\n"
                },
                "note": {
                    "type": "string",
                    "description": "The note associated to the user.\n"
                },
                "password": {
                    "type": "string",
                    "description": "The password of the user.\n",
                    "secret": true
                },
                "projectsLimit": {
                    "type": "integer",
                    "description": "Integer, defaults to 0.  Number of projects user can create.\n"
                },
                "resetPassword": {
                    "type": "boolean",
                    "description": "Boolean, defaults to false. Send user password reset link.\n"
                },
                "skipConfirmation": {
                    "type": "boolean",
                    "description": "Boolean, defaults to true. Whether to skip confirmation.\n"
                },
                "state": {
                    "type": "string",
                    "description": "String, defaults to 'active'. The state of the user account. Valid values are `active`, `deactivated`, `blocked`.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The username of the user.\n"
                }
            },
            "required": [
                "email",
                "name",
                "namespaceId",
                "username"
            ],
            "inputProperties": {
                "canCreateGroup": {
                    "type": "boolean",
                    "description": "Boolean, defaults to false. Whether to allow the user to create groups.\n"
                },
                "email": {
                    "type": "string",
                    "description": "The e-mail address of the user.\n"
                },
                "externUid": {
                    "type": "string",
                    "description": "String, a specific external authentication provider UID.\n"
                },
                "externalProvider": {
                    "type": "string",
                    "description": "String, the external provider.\n"
                },
                "isAdmin": {
                    "type": "boolean",
                    "description": "Boolean, defaults to false.  Whether to enable administrative privileges\n"
                },
                "isExternal": {
                    "type": "boolean",
                    "description": "Boolean, defaults to false. Whether a user has access only to some internal or private projects. External users can only access projects to which they are explicitly granted access.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the user.\n"
                },
                "namespaceId": {
                    "type": "integer",
                    "description": "The ID of the user's namespace. Available since GitLab 14.10.\n"
                },
                "note": {
                    "type": "string",
                    "description": "The note associated to the user.\n"
                },
                "password": {
                    "type": "string",
                    "description": "The password of the user.\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                },
                "projectsLimit": {
                    "type": "integer",
                    "description": "Integer, defaults to 0.  Number of projects user can create.\n"
                },
                "resetPassword": {
                    "type": "boolean",
                    "description": "Boolean, defaults to false. Send user password reset link.\n",
                    "willReplaceOnChanges": true
                },
                "skipConfirmation": {
                    "type": "boolean",
                    "description": "Boolean, defaults to true. Whether to skip confirmation.\n",
                    "willReplaceOnChanges": true
                },
                "state": {
                    "type": "string",
                    "description": "String, defaults to 'active'. The state of the user account. Valid values are `active`, `deactivated`, `blocked`.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The username of the user.\n"
                }
            },
            "requiredInputs": [
                "email",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering User resources.\n",
                "properties": {
                    "canCreateGroup": {
                        "type": "boolean",
                        "description": "Boolean, defaults to false. Whether to allow the user to create groups.\n"
                    },
                    "email": {
                        "type": "string",
                        "description": "The e-mail address of the user.\n"
                    },
                    "externUid": {
                        "type": "string",
                        "description": "String, a specific external authentication provider UID.\n"
                    },
                    "externalProvider": {
                        "type": "string",
                        "description": "String, the external provider.\n"
                    },
                    "isAdmin": {
                        "type": "boolean",
                        "description": "Boolean, defaults to false.  Whether to enable administrative privileges\n"
                    },
                    "isExternal": {
                        "type": "boolean",
                        "description": "Boolean, defaults to false. Whether a user has access only to some internal or private projects. External users can only access projects to which they are explicitly granted access.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the user.\n"
                    },
                    "namespaceId": {
                        "type": "integer",
                        "description": "The ID of the user's namespace. Available since GitLab 14.10.\n"
                    },
                    "note": {
                        "type": "string",
                        "description": "The note associated to the user.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "The password of the user.\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "projectsLimit": {
                        "type": "integer",
                        "description": "Integer, defaults to 0.  Number of projects user can create.\n"
                    },
                    "resetPassword": {
                        "type": "boolean",
                        "description": "Boolean, defaults to false. Send user password reset link.\n",
                        "willReplaceOnChanges": true
                    },
                    "skipConfirmation": {
                        "type": "boolean",
                        "description": "Boolean, defaults to true. Whether to skip confirmation.\n",
                        "willReplaceOnChanges": true
                    },
                    "state": {
                        "type": "string",
                        "description": "String, defaults to 'active'. The state of the user account. Valid values are `active`, `deactivated`, `blocked`.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "The username of the user.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/userCustomAttribute:UserCustomAttribute": {
            "description": "The `gitlab.UserCustomAttribute` resource allows to manage custom attributes for a user.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/custom_attributes.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst attr = new gitlab.UserCustomAttribute(\"attr\", {\n    user: 42,\n    key: \"location\",\n    value: \"Greenland\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nattr = gitlab.UserCustomAttribute(\"attr\",\n    user=42,\n    key=\"location\",\n    value=\"Greenland\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var attr = new GitLab.UserCustomAttribute(\"attr\", new()\n    {\n        User = 42,\n        Key = \"location\",\n        Value = \"Greenland\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewUserCustomAttribute(ctx, \"attr\", \u0026gitlab.UserCustomAttributeArgs{\n\t\t\tUser:  pulumi.Int(42),\n\t\t\tKey:   pulumi.String(\"location\"),\n\t\t\tValue: pulumi.String(\"Greenland\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.UserCustomAttribute;\nimport com.pulumi.gitlab.UserCustomAttributeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var attr = new UserCustomAttribute(\"attr\", UserCustomAttributeArgs.builder()\n            .user(\"42\")\n            .key(\"location\")\n            .value(\"Greenland\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  attr:\n    type: gitlab:UserCustomAttribute\n    properties:\n      user: '42'\n      key: location\n      value: Greenland\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_user_custom_attribute`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_user_custom_attribute.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nYou can import a user custom attribute using an id made up of `{user-id}:{key}`, e.g.\n\n```sh\n$ pulumi import gitlab:index/userCustomAttribute:UserCustomAttribute attr 42:location\n```\n\n",
            "properties": {
                "key": {
                    "type": "string",
                    "description": "Key for the Custom Attribute.\n"
                },
                "user": {
                    "type": "integer",
                    "description": "The id of the user.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value for the Custom Attribute.\n"
                }
            },
            "required": [
                "key",
                "user",
                "value"
            ],
            "inputProperties": {
                "key": {
                    "type": "string",
                    "description": "Key for the Custom Attribute.\n"
                },
                "user": {
                    "type": "integer",
                    "description": "The id of the user.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value for the Custom Attribute.\n"
                }
            },
            "requiredInputs": [
                "key",
                "user",
                "value"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserCustomAttribute resources.\n",
                "properties": {
                    "key": {
                        "type": "string",
                        "description": "Key for the Custom Attribute.\n"
                    },
                    "user": {
                        "type": "integer",
                        "description": "The id of the user.\n"
                    },
                    "value": {
                        "type": "string",
                        "description": "Value for the Custom Attribute.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/userGpgKey:UserGpgKey": {
            "description": "The `gitlab.UserGpgKey` resource allows to manage the lifecycle of a GPG key assigned to the current user or a specific user.\n\t\t\n\u003e Managing GPG keys for arbitrary users requires admin privileges.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/users.html#get-a-specific-gpg-key)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getUser({\n    username: \"example-user\",\n});\n// Manages a GPG key for the specified user. An admin token is required if `user_id` is specified.\nconst exampleUserGpgKey = new gitlab.UserGpgKey(\"example\", {\n    userId: example.then(example =\u003e example.id),\n    key: `-----BEGIN PGP PUBLIC KEY BLOCK-----\n...\n-----END PGP PUBLIC KEY BLOCK-----`,\n});\n// Manages a GPG key for the current user\nconst exampleUser = new gitlab.UserGpgKey(\"example_user\", {key: `-----BEGIN PGP PUBLIC KEY BLOCK-----\n...\n-----END PGP PUBLIC KEY BLOCK-----`});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_user(username=\"example-user\")\n# Manages a GPG key for the specified user. An admin token is required if `user_id` is specified.\nexample_user_gpg_key = gitlab.UserGpgKey(\"example\",\n    user_id=example.id,\n    key=\"\"\"-----BEGIN PGP PUBLIC KEY BLOCK-----\n...\n-----END PGP PUBLIC KEY BLOCK-----\"\"\")\n# Manages a GPG key for the current user\nexample_user = gitlab.UserGpgKey(\"example_user\", key=\"\"\"-----BEGIN PGP PUBLIC KEY BLOCK-----\n...\n-----END PGP PUBLIC KEY BLOCK-----\"\"\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetUser.Invoke(new()\n    {\n        Username = \"example-user\",\n    });\n\n    // Manages a GPG key for the specified user. An admin token is required if `user_id` is specified.\n    var exampleUserGpgKey = new GitLab.UserGpgKey(\"example\", new()\n    {\n        UserId = example.Apply(getUserResult =\u003e getUserResult.Id),\n        Key = @\"-----BEGIN PGP PUBLIC KEY BLOCK-----\n...\n-----END PGP PUBLIC KEY BLOCK-----\",\n    });\n\n    // Manages a GPG key for the current user\n    var exampleUser = new GitLab.UserGpgKey(\"example_user\", new()\n    {\n        Key = @\"-----BEGIN PGP PUBLIC KEY BLOCK-----\n...\n-----END PGP PUBLIC KEY BLOCK-----\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := gitlab.LookupUser(ctx, \u0026gitlab.LookupUserArgs{\n\t\t\tUsername: pulumi.StringRef(\"example-user\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Manages a GPG key for the specified user. An admin token is required if `user_id` is specified.\n\t\t_, err = gitlab.NewUserGpgKey(ctx, \"example\", \u0026gitlab.UserGpgKeyArgs{\n\t\t\tUserId: pulumi.String(example.Id),\n\t\t\tKey:    pulumi.String(\"-----BEGIN PGP PUBLIC KEY BLOCK-----\\n...\\n-----END PGP PUBLIC KEY BLOCK-----\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Manages a GPG key for the current user\n\t\t_, err = gitlab.NewUserGpgKey(ctx, \"example_user\", \u0026gitlab.UserGpgKeyArgs{\n\t\t\tKey: pulumi.String(\"-----BEGIN PGP PUBLIC KEY BLOCK-----\\n...\\n-----END PGP PUBLIC KEY BLOCK-----\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetUserArgs;\nimport com.pulumi.gitlab.UserGpgKey;\nimport com.pulumi.gitlab.UserGpgKeyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getUser(GetUserArgs.builder()\n            .username(\"example-user\")\n            .build());\n\n        // Manages a GPG key for the specified user. An admin token is required if `user_id` is specified.\n        var exampleUserGpgKey = new UserGpgKey(\"exampleUserGpgKey\", UserGpgKeyArgs.builder()\n            .userId(example.applyValue(getUserResult -\u003e getUserResult.id()))\n            .key(\"\"\"\n-----BEGIN PGP PUBLIC KEY BLOCK-----\n...\n-----END PGP PUBLIC KEY BLOCK-----            \"\"\")\n            .build());\n\n        // Manages a GPG key for the current user\n        var exampleUser = new UserGpgKey(\"exampleUser\", UserGpgKeyArgs.builder()\n            .key(\"\"\"\n-----BEGIN PGP PUBLIC KEY BLOCK-----\n...\n-----END PGP PUBLIC KEY BLOCK-----            \"\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Manages a GPG key for the specified user. An admin token is required if `user_id` is specified.\n  exampleUserGpgKey:\n    type: gitlab:UserGpgKey\n    name: example\n    properties:\n      userId: ${example.id}\n      key: |-\n        -----BEGIN PGP PUBLIC KEY BLOCK-----\n        ...\n        -----END PGP PUBLIC KEY BLOCK-----\n  # Manages a GPG key for the current user\n  exampleUser:\n    type: gitlab:UserGpgKey\n    name: example_user\n    properties:\n      key: |-\n        -----BEGIN PGP PUBLIC KEY BLOCK-----\n        ...\n        -----END PGP PUBLIC KEY BLOCK-----\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getUser\n      Arguments:\n        username: example-user\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_user_gpgkey`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_user_gpgkey.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nYou can import a GPG key for a specific user using an id made up of `{user-id}:{key}`, e.g.\n\n```sh\n$ pulumi import gitlab:index/userGpgKey:UserGpgKey example 42:1\n```\n\nAlternatively, you can import a GPG key for the current user using an id made up of `{key}`, e.g.\n\n```sh\n$ pulumi import gitlab:index/userGpgKey:UserGpgKey example_user 1\n```\n\n",
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "The time when this key was created in GitLab.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The armored GPG public key.\n"
                },
                "keyId": {
                    "type": "integer",
                    "description": "The ID of the GPG key.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID of the user to add the GPG key to. If this field is omitted, this resource manages a GPG key for the current user. Otherwise, this resource manages a GPG key for the specified user, and an admin token is required.\n"
                }
            },
            "required": [
                "createdAt",
                "key",
                "keyId"
            ],
            "inputProperties": {
                "key": {
                    "type": "string",
                    "description": "The armored GPG public key.\n",
                    "willReplaceOnChanges": true
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID of the user to add the GPG key to. If this field is omitted, this resource manages a GPG key for the current user. Otherwise, this resource manages a GPG key for the specified user, and an admin token is required.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "key"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserGpgKey resources.\n",
                "properties": {
                    "createdAt": {
                        "type": "string",
                        "description": "The time when this key was created in GitLab.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "The armored GPG public key.\n",
                        "willReplaceOnChanges": true
                    },
                    "keyId": {
                        "type": "integer",
                        "description": "The ID of the GPG key.\n"
                    },
                    "userId": {
                        "type": "integer",
                        "description": "The ID of the user to add the GPG key to. If this field is omitted, this resource manages a GPG key for the current user. Otherwise, this resource manages a GPG key for the specified user, and an admin token is required.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/userImpersonationToken:UserImpersonationToken": {
            "description": "The `gitlab.UserImpersonationToken` resource allows to manage impersonation tokens of users.\nRequires administrator access. Token values are returned once. You are only able to create impersonation tokens to impersonate the user and perform both API calls and Git reads and writes. The user can’t see these tokens in their profile settings page.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/users.html#create-an-impersonation-token)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst _this = new gitlab.UserImpersonationToken(\"this\", {\n    userId: 12345,\n    name: \"token_name\",\n    scopes: [\"api\"],\n    expiresAt: \"2024-08-27\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nthis = gitlab.UserImpersonationToken(\"this\",\n    user_id=12345,\n    name=\"token_name\",\n    scopes=[\"api\"],\n    expires_at=\"2024-08-27\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @this = new GitLab.UserImpersonationToken(\"this\", new()\n    {\n        UserId = 12345,\n        Name = \"token_name\",\n        Scopes = new[]\n        {\n            \"api\",\n        },\n        ExpiresAt = \"2024-08-27\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewUserImpersonationToken(ctx, \"this\", \u0026gitlab.UserImpersonationTokenArgs{\n\t\t\tUserId: pulumi.Int(12345),\n\t\t\tName:   pulumi.String(\"token_name\"),\n\t\t\tScopes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"api\"),\n\t\t\t},\n\t\t\tExpiresAt: pulumi.String(\"2024-08-27\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.UserImpersonationToken;\nimport com.pulumi.gitlab.UserImpersonationTokenArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var this_ = new UserImpersonationToken(\"this\", UserImpersonationTokenArgs.builder()\n            .userId(12345)\n            .name(\"token_name\")\n            .scopes(\"api\")\n            .expiresAt(\"2024-08-27\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  this:\n    type: gitlab:UserImpersonationToken\n    properties:\n      userId: 12345\n      name: token_name\n      scopes:\n        - api\n      expiresAt: 2024-08-27\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_user_impersonation_token`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_user_impersonation_token.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nA GitLab User Impersonation Token can be imported using a key composed of `\u003cuser-id\u003e:\u003ctoken-id\u003e`, e.g.\n\n```sh\n$ pulumi import gitlab:index/userImpersonationToken:UserImpersonationToken example \"12345:1\"\n```\n\nNOTE: the `token` resource attribute is not available for imported resources as this information cannot be read from the GitLab API.\n\n",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "True if the token is active.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Time the token has been created, RFC3339 format.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "Expiration date of the impersonation token in ISO format (YYYY-MM-DD).\n"
                },
                "impersonation": {
                    "type": "boolean",
                    "description": "True as the token is always an impersonation token.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the impersonation token.\n"
                },
                "revoked": {
                    "type": "boolean",
                    "description": "True if the token is revoked.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Array of scopes of the impersonation token. valid values are: `api`, `read_user`, `read_api`, `read_repository`, `write_repository`, `read_registry`, `write_registry`, `sudo`, `admin_mode`, `create_runner`, `manage_runner`, `ai_features`, `k8s_proxy`, `read_service_ping`\n"
                },
                "token": {
                    "type": "string",
                    "description": "The token of the user impersonation token. **Note**: the token is not available for imported resources.\n",
                    "secret": true
                },
                "tokenId": {
                    "type": "integer",
                    "description": "ID of the impersonation token.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID of the user.\n"
                }
            },
            "required": [
                "active",
                "createdAt",
                "expiresAt",
                "impersonation",
                "name",
                "revoked",
                "scopes",
                "token",
                "tokenId",
                "userId"
            ],
            "inputProperties": {
                "expiresAt": {
                    "type": "string",
                    "description": "Expiration date of the impersonation token in ISO format (YYYY-MM-DD).\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the impersonation token.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Array of scopes of the impersonation token. valid values are: `api`, `read_user`, `read_api`, `read_repository`, `write_repository`, `read_registry`, `write_registry`, `sudo`, `admin_mode`, `create_runner`, `manage_runner`, `ai_features`, `k8s_proxy`, `read_service_ping`\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID of the user.\n"
                }
            },
            "requiredInputs": [
                "expiresAt",
                "scopes",
                "userId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserImpersonationToken resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "True if the token is active.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Time the token has been created, RFC3339 format.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "Expiration date of the impersonation token in ISO format (YYYY-MM-DD).\n"
                    },
                    "impersonation": {
                        "type": "boolean",
                        "description": "True as the token is always an impersonation token.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the impersonation token.\n"
                    },
                    "revoked": {
                        "type": "boolean",
                        "description": "True if the token is revoked.\n"
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Array of scopes of the impersonation token. valid values are: `api`, `read_user`, `read_api`, `read_repository`, `write_repository`, `read_registry`, `write_registry`, `sudo`, `admin_mode`, `create_runner`, `manage_runner`, `ai_features`, `k8s_proxy`, `read_service_ping`\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "The token of the user impersonation token. **Note**: the token is not available for imported resources.\n",
                        "secret": true
                    },
                    "tokenId": {
                        "type": "integer",
                        "description": "ID of the impersonation token.\n"
                    },
                    "userId": {
                        "type": "integer",
                        "description": "The ID of the user.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/userRunner:UserRunner": {
            "description": "The `gitlab.UserRunner` resource allows creating a GitLab runner using the new [GitLab Runner Registration Flow](https://docs.gitlab.com/ee/ci/runners/new_creation_workflow.html).\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/users.html#create-a-runner)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\n// Create a project runner\nconst projectRunner = new gitlab.UserRunner(\"project_runner\", {\n    runnerType: \"project_type\",\n    projectId: 123456,\n    description: \"A runner created using a user access token instead of a registration token\",\n    tagLists: [\n        \"a-tag\",\n        \"other-tag\",\n    ],\n    untagged: true,\n});\n// Create a group runner\nconst groupRunner = new gitlab.UserRunner(\"group_runner\", {\n    runnerType: \"group_type\",\n    groupId: 123456,\n});\n// Create a instance runner\nconst instanceRunner = new gitlab.UserRunner(\"instance_runner\", {runnerType: \"instance_type\"});\nconst configToml = pulumi.interpolate`concurrent = 1\ncheck_interval = 0\n\n[session_server]\n  session_timeout = 1800\n\n[[runners]]\n  name = \"my_gitlab_runner\"\n  url = \"https://example.gitlab.com\"\n  token = \"${groupRunner.token}\"\n  executor = \"docker\"\n\n  [runners.custom_build_dir]\n  [runners.cache]\n    [runners.cache.s3]\n    [runners.cache.gcs]\n    [runners.cache.azure]\n  [runners.docker]\n    tls_verify = false\n    image = \"ubuntu\"\n    privileged = true\n    disable_entrypoint_overwrite = false\n    oom_kill_disable = false\n    disable_cache = false\n    volumes = [\"/cache\", \"/certs/client\"]\n    shm_size = 0\n`;\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\n# Create a project runner\nproject_runner = gitlab.UserRunner(\"project_runner\",\n    runner_type=\"project_type\",\n    project_id=123456,\n    description=\"A runner created using a user access token instead of a registration token\",\n    tag_lists=[\n        \"a-tag\",\n        \"other-tag\",\n    ],\n    untagged=True)\n# Create a group runner\ngroup_runner = gitlab.UserRunner(\"group_runner\",\n    runner_type=\"group_type\",\n    group_id=123456)\n# Create a instance runner\ninstance_runner = gitlab.UserRunner(\"instance_runner\", runner_type=\"instance_type\")\nconfig_toml = group_runner.token.apply(lambda token: f\"\"\"concurrent = 1\ncheck_interval = 0\n\n[session_server]\n  session_timeout = 1800\n\n[[runners]]\n  name = \"my_gitlab_runner\"\n  url = \"https://example.gitlab.com\"\n  token = \"{token}\"\n  executor = \"docker\"\n\n  [runners.custom_build_dir]\n  [runners.cache]\n    [runners.cache.s3]\n    [runners.cache.gcs]\n    [runners.cache.azure]\n  [runners.docker]\n    tls_verify = false\n    image = \"ubuntu\"\n    privileged = true\n    disable_entrypoint_overwrite = false\n    oom_kill_disable = false\n    disable_cache = false\n    volumes = [\"/cache\", \"/certs/client\"]\n    shm_size = 0\n\"\"\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create a project runner\n    var projectRunner = new GitLab.UserRunner(\"project_runner\", new()\n    {\n        RunnerType = \"project_type\",\n        ProjectId = 123456,\n        Description = \"A runner created using a user access token instead of a registration token\",\n        TagLists = new[]\n        {\n            \"a-tag\",\n            \"other-tag\",\n        },\n        Untagged = true,\n    });\n\n    // Create a group runner\n    var groupRunner = new GitLab.UserRunner(\"group_runner\", new()\n    {\n        RunnerType = \"group_type\",\n        GroupId = 123456,\n    });\n\n    // Create a instance runner\n    var instanceRunner = new GitLab.UserRunner(\"instance_runner\", new()\n    {\n        RunnerType = \"instance_type\",\n    });\n\n    var configToml = groupRunner.Token.Apply(token =\u003e @$\"concurrent = 1\ncheck_interval = 0\n\n[session_server]\n  session_timeout = 1800\n\n[[runners]]\n  name = \"\"my_gitlab_runner\"\"\n  url = \"\"https://example.gitlab.com\"\"\n  token = \"\"{token}\"\"\n  executor = \"\"docker\"\"\n\n  [runners.custom_build_dir]\n  [runners.cache]\n    [runners.cache.s3]\n    [runners.cache.gcs]\n    [runners.cache.azure]\n  [runners.docker]\n    tls_verify = false\n    image = \"\"ubuntu\"\"\n    privileged = true\n    disable_entrypoint_overwrite = false\n    oom_kill_disable = false\n    disable_cache = false\n    volumes = [\"\"/cache\"\", \"\"/certs/client\"\"]\n    shm_size = 0\n\");\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Create a project runner\n\t\t_, err := gitlab.NewUserRunner(ctx, \"project_runner\", \u0026gitlab.UserRunnerArgs{\n\t\t\tRunnerType:  pulumi.String(\"project_type\"),\n\t\t\tProjectId:   pulumi.Int(123456),\n\t\t\tDescription: pulumi.String(\"A runner created using a user access token instead of a registration token\"),\n\t\t\tTagLists: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"a-tag\"),\n\t\t\t\tpulumi.String(\"other-tag\"),\n\t\t\t},\n\t\t\tUntagged: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Create a group runner\n\t\tgroupRunner, err := gitlab.NewUserRunner(ctx, \"group_runner\", \u0026gitlab.UserRunnerArgs{\n\t\t\tRunnerType: pulumi.String(\"group_type\"),\n\t\t\tGroupId:    pulumi.Int(123456),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Create a instance runner\n\t\t_, err = gitlab.NewUserRunner(ctx, \"instance_runner\", \u0026gitlab.UserRunnerArgs{\n\t\t\tRunnerType: pulumi.String(\"instance_type\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = groupRunner.Token.ApplyT(func(token string) (string, error) {\n\t\t\treturn fmt.Sprintf(`concurrent = 1\ncheck_interval = 0\n\n[session_server]\n  session_timeout = 1800\n\n[[runners]]\n  name = \"my_gitlab_runner\"\n  url = \"https://example.gitlab.com\"\n  token = \"%v\"\n  executor = \"docker\"\n\n  [runners.custom_build_dir]\n  [runners.cache]\n    [runners.cache.s3]\n    [runners.cache.gcs]\n    [runners.cache.azure]\n  [runners.docker]\n    tls_verify = false\n    image = \"ubuntu\"\n    privileged = true\n    disable_entrypoint_overwrite = false\n    oom_kill_disable = false\n    disable_cache = false\n    volumes = [\"/cache\", \"/certs/client\"]\n    shm_size = 0\n`, token), nil\n\t\t}).(pulumi.StringOutput)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.UserRunner;\nimport com.pulumi.gitlab.UserRunnerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Create a project runner\n        var projectRunner = new UserRunner(\"projectRunner\", UserRunnerArgs.builder()\n            .runnerType(\"project_type\")\n            .projectId(123456)\n            .description(\"A runner created using a user access token instead of a registration token\")\n            .tagLists(            \n                \"a-tag\",\n                \"other-tag\")\n            .untagged(true)\n            .build());\n\n        // Create a group runner\n        var groupRunner = new UserRunner(\"groupRunner\", UserRunnerArgs.builder()\n            .runnerType(\"group_type\")\n            .groupId(123456)\n            .build());\n\n        // Create a instance runner\n        var instanceRunner = new UserRunner(\"instanceRunner\", UserRunnerArgs.builder()\n            .runnerType(\"instance_type\")\n            .build());\n\n        final var configToml = groupRunner.token().applyValue(token -\u003e \"\"\"\nconcurrent = 1\ncheck_interval = 0\n\n[session_server]\n  session_timeout = 1800\n\n[[runners]]\n  name = \"my_gitlab_runner\"\n  url = \"https://example.gitlab.com\"\n  token = \"%s\"\n  executor = \"docker\"\n\n  [runners.custom_build_dir]\n  [runners.cache]\n    [runners.cache.s3]\n    [runners.cache.gcs]\n    [runners.cache.azure]\n  [runners.docker]\n    tls_verify = false\n    image = \"ubuntu\"\n    privileged = true\n    disable_entrypoint_overwrite = false\n    oom_kill_disable = false\n    disable_cache = false\n    volumes = [\"/cache\", \"/certs/client\"]\n    shm_size = 0\n\", token));\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a project runner\n  projectRunner:\n    type: gitlab:UserRunner\n    name: project_runner\n    properties:\n      runnerType: project_type\n      projectId: 123456\n      description: A runner created using a user access token instead of a registration token\n      tagLists:\n        - a-tag\n        - other-tag\n      untagged: true\n  # Create a group runner\n  groupRunner:\n    type: gitlab:UserRunner\n    name: group_runner\n    properties:\n      runnerType: group_type\n      groupId: 123456 # populate other attributes...\n  # Create a instance runner\n  instanceRunner:\n    type: gitlab:UserRunner\n    name: instance_runner\n    properties:\n      runnerType: instance_type\nvariables:\n  configToml: |\n    concurrent = 1\n    check_interval = 0\n\n    [session_server]\n      session_timeout = 1800\n\n    [[runners]]\n      name = \"my_gitlab_runner\"\n      url = \"https://example.gitlab.com\"\n      token = \"${groupRunner.token}\"\n      executor = \"docker\"\n\n      [runners.custom_build_dir]\n      [runners.cache]\n        [runners.cache.s3]\n        [runners.cache.gcs]\n        [runners.cache.azure]\n      [runners.docker]\n        tls_verify = false\n        image = \"ubuntu\"\n        privileged = true\n        disable_entrypoint_overwrite = false\n        oom_kill_disable = false\n        disable_cache = false\n        volumes = [\"/cache\", \"/certs/client\"]\n        shm_size = 0\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_user_runner`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_user_runner.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nYou can import a gitlab runner using its ID\n\nNote: Importing a runner will not provide access to the `token` attribute\n\n```sh\n$ pulumi import gitlab:index/userRunner:UserRunner example 12345\n```\n\n",
            "properties": {
                "accessLevel": {
                    "type": "string",
                    "description": "The access level of the runner. Valid values are: `not_protected`, `ref_protected`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the runner.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of the group that the runner is created in. Required if runner*type is group*type.\n"
                },
                "locked": {
                    "type": "boolean",
                    "description": "Specifies if the runner should be locked for the current project.\n"
                },
                "maintenanceNote": {
                    "type": "string",
                    "description": "Free-form maintenance notes for the runner (1024 characters)\n"
                },
                "maximumTimeout": {
                    "type": "integer",
                    "description": "Maximum timeout that limits the amount of time (in seconds) that runners can run jobs. Must be at least 600 (10 minutes).\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Specifies if the runner should ignore new jobs.\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "The ID of the project that the runner is created in. Required if runner*type is project*type.\n"
                },
                "runnerType": {
                    "type": "string",
                    "description": "The scope of the runner. Valid values are: `instance_type`, `group_type`, `project_type`.\n"
                },
                "tagLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of runner tags.\n"
                },
                "token": {
                    "type": "string",
                    "description": "The authentication token to use when setting up a new runner with this configuration. This value cannot be imported.\n",
                    "secret": true
                },
                "untagged": {
                    "type": "boolean",
                    "description": "Specifies if the runner should handle untagged jobs.\n"
                }
            },
            "required": [
                "accessLevel",
                "description",
                "locked",
                "maintenanceNote",
                "maximumTimeout",
                "paused",
                "runnerType",
                "tagLists",
                "token",
                "untagged"
            ],
            "inputProperties": {
                "accessLevel": {
                    "type": "string",
                    "description": "The access level of the runner. Valid values are: `not_protected`, `ref_protected`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the runner.\n"
                },
                "groupId": {
                    "type": "integer",
                    "description": "The ID of the group that the runner is created in. Required if runner*type is group*type.\n"
                },
                "locked": {
                    "type": "boolean",
                    "description": "Specifies if the runner should be locked for the current project.\n"
                },
                "maintenanceNote": {
                    "type": "string",
                    "description": "Free-form maintenance notes for the runner (1024 characters)\n"
                },
                "maximumTimeout": {
                    "type": "integer",
                    "description": "Maximum timeout that limits the amount of time (in seconds) that runners can run jobs. Must be at least 600 (10 minutes).\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Specifies if the runner should ignore new jobs.\n"
                },
                "projectId": {
                    "type": "integer",
                    "description": "The ID of the project that the runner is created in. Required if runner*type is project*type.\n"
                },
                "runnerType": {
                    "type": "string",
                    "description": "The scope of the runner. Valid values are: `instance_type`, `group_type`, `project_type`.\n"
                },
                "tagLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of runner tags.\n"
                },
                "untagged": {
                    "type": "boolean",
                    "description": "Specifies if the runner should handle untagged jobs.\n"
                }
            },
            "requiredInputs": [
                "runnerType"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserRunner resources.\n",
                "properties": {
                    "accessLevel": {
                        "type": "string",
                        "description": "The access level of the runner. Valid values are: `not_protected`, `ref_protected`.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the runner.\n"
                    },
                    "groupId": {
                        "type": "integer",
                        "description": "The ID of the group that the runner is created in. Required if runner*type is group*type.\n"
                    },
                    "locked": {
                        "type": "boolean",
                        "description": "Specifies if the runner should be locked for the current project.\n"
                    },
                    "maintenanceNote": {
                        "type": "string",
                        "description": "Free-form maintenance notes for the runner (1024 characters)\n"
                    },
                    "maximumTimeout": {
                        "type": "integer",
                        "description": "Maximum timeout that limits the amount of time (in seconds) that runners can run jobs. Must be at least 600 (10 minutes).\n"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "Specifies if the runner should ignore new jobs.\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "The ID of the project that the runner is created in. Required if runner*type is project*type.\n"
                    },
                    "runnerType": {
                        "type": "string",
                        "description": "The scope of the runner. Valid values are: `instance_type`, `group_type`, `project_type`.\n"
                    },
                    "tagLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of runner tags.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "The authentication token to use when setting up a new runner with this configuration. This value cannot be imported.\n",
                        "secret": true
                    },
                    "untagged": {
                        "type": "boolean",
                        "description": "Specifies if the runner should handle untagged jobs.\n"
                    }
                },
                "type": "object"
            }
        },
        "gitlab:index/userSshKey:UserSshKey": {
            "description": "The `gitlab.UserSshKey` resource allows to manage the lifecycle of an SSH key assigned to a user.\n\n**Upstream API**: [GitLab API docs](https://docs.gitlab.com/ee/api/users.html#single-ssh-key)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getUser({\n    username: \"example-user\",\n});\nconst exampleUserSshKey = new gitlab.UserSshKey(\"example\", {\n    userId: example.then(example =\u003e example.id),\n    title: \"example-key\",\n    key: \"ssh-ed25519 AAAA...\",\n    expiresAt: \"2016-01-21T00:00:00.000Z\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_user(username=\"example-user\")\nexample_user_ssh_key = gitlab.UserSshKey(\"example\",\n    user_id=example.id,\n    title=\"example-key\",\n    key=\"ssh-ed25519 AAAA...\",\n    expires_at=\"2016-01-21T00:00:00.000Z\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetUser.Invoke(new()\n    {\n        Username = \"example-user\",\n    });\n\n    var exampleUserSshKey = new GitLab.UserSshKey(\"example\", new()\n    {\n        UserId = example.Apply(getUserResult =\u003e getUserResult.Id),\n        Title = \"example-key\",\n        Key = \"ssh-ed25519 AAAA...\",\n        ExpiresAt = \"2016-01-21T00:00:00.000Z\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := gitlab.LookupUser(ctx, \u0026gitlab.LookupUserArgs{\n\t\t\tUsername: pulumi.StringRef(\"example-user\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.NewUserSshKey(ctx, \"example\", \u0026gitlab.UserSshKeyArgs{\n\t\t\tUserId:    pulumi.String(example.Id),\n\t\t\tTitle:     pulumi.String(\"example-key\"),\n\t\t\tKey:       pulumi.String(\"ssh-ed25519 AAAA...\"),\n\t\t\tExpiresAt: pulumi.String(\"2016-01-21T00:00:00.000Z\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetUserArgs;\nimport com.pulumi.gitlab.UserSshKey;\nimport com.pulumi.gitlab.UserSshKeyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getUser(GetUserArgs.builder()\n            .username(\"example-user\")\n            .build());\n\n        var exampleUserSshKey = new UserSshKey(\"exampleUserSshKey\", UserSshKeyArgs.builder()\n            .userId(example.applyValue(getUserResult -\u003e getUserResult.id()))\n            .title(\"example-key\")\n            .key(\"ssh-ed25519 AAAA...\")\n            .expiresAt(\"2016-01-21T00:00:00.000Z\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleUserSshKey:\n    type: gitlab:UserSshKey\n    name: example\n    properties:\n      userId: ${example.id}\n      title: example-key\n      key: ssh-ed25519 AAAA...\n      expiresAt: 2016-01-21T00:00:00.000Z\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getUser\n      Arguments:\n        username: example-user\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStarting in Terraform v1.5.0 you can use an import block to import `gitlab_user_sshkey`. For example:\n\nterraform\n\nimport {\n\n  to = gitlab_user_sshkey.example\n\n  id = \"see CLI command below for ID\"\n\n}\n\nImport using the CLI is supported using the following syntax:\n\nYou can import a user ssh key using an id made up of `{user-id}:{key}`, e.g.\n\n```sh\n$ pulumi import gitlab:index/userSshKey:UserSshKey example 42:1\n```\n\n",
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "The time when this key was created in GitLab.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "The expiration date of the SSH key in ISO 8601 format (YYYY-MM-DDTHH:MM:SSZ)\n"
                },
                "key": {
                    "type": "string",
                    "description": "The ssh key. The SSH key `comment` (trailing part) is optional and ignored for diffing, because GitLab overrides it with the username and GitLab hostname.\n"
                },
                "keyId": {
                    "type": "integer",
                    "description": "The ID of the ssh key.\n"
                },
                "title": {
                    "type": "string",
                    "description": "The title of the ssh key.\n"
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID or username of the user. If this field is omitted, this resource manages a SSH key for the current user. Otherwise, this resource manages a SSH key for the specified user, and an admin token is required.\n"
                }
            },
            "required": [
                "createdAt",
                "key",
                "keyId",
                "title",
                "userId"
            ],
            "inputProperties": {
                "expiresAt": {
                    "type": "string",
                    "description": "The expiration date of the SSH key in ISO 8601 format (YYYY-MM-DDTHH:MM:SSZ)\n",
                    "willReplaceOnChanges": true
                },
                "key": {
                    "type": "string",
                    "description": "The ssh key. The SSH key `comment` (trailing part) is optional and ignored for diffing, because GitLab overrides it with the username and GitLab hostname.\n",
                    "willReplaceOnChanges": true
                },
                "title": {
                    "type": "string",
                    "description": "The title of the ssh key.\n",
                    "willReplaceOnChanges": true
                },
                "userId": {
                    "type": "integer",
                    "description": "The ID or username of the user. If this field is omitted, this resource manages a SSH key for the current user. Otherwise, this resource manages a SSH key for the specified user, and an admin token is required.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "key",
                "title"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserSshKey resources.\n",
                "properties": {
                    "createdAt": {
                        "type": "string",
                        "description": "The time when this key was created in GitLab.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "The expiration date of the SSH key in ISO 8601 format (YYYY-MM-DDTHH:MM:SSZ)\n",
                        "willReplaceOnChanges": true
                    },
                    "key": {
                        "type": "string",
                        "description": "The ssh key. The SSH key `comment` (trailing part) is optional and ignored for diffing, because GitLab overrides it with the username and GitLab hostname.\n",
                        "willReplaceOnChanges": true
                    },
                    "keyId": {
                        "type": "integer",
                        "description": "The ID of the ssh key.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "The title of the ssh key.\n",
                        "willReplaceOnChanges": true
                    },
                    "userId": {
                        "type": "integer",
                        "description": "The ID or username of the user. If this field is omitted, this resource manages a SSH key for the current user. Otherwise, this resource manages a SSH key for the specified user, and an admin token is required.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "gitlab:index/getApplication:getApplication": {
            "description": "The `gitlab.Application` data source retrieves information about a gitlab application.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/applications.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetApplicationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var oidc = GitlabFunctions.getApplication(GetApplicationArgs.builder()\n            .applicationId(1)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  oidc:\n    fn::invoke:\n      Function: gitlab:getApplication\n      Arguments:\n        applicationId: 1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getApplication.\n",
                "properties": {
                    "id": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "id"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getApplication.\n",
                "properties": {
                    "applicationId": {
                        "description": "Internal GitLab application id.\n",
                        "type": "string"
                    },
                    "confidential": {
                        "description": "Indicates if the application is kept confidential.\n",
                        "type": "boolean"
                    },
                    "id": {
                        "type": "string"
                    },
                    "name": {
                        "description": "The name of the GitLab application.\n",
                        "type": "string"
                    },
                    "redirectUrl": {
                        "description": "The redirect url of the application.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "applicationId",
                    "confidential",
                    "id",
                    "name",
                    "redirectUrl"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getBranch:getBranch": {
            "description": "The `gitlab.Branch` data source allows details of a repository branch to be retrieved by its name and project.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/branches.html#get-single-repository-branch)\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getBranch.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the branch.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The full path or id of the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getBranch.\n",
                "properties": {
                    "canPush": {
                        "description": "Bool, true if you can push to the branch.\n",
                        "type": "boolean"
                    },
                    "commits": {
                        "description": "The commit associated with the branch ref.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getBranchCommit:getBranchCommit"
                        },
                        "type": "array"
                    },
                    "default": {
                        "description": "Bool, true if branch is the default branch for the project.\n",
                        "type": "boolean"
                    },
                    "developerCanMerge": {
                        "description": "Bool, true if developer level access allows to merge branch.\n",
                        "type": "boolean"
                    },
                    "developerCanPush": {
                        "description": "Bool, true if developer level access allows git push.\n",
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "merged": {
                        "description": "Bool, true if the branch has been merged into it's parent.\n",
                        "type": "boolean"
                    },
                    "name": {
                        "description": "The name of the branch.\n",
                        "type": "string"
                    },
                    "project": {
                        "description": "The full path or id of the project.\n",
                        "type": "string"
                    },
                    "protected": {
                        "description": "Bool, true if branch has branch protection.\n",
                        "type": "boolean"
                    },
                    "webUrl": {
                        "description": "The url of the created branch (https.)\n",
                        "type": "string"
                    }
                },
                "required": [
                    "canPush",
                    "commits",
                    "default",
                    "developerCanMerge",
                    "developerCanPush",
                    "merged",
                    "name",
                    "project",
                    "protected",
                    "webUrl",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getClusterAgent:getClusterAgent": {
            "description": "The `gitlab.ClusterAgent` data source allows to retrieve details about a GitLab Agent for Kubernetes.\n\n\u003e Requires at least GitLab 14.10\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/cluster_agents.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getClusterAgent({\n    project: \"12345\",\n    agentId: 1,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_cluster_agent(project=\"12345\",\n    agent_id=1)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetClusterAgent.Invoke(new()\n    {\n        Project = \"12345\",\n        AgentId = 1,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.LookupClusterAgent(ctx, \u0026gitlab.LookupClusterAgentArgs{\n\t\t\tProject: \"12345\",\n\t\t\tAgentId: 1,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetClusterAgentArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getClusterAgent(GetClusterAgentArgs.builder()\n            .project(\"12345\")\n            .agentId(1)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getClusterAgent\n      Arguments:\n        project: '12345'\n        agentId: 1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getClusterAgent.\n",
                "properties": {
                    "agentId": {
                        "type": "integer",
                        "description": "The ID of the agent.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "ID or full path of the project maintained by the authenticated user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "agentId",
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getClusterAgent.\n",
                "properties": {
                    "agentId": {
                        "description": "The ID of the agent.\n",
                        "type": "integer"
                    },
                    "createdAt": {
                        "description": "The ISO8601 datetime when the agent was created.\n",
                        "type": "string"
                    },
                    "createdByUserId": {
                        "description": "The ID of the user who created the agent.\n",
                        "type": "integer"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "The Name of the agent.\n",
                        "type": "string"
                    },
                    "project": {
                        "description": "ID or full path of the project maintained by the authenticated user.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "agentId",
                    "createdAt",
                    "createdByUserId",
                    "name",
                    "project",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getClusterAgents:getClusterAgents": {
            "description": "The `gitlab.getClusterAgents` data source allows details of GitLab Agents for Kubernetes in a project.\n\n\u003e Requires at least GitLab 14.10\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/cluster_agents.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst agents = gitlab.getClusterAgents({\n    project: \"12345\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nagents = gitlab.get_cluster_agents(project=\"12345\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var agents = GitLab.GetClusterAgents.Invoke(new()\n    {\n        Project = \"12345\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.GetClusterAgents(ctx, \u0026gitlab.GetClusterAgentsArgs{\n\t\t\tProject: \"12345\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetClusterAgentsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var agents = GitlabFunctions.getClusterAgents(GetClusterAgentsArgs.builder()\n            .project(\"12345\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  agents:\n    fn::invoke:\n      Function: gitlab:getClusterAgents\n      Arguments:\n        project: '12345'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getClusterAgents.\n",
                "properties": {
                    "project": {
                        "type": "string",
                        "description": "The ID or full path of the project owned by the authenticated user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getClusterAgents.\n",
                "properties": {
                    "clusterAgents": {
                        "description": "List of the registered agents.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getClusterAgentsClusterAgent:getClusterAgentsClusterAgent"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "project": {
                        "description": "The ID or full path of the project owned by the authenticated user.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "clusterAgents",
                    "project",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getComplianceFramework:getComplianceFramework": {
            "description": "The `gitlab.ComplianceFramework` data source allows details of a compliance framework to be retrieved by its name and the namespace it belongs to.\n\n**Upstream API**: [GitLab GraphQL API docs](https://docs.gitlab.com/ee/api/graphql/reference/#querynamespace)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getComplianceFramework({\n    namespacePath: \"top-level-group\",\n    name: \"HIPAA\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_compliance_framework(namespace_path=\"top-level-group\",\n    name=\"HIPAA\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetComplianceFramework.Invoke(new()\n    {\n        NamespacePath = \"top-level-group\",\n        Name = \"HIPAA\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.LookupComplianceFramework(ctx, \u0026gitlab.LookupComplianceFrameworkArgs{\n\t\t\tNamespacePath: \"top-level-group\",\n\t\t\tName:          \"HIPAA\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetComplianceFrameworkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getComplianceFramework(GetComplianceFrameworkArgs.builder()\n            .namespacePath(\"top-level-group\")\n            .name(\"HIPAA\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getComplianceFramework\n      Arguments:\n        namespacePath: top-level-group\n        name: HIPAA\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getComplianceFramework.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Name for the compliance framework.\n"
                    },
                    "namespacePath": {
                        "type": "string",
                        "description": "Full path of the namespace to where the compliance framework is.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "namespacePath"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getComplianceFramework.\n",
                "properties": {
                    "color": {
                        "description": "Color representation of the compliance framework in hex format. e.g. #FCA121.\n",
                        "type": "string"
                    },
                    "default": {
                        "description": "Is the compliance framework the default framework for the group.\n",
                        "type": "boolean"
                    },
                    "description": {
                        "description": "Description for the compliance framework.\n",
                        "type": "string"
                    },
                    "frameworkId": {
                        "description": "Globally unique ID of the compliance framework.\n",
                        "type": "string"
                    },
                    "id": {
                        "type": "string"
                    },
                    "name": {
                        "description": "Name for the compliance framework.\n",
                        "type": "string"
                    },
                    "namespacePath": {
                        "description": "Full path of the namespace to where the compliance framework is.\n",
                        "type": "string"
                    },
                    "pipelineConfigurationFullPath": {
                        "description": "Full path of the compliance pipeline configuration stored in a project repository, such as `.gitlab/.compliance-gitlab-ci.yml@compliance/hipaa`. Format: `path/file.y[a]ml@group-name/project-name` **Note**: Ultimate license required.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "color",
                    "default",
                    "description",
                    "frameworkId",
                    "id",
                    "name",
                    "namespacePath",
                    "pipelineConfigurationFullPath"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getCurrentUser:getCurrentUser": {
            "description": "The `gitlab.getCurrentUser` data source allows details of the current user (determined by `token` provider attribute) to be retrieved.\n\n**Upstream API**: [GitLab GraphQL API docs](https://docs.gitlab.com/ee/api/graphql/reference/index.html#querycurrentuser)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getCurrentUser({});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_current_user()\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetCurrentUser.Invoke();\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.GetCurrentUser(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getCurrentUser();\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getCurrentUser\n      Arguments: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getCurrentUser.\n",
                "properties": {
                    "bot": {
                        "description": "Indicates if the user is a bot.\n",
                        "type": "boolean"
                    },
                    "globalId": {
                        "description": "Global ID of the user. This is in the form of a GraphQL globally unique ID.\n",
                        "type": "string"
                    },
                    "globalNamespaceId": {
                        "description": "Personal namespace of the user. This is in the form of a GraphQL globally unique ID.\n",
                        "type": "string"
                    },
                    "groupCount": {
                        "description": "Group count for the user.\n",
                        "type": "integer"
                    },
                    "id": {
                        "description": "ID of the user.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "Human-readable name of the user. Returns **** if the user is a project bot and the requester does not have permission to view the project.\n",
                        "type": "string"
                    },
                    "namespaceId": {
                        "description": "Personal namespace of the user.\n",
                        "type": "string"
                    },
                    "publicEmail": {
                        "description": "User’s public email.\n",
                        "type": "string"
                    },
                    "username": {
                        "description": "Username of the user. Unique within this instance of GitLab.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "bot",
                    "globalId",
                    "globalNamespaceId",
                    "groupCount",
                    "id",
                    "name",
                    "namespaceId",
                    "publicEmail",
                    "username"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getGroup:getGroup": {
            "description": "The `gitlab.Group` data source allows details of a group to be retrieved by its id or full path.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/groups.html#details-of-a-group)\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGroup.\n",
                "properties": {
                    "fullPath": {
                        "type": "string",
                        "description": "The full path of the group.\n"
                    },
                    "groupId": {
                        "type": "integer",
                        "description": "The ID of the group.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getGroup.\n",
                "properties": {
                    "defaultBranch": {
                        "description": "The default branch of the group.\n",
                        "type": "string"
                    },
                    "defaultBranchProtection": {
                        "description": "Whether developers and maintainers can push to the applicable default branch.\n",
                        "type": "integer"
                    },
                    "description": {
                        "description": "The description of the group.\n",
                        "type": "string"
                    },
                    "extraSharedRunnersMinutesLimit": {
                        "description": "Can be set by administrators only. Additional CI/CD minutes for this group.\n",
                        "type": "integer"
                    },
                    "fullName": {
                        "description": "The full name of the group.\n",
                        "type": "string"
                    },
                    "fullPath": {
                        "description": "The full path of the group.\n",
                        "type": "string"
                    },
                    "groupId": {
                        "description": "The ID of the group.\n",
                        "type": "integer"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "lfsEnabled": {
                        "description": "Boolean, is LFS enabled for projects in this group.\n",
                        "type": "boolean"
                    },
                    "membershipLock": {
                        "description": "Users cannot be added to projects in this group.\n",
                        "type": "boolean"
                    },
                    "name": {
                        "description": "The name of this group.\n",
                        "type": "string"
                    },
                    "parentId": {
                        "description": "Integer, ID of the parent group.\n",
                        "type": "integer"
                    },
                    "path": {
                        "description": "The path of the group.\n",
                        "type": "string"
                    },
                    "preventForkingOutsideGroup": {
                        "description": "When enabled, users can not fork projects from this group to external namespaces.\n",
                        "type": "boolean"
                    },
                    "requestAccessEnabled": {
                        "description": "Boolean, is request for access enabled to the group.\n",
                        "type": "boolean"
                    },
                    "runnersToken": {
                        "description": "The group level registration token to use during runner setup.\n",
                        "secret": true,
                        "type": "string"
                    },
                    "sharedRunnersMinutesLimit": {
                        "description": "Can be set by administrators only. Maximum number of monthly CI/CD minutes for this group. Can be nil (default; inherit system default), 0 (unlimited), or \u003e 0.\n",
                        "type": "integer"
                    },
                    "sharedRunnersSetting": {
                        "description": "Enable or disable shared runners for a group’s subgroups and projects. Valid values are: `enabled`, `disabled_and_overridable`, `disabled_and_unoverridable`, `disabled_with_override`.\n",
                        "type": "string"
                    },
                    "sharedWithGroups": {
                        "description": "Describes groups which have access shared to this group.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getGroupSharedWithGroup:getGroupSharedWithGroup"
                        },
                        "type": "array"
                    },
                    "visibilityLevel": {
                        "description": "Visibility level of the group. Possible values are `private`, `internal`, `public`.\n",
                        "type": "string"
                    },
                    "webUrl": {
                        "description": "Web URL of the group.\n",
                        "type": "string"
                    },
                    "wikiAccessLevel": {
                        "description": "The group's wiki access level. Only available on Premium and Ultimate plans. Valid values are `disabled`, `private`, `enabled`.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "defaultBranch",
                    "defaultBranchProtection",
                    "description",
                    "extraSharedRunnersMinutesLimit",
                    "fullName",
                    "fullPath",
                    "groupId",
                    "lfsEnabled",
                    "membershipLock",
                    "name",
                    "parentId",
                    "path",
                    "preventForkingOutsideGroup",
                    "requestAccessEnabled",
                    "runnersToken",
                    "sharedRunnersMinutesLimit",
                    "sharedRunnersSetting",
                    "sharedWithGroups",
                    "visibilityLevel",
                    "webUrl",
                    "wikiAccessLevel",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getGroupBillableMemberMemberships:getGroupBillableMemberMemberships": {
            "description": "The `gitlab.getGroupBillableMemberMemberships` data source allows (sub)group- and project-memberships of a billable member of a group to be retrieved by either the user ID, username or email address.\n\n\u003e You must be an administrator!\n\n\u003e When using the `email` attribute, an exact match is not guaranteed. The most related match will be returned. Starting with GitLab 16.6,\nthe most related match will prioritize an exact match if one is available.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/members.html#list-memberships-for-a-billable-member-of-a-group)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst testUserMembership = gitlab.getGroupBillableMemberMemberships({\n    userId: 21,\n    groupId: \"42\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\ntest_user_membership = gitlab.get_group_billable_member_memberships(user_id=21,\n    group_id=\"42\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testUserMembership = GitLab.GetGroupBillableMemberMemberships.Invoke(new()\n    {\n        UserId = 21,\n        GroupId = \"42\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.GetGroupBillableMemberMemberships(ctx, \u0026gitlab.GetGroupBillableMemberMembershipsArgs{\n\t\t\tUserId:  21,\n\t\t\tGroupId: \"42\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetGroupBillableMemberMembershipsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var testUserMembership = GitlabFunctions.getGroupBillableMemberMemberships(GetGroupBillableMemberMembershipsArgs.builder()\n            .userId(21)\n            .groupId(42)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  testUserMembership:\n    fn::invoke:\n      Function: gitlab:getGroupBillableMemberMemberships\n      Arguments:\n        userId: 21\n        groupId: 42\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGroupBillableMemberMemberships.\n",
                "properties": {
                    "groupId": {
                        "type": "string",
                        "description": "The ID of the group.\n"
                    },
                    "userId": {
                        "type": "integer",
                        "description": "The ID of the user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "groupId",
                    "userId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGroupBillableMemberMemberships.\n",
                "properties": {
                    "groupId": {
                        "description": "The ID of the group.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The id of the data source. It will always be equal to the user_id\n",
                        "type": "string"
                    },
                    "memberships": {
                        "description": "group- and/or project-memberships of the user.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getGroupBillableMemberMembershipsMembership:getGroupBillableMemberMembershipsMembership"
                        },
                        "type": "array"
                    },
                    "userId": {
                        "description": "The ID of the user.\n",
                        "type": "integer"
                    }
                },
                "required": [
                    "groupId",
                    "id",
                    "memberships",
                    "userId"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getGroupHook:getGroupHook": {
            "description": "The `gitlab.GroupHook` data source allows to retrieve details about a hook in a group.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/groups.html#get-group-hook)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetGroupArgs;\nimport com.pulumi.gitlab.inputs.GetGroupHookArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getGroup(GetGroupArgs.builder()\n            .id(\"foo/bar/baz\")\n            .build());\n\n        final var exampleGetGroupHook = GitlabFunctions.getGroupHook(GetGroupHookArgs.builder()\n            .group(example.applyValue(getGroupResult -\u003e getGroupResult.id()))\n            .hookId(1)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getGroup\n      Arguments:\n        id: foo/bar/baz\n  exampleGetGroupHook:\n    fn::invoke:\n      Function: gitlab:getGroupHook\n      Arguments:\n        group: ${example.id}\n        hookId: 1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGroupHook.\n",
                "properties": {
                    "group": {
                        "type": "string",
                        "description": "The ID or full path of the group.\n"
                    },
                    "hookId": {
                        "type": "integer",
                        "description": "The id of the group hook.\n"
                    }
                },
                "type": "object",
                "required": [
                    "group",
                    "hookId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGroupHook.\n",
                "properties": {
                    "confidentialIssuesEvents": {
                        "description": "Invoke the hook for confidential issues events.\n",
                        "type": "boolean"
                    },
                    "confidentialNoteEvents": {
                        "description": "Invoke the hook for confidential notes events.\n",
                        "type": "boolean"
                    },
                    "customWebhookTemplate": {
                        "description": "Set a custom webhook template.\n",
                        "type": "string"
                    },
                    "deploymentEvents": {
                        "description": "Invoke the hook for deployment events.\n",
                        "type": "boolean"
                    },
                    "enableSslVerification": {
                        "description": "Enable ssl verification when invoking the hook.\n",
                        "type": "boolean"
                    },
                    "group": {
                        "description": "The ID or full path of the group.\n",
                        "type": "string"
                    },
                    "groupId": {
                        "description": "The id of the group for the hook.\n",
                        "type": "integer"
                    },
                    "hookId": {
                        "description": "The id of the group hook.\n",
                        "type": "integer"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "issuesEvents": {
                        "description": "Invoke the hook for issues events.\n",
                        "type": "boolean"
                    },
                    "jobEvents": {
                        "description": "Invoke the hook for job events.\n",
                        "type": "boolean"
                    },
                    "mergeRequestsEvents": {
                        "description": "Invoke the hook for merge requests.\n",
                        "type": "boolean"
                    },
                    "noteEvents": {
                        "description": "Invoke the hook for notes events.\n",
                        "type": "boolean"
                    },
                    "pipelineEvents": {
                        "description": "Invoke the hook for pipeline events.\n",
                        "type": "boolean"
                    },
                    "pushEvents": {
                        "description": "Invoke the hook for push events.\n",
                        "type": "boolean"
                    },
                    "pushEventsBranchFilter": {
                        "description": "Invoke the hook for push events on matching branches only.\n",
                        "type": "string"
                    },
                    "releasesEvents": {
                        "description": "Invoke the hook for releases events.\n",
                        "type": "boolean"
                    },
                    "subgroupEvents": {
                        "description": "Invoke the hook for subgroup events.\n",
                        "type": "boolean"
                    },
                    "tagPushEvents": {
                        "description": "Invoke the hook for tag push events.\n",
                        "type": "boolean"
                    },
                    "token": {
                        "description": "A token to present when invoking the hook. The token is not available for imported resources.\n",
                        "type": "string"
                    },
                    "url": {
                        "description": "The url of the hook to invoke.\n",
                        "type": "string"
                    },
                    "wikiPageEvents": {
                        "description": "Invoke the hook for wiki page events.\n",
                        "type": "boolean"
                    }
                },
                "required": [
                    "confidentialIssuesEvents",
                    "confidentialNoteEvents",
                    "customWebhookTemplate",
                    "deploymentEvents",
                    "enableSslVerification",
                    "group",
                    "groupId",
                    "hookId",
                    "issuesEvents",
                    "jobEvents",
                    "mergeRequestsEvents",
                    "noteEvents",
                    "pipelineEvents",
                    "pushEvents",
                    "pushEventsBranchFilter",
                    "releasesEvents",
                    "subgroupEvents",
                    "tagPushEvents",
                    "token",
                    "url",
                    "wikiPageEvents",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getGroupHooks:getGroupHooks": {
            "description": "The `gitlab.getGroupHooks` data source allows to retrieve details about hooks in a group.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/groups.html#list-group-hooks)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetGroupArgs;\nimport com.pulumi.gitlab.inputs.GetGroupHooksArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getGroup(GetGroupArgs.builder()\n            .id(\"foo/bar/baz\")\n            .build());\n\n        final var examples = GitlabFunctions.getGroupHooks(GetGroupHooksArgs.builder()\n            .group(example.applyValue(getGroupResult -\u003e getGroupResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getGroup\n      Arguments:\n        id: foo/bar/baz\n  examples:\n    fn::invoke:\n      Function: gitlab:getGroupHooks\n      Arguments:\n        group: ${example.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGroupHooks.\n",
                "properties": {
                    "group": {
                        "type": "string",
                        "description": "The ID or full path of the group.\n"
                    }
                },
                "type": "object",
                "required": [
                    "group"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGroupHooks.\n",
                "properties": {
                    "group": {
                        "description": "The ID or full path of the group.\n",
                        "type": "string"
                    },
                    "hooks": {
                        "description": "The list of hooks.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getGroupHooksHook:getGroupHooksHook"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "group",
                    "hooks",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getGroupIds:getGroupIds": {
            "description": "The `gitlab.getGroupIds` data source identification information for a given group, allowing a user to translate a full path or ID into the GraphQL ID of the group.\n\n**Upstream API**: [GitLab GraphQL API docs](https://docs.gitlab.com/ee/api/graphql/reference/#querygroup)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst newGroup = new gitlab.Group(\"new_group\", {});\n// use group IDs to get additional information, such as the GraphQL ID\n// for other resources\nconst foo = gitlab.getGroupIds({\n    group: \"gitlab_group.new_group.id\",\n});\nexport const graphQLId = foo.then(foo =\u003e foo.groupGraphqlId);\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nnew_group = gitlab.Group(\"new_group\")\n# use group IDs to get additional information, such as the GraphQL ID\n# for other resources\nfoo = gitlab.get_group_ids(group=\"gitlab_group.new_group.id\")\npulumi.export(\"graphQLId\", foo.group_graphql_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var newGroup = new GitLab.Group(\"new_group\");\n\n    // use group IDs to get additional information, such as the GraphQL ID\n    // for other resources\n    var foo = GitLab.GetGroupIds.Invoke(new()\n    {\n        Group = \"gitlab_group.new_group.id\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"graphQLId\"] = foo.Apply(getGroupIdsResult =\u003e getGroupIdsResult.GroupGraphqlId),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewGroup(ctx, \"new_group\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// use group IDs to get additional information, such as the GraphQL ID\n\t\t// for other resources\n\t\tfoo, err := gitlab.GetGroupIds(ctx, \u0026gitlab.GetGroupIdsArgs{\n\t\t\tGroup: \"gitlab_group.new_group.id\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"graphQLId\", foo.GroupGraphqlId)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Group;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetGroupIdsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var newGroup = new Group(\"newGroup\");\n\n        // use group IDs to get additional information, such as the GraphQL ID\n        // for other resources\n        final var foo = GitlabFunctions.getGroupIds(GetGroupIdsArgs.builder()\n            .group(\"gitlab_group.new_group.id\")\n            .build());\n\n        ctx.export(\"graphQLId\", foo.applyValue(getGroupIdsResult -\u003e getGroupIdsResult.groupGraphqlId()));\n    }\n}\n```\n```yaml\nresources:\n  newGroup:\n    type: gitlab:Group\n    name: new_group\nvariables:\n  # use group IDs to get additional information, such as the GraphQL ID\n  # // for other resources\n  foo:\n    fn::invoke:\n      Function: gitlab:getGroupIds\n      Arguments:\n        group: gitlab_group.new_group.id\noutputs:\n  graphQLId: ${foo.groupGraphqlId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGroupIds.\n",
                "properties": {
                    "group": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the group.\n"
                    }
                },
                "type": "object",
                "required": [
                    "group"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGroupIds.\n",
                "properties": {
                    "group": {
                        "description": "The ID or URL-encoded path of the group.\n",
                        "type": "string"
                    },
                    "groupFullPath": {
                        "description": "The full path of the group.\n",
                        "type": "string"
                    },
                    "groupGraphqlId": {
                        "description": "The GraphQL ID of the group.\n",
                        "type": "string"
                    },
                    "groupId": {
                        "description": "The ID of the group.\n",
                        "type": "string"
                    },
                    "id": {
                        "type": "string"
                    }
                },
                "required": [
                    "group",
                    "groupFullPath",
                    "groupGraphqlId",
                    "groupId",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getGroupMembership:getGroupMembership": {
            "description": "The `gitlab.GroupMembership` data source allows to list and filter all members of a group specified by either its id or full path.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/members.html#list-all-members-of-a-group-or-project)\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGroupMembership.\n",
                "properties": {
                    "accessLevel": {
                        "type": "string",
                        "description": "Only return members with the desired access level. Acceptable values are: `guest`, `reporter`, `developer`, `maintainer`, `owner`.\n"
                    },
                    "fullPath": {
                        "type": "string",
                        "description": "The full path of the group.\n"
                    },
                    "groupId": {
                        "type": "integer",
                        "description": "The ID of the group.\n"
                    },
                    "inherited": {
                        "type": "boolean",
                        "description": "Return all project members including members through ancestor groups.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getGroupMembership.\n",
                "properties": {
                    "accessLevel": {
                        "description": "Only return members with the desired access level. Acceptable values are: `guest`, `reporter`, `developer`, `maintainer`, `owner`.\n",
                        "type": "string"
                    },
                    "fullPath": {
                        "description": "The full path of the group.\n",
                        "type": "string"
                    },
                    "groupId": {
                        "description": "The ID of the group.\n",
                        "type": "integer"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "inherited": {
                        "description": "Return all project members including members through ancestor groups.\n",
                        "type": "boolean"
                    },
                    "members": {
                        "description": "The list of group members.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getGroupMembershipMember:getGroupMembershipMember"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "accessLevel",
                    "fullPath",
                    "groupId",
                    "members",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getGroupProvisionedUsers:getGroupProvisionedUsers": {
            "description": "The `gitlab.getGroupProvisionedUsers` data source allows details of the provisioned users of a given group.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/groups.html#list-provisioned-users)\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGroupProvisionedUsers.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "Return only active provisioned users.\n"
                    },
                    "blocked": {
                        "type": "boolean",
                        "description": "Return only blocked provisioned users.\n"
                    },
                    "createdAfter": {
                        "type": "string",
                        "description": "Return only provisioned users created on or after the specified date. Expected in ISO 8601 format (YYYY-MM-DDTHH:MM:SSZ).\n"
                    },
                    "createdBefore": {
                        "type": "string",
                        "description": "Return only provisioned users created on or before the specified date. Expected in ISO 8601 format (YYYY-MM-DDTHH:MM:SSZ).\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the group.\n"
                    },
                    "provisionedUsers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getGroupProvisionedUsersProvisionedUser:getGroupProvisionedUsersProvisionedUser"
                        },
                        "description": "The list of provisioned users.\n"
                    },
                    "search": {
                        "type": "string",
                        "description": "The search query to filter the provisioned users.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "The username of the provisioned user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "id"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGroupProvisionedUsers.\n",
                "properties": {
                    "active": {
                        "description": "Return only active provisioned users.\n",
                        "type": "boolean"
                    },
                    "blocked": {
                        "description": "Return only blocked provisioned users.\n",
                        "type": "boolean"
                    },
                    "createdAfter": {
                        "description": "Return only provisioned users created on or after the specified date. Expected in ISO 8601 format (YYYY-MM-DDTHH:MM:SSZ).\n",
                        "type": "string"
                    },
                    "createdBefore": {
                        "description": "Return only provisioned users created on or before the specified date. Expected in ISO 8601 format (YYYY-MM-DDTHH:MM:SSZ).\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The ID or URL-encoded path of the group.\n",
                        "type": "string"
                    },
                    "provisionedUsers": {
                        "description": "The list of provisioned users.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getGroupProvisionedUsersProvisionedUser:getGroupProvisionedUsersProvisionedUser"
                        },
                        "type": "array"
                    },
                    "search": {
                        "description": "The search query to filter the provisioned users.\n",
                        "type": "string"
                    },
                    "username": {
                        "description": "The username of the provisioned user.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getGroupServiceAccount:getGroupServiceAccount": {
            "description": "The `gitlab.GroupServiceAccount` data source retrieves information about a gitlab service account for a group.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/group_service_accounts.html#list-service-account-users)\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGroupServiceAccount.\n",
                "properties": {
                    "group": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the target group. Must be a top-level group.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the user. If not specified, the default Service account user name is used.\n"
                    },
                    "serviceAccountId": {
                        "type": "string",
                        "description": "The service account id.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "The username of the user. If not specified, it's automatically generated.\n"
                    }
                },
                "type": "object",
                "required": [
                    "group",
                    "serviceAccountId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGroupServiceAccount.\n",
                "properties": {
                    "group": {
                        "description": "The ID or URL-encoded path of the target group. Must be a top-level group.\n",
                        "type": "string"
                    },
                    "id": {
                        "type": "string"
                    },
                    "name": {
                        "description": "The name of the user. If not specified, the default Service account user name is used.\n",
                        "type": "string"
                    },
                    "serviceAccountId": {
                        "description": "The service account id.\n",
                        "type": "string"
                    },
                    "username": {
                        "description": "The username of the user. If not specified, it's automatically generated.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "group",
                    "id",
                    "serviceAccountId"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getGroupSubgroups:getGroupSubgroups": {
            "description": "The `gitlab.getGroupSubgroups` data source allows to get subgroups of a group.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/groups.html#list-a-groups-subgroups)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nexport = async () =\u003e {\n    const subgroups = await gitlab.getGroupSubgroups({\n        groupId: 123456,\n    });\n    return {\n        subgroups: subgroups,\n    };\n}\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nsubgroups = gitlab.get_group_subgroups(group_id=123456)\npulumi.export(\"subgroups\", subgroups)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var subgroups = GitLab.GetGroupSubgroups.Invoke(new()\n    {\n        GroupId = 123456,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"subgroups\"] = subgroups,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tsubgroups, err := gitlab.GetGroupSubgroups(ctx, \u0026gitlab.GetGroupSubgroupsArgs{\n\t\t\tGroupId: 123456,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"subgroups\", subgroups)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetGroupSubgroupsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var subgroups = GitlabFunctions.getGroupSubgroups(GetGroupSubgroupsArgs.builder()\n            .groupId(\"123456\")\n            .build());\n\n        ctx.export(\"subgroups\", subgroups.applyValue(getGroupSubgroupsResult -\u003e getGroupSubgroupsResult));\n    }\n}\n```\n```yaml\nvariables:\n  subgroups:\n    fn::invoke:\n      Function: gitlab:getGroupSubgroups\n      Arguments:\n        groupId: '123456'\noutputs:\n  subgroups: ${subgroups}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGroupSubgroups.\n",
                "properties": {
                    "allAvailable": {
                        "type": "boolean",
                        "description": "Show all the groups you have access to.\n"
                    },
                    "groupId": {
                        "type": "integer",
                        "description": "The ID of the group.\n"
                    },
                    "minAccessLevel": {
                        "type": "string",
                        "description": "Limit to groups where current user has at least this access level.\n"
                    },
                    "orderBy": {
                        "type": "string",
                        "description": "Order groups by name, path or id.\n"
                    },
                    "owned": {
                        "type": "boolean",
                        "description": "Limit to groups explicitly owned by the current user.\n"
                    },
                    "search": {
                        "type": "string",
                        "description": "Return the list of authorized groups matching the search criteria.\n"
                    },
                    "skipGroups": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "Skip the group IDs passed.\n"
                    },
                    "sort": {
                        "type": "string",
                        "description": "Order groups in asc or desc order.\n"
                    },
                    "statistics": {
                        "type": "boolean",
                        "description": "Include group statistics (administrators only).\n"
                    },
                    "withCustomAttributes": {
                        "type": "boolean",
                        "description": "Include custom attributes in response (administrators only).\n"
                    }
                },
                "type": "object",
                "required": [
                    "groupId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGroupSubgroups.\n",
                "properties": {
                    "allAvailable": {
                        "description": "Show all the groups you have access to.\n",
                        "type": "boolean"
                    },
                    "groupId": {
                        "description": "The ID of the group.\n",
                        "type": "integer"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "minAccessLevel": {
                        "description": "Limit to groups where current user has at least this access level.\n",
                        "type": "string"
                    },
                    "orderBy": {
                        "description": "Order groups by name, path or id.\n",
                        "type": "string"
                    },
                    "owned": {
                        "description": "Limit to groups explicitly owned by the current user.\n",
                        "type": "boolean"
                    },
                    "search": {
                        "description": "Return the list of authorized groups matching the search criteria.\n",
                        "type": "string"
                    },
                    "skipGroups": {
                        "description": "Skip the group IDs passed.\n",
                        "items": {
                            "type": "integer"
                        },
                        "type": "array"
                    },
                    "sort": {
                        "description": "Order groups in asc or desc order.\n",
                        "type": "string"
                    },
                    "statistics": {
                        "description": "Include group statistics (administrators only).\n",
                        "type": "boolean"
                    },
                    "subgroups": {
                        "description": "Subgroups of the parent group.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getGroupSubgroupsSubgroup:getGroupSubgroupsSubgroup"
                        },
                        "type": "array"
                    },
                    "withCustomAttributes": {
                        "description": "Include custom attributes in response (administrators only).\n",
                        "type": "boolean"
                    }
                },
                "required": [
                    "allAvailable",
                    "groupId",
                    "minAccessLevel",
                    "orderBy",
                    "owned",
                    "search",
                    "skipGroups",
                    "sort",
                    "statistics",
                    "subgroups",
                    "withCustomAttributes",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getGroupVariable:getGroupVariable": {
            "description": "The `gitlab.GroupVariable` data source allows to retrieve details about a group-level CI/CD variable.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/group_level_variables.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = gitlab.getGroupVariable({\n    group: \"my/example/group\",\n    key: \"foo\",\n});\n// Using an environment scope\nconst bar = gitlab.getGroupVariable({\n    group: \"my/example/group\",\n    key: \"bar\",\n    environmentScope: \"staging/*\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.get_group_variable(group=\"my/example/group\",\n    key=\"foo\")\n# Using an environment scope\nbar = gitlab.get_group_variable(group=\"my/example/group\",\n    key=\"bar\",\n    environment_scope=\"staging/*\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = GitLab.GetGroupVariable.Invoke(new()\n    {\n        Group = \"my/example/group\",\n        Key = \"foo\",\n    });\n\n    // Using an environment scope\n    var bar = GitLab.GetGroupVariable.Invoke(new()\n    {\n        Group = \"my/example/group\",\n        Key = \"bar\",\n        EnvironmentScope = \"staging/*\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.LookupGroupVariable(ctx, \u0026gitlab.LookupGroupVariableArgs{\n\t\t\tGroup: \"my/example/group\",\n\t\t\tKey:   \"foo\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Using an environment scope\n\t\t_, err = gitlab.LookupGroupVariable(ctx, \u0026gitlab.LookupGroupVariableArgs{\n\t\t\tGroup:            \"my/example/group\",\n\t\t\tKey:              \"bar\",\n\t\t\tEnvironmentScope: pulumi.StringRef(\"staging/*\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetGroupVariableArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var foo = GitlabFunctions.getGroupVariable(GetGroupVariableArgs.builder()\n            .group(\"my/example/group\")\n            .key(\"foo\")\n            .build());\n\n        // Using an environment scope\n        final var bar = GitlabFunctions.getGroupVariable(GetGroupVariableArgs.builder()\n            .group(\"my/example/group\")\n            .key(\"bar\")\n            .environmentScope(\"staging/*\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  foo:\n    fn::invoke:\n      Function: gitlab:getGroupVariable\n      Arguments:\n        group: my/example/group\n        key: foo\n  # Using an environment scope\n  bar:\n    fn::invoke:\n      Function: gitlab:getGroupVariable\n      Arguments:\n        group: my/example/group\n        key: bar\n        environmentScope: staging/*\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGroupVariable.\n",
                "properties": {
                    "environmentScope": {
                        "type": "string",
                        "description": "The environment scope of the variable. Defaults to all environment (`*`). Note that in Community Editions of Gitlab, values other than `*` will cause inconsistent plans.\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "The name or id of the group.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "The name of the variable.\n"
                    }
                },
                "type": "object",
                "required": [
                    "group",
                    "key"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGroupVariable.\n",
                "properties": {
                    "description": {
                        "description": "The description of the variable.\n",
                        "type": "string"
                    },
                    "environmentScope": {
                        "description": "The environment scope of the variable. Defaults to all environment (`*`). Note that in Community Editions of Gitlab, values other than `*` will cause inconsistent plans.\n",
                        "type": "string"
                    },
                    "group": {
                        "description": "The name or id of the group.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "key": {
                        "description": "The name of the variable.\n",
                        "type": "string"
                    },
                    "masked": {
                        "description": "If set to `true`, the value of the variable will be hidden in job logs. The value must meet the [masking requirements](https://docs.gitlab.com/ee/ci/variables/#masked-variables). Defaults to `false`.\n",
                        "type": "boolean"
                    },
                    "protected": {
                        "description": "If set to `true`, the variable will be passed only to pipelines running on protected branches and tags. Defaults to `false`.\n",
                        "type": "boolean"
                    },
                    "raw": {
                        "description": "Whether the variable is treated as a raw string. Default: false. When true, variables in the value are not expanded.\n",
                        "type": "boolean"
                    },
                    "value": {
                        "description": "The value of the variable.\n",
                        "type": "string"
                    },
                    "variableType": {
                        "description": "The type of a variable. Valid values are: `env_var`, `file`. Default is `env_var`.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "description",
                    "environmentScope",
                    "group",
                    "key",
                    "masked",
                    "protected",
                    "raw",
                    "value",
                    "variableType",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getGroupVariables:getGroupVariables": {
            "description": "The `gitlab.getGroupVariables` data source allows to retrieve all group-level CI/CD variables.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/group_level_variables.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst vars = gitlab.getGroupVariables({\n    group: \"my/example/group\",\n});\n// Using an environment scope\nconst stagingVars = gitlab.getGroupVariables({\n    group: \"my/example/group\",\n    environmentScope: \"staging/*\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nvars = gitlab.get_group_variables(group=\"my/example/group\")\n# Using an environment scope\nstaging_vars = gitlab.get_group_variables(group=\"my/example/group\",\n    environment_scope=\"staging/*\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var vars = GitLab.GetGroupVariables.Invoke(new()\n    {\n        Group = \"my/example/group\",\n    });\n\n    // Using an environment scope\n    var stagingVars = GitLab.GetGroupVariables.Invoke(new()\n    {\n        Group = \"my/example/group\",\n        EnvironmentScope = \"staging/*\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.GetGroupVariables(ctx, \u0026gitlab.GetGroupVariablesArgs{\n\t\t\tGroup: \"my/example/group\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Using an environment scope\n\t\t_, err = gitlab.GetGroupVariables(ctx, \u0026gitlab.GetGroupVariablesArgs{\n\t\t\tGroup:            \"my/example/group\",\n\t\t\tEnvironmentScope: pulumi.StringRef(\"staging/*\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetGroupVariablesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var vars = GitlabFunctions.getGroupVariables(GetGroupVariablesArgs.builder()\n            .group(\"my/example/group\")\n            .build());\n\n        // Using an environment scope\n        final var stagingVars = GitlabFunctions.getGroupVariables(GetGroupVariablesArgs.builder()\n            .group(\"my/example/group\")\n            .environmentScope(\"staging/*\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  vars:\n    fn::invoke:\n      Function: gitlab:getGroupVariables\n      Arguments:\n        group: my/example/group\n  # Using an environment scope\n  stagingVars:\n    fn::invoke:\n      Function: gitlab:getGroupVariables\n      Arguments:\n        group: my/example/group\n        environmentScope: staging/*\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGroupVariables.\n",
                "properties": {
                    "environmentScope": {
                        "type": "string",
                        "description": "The environment scope of the variable. Defaults to all environment (`*`).\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "The name or id of the group.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "group"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGroupVariables.\n",
                "properties": {
                    "environmentScope": {
                        "description": "The environment scope of the variable. Defaults to all environment (`*`).\n",
                        "type": "string"
                    },
                    "group": {
                        "description": "The name or id of the group.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "variables": {
                        "description": "The list of variables returned by the search\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getGroupVariablesVariable:getGroupVariablesVariable"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "group",
                    "variables",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getGroups:getGroups": {
            "description": "The `gitlab.getGroups` data source allows details of multiple groups to be retrieved given some optional filter criteria.\n\n\u003e Some attributes might not be returned depending on if you're an admin or not.\n\n\u003e Some available options require administrator privileges.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/groups.html#list-groups)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getGroups({\n    sort: \"desc\",\n    orderBy: \"name\",\n});\nconst example-two = gitlab.getGroups({\n    search: \"GitLab\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_groups(sort=\"desc\",\n    order_by=\"name\")\nexample_two = gitlab.get_groups(search=\"GitLab\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetGroups.Invoke(new()\n    {\n        Sort = \"desc\",\n        OrderBy = \"name\",\n    });\n\n    var example_two = GitLab.GetGroups.Invoke(new()\n    {\n        Search = \"GitLab\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.GetGroups(ctx, \u0026gitlab.GetGroupsArgs{\n\t\t\tSort:    pulumi.StringRef(\"desc\"),\n\t\t\tOrderBy: pulumi.StringRef(\"name\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.GetGroups(ctx, \u0026gitlab.GetGroupsArgs{\n\t\t\tSearch: pulumi.StringRef(\"GitLab\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetGroupsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getGroups(GetGroupsArgs.builder()\n            .sort(\"desc\")\n            .orderBy(\"name\")\n            .build());\n\n        final var example-two = GitlabFunctions.getGroups(GetGroupsArgs.builder()\n            .search(\"GitLab\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getGroups\n      Arguments:\n        sort: desc\n        orderBy: name\n  example-two:\n    fn::invoke:\n      Function: gitlab:getGroups\n      Arguments:\n        search: GitLab\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGroups.\n",
                "properties": {
                    "orderBy": {
                        "type": "string",
                        "description": "Order the groups' list by `id`, `name`, `path`, or `similarity`. (Requires administrator privileges)\n"
                    },
                    "search": {
                        "type": "string",
                        "description": "Search groups by name or path.\n"
                    },
                    "sort": {
                        "type": "string",
                        "description": "Sort groups' list in asc or desc order. (Requires administrator privileges)\n"
                    },
                    "topLevelOnly": {
                        "type": "boolean",
                        "description": "Limit to top level groups, excluding all subgroups.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getGroups.\n",
                "properties": {
                    "groups": {
                        "description": "The list of groups.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getGroupsGroup:getGroupsGroup"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "orderBy": {
                        "description": "Order the groups' list by `id`, `name`, `path`, or `similarity`. (Requires administrator privileges)\n",
                        "type": "string"
                    },
                    "search": {
                        "description": "Search groups by name or path.\n",
                        "type": "string"
                    },
                    "sort": {
                        "description": "Sort groups' list in asc or desc order. (Requires administrator privileges)\n",
                        "type": "string"
                    },
                    "topLevelOnly": {
                        "description": "Limit to top level groups, excluding all subgroups.\n",
                        "type": "boolean"
                    }
                },
                "required": [
                    "groups",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getInstanceDeployKeys:getInstanceDeployKeys": {
            "description": "The `gitlab.getInstanceDeployKeys` data source allows to retrieve a list of deploy keys for a GitLab instance.\n\n\u003e This data source requires administration privileges.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/deploy_keys.html#list-all-deploy-keys)\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getInstanceDeployKeys.\n",
                "properties": {
                    "public": {
                        "type": "boolean",
                        "description": "Only return deploy keys that are public.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getInstanceDeployKeys.\n",
                "properties": {
                    "deployKeys": {
                        "description": "The list of all deploy keys across all projects of the GitLab instance.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getInstanceDeployKeysDeployKey:getInstanceDeployKeysDeployKey"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "public": {
                        "description": "Only return deploy keys that are public.\n",
                        "type": "boolean"
                    }
                },
                "required": [
                    "deployKeys",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getInstanceVariable:getInstanceVariable": {
            "description": "The `gitlab.InstanceVariable` data source allows to retrieve details about an instance-level CI/CD variable.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/instance_level_ci_variables.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = gitlab.getInstanceVariable({\n    key: \"foo\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.get_instance_variable(key=\"foo\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = GitLab.GetInstanceVariable.Invoke(new()\n    {\n        Key = \"foo\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.LookupInstanceVariable(ctx, \u0026gitlab.LookupInstanceVariableArgs{\n\t\t\tKey: \"foo\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetInstanceVariableArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var foo = GitlabFunctions.getInstanceVariable(GetInstanceVariableArgs.builder()\n            .key(\"foo\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  foo:\n    fn::invoke:\n      Function: gitlab:getInstanceVariable\n      Arguments:\n        key: foo\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getInstanceVariable.\n",
                "properties": {
                    "key": {
                        "type": "string",
                        "description": "The name of the variable.\n"
                    }
                },
                "type": "object",
                "required": [
                    "key"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getInstanceVariable.\n",
                "properties": {
                    "description": {
                        "description": "The description of the variable. Maximum of 255 characters.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "key": {
                        "description": "The name of the variable.\n",
                        "type": "string"
                    },
                    "masked": {
                        "description": "If set to `true`, the value of the variable will be hidden in job logs. The value must meet the [masking requirements](https://docs.gitlab.com/ee/ci/variables/#masked-variables). Defaults to `false`.\n",
                        "type": "boolean"
                    },
                    "protected": {
                        "description": "If set to `true`, the variable will be passed only to pipelines running on protected branches and tags. Defaults to `false`.\n",
                        "type": "boolean"
                    },
                    "raw": {
                        "description": "Whether the variable is treated as a raw string. Default: false. When true, variables in the value are not expanded.\n",
                        "type": "boolean"
                    },
                    "value": {
                        "description": "The value of the variable.\n",
                        "type": "string"
                    },
                    "variableType": {
                        "description": "The type of a variable. Valid values are: `env_var`, `file`. Default is `env_var`.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "description",
                    "key",
                    "masked",
                    "protected",
                    "raw",
                    "value",
                    "variableType",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getInstanceVariables:getInstanceVariables": {
            "description": "The `gitlab.getInstanceVariables` data source allows to retrieve all instance-level CI/CD variables.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/instance_level_ci_variables.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst vars = gitlab.getInstanceVariables({});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nvars = gitlab.get_instance_variables()\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var vars = GitLab.GetInstanceVariables.Invoke();\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.GetInstanceVariables(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var vars = GitlabFunctions.getInstanceVariables();\n\n    }\n}\n```\n```yaml\nvariables:\n  vars:\n    fn::invoke:\n      Function: gitlab:getInstanceVariables\n      Arguments: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getInstanceVariables.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "variables": {
                        "description": "The list of variables returned by the search\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getInstanceVariablesVariable:getInstanceVariablesVariable"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "variables",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getMetadata:getMetadata": {
            "description": "The `gitlab.getMetadata` data source retrieves the metadata of the GitLab instance.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/metadata.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst this = gitlab.getMetadata({});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nthis = gitlab.get_metadata()\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @this = GitLab.GetMetadata.Invoke();\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.GetMetadata(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var this = GitlabFunctions.getMetadata();\n\n    }\n}\n```\n```yaml\nvariables:\n  this:\n    fn::invoke:\n      Function: gitlab:getMetadata\n      Arguments: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getMetadata.\n",
                "properties": {
                    "enterprise": {
                        "description": "If the GitLab instance is an enterprise instance or not. Supported for GitLab 15.6 onwards.\n",
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The id of the data source. It will always be `1`\n",
                        "type": "string"
                    },
                    "kas": {
                        "$ref": "#/types/gitlab:index/getMetadataKas:getMetadataKas",
                        "description": "Metadata about the GitLab agent server for Kubernetes (KAS).\n"
                    },
                    "revision": {
                        "description": "Revision of the GitLab instance.\n",
                        "type": "string"
                    },
                    "version": {
                        "description": "Version of the GitLab instance.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "enterprise",
                    "id",
                    "kas",
                    "revision",
                    "version"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getPipelineSchedule:getPipelineSchedule": {
            "description": "The `gitlab.PipelineSchedule` data source retrieves information about a gitlab pipeline schedule for a project.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/pipeline_schedules.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getPipelineSchedule({\n    project: \"12345\",\n    pipelineScheduleId: 1,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_pipeline_schedule(project=\"12345\",\n    pipeline_schedule_id=1)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetPipelineSchedule.Invoke(new()\n    {\n        Project = \"12345\",\n        PipelineScheduleId = 1,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.LookupPipelineSchedule(ctx, \u0026gitlab.LookupPipelineScheduleArgs{\n\t\t\tProject:            \"12345\",\n\t\t\tPipelineScheduleId: 1,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetPipelineScheduleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getPipelineSchedule(GetPipelineScheduleArgs.builder()\n            .project(\"12345\")\n            .pipelineScheduleId(1)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getPipelineSchedule\n      Arguments:\n        project: '12345'\n        pipelineScheduleId: 1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPipelineSchedule.\n",
                "properties": {
                    "cronTimezone": {
                        "type": "string",
                        "description": "The timezone.\n"
                    },
                    "pipelineScheduleId": {
                        "type": "integer",
                        "description": "The pipeline schedule id.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project to add the schedule to.\n"
                    }
                },
                "type": "object",
                "required": [
                    "pipelineScheduleId",
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPipelineSchedule.\n",
                "properties": {
                    "active": {
                        "description": "The activation status of pipeline schedule.\n",
                        "type": "boolean"
                    },
                    "createdAt": {
                        "description": "The datetime of when the schedule was created.\n",
                        "type": "string"
                    },
                    "cron": {
                        "description": "The cron (e.g. `0 1 * * *`).\n",
                        "type": "string"
                    },
                    "cronTimezone": {
                        "description": "The timezone.\n",
                        "type": "string"
                    },
                    "description": {
                        "description": "The description of the pipeline schedule.\n",
                        "type": "string"
                    },
                    "id": {
                        "type": "string"
                    },
                    "lastPipeline": {
                        "$ref": "#/types/gitlab:index/getPipelineScheduleLastPipeline:getPipelineScheduleLastPipeline",
                        "description": "The details of the last pipeline run by the schedule.\n"
                    },
                    "nextRunAt": {
                        "description": "The datetime of when the schedule will next run.\n",
                        "type": "string"
                    },
                    "owner": {
                        "$ref": "#/types/gitlab:index/getPipelineScheduleOwner:getPipelineScheduleOwner",
                        "description": "The details of the pipeline schedule owner.\n"
                    },
                    "pipelineScheduleId": {
                        "description": "The pipeline schedule id.\n",
                        "type": "integer"
                    },
                    "project": {
                        "description": "The name or id of the project to add the schedule to.\n",
                        "type": "string"
                    },
                    "ref": {
                        "description": "The branch/tag name to be triggered. This will be the full branch reference, for example: `refs/heads/main`, not `main`.\n",
                        "type": "string"
                    },
                    "updatedAt": {
                        "description": "The datetime of when the schedule was last updated.\n",
                        "type": "string"
                    },
                    "variables": {
                        "description": "The list of the pipeline schedule variables.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getPipelineScheduleVariable:getPipelineScheduleVariable"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "active",
                    "createdAt",
                    "cron",
                    "cronTimezone",
                    "description",
                    "id",
                    "lastPipeline",
                    "nextRunAt",
                    "owner",
                    "pipelineScheduleId",
                    "project",
                    "ref",
                    "updatedAt",
                    "variables"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getPipelineSchedules:getPipelineSchedules": {
            "description": "The `gitlab.PipelineSchedule` data source retrieves information about a gitlab pipeline schedule for a project.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/pipeline_schedules.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getPipelineSchedules({\n    project: \"12345\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_pipeline_schedules(project=\"12345\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetPipelineSchedules.Invoke(new()\n    {\n        Project = \"12345\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.GetPipelineSchedules(ctx, \u0026gitlab.GetPipelineSchedulesArgs{\n\t\t\tProject: \"12345\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetPipelineSchedulesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getPipelineSchedules(GetPipelineSchedulesArgs.builder()\n            .project(\"12345\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getPipelineSchedules\n      Arguments:\n        project: '12345'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPipelineSchedules.\n",
                "properties": {
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project to add the schedule to.\n"
                    }
                },
                "type": "object",
                "required": [
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPipelineSchedules.\n",
                "properties": {
                    "id": {
                        "type": "string"
                    },
                    "pipelineSchedules": {
                        "description": "The list of pipeline schedules.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getPipelineSchedulesPipelineSchedule:getPipelineSchedulesPipelineSchedule"
                        },
                        "type": "array"
                    },
                    "project": {
                        "description": "The name or id of the project to add the schedule to.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "id",
                    "pipelineSchedules",
                    "project"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getProject:getProject": {
            "description": "The `gitlab.Project` data source allows details of a project to be retrieved by either its ID or its path with namespace.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/projects.html#get-single-project)\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProject.\n",
                "properties": {
                    "ciDefaultGitDepth": {
                        "type": "integer",
                        "description": "Default number of revisions for shallow cloning.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The integer that uniquely identifies the project within the gitlab install.\n"
                    },
                    "pathWithNamespace": {
                        "type": "string",
                        "description": "The path of the repository with namespace.\n"
                    },
                    "publicBuilds": {
                        "type": "boolean",
                        "description": "If true, jobs can be viewed by non-project members.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getProject.\n",
                "properties": {
                    "allowPipelineTriggerApproveDeployment": {
                        "description": "Set whether or not a pipeline triggerer is allowed to approve deployments. Premium and Ultimate only.\n",
                        "type": "boolean"
                    },
                    "analyticsAccessLevel": {
                        "description": "Set the analytics access level. Valid values are `disabled`, `private`, `enabled`.\n",
                        "type": "string"
                    },
                    "archived": {
                        "description": "Whether the project is in read-only mode (archived).\n",
                        "type": "boolean"
                    },
                    "autoCancelPendingPipelines": {
                        "description": "Auto-cancel pending pipelines. This isn’t a boolean, but enabled/disabled.\n",
                        "type": "string"
                    },
                    "autoDevopsDeployStrategy": {
                        "description": "Auto Deploy strategy. Valid values are `continuous`, `manual`, `timed_incremental`.\n",
                        "type": "string"
                    },
                    "autoDevopsEnabled": {
                        "description": "Enable Auto DevOps for this project.\n",
                        "type": "boolean"
                    },
                    "autocloseReferencedIssues": {
                        "description": "Set whether auto-closing referenced issues on default branch.\n",
                        "type": "boolean"
                    },
                    "buildGitStrategy": {
                        "description": "The Git strategy. Defaults to fetch.\n",
                        "type": "string"
                    },
                    "buildTimeout": {
                        "description": "The maximum amount of time, in seconds, that a job can run.\n",
                        "type": "integer"
                    },
                    "buildsAccessLevel": {
                        "description": "Set the builds access level. Valid values are `disabled`, `private`, `enabled`.\n",
                        "type": "string"
                    },
                    "ciConfigPath": {
                        "description": "CI config file path for the project.\n",
                        "type": "string"
                    },
                    "ciDefaultGitDepth": {
                        "description": "Default number of revisions for shallow cloning.\n",
                        "type": "integer"
                    },
                    "ciPipelineVariablesMinimumOverrideRole": {
                        "description": "The minimum role required to set variables when running pipelines and jobs. Introduced in GitLab 17.1. Valid values are `developer`, `maintainer`, `owner`, `no_one_allowed`\n",
                        "type": "string"
                    },
                    "ciRestrictPipelineCancellationRole": {
                        "description": "The role required to cancel a pipeline or job. Introduced in GitLab 16.8. Premium and Ultimate only. Valid values are `developer`, `maintainer`, `no one`\n",
                        "type": "string"
                    },
                    "ciSeparatedCaches": {
                        "description": "Use separate caches for protected branches.\n",
                        "type": "boolean"
                    },
                    "containerExpirationPolicies": {
                        "description": "Set the image cleanup policy for this project. **Note**: this field is sometimes named `container_expiration_policy_attributes` in the GitLab Upstream API.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectContainerExpirationPolicy:getProjectContainerExpirationPolicy"
                        },
                        "type": "array"
                    },
                    "containerRegistryAccessLevel": {
                        "description": "Set visibility of container registry, for this project. Valid values are `disabled`, `private`, `enabled`.\n",
                        "type": "string"
                    },
                    "defaultBranch": {
                        "description": "The default branch for the project.\n",
                        "type": "string"
                    },
                    "description": {
                        "description": "A description of the project.\n",
                        "type": "string"
                    },
                    "emailsEnabled": {
                        "description": "Enable email notifications.\n",
                        "type": "boolean"
                    },
                    "emptyRepo": {
                        "description": "Whether the project is empty.\n",
                        "type": "boolean"
                    },
                    "environmentsAccessLevel": {
                        "description": "Set the environments access level. Valid values are `disabled`, `private`, `enabled`.\n",
                        "type": "string"
                    },
                    "externalAuthorizationClassificationLabel": {
                        "description": "The classification label for the project.\n",
                        "type": "string"
                    },
                    "featureFlagsAccessLevel": {
                        "description": "Set the feature flags access level. Valid values are `disabled`, `private`, `enabled`.\n",
                        "type": "string"
                    },
                    "forkingAccessLevel": {
                        "description": "Set the forking access level. Valid values are `disabled`, `private`, `enabled`.\n",
                        "type": "string"
                    },
                    "httpUrlToRepo": {
                        "description": "URL that can be provided to `git clone` to clone the\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The integer that uniquely identifies the project within the gitlab install.\n",
                        "type": "string"
                    },
                    "importUrl": {
                        "description": "URL the project was imported from.\n",
                        "type": "string"
                    },
                    "infrastructureAccessLevel": {
                        "description": "Set the infrastructure access level. Valid values are `disabled`, `private`, `enabled`.\n",
                        "type": "string"
                    },
                    "issuesAccessLevel": {
                        "description": "Set the issues access level. Valid values are `disabled`, `private`, `enabled`.\n",
                        "type": "string"
                    },
                    "issuesEnabled": {
                        "description": "Enable issue tracking for the project.\n",
                        "type": "boolean"
                    },
                    "keepLatestArtifact": {
                        "description": "Disable or enable the ability to keep the latest artifact for this project.\n",
                        "type": "boolean"
                    },
                    "lfsEnabled": {
                        "description": "Enable LFS for the project.\n",
                        "type": "boolean"
                    },
                    "mergeCommitTemplate": {
                        "description": "Template used to create merge commit message in merge requests. (Introduced in GitLab 14.5.)\n",
                        "type": "string"
                    },
                    "mergePipelinesEnabled": {
                        "description": "Enable or disable merge pipelines.\n",
                        "type": "boolean"
                    },
                    "mergeRequestsAccessLevel": {
                        "description": "Set the merge requests access level. Valid values are `disabled`, `private`, `enabled`.\n",
                        "type": "string"
                    },
                    "mergeRequestsEnabled": {
                        "description": "Enable merge requests for the project.\n",
                        "type": "boolean"
                    },
                    "mergeTrainsEnabled": {
                        "description": "Enable or disable merge trains.\n",
                        "type": "boolean"
                    },
                    "modelExperimentsAccessLevel": {
                        "description": "The visibility of machine learning model experiments.\n",
                        "type": "string"
                    },
                    "modelRegistryAccessLevel": {
                        "description": "The visibility of machine learning model registry.\n",
                        "type": "string"
                    },
                    "monitorAccessLevel": {
                        "description": "Set the monitor access level. Valid values are `disabled`, `private`, `enabled`.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "The name of the project.\n",
                        "type": "string"
                    },
                    "namespaceId": {
                        "description": "The namespace (group or user) of the project. Defaults to your user.\n",
                        "type": "integer"
                    },
                    "path": {
                        "description": "The path of the repository.\n",
                        "type": "string"
                    },
                    "pathWithNamespace": {
                        "description": "The path of the repository with namespace.\n",
                        "type": "string"
                    },
                    "pipelinesEnabled": {
                        "description": "Enable pipelines for the project.\n",
                        "type": "boolean"
                    },
                    "printingMergeRequestLinkEnabled": {
                        "description": "Show link to create/view merge request when pushing from the command line\n",
                        "type": "boolean"
                    },
                    "publicBuilds": {
                        "description": "If true, jobs can be viewed by non-project members.\n",
                        "type": "boolean"
                    },
                    "pushRules": {
                        "description": "Push rules for the project. Push rules are only available on Enterprise plans and if the authenticated has permissions to read them.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectPushRule:getProjectPushRule"
                        },
                        "type": "array"
                    },
                    "releasesAccessLevel": {
                        "description": "Set the releases access level. Valid values are `disabled`, `private`, `enabled`.\n",
                        "type": "string"
                    },
                    "removeSourceBranchAfterMerge": {
                        "description": "Enable `Delete source branch` option by default for all new merge requests\n",
                        "type": "boolean"
                    },
                    "repositoryAccessLevel": {
                        "description": "Set the repository access level. Valid values are `disabled`, `private`, `enabled`.\n",
                        "type": "string"
                    },
                    "repositoryStorage": {
                        "description": "Which storage shard the repository is on. (administrator only)\n",
                        "type": "string"
                    },
                    "requestAccessEnabled": {
                        "description": "Allow users to request member access.\n",
                        "type": "boolean"
                    },
                    "requirementsAccessLevel": {
                        "description": "Set the requirements access level. Valid values are `disabled`, `private`, `enabled`.\n",
                        "type": "string"
                    },
                    "resolveOutdatedDiffDiscussions": {
                        "description": "Automatically resolve merge request diffs discussions on lines changed with a push.\n",
                        "type": "boolean"
                    },
                    "restrictUserDefinedVariables": {
                        "description": "Allow only users with the Maintainer role to pass user-defined variables when triggering a pipeline.\n",
                        "type": "boolean"
                    },
                    "runnersToken": {
                        "description": "Registration token to use during runner setup.\n",
                        "secret": true,
                        "type": "string"
                    },
                    "securityAndComplianceAccessLevel": {
                        "description": "Set the security and compliance access level. Valid values are `disabled`, `private`, `enabled`.\n",
                        "type": "string"
                    },
                    "sharedWithGroups": {
                        "description": "Describes groups which have access shared to this project.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectSharedWithGroup:getProjectSharedWithGroup"
                        },
                        "type": "array"
                    },
                    "snippetsAccessLevel": {
                        "description": "Set the snippets access level. Valid values are `disabled`, `private`, `enabled`.\n",
                        "type": "string"
                    },
                    "snippetsEnabled": {
                        "description": "Enable snippets for the project.\n",
                        "type": "boolean"
                    },
                    "squashCommitTemplate": {
                        "description": "Template used to create squash commit message in merge requests. (Introduced in GitLab 14.6.)\n",
                        "type": "string"
                    },
                    "sshUrlToRepo": {
                        "description": "URL that can be provided to `git clone` to clone the\n",
                        "type": "string"
                    },
                    "suggestionCommitMessage": {
                        "description": "The commit message used to apply merge request suggestions.\n",
                        "type": "string"
                    },
                    "topics": {
                        "description": "The list of topics for the project.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "visibilityLevel": {
                        "description": "Repositories are created as private by default.\n",
                        "type": "string"
                    },
                    "webUrl": {
                        "description": "URL that can be used to find the project in a browser.\n",
                        "type": "string"
                    },
                    "wikiAccessLevel": {
                        "description": "Set the wiki access level. Valid values are `disabled`, `private`, `enabled`.\n",
                        "type": "string"
                    },
                    "wikiEnabled": {
                        "description": "Enable wiki for the project.\n",
                        "type": "boolean"
                    }
                },
                "required": [
                    "allowPipelineTriggerApproveDeployment",
                    "analyticsAccessLevel",
                    "archived",
                    "autoCancelPendingPipelines",
                    "autoDevopsDeployStrategy",
                    "autoDevopsEnabled",
                    "autocloseReferencedIssues",
                    "buildGitStrategy",
                    "buildTimeout",
                    "buildsAccessLevel",
                    "ciConfigPath",
                    "ciDefaultGitDepth",
                    "ciPipelineVariablesMinimumOverrideRole",
                    "ciRestrictPipelineCancellationRole",
                    "ciSeparatedCaches",
                    "containerExpirationPolicies",
                    "containerRegistryAccessLevel",
                    "defaultBranch",
                    "description",
                    "emailsEnabled",
                    "emptyRepo",
                    "environmentsAccessLevel",
                    "externalAuthorizationClassificationLabel",
                    "featureFlagsAccessLevel",
                    "forkingAccessLevel",
                    "httpUrlToRepo",
                    "id",
                    "importUrl",
                    "infrastructureAccessLevel",
                    "issuesAccessLevel",
                    "issuesEnabled",
                    "keepLatestArtifact",
                    "lfsEnabled",
                    "mergeCommitTemplate",
                    "mergePipelinesEnabled",
                    "mergeRequestsAccessLevel",
                    "mergeRequestsEnabled",
                    "mergeTrainsEnabled",
                    "modelExperimentsAccessLevel",
                    "modelRegistryAccessLevel",
                    "monitorAccessLevel",
                    "name",
                    "namespaceId",
                    "path",
                    "pathWithNamespace",
                    "pipelinesEnabled",
                    "printingMergeRequestLinkEnabled",
                    "pushRules",
                    "releasesAccessLevel",
                    "removeSourceBranchAfterMerge",
                    "repositoryAccessLevel",
                    "repositoryStorage",
                    "requestAccessEnabled",
                    "requirementsAccessLevel",
                    "resolveOutdatedDiffDiscussions",
                    "restrictUserDefinedVariables",
                    "runnersToken",
                    "securityAndComplianceAccessLevel",
                    "sharedWithGroups",
                    "snippetsAccessLevel",
                    "snippetsEnabled",
                    "squashCommitTemplate",
                    "sshUrlToRepo",
                    "suggestionCommitMessage",
                    "topics",
                    "visibilityLevel",
                    "webUrl",
                    "wikiAccessLevel",
                    "wikiEnabled"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getProjectBranches:getProjectBranches": {
            "description": "The `gitlab.getProjectBranches` data source allows details of the branches of a given project to be retrieved.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/branches.html#list-repository-branches)\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectBranches.\n",
                "properties": {
                    "project": {
                        "type": "string",
                        "description": "ID or URL-encoded path of the project owned by the authenticated user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectBranches.\n",
                "properties": {
                    "branches": {
                        "description": "The list of branches of the project, as defined below.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectBranchesBranch:getProjectBranchesBranch"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "project": {
                        "description": "ID or URL-encoded path of the project owned by the authenticated user.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "branches",
                    "project",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getProjectEnvironments:getProjectEnvironments": {
            "description": "The `gitlab.getProjectEnvironments` data source retrieves information about all environments of the given project.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/environments.html#list-environments)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst thisProject = new gitlab.Project(\"this\", {\n    name: \"example\",\n    initializeWithReadme: true,\n});\nconst this = gitlab.getProjectEnvironmentsOutput({\n    project: thisProject.pathWithNamespace,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nthis_project = gitlab.Project(\"this\",\n    name=\"example\",\n    initialize_with_readme=True)\nthis = gitlab.get_project_environments_output(project=this_project.path_with_namespace)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var thisProject = new GitLab.Project(\"this\", new()\n    {\n        Name = \"example\",\n        InitializeWithReadme = true,\n    });\n\n    var @this = GitLab.GetProjectEnvironments.Invoke(new()\n    {\n        Project = thisProject.PathWithNamespace,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tthisProject, err := gitlab.NewProject(ctx, \"this\", \u0026gitlab.ProjectArgs{\n\t\t\tName:                 pulumi.String(\"example\"),\n\t\t\tInitializeWithReadme: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = gitlab.GetProjectEnvironmentsOutput(ctx, gitlab.GetProjectEnvironmentsOutputArgs{\n\t\t\tProject: thisProject.PathWithNamespace,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.ProjectArgs;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetProjectEnvironmentsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var thisProject = new Project(\"thisProject\", ProjectArgs.builder()\n            .name(\"example\")\n            .initializeWithReadme(true)\n            .build());\n\n        final var this = GitlabFunctions.getProjectEnvironments(GetProjectEnvironmentsArgs.builder()\n            .project(thisProject.pathWithNamespace())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  thisProject:\n    type: gitlab:Project\n    name: this\n    properties:\n      name: example\n      initializeWithReadme: true\nvariables:\n  this:\n    fn::invoke:\n      Function: gitlab:getProjectEnvironments\n      Arguments:\n        project: ${thisProject.pathWithNamespace}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectEnvironments.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Return the environment with this name. Mutually exclusive with search.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or full path of the project.\n"
                    },
                    "search": {
                        "type": "string",
                        "description": "Return list of environments matching the search criteria. Mutually exclusive with name. Must be at least 3 characters long.\n"
                    },
                    "states": {
                        "type": "string",
                        "description": "List all environments that match the specified state. Valid values are `available`, `stopping`, `stopped`. Returns all environments if not set.\n"
                    }
                },
                "type": "object",
                "required": [
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectEnvironments.\n",
                "properties": {
                    "environments": {
                        "description": "The list of environments.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectEnvironmentsEnvironment:getProjectEnvironmentsEnvironment"
                        },
                        "type": "array"
                    },
                    "id": {
                        "type": "string"
                    },
                    "name": {
                        "description": "Return the environment with this name. Mutually exclusive with search.\n",
                        "type": "string"
                    },
                    "project": {
                        "description": "The ID or full path of the project.\n",
                        "type": "string"
                    },
                    "search": {
                        "description": "Return list of environments matching the search criteria. Mutually exclusive with name. Must be at least 3 characters long.\n",
                        "type": "string"
                    },
                    "states": {
                        "description": "List all environments that match the specified state. Valid values are `available`, `stopping`, `stopped`. Returns all environments if not set.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "environments",
                    "id",
                    "project"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getProjectHook:getProjectHook": {
            "description": "The `gitlab.ProjectHook` data source allows to retrieve details about a hook in a project.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/projects.html#get-project-hook)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getProject({\n    id: \"foo/bar/baz\",\n});\nconst exampleGetProjectHook = example.then(example =\u003e gitlab.getProjectHook({\n    project: example.id,\n    hookId: 1,\n}));\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_project(id=\"foo/bar/baz\")\nexample_get_project_hook = gitlab.get_project_hook(project=example.id,\n    hook_id=1)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetProject.Invoke(new()\n    {\n        Id = \"foo/bar/baz\",\n    });\n\n    var exampleGetProjectHook = GitLab.GetProjectHook.Invoke(new()\n    {\n        Project = example.Apply(getProjectResult =\u003e getProjectResult.Id),\n        HookId = 1,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := gitlab.LookupProject(ctx, \u0026gitlab.LookupProjectArgs{\n\t\t\tId: pulumi.StringRef(\"foo/bar/baz\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.LookupProjectHook(ctx, \u0026gitlab.LookupProjectHookArgs{\n\t\t\tProject: example.Id,\n\t\t\tHookId:  1,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetProjectArgs;\nimport com.pulumi.gitlab.inputs.GetProjectHookArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getProject(GetProjectArgs.builder()\n            .id(\"foo/bar/baz\")\n            .build());\n\n        final var exampleGetProjectHook = GitlabFunctions.getProjectHook(GetProjectHookArgs.builder()\n            .project(example.applyValue(getProjectResult -\u003e getProjectResult.id()))\n            .hookId(1)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getProject\n      Arguments:\n        id: foo/bar/baz\n  exampleGetProjectHook:\n    fn::invoke:\n      Function: gitlab:getProjectHook\n      Arguments:\n        project: ${example.id}\n        hookId: 1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectHook.\n",
                "properties": {
                    "hookId": {
                        "type": "integer",
                        "description": "The id of the project hook.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project to add the hook to.\n"
                    }
                },
                "type": "object",
                "required": [
                    "hookId",
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectHook.\n",
                "properties": {
                    "confidentialIssuesEvents": {
                        "description": "Invoke the hook for confidential issues events.\n",
                        "type": "boolean"
                    },
                    "confidentialNoteEvents": {
                        "description": "Invoke the hook for confidential notes events.\n",
                        "type": "boolean"
                    },
                    "customWebhookTemplate": {
                        "description": "Set a custom webhook template.\n",
                        "type": "string"
                    },
                    "deploymentEvents": {
                        "description": "Invoke the hook for deployment events.\n",
                        "type": "boolean"
                    },
                    "enableSslVerification": {
                        "description": "Enable ssl verification when invoking the hook.\n",
                        "type": "boolean"
                    },
                    "hookId": {
                        "description": "The id of the project hook.\n",
                        "type": "integer"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "issuesEvents": {
                        "description": "Invoke the hook for issues events.\n",
                        "type": "boolean"
                    },
                    "jobEvents": {
                        "description": "Invoke the hook for job events.\n",
                        "type": "boolean"
                    },
                    "mergeRequestsEvents": {
                        "description": "Invoke the hook for merge requests.\n",
                        "type": "boolean"
                    },
                    "noteEvents": {
                        "description": "Invoke the hook for notes events.\n",
                        "type": "boolean"
                    },
                    "pipelineEvents": {
                        "description": "Invoke the hook for pipeline events.\n",
                        "type": "boolean"
                    },
                    "project": {
                        "description": "The name or id of the project to add the hook to.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "description": "The id of the project for the hook.\n",
                        "type": "integer"
                    },
                    "pushEvents": {
                        "description": "Invoke the hook for push events.\n",
                        "type": "boolean"
                    },
                    "pushEventsBranchFilter": {
                        "description": "Invoke the hook for push events on matching branches only.\n",
                        "type": "string"
                    },
                    "releasesEvents": {
                        "description": "Invoke the hook for releases events.\n",
                        "type": "boolean"
                    },
                    "tagPushEvents": {
                        "description": "Invoke the hook for tag push events.\n",
                        "type": "boolean"
                    },
                    "token": {
                        "description": "A token to present when invoking the hook. The token is not available for imported resources.\n",
                        "type": "string"
                    },
                    "url": {
                        "description": "The url of the hook to invoke.\n",
                        "type": "string"
                    },
                    "wikiPageEvents": {
                        "description": "Invoke the hook for wiki page events.\n",
                        "type": "boolean"
                    }
                },
                "required": [
                    "confidentialIssuesEvents",
                    "confidentialNoteEvents",
                    "customWebhookTemplate",
                    "deploymentEvents",
                    "enableSslVerification",
                    "hookId",
                    "issuesEvents",
                    "jobEvents",
                    "mergeRequestsEvents",
                    "noteEvents",
                    "pipelineEvents",
                    "project",
                    "projectId",
                    "pushEvents",
                    "pushEventsBranchFilter",
                    "releasesEvents",
                    "tagPushEvents",
                    "token",
                    "url",
                    "wikiPageEvents",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getProjectHooks:getProjectHooks": {
            "description": "The `gitlab.getProjectHooks` data source allows to retrieve details about hooks in a project.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/projects.html#list-project-hooks)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getProject({\n    id: \"foo/bar/baz\",\n});\nconst examples = example.then(example =\u003e gitlab.getProjectHooks({\n    project: example.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_project(id=\"foo/bar/baz\")\nexamples = gitlab.get_project_hooks(project=example.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetProject.Invoke(new()\n    {\n        Id = \"foo/bar/baz\",\n    });\n\n    var examples = GitLab.GetProjectHooks.Invoke(new()\n    {\n        Project = example.Apply(getProjectResult =\u003e getProjectResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := gitlab.LookupProject(ctx, \u0026gitlab.LookupProjectArgs{\n\t\t\tId: pulumi.StringRef(\"foo/bar/baz\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.GetProjectHooks(ctx, \u0026gitlab.GetProjectHooksArgs{\n\t\t\tProject: example.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetProjectArgs;\nimport com.pulumi.gitlab.inputs.GetProjectHooksArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getProject(GetProjectArgs.builder()\n            .id(\"foo/bar/baz\")\n            .build());\n\n        final var examples = GitlabFunctions.getProjectHooks(GetProjectHooksArgs.builder()\n            .project(example.applyValue(getProjectResult -\u003e getProjectResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getProject\n      Arguments:\n        id: foo/bar/baz\n  examples:\n    fn::invoke:\n      Function: gitlab:getProjectHooks\n      Arguments:\n        project: ${example.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectHooks.\n",
                "properties": {
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectHooks.\n",
                "properties": {
                    "hooks": {
                        "description": "The list of hooks.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectHooksHook:getProjectHooksHook"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "project": {
                        "description": "The name or id of the project.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "hooks",
                    "project",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getProjectIds:getProjectIds": {
            "description": "The `gitlab.getProjectIds` data source identification information for a given project, allowing a user to translate a full path or ID into the GraphQL ID of the project.\n\n**Upstream API**: [GitLab GraphQL API docs](https://docs.gitlab.com/ee/api/graphql/reference/#queryproject)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst newProject = new gitlab.Project(\"new_project\", {});\n// use project IDs to get additional information, such as the GraphQL ID\n// for other resources\nconst foo = gitlab.getProjectIds({\n    project: \"gitlab_project.new_project.id\",\n});\nexport const graphQLId = foo.then(foo =\u003e foo.projectGraphqlId);\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nnew_project = gitlab.Project(\"new_project\")\n# use project IDs to get additional information, such as the GraphQL ID\n# for other resources\nfoo = gitlab.get_project_ids(project=\"gitlab_project.new_project.id\")\npulumi.export(\"graphQLId\", foo.project_graphql_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var newProject = new GitLab.Project(\"new_project\");\n\n    // use project IDs to get additional information, such as the GraphQL ID\n    // for other resources\n    var foo = GitLab.GetProjectIds.Invoke(new()\n    {\n        Project = \"gitlab_project.new_project.id\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"graphQLId\"] = foo.Apply(getProjectIdsResult =\u003e getProjectIdsResult.ProjectGraphqlId),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewProject(ctx, \"new_project\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// use project IDs to get additional information, such as the GraphQL ID\n\t\t// for other resources\n\t\tfoo, err := gitlab.GetProjectIds(ctx, \u0026gitlab.GetProjectIdsArgs{\n\t\t\tProject: \"gitlab_project.new_project.id\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"graphQLId\", foo.ProjectGraphqlId)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.Project;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetProjectIdsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var newProject = new Project(\"newProject\");\n\n        // use project IDs to get additional information, such as the GraphQL ID\n        // for other resources\n        final var foo = GitlabFunctions.getProjectIds(GetProjectIdsArgs.builder()\n            .project(\"gitlab_project.new_project.id\")\n            .build());\n\n        ctx.export(\"graphQLId\", foo.applyValue(getProjectIdsResult -\u003e getProjectIdsResult.projectGraphqlId()));\n    }\n}\n```\n```yaml\nresources:\n  newProject:\n    type: gitlab:Project\n    name: new_project\nvariables:\n  # use project IDs to get additional information, such as the GraphQL ID\n  # // for other resources\n  foo:\n    fn::invoke:\n      Function: gitlab:getProjectIds\n      Arguments:\n        project: gitlab_project.new_project.id\noutputs:\n  graphQLId: ${foo.projectGraphqlId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectIds.\n",
                "properties": {
                    "project": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectIds.\n",
                "properties": {
                    "id": {
                        "type": "string"
                    },
                    "project": {
                        "description": "The ID or URL-encoded path of the project.\n",
                        "type": "string"
                    },
                    "projectFullPath": {
                        "description": "The full path of the project.\n",
                        "type": "string"
                    },
                    "projectGraphqlId": {
                        "description": "The GraphQL ID of the project.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "description": "The ID of the project.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "id",
                    "project",
                    "projectFullPath",
                    "projectGraphqlId",
                    "projectId"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getProjectIssue:getProjectIssue": {
            "description": "The `gitlab.ProjectIssue` data source allows to retrieve details about an issue in a project.\n\n**Upstream API**: [GitLab API docs](https://docs.gitlab.com/ee/api/issues.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = gitlab.getProject({\n    pathWithNamespace: \"foo/bar/baz\",\n});\nconst welcomeIssue = foo.then(foo =\u003e gitlab.getProjectIssue({\n    project: foo.id,\n    iid: 1,\n}));\nexport const welcomeIssueWebUrl = webUrl;\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.get_project(path_with_namespace=\"foo/bar/baz\")\nwelcome_issue = gitlab.get_project_issue(project=foo.id,\n    iid=1)\npulumi.export(\"welcomeIssueWebUrl\", web_url)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = GitLab.GetProject.Invoke(new()\n    {\n        PathWithNamespace = \"foo/bar/baz\",\n    });\n\n    var welcomeIssue = GitLab.GetProjectIssue.Invoke(new()\n    {\n        Project = foo.Apply(getProjectResult =\u003e getProjectResult.Id),\n        Iid = 1,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"welcomeIssueWebUrl\"] = webUrl,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfoo, err := gitlab.LookupProject(ctx, \u0026gitlab.LookupProjectArgs{\n\t\t\tPathWithNamespace: pulumi.StringRef(\"foo/bar/baz\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.LookupProjectIssue(ctx, \u0026gitlab.LookupProjectIssueArgs{\n\t\t\tProject: foo.Id,\n\t\t\tIid:     1,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"welcomeIssueWebUrl\", webUrl)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetProjectArgs;\nimport com.pulumi.gitlab.inputs.GetProjectIssueArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var foo = GitlabFunctions.getProject(GetProjectArgs.builder()\n            .pathWithNamespace(\"foo/bar/baz\")\n            .build());\n\n        final var welcomeIssue = GitlabFunctions.getProjectIssue(GetProjectIssueArgs.builder()\n            .project(foo.applyValue(getProjectResult -\u003e getProjectResult.id()))\n            .iid(1)\n            .build());\n\n        ctx.export(\"welcomeIssueWebUrl\", webUrl);\n    }\n}\n```\n```yaml\nvariables:\n  foo:\n    fn::invoke:\n      Function: gitlab:getProject\n      Arguments:\n        pathWithNamespace: foo/bar/baz\n  welcomeIssue:\n    fn::invoke:\n      Function: gitlab:getProjectIssue\n      Arguments:\n        project: ${foo.id}\n        iid: 1\noutputs:\n  welcomeIssueWebUrl: ${webUrl}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectIssue.\n",
                "properties": {
                    "iid": {
                        "type": "integer",
                        "description": "The internal ID of the project's issue.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or ID of the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "iid",
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectIssue.\n",
                "properties": {
                    "assigneeIds": {
                        "description": "The IDs of the users to assign the issue to.\n",
                        "items": {
                            "type": "integer"
                        },
                        "type": "array"
                    },
                    "authorId": {
                        "description": "The ID of the author of the issue. Use `gitlab.User` data source to get more information about the user.\n",
                        "type": "integer"
                    },
                    "closedAt": {
                        "description": "When the issue was closed. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n",
                        "type": "string"
                    },
                    "closedByUserId": {
                        "description": "The ID of the user that closed the issue. Use `gitlab.User` data source to get more information about the user.\n",
                        "type": "integer"
                    },
                    "confidential": {
                        "description": "Set an issue to be confidential.\n",
                        "type": "boolean"
                    },
                    "createdAt": {
                        "description": "When the issue was created. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z. Requires administrator or project/group owner rights.\n",
                        "type": "string"
                    },
                    "description": {
                        "description": "The description of an issue. Limited to 1,048,576 characters.\n",
                        "type": "string"
                    },
                    "discussionLocked": {
                        "description": "Whether the issue is locked for discussions or not.\n",
                        "type": "boolean"
                    },
                    "discussionToResolve": {
                        "description": "The ID of a discussion to resolve. This fills out the issue with a default description and mark the discussion as resolved. Use in combination with merge*request*to*resolve*discussions_of.\n",
                        "type": "string"
                    },
                    "downvotes": {
                        "description": "The number of downvotes the issue has received.\n",
                        "type": "integer"
                    },
                    "dueDate": {
                        "description": "The due date. Date time string in the format YYYY-MM-DD, for example 2016-03-11.\n",
                        "type": "string"
                    },
                    "epicId": {
                        "description": "ID of the epic to add the issue to. Valid values are greater than or equal to 0.\n",
                        "type": "integer"
                    },
                    "epicIssueId": {
                        "description": "The ID of the epic issue.\n",
                        "type": "integer"
                    },
                    "externalId": {
                        "description": "The external ID of the issue.\n",
                        "type": "string"
                    },
                    "humanTimeEstimate": {
                        "description": "The human-readable time estimate of the issue.\n",
                        "type": "string"
                    },
                    "humanTotalTimeSpent": {
                        "description": "The human-readable total time spent of the issue.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "iid": {
                        "description": "The internal ID of the project's issue.\n",
                        "type": "integer"
                    },
                    "issueId": {
                        "description": "The instance-wide ID of the issue.\n",
                        "type": "integer"
                    },
                    "issueLinkId": {
                        "description": "The ID of the issue link.\n",
                        "type": "integer"
                    },
                    "issueType": {
                        "description": "The type of issue. Valid values are: `issue`, `incident`, `test_case`.\n",
                        "type": "string"
                    },
                    "labels": {
                        "description": "The labels of an issue.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "links": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "The links of the issue.\n",
                        "type": "object"
                    },
                    "mergeRequestToResolveDiscussionsOf": {
                        "description": "The IID of a merge request in which to resolve all issues. This fills out the issue with a default description and mark all discussions as resolved. When passing a description or title, these values take precedence over the default values.\n",
                        "type": "integer"
                    },
                    "mergeRequestsCount": {
                        "description": "The number of merge requests associated with the issue.\n",
                        "type": "integer"
                    },
                    "milestoneId": {
                        "description": "The global ID of a milestone to assign issue. To find the milestone_id associated with a milestone, view an issue with the milestone assigned and use the API to retrieve the issue's details.\n",
                        "type": "integer"
                    },
                    "movedToId": {
                        "description": "The ID of the issue that was moved to.\n",
                        "type": "integer"
                    },
                    "project": {
                        "description": "The name or ID of the project.\n",
                        "type": "string"
                    },
                    "references": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "The references of the issue.\n",
                        "type": "object"
                    },
                    "state": {
                        "description": "The state of the issue. Valid values are: `opened`, `closed`.\n",
                        "type": "string"
                    },
                    "subscribed": {
                        "description": "Whether the authenticated user is subscribed to the issue or not.\n",
                        "type": "boolean"
                    },
                    "taskCompletionStatuses": {
                        "description": "The task completion status. It's always a one element list.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectIssueTaskCompletionStatus:getProjectIssueTaskCompletionStatus"
                        },
                        "type": "array"
                    },
                    "timeEstimate": {
                        "description": "The time estimate of the issue.\n",
                        "type": "integer"
                    },
                    "title": {
                        "description": "The title of the issue.\n",
                        "type": "string"
                    },
                    "totalTimeSpent": {
                        "description": "The total time spent of the issue.\n",
                        "type": "integer"
                    },
                    "updatedAt": {
                        "description": "When the issue was updated. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n",
                        "type": "string"
                    },
                    "upvotes": {
                        "description": "The number of upvotes the issue has received.\n",
                        "type": "integer"
                    },
                    "userNotesCount": {
                        "description": "The number of user notes on the issue.\n",
                        "type": "integer"
                    },
                    "webUrl": {
                        "description": "The web URL of the issue.\n",
                        "type": "string"
                    },
                    "weight": {
                        "description": "The weight of the issue. Valid values are greater than or equal to 0.\n",
                        "type": "integer"
                    }
                },
                "required": [
                    "assigneeIds",
                    "authorId",
                    "closedAt",
                    "closedByUserId",
                    "confidential",
                    "createdAt",
                    "description",
                    "discussionLocked",
                    "discussionToResolve",
                    "downvotes",
                    "dueDate",
                    "epicId",
                    "epicIssueId",
                    "externalId",
                    "humanTimeEstimate",
                    "humanTotalTimeSpent",
                    "iid",
                    "issueId",
                    "issueLinkId",
                    "issueType",
                    "labels",
                    "links",
                    "mergeRequestToResolveDiscussionsOf",
                    "mergeRequestsCount",
                    "milestoneId",
                    "movedToId",
                    "project",
                    "references",
                    "state",
                    "subscribed",
                    "taskCompletionStatuses",
                    "timeEstimate",
                    "title",
                    "totalTimeSpent",
                    "updatedAt",
                    "upvotes",
                    "userNotesCount",
                    "webUrl",
                    "weight",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getProjectIssues:getProjectIssues": {
            "description": "The `gitlab.getProjectIssues` data source allows to retrieve details about issues in a project.\n\n**Upstream API**: [GitLab API docs](https://docs.gitlab.com/ee/api/issues.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = gitlab.getProject({\n    id: \"foo/bar/baz\",\n});\nconst allWithFoo = foo.then(foo =\u003e gitlab.getProjectIssues({\n    project: foo.id,\n    search: \"foo\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.get_project(id=\"foo/bar/baz\")\nall_with_foo = gitlab.get_project_issues(project=foo.id,\n    search=\"foo\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = GitLab.GetProject.Invoke(new()\n    {\n        Id = \"foo/bar/baz\",\n    });\n\n    var allWithFoo = GitLab.GetProjectIssues.Invoke(new()\n    {\n        Project = foo.Apply(getProjectResult =\u003e getProjectResult.Id),\n        Search = \"foo\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfoo, err := gitlab.LookupProject(ctx, \u0026gitlab.LookupProjectArgs{\n\t\t\tId: pulumi.StringRef(\"foo/bar/baz\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.GetProjectIssues(ctx, \u0026gitlab.GetProjectIssuesArgs{\n\t\t\tProject: foo.Id,\n\t\t\tSearch:  pulumi.StringRef(\"foo\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetProjectArgs;\nimport com.pulumi.gitlab.inputs.GetProjectIssuesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var foo = GitlabFunctions.getProject(GetProjectArgs.builder()\n            .id(\"foo/bar/baz\")\n            .build());\n\n        final var allWithFoo = GitlabFunctions.getProjectIssues(GetProjectIssuesArgs.builder()\n            .project(foo.applyValue(getProjectResult -\u003e getProjectResult.id()))\n            .search(\"foo\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  foo:\n    fn::invoke:\n      Function: gitlab:getProject\n      Arguments:\n        id: foo/bar/baz\n  allWithFoo:\n    fn::invoke:\n      Function: gitlab:getProjectIssues\n      Arguments:\n        project: ${foo.id}\n        search: foo\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectIssues.\n",
                "properties": {
                    "assigneeId": {
                        "type": "integer",
                        "description": "Return issues assigned to the given user id. Mutually exclusive with assignee_username. None returns unassigned issues. Any returns issues with an assignee.\n"
                    },
                    "assigneeUsername": {
                        "type": "string",
                        "description": "Return issues assigned to the given username. Similar to assignee*id and mutually exclusive with assignee*id. In GitLab CE, the assignee_username array should only contain a single value. Otherwise, an invalid parameter error is returned.\n"
                    },
                    "authorId": {
                        "type": "integer",
                        "description": "Return issues created by the given user id. Combine with scope=all or scope=assigned*to*me.\n"
                    },
                    "confidential": {
                        "type": "boolean",
                        "description": "Filter confidential or public issues.\n"
                    },
                    "createdAfter": {
                        "type": "string",
                        "description": "Return issues created on or after the given time. Expected in ISO 8601 format (2019-03-15T08:00:00Z)\n"
                    },
                    "createdBefore": {
                        "type": "string",
                        "description": "Return issues created on or before the given time. Expected in ISO 8601 format (2019-03-15T08:00:00Z)\n"
                    },
                    "dueDate": {
                        "type": "string",
                        "description": "Return issues that have no due date, are overdue, or whose due date is this week, this month, or between two weeks ago and next month. Accepts: 0 (no due date), any, today, tomorrow, overdue, week, month, next*month*and*previous*two_weeks.\n"
                    },
                    "iids": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "Return only the issues having the given iid\n"
                    },
                    "issueType": {
                        "type": "string",
                        "description": "Filter to a given type of issue. Valid values are [issue incident test_case]. (Introduced in GitLab 13.12)\n"
                    },
                    "labels": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Return issues with labels. Issues must have all labels to be returned. None lists all issues with no labels. Any lists all issues with at least one label. No+Label (Deprecated) lists all issues with no labels. Predefined names are case-insensitive.\n"
                    },
                    "milestone": {
                        "type": "string",
                        "description": "The milestone title. None lists all issues with no milestone. Any lists all issues that have an assigned milestone.\n"
                    },
                    "myReactionEmoji": {
                        "type": "string",
                        "description": "Return issues reacted by the authenticated user by the given emoji. None returns issues not given a reaction. Any returns issues given at least one reaction.\n"
                    },
                    "notAssigneeIds": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "Return issues that do not match the assignee id.\n"
                    },
                    "notAuthorIds": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "Return issues that do not match the author id.\n"
                    },
                    "notLabels": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Return issues that do not match the labels.\n"
                    },
                    "notMilestone": {
                        "type": "string",
                        "description": "Return issues that do not match the milestone.\n"
                    },
                    "notMyReactionEmojis": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Return issues not reacted by the authenticated user by the given emoji.\n"
                    },
                    "orderBy": {
                        "type": "string",
                        "description": "Return issues ordered by. Valid values are `created_at`, `updated_at`, `priority`, `due_date`, `relative_position`, `label_priority`, `milestone_due`, `popularity`, `weight`. Default is created_at\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project.\n"
                    },
                    "scope": {
                        "type": "string",
                        "description": "Return issues for the given scope. Valid values are `created_by_me`, `assigned_to_me`, `all`. Defaults to all.\n"
                    },
                    "search": {
                        "type": "string",
                        "description": "Search project issues against their title and description\n"
                    },
                    "sort": {
                        "type": "string",
                        "description": "Return issues sorted in asc or desc order. Default is desc\n"
                    },
                    "updatedAfter": {
                        "type": "string",
                        "description": "Return issues updated on or after the given time. Expected in ISO 8601 format (2019-03-15T08:00:00Z)\n"
                    },
                    "updatedBefore": {
                        "type": "string",
                        "description": "Return issues updated on or before the given time. Expected in ISO 8601 format (2019-03-15T08:00:00Z)\n"
                    },
                    "weight": {
                        "type": "integer",
                        "description": "Return issues with the specified weight. None returns issues with no weight assigned. Any returns issues with a weight assigned.\n"
                    },
                    "withLabelsDetails": {
                        "type": "boolean",
                        "description": "If true, the response returns more details for each label in labels field: :name, :color, :description, :description*html, :text*color. Default is false. description_html was introduced in GitLab 12.7\n"
                    }
                },
                "type": "object",
                "required": [
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectIssues.\n",
                "properties": {
                    "assigneeId": {
                        "description": "Return issues assigned to the given user id. Mutually exclusive with assignee_username. None returns unassigned issues. Any returns issues with an assignee.\n",
                        "type": "integer"
                    },
                    "assigneeUsername": {
                        "description": "Return issues assigned to the given username. Similar to assignee*id and mutually exclusive with assignee*id. In GitLab CE, the assignee_username array should only contain a single value. Otherwise, an invalid parameter error is returned.\n",
                        "type": "string"
                    },
                    "authorId": {
                        "description": "Return issues created by the given user id. Combine with scope=all or scope=assigned*to*me.\n",
                        "type": "integer"
                    },
                    "confidential": {
                        "description": "Filter confidential or public issues.\n",
                        "type": "boolean"
                    },
                    "createdAfter": {
                        "description": "Return issues created on or after the given time. Expected in ISO 8601 format (2019-03-15T08:00:00Z)\n",
                        "type": "string"
                    },
                    "createdBefore": {
                        "description": "Return issues created on or before the given time. Expected in ISO 8601 format (2019-03-15T08:00:00Z)\n",
                        "type": "string"
                    },
                    "dueDate": {
                        "description": "Return issues that have no due date, are overdue, or whose due date is this week, this month, or between two weeks ago and next month. Accepts: 0 (no due date), any, today, tomorrow, overdue, week, month, next*month*and*previous*two_weeks.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "iids": {
                        "description": "Return only the issues having the given iid\n",
                        "items": {
                            "type": "integer"
                        },
                        "type": "array"
                    },
                    "issueType": {
                        "description": "Filter to a given type of issue. Valid values are [issue incident test_case]. (Introduced in GitLab 13.12)\n",
                        "type": "string"
                    },
                    "issues": {
                        "description": "The list of issues returned by the search.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectIssuesIssue:getProjectIssuesIssue"
                        },
                        "type": "array"
                    },
                    "labels": {
                        "description": "Return issues with labels. Issues must have all labels to be returned. None lists all issues with no labels. Any lists all issues with at least one label. No+Label (Deprecated) lists all issues with no labels. Predefined names are case-insensitive.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "milestone": {
                        "description": "The milestone title. None lists all issues with no milestone. Any lists all issues that have an assigned milestone.\n",
                        "type": "string"
                    },
                    "myReactionEmoji": {
                        "description": "Return issues reacted by the authenticated user by the given emoji. None returns issues not given a reaction. Any returns issues given at least one reaction.\n",
                        "type": "string"
                    },
                    "notAssigneeIds": {
                        "description": "Return issues that do not match the assignee id.\n",
                        "items": {
                            "type": "integer"
                        },
                        "type": "array"
                    },
                    "notAuthorIds": {
                        "description": "Return issues that do not match the author id.\n",
                        "items": {
                            "type": "integer"
                        },
                        "type": "array"
                    },
                    "notLabels": {
                        "description": "Return issues that do not match the labels.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "notMilestone": {
                        "description": "Return issues that do not match the milestone.\n",
                        "type": "string"
                    },
                    "notMyReactionEmojis": {
                        "description": "Return issues not reacted by the authenticated user by the given emoji.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "orderBy": {
                        "description": "Return issues ordered by. Valid values are `created_at`, `updated_at`, `priority`, `due_date`, `relative_position`, `label_priority`, `milestone_due`, `popularity`, `weight`. Default is created_at\n",
                        "type": "string"
                    },
                    "project": {
                        "description": "The name or id of the project.\n",
                        "type": "string"
                    },
                    "scope": {
                        "description": "Return issues for the given scope. Valid values are `created_by_me`, `assigned_to_me`, `all`. Defaults to all.\n",
                        "type": "string"
                    },
                    "search": {
                        "description": "Search project issues against their title and description\n",
                        "type": "string"
                    },
                    "sort": {
                        "description": "Return issues sorted in asc or desc order. Default is desc\n",
                        "type": "string"
                    },
                    "updatedAfter": {
                        "description": "Return issues updated on or after the given time. Expected in ISO 8601 format (2019-03-15T08:00:00Z)\n",
                        "type": "string"
                    },
                    "updatedBefore": {
                        "description": "Return issues updated on or before the given time. Expected in ISO 8601 format (2019-03-15T08:00:00Z)\n",
                        "type": "string"
                    },
                    "weight": {
                        "description": "Return issues with the specified weight. None returns issues with no weight assigned. Any returns issues with a weight assigned.\n",
                        "type": "integer"
                    },
                    "withLabelsDetails": {
                        "description": "If true, the response returns more details for each label in labels field: :name, :color, :description, :description*html, :text*color. Default is false. description_html was introduced in GitLab 12.7\n",
                        "type": "boolean"
                    }
                },
                "required": [
                    "issues",
                    "project",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getProjectMembership:getProjectMembership": {
            "description": "The `gitlab.ProjectMembership` data source allows to list and filter all members of a project specified by either its id or full path.\n\n\u003e **Note** exactly one of project_id or full_path must be provided.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/members.html#list-all-members-of-a-group-or-project)\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectMembership.\n",
                "properties": {
                    "fullPath": {
                        "type": "string",
                        "description": "The full path of the project.\n"
                    },
                    "inherited": {
                        "type": "boolean",
                        "description": "Return all project members including members through ancestor groups\n"
                    },
                    "projectId": {
                        "type": "integer",
                        "description": "The ID of the project.\n"
                    },
                    "query": {
                        "type": "string",
                        "description": "A query string to search for members\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getProjectMembership.\n",
                "properties": {
                    "fullPath": {
                        "description": "The full path of the project.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "inherited": {
                        "description": "Return all project members including members through ancestor groups\n",
                        "type": "boolean"
                    },
                    "members": {
                        "description": "The list of project members.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectMembershipMember:getProjectMembershipMember"
                        },
                        "type": "array"
                    },
                    "projectId": {
                        "description": "The ID of the project.\n",
                        "type": "integer"
                    },
                    "query": {
                        "description": "A query string to search for members\n",
                        "type": "string"
                    }
                },
                "required": [
                    "fullPath",
                    "members",
                    "projectId",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getProjectMergeRequest:getProjectMergeRequest": {
            "description": "The `gitlab.getProjectMergeRequest` data source retrieves\ninformation about a single merge request related to a specific project.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/merge_requests.html#get-single-mr)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst byProjectId = gitlab.getProjectMergeRequest({\n    project: \"123\",\n    iid: 456,\n});\nconst byProjectName = gitlab.getProjectMergeRequest({\n    project: \"company/group/project1\",\n    iid: 3,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nby_project_id = gitlab.get_project_merge_request(project=\"123\",\n    iid=456)\nby_project_name = gitlab.get_project_merge_request(project=\"company/group/project1\",\n    iid=3)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var byProjectId = GitLab.GetProjectMergeRequest.Invoke(new()\n    {\n        Project = \"123\",\n        Iid = 456,\n    });\n\n    var byProjectName = GitLab.GetProjectMergeRequest.Invoke(new()\n    {\n        Project = \"company/group/project1\",\n        Iid = 3,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.GetProjectMergeRequest(ctx, \u0026gitlab.GetProjectMergeRequestArgs{\n\t\t\tProject: \"123\",\n\t\t\tIid:     456,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.GetProjectMergeRequest(ctx, \u0026gitlab.GetProjectMergeRequestArgs{\n\t\t\tProject: \"company/group/project1\",\n\t\t\tIid:     3,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetProjectMergeRequestArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var byProjectId = GitlabFunctions.getProjectMergeRequest(GetProjectMergeRequestArgs.builder()\n            .project(\"123\")\n            .iid(456)\n            .build());\n\n        final var byProjectName = GitlabFunctions.getProjectMergeRequest(GetProjectMergeRequestArgs.builder()\n            .project(\"company/group/project1\")\n            .iid(3)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  byProjectId:\n    fn::invoke:\n      Function: gitlab:getProjectMergeRequest\n      Arguments:\n        project: '123'\n        iid: 456\n  byProjectName:\n    fn::invoke:\n      Function: gitlab:getProjectMergeRequest\n      Arguments:\n        project: company/group/project1\n        iid: 3\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectMergeRequest.\n",
                "properties": {
                    "iid": {
                        "type": "number",
                        "description": "The unique project level ID of the merge request.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or path of the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "iid",
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectMergeRequest.\n",
                "properties": {
                    "assignee": {
                        "$ref": "#/types/gitlab:index/getProjectMergeRequestAssignee:getProjectMergeRequestAssignee",
                        "description": "First assignee of the merge request.\n"
                    },
                    "assignees": {
                        "description": "Assignees of the merge request.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectMergeRequestAssignee:getProjectMergeRequestAssignee"
                        },
                        "type": "array"
                    },
                    "author": {
                        "$ref": "#/types/gitlab:index/getProjectMergeRequestAuthor:getProjectMergeRequestAuthor",
                        "description": "User who created this merge request.\n"
                    },
                    "blockingDiscussionsResolved": {
                        "description": "Indicates if all discussions are resolved only if all are\nrequired before merge request can be merged.\n",
                        "type": "boolean"
                    },
                    "changesCount": {
                        "description": "Number of changes made on the merge request. Empty when the\nmerge request is created, and populates asynchronously.\n",
                        "type": "string"
                    },
                    "closedAt": {
                        "description": "Timestamp of when the merge request was closed.\n",
                        "type": "string"
                    },
                    "closedBy": {
                        "$ref": "#/types/gitlab:index/getProjectMergeRequestClosedBy:getProjectMergeRequestClosedBy",
                        "description": "User who closed this merge request.\n"
                    },
                    "createdAt": {
                        "description": "Timestamp of when the merge request was created.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The unique instance level ID of the merge request.\n",
                        "type": "number"
                    },
                    "iid": {
                        "description": "The unique project level ID of the merge request.\n",
                        "type": "number"
                    },
                    "project": {
                        "description": "The ID or path of the project.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "assignee",
                    "assignees",
                    "author",
                    "blockingDiscussionsResolved",
                    "changesCount",
                    "closedAt",
                    "closedBy",
                    "createdAt",
                    "id",
                    "iid",
                    "project"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getProjectMilestone:getProjectMilestone": {
            "description": "The `gitlab.ProjectMilestone` data source allows get details of a project milestone.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/milestones.html)\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectMilestone.\n",
                "properties": {
                    "milestoneId": {
                        "type": "integer",
                        "description": "The instance-wide ID of the project’s milestone.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "milestoneId",
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectMilestone.\n",
                "properties": {
                    "createdAt": {
                        "description": "The time of creation of the milestone. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n",
                        "type": "string"
                    },
                    "description": {
                        "description": "The description of the milestone.\n",
                        "type": "string"
                    },
                    "dueDate": {
                        "description": "The due date of the milestone. Date time string in the format YYYY-MM-DD, for example 2016-03-11.\n",
                        "type": "string"
                    },
                    "expired": {
                        "description": "Bool, true if milestone expired.\n",
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "iid": {
                        "description": "The ID of the project's milestone.\n",
                        "type": "integer"
                    },
                    "milestoneId": {
                        "description": "The instance-wide ID of the project’s milestone.\n",
                        "type": "integer"
                    },
                    "project": {
                        "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "description": "The project ID of milestone.\n",
                        "type": "integer"
                    },
                    "startDate": {
                        "description": "The start date of the milestone. Date time string in the format YYYY-MM-DD, for example 2016-03-11.\n",
                        "type": "string"
                    },
                    "state": {
                        "description": "The state of the milestone. Valid values are: `active`, `closed`.\n",
                        "type": "string"
                    },
                    "title": {
                        "description": "The title of a milestone.\n",
                        "type": "string"
                    },
                    "updatedAt": {
                        "description": "The last update time of the milestone. Date time string, ISO 8601 formatted, for example 2016-03-11T03:45:40Z.\n",
                        "type": "string"
                    },
                    "webUrl": {
                        "description": "The web URL of the milestone.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "createdAt",
                    "description",
                    "dueDate",
                    "expired",
                    "iid",
                    "milestoneId",
                    "project",
                    "projectId",
                    "startDate",
                    "state",
                    "title",
                    "updatedAt",
                    "webUrl",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getProjectMilestones:getProjectMilestones": {
            "description": "The `gitlab.getProjectMilestones` data source allows get details of a project milestones.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/milestones.html)\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectMilestones.\n",
                "properties": {
                    "iids": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "Return only the milestones having the given `iid` (Note: ignored if `include_parent_milestones` is set as `true`).\n"
                    },
                    "includeParentMilestones": {
                        "type": "boolean",
                        "description": "Include group milestones from parent group and its ancestors. Introduced in GitLab 13.4.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n",
                        "willReplaceOnChanges": true
                    },
                    "search": {
                        "type": "string",
                        "description": "Return only milestones with a title or description matching the provided string.\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "Return only `active` or `closed` milestones.\n"
                    },
                    "title": {
                        "type": "string",
                        "description": "Return only the milestones having the given `title`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectMilestones.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "iids": {
                        "description": "Return only the milestones having the given `iid` (Note: ignored if `include_parent_milestones` is set as `true`).\n",
                        "items": {
                            "type": "integer"
                        },
                        "type": "array"
                    },
                    "includeParentMilestones": {
                        "description": "Include group milestones from parent group and its ancestors. Introduced in GitLab 13.4.\n",
                        "type": "boolean"
                    },
                    "milestones": {
                        "description": "List of milestones from a project.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectMilestonesMilestone:getProjectMilestonesMilestone"
                        },
                        "type": "array"
                    },
                    "project": {
                        "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n",
                        "type": "string"
                    },
                    "search": {
                        "description": "Return only milestones with a title or description matching the provided string.\n",
                        "type": "string"
                    },
                    "state": {
                        "description": "Return only `active` or `closed` milestones.\n",
                        "type": "string"
                    },
                    "title": {
                        "description": "Return only the milestones having the given `title`.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "milestones",
                    "project",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getProjectProtectedBranch:getProjectProtectedBranch": {
            "description": "The `gitlab.getProjectProtectedBranch` data source allows details of a protected branch to be retrieved by its name and the project it belongs to.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/protected_branches.html#get-a-single-protected-branch-or-wildcard-protected-branch)\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectProtectedBranch.\n",
                "properties": {
                    "mergeAccessLevels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectProtectedBranchMergeAccessLevel:getProjectProtectedBranchMergeAccessLevel"
                        },
                        "description": "Array of access levels and user(s)/group(s) allowed to merge to protected branch.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the protected branch.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The integer or path with namespace that uniquely identifies the project.\n"
                    },
                    "pushAccessLevels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectProtectedBranchPushAccessLevel:getProjectProtectedBranchPushAccessLevel"
                        },
                        "description": "Array of access levels and user(s)/group(s) allowed to push to protected branch.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectProtectedBranch.\n",
                "properties": {
                    "allowForcePush": {
                        "description": "Whether force push is allowed.\n",
                        "type": "boolean"
                    },
                    "codeOwnerApprovalRequired": {
                        "description": "Reject code pushes that change files listed in the CODEOWNERS file.\n",
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The ID of this resource.\n",
                        "type": "integer"
                    },
                    "mergeAccessLevels": {
                        "description": "Array of access levels and user(s)/group(s) allowed to merge to protected branch.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectProtectedBranchMergeAccessLevel:getProjectProtectedBranchMergeAccessLevel"
                        },
                        "type": "array"
                    },
                    "name": {
                        "description": "The name of the protected branch.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "description": "The integer or path with namespace that uniquely identifies the project.\n",
                        "type": "string"
                    },
                    "pushAccessLevels": {
                        "description": "Array of access levels and user(s)/group(s) allowed to push to protected branch.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectProtectedBranchPushAccessLevel:getProjectProtectedBranchPushAccessLevel"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "allowForcePush",
                    "codeOwnerApprovalRequired",
                    "id",
                    "name",
                    "projectId"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getProjectProtectedBranches:getProjectProtectedBranches": {
            "description": "The `gitlab.getProjectProtectedBranches` data source allows details of the protected branches of a given project.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/protected_branches.html#list-protected-branches)\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectProtectedBranches.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "The integer or path with namespace that uniquely identifies the project.\n"
                    },
                    "protectedBranches": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectProtectedBranchesProtectedBranch:getProjectProtectedBranchesProtectedBranch"
                        },
                        "description": "A list of protected branches, as defined below.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectProtectedBranches.\n",
                "properties": {
                    "id": {
                        "description": "The ID of this resource.\n",
                        "type": "integer"
                    },
                    "projectId": {
                        "description": "The integer or path with namespace that uniquely identifies the project.\n",
                        "type": "string"
                    },
                    "protectedBranches": {
                        "description": "A list of protected branches, as defined below.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectProtectedBranchesProtectedBranch:getProjectProtectedBranchesProtectedBranch"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "id",
                    "projectId"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getProjectProtectedTag:getProjectProtectedTag": {
            "description": "The `gitlab.getProjectProtectedTag` data source allows details of a protected tag to be retrieved by its name and the project it belongs to.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/protected_tags.html#get-a-single-protected-tag-or-wildcard-protected-tag)\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectProtectedTag.\n",
                "properties": {
                    "project": {
                        "type": "string",
                        "description": "The integer or path with namespace that uniquely identifies the project.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "The name of the protected tag.\n"
                    }
                },
                "type": "object",
                "required": [
                    "project",
                    "tag"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectProtectedTag.\n",
                "properties": {
                    "createAccessLevels": {
                        "description": "Array of access levels/user(s)/group(s) allowed to create protected tags.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectProtectedTagCreateAccessLevel:getProjectProtectedTagCreateAccessLevel"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The ID of this resource. In the format of `\u003ctag\u003e`.\n",
                        "type": "string"
                    },
                    "project": {
                        "description": "The integer or path with namespace that uniquely identifies the project.\n",
                        "type": "string"
                    },
                    "tag": {
                        "description": "The name of the protected tag.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "createAccessLevels",
                    "id",
                    "project",
                    "tag"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getProjectProtectedTags:getProjectProtectedTags": {
            "description": "The `gitlab.getProjectProtectedTags` data source allows details of the protected tags of a given project.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/protected_tags.html#list-protected-tags)\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectProtectedTags.\n",
                "properties": {
                    "project": {
                        "type": "string",
                        "description": "The integer or path with namespace that uniquely identifies the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectProtectedTags.\n",
                "properties": {
                    "id": {
                        "description": "The ID of this resource.\n",
                        "type": "string"
                    },
                    "project": {
                        "description": "The integer or path with namespace that uniquely identifies the project.\n",
                        "type": "string"
                    },
                    "protectedTags": {
                        "description": "A list of protected tags, as defined below.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectProtectedTagsProtectedTag:getProjectProtectedTagsProtectedTag"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "id",
                    "project",
                    "protectedTags"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getProjectTag:getProjectTag": {
            "description": "The `gitlab.ProjectTag` data source allows details of a project tag to be retrieved by its name.\n\n**Upstream API**: [GitLab API docs](https://docs.gitlab.com/ee/api/tags.html)\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectTag.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of a tag.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectTag.\n",
                "properties": {
                    "commits": {
                        "description": "The commit associated with the tag.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectTagCommit:getProjectTagCommit"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "message": {
                        "description": "The message of the annotated tag.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "The name of a tag.\n",
                        "type": "string"
                    },
                    "project": {
                        "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n",
                        "type": "string"
                    },
                    "protected": {
                        "description": "Bool, true if tag has tag protection.\n",
                        "type": "boolean"
                    },
                    "releases": {
                        "description": "The release associated with the tag.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectTagRelease:getProjectTagRelease"
                        },
                        "type": "array"
                    },
                    "target": {
                        "description": "The unique id assigned to the commit by Gitlab.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "commits",
                    "message",
                    "name",
                    "project",
                    "protected",
                    "releases",
                    "target",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getProjectTags:getProjectTags": {
            "description": "The `gitlab.getProjectTags` data source allows details of project tags to be retrieved by some search criteria.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/tags.html#list-project-repository-tags)\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectTags.\n",
                "properties": {
                    "orderBy": {
                        "type": "string",
                        "description": "Return tags ordered by `name` or `updated` fields. Default is `updated`.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n"
                    },
                    "search": {
                        "type": "string",
                        "description": "Return list of tags matching the search criteria. You can use `^term` and `term$` to find tags that begin and end with `term` respectively. No other regular expressions are supported.\n"
                    },
                    "sort": {
                        "type": "string",
                        "description": "Return tags sorted in `asc` or `desc` order. Default is `desc`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectTags.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "orderBy": {
                        "description": "Return tags ordered by `name` or `updated` fields. Default is `updated`.\n",
                        "type": "string"
                    },
                    "project": {
                        "description": "The ID or URL-encoded path of the project owned by the authenticated user.\n",
                        "type": "string"
                    },
                    "search": {
                        "description": "Return list of tags matching the search criteria. You can use `^term` and `term$` to find tags that begin and end with `term` respectively. No other regular expressions are supported.\n",
                        "type": "string"
                    },
                    "sort": {
                        "description": "Return tags sorted in `asc` or `desc` order. Default is `desc`.\n",
                        "type": "string"
                    },
                    "tags": {
                        "description": "List of repository tags from a project.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectTagsTag:getProjectTagsTag"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "project",
                    "tags",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getProjectVariable:getProjectVariable": {
            "description": "The `gitlab.ProjectVariable` data source allows to retrieve details about a project-level CI/CD variable.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/project_level_variables.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst foo = gitlab.getProjectVariable({\n    project: \"my/example/project\",\n    key: \"foo\",\n});\n// Using an environment scope\nconst bar = gitlab.getProjectVariable({\n    project: \"my/example/project\",\n    key: \"bar\",\n    environmentScope: \"staging/*\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nfoo = gitlab.get_project_variable(project=\"my/example/project\",\n    key=\"foo\")\n# Using an environment scope\nbar = gitlab.get_project_variable(project=\"my/example/project\",\n    key=\"bar\",\n    environment_scope=\"staging/*\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = GitLab.GetProjectVariable.Invoke(new()\n    {\n        Project = \"my/example/project\",\n        Key = \"foo\",\n    });\n\n    // Using an environment scope\n    var bar = GitLab.GetProjectVariable.Invoke(new()\n    {\n        Project = \"my/example/project\",\n        Key = \"bar\",\n        EnvironmentScope = \"staging/*\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.LookupProjectVariable(ctx, \u0026gitlab.LookupProjectVariableArgs{\n\t\t\tProject: \"my/example/project\",\n\t\t\tKey:     \"foo\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Using an environment scope\n\t\t_, err = gitlab.LookupProjectVariable(ctx, \u0026gitlab.LookupProjectVariableArgs{\n\t\t\tProject:          \"my/example/project\",\n\t\t\tKey:              \"bar\",\n\t\t\tEnvironmentScope: pulumi.StringRef(\"staging/*\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetProjectVariableArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var foo = GitlabFunctions.getProjectVariable(GetProjectVariableArgs.builder()\n            .project(\"my/example/project\")\n            .key(\"foo\")\n            .build());\n\n        // Using an environment scope\n        final var bar = GitlabFunctions.getProjectVariable(GetProjectVariableArgs.builder()\n            .project(\"my/example/project\")\n            .key(\"bar\")\n            .environmentScope(\"staging/*\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  foo:\n    fn::invoke:\n      Function: gitlab:getProjectVariable\n      Arguments:\n        project: my/example/project\n        key: foo\n  # Using an environment scope\n  bar:\n    fn::invoke:\n      Function: gitlab:getProjectVariable\n      Arguments:\n        project: my/example/project\n        key: bar\n        environmentScope: staging/*\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectVariable.\n",
                "properties": {
                    "environmentScope": {
                        "type": "string",
                        "description": "The environment scope of the variable. Defaults to all environment (`*`). Note that in Community Editions of Gitlab, values other than `*` will cause inconsistent plans.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "The name of the variable.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "key",
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectVariable.\n",
                "properties": {
                    "description": {
                        "description": "The description of the variable.\n",
                        "type": "string"
                    },
                    "environmentScope": {
                        "description": "The environment scope of the variable. Defaults to all environment (`*`). Note that in Community Editions of Gitlab, values other than `*` will cause inconsistent plans.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "key": {
                        "description": "The name of the variable.\n",
                        "type": "string"
                    },
                    "masked": {
                        "description": "If set to `true`, the value of the variable will be hidden in job logs. The value must meet the [masking requirements](https://docs.gitlab.com/ee/ci/variables/#masked-variables). Defaults to `false`.\n",
                        "type": "boolean"
                    },
                    "project": {
                        "description": "The name or id of the project.\n",
                        "type": "string"
                    },
                    "protected": {
                        "description": "If set to `true`, the variable will be passed only to pipelines running on protected branches and tags. Defaults to `false`.\n",
                        "type": "boolean"
                    },
                    "raw": {
                        "description": "Whether the variable is treated as a raw string. Default: false. When true, variables in the value are not expanded.\n",
                        "type": "boolean"
                    },
                    "value": {
                        "description": "The value of the variable.\n",
                        "type": "string"
                    },
                    "variableType": {
                        "description": "The type of a variable. Valid values are: `env_var`, `file`. Default is `env_var`.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "description",
                    "environmentScope",
                    "key",
                    "masked",
                    "project",
                    "protected",
                    "raw",
                    "value",
                    "variableType",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getProjectVariables:getProjectVariables": {
            "description": "The `gitlab.getProjectVariables` data source allows to retrieve all project-level CI/CD variables.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/project_level_variables.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst vars = gitlab.getProjectVariables({\n    project: \"my/example/project\",\n});\n// Using an environment scope\nconst stagingVars = gitlab.getProjectVariables({\n    project: \"my/example/project\",\n    environmentScope: \"staging/*\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nvars = gitlab.get_project_variables(project=\"my/example/project\")\n# Using an environment scope\nstaging_vars = gitlab.get_project_variables(project=\"my/example/project\",\n    environment_scope=\"staging/*\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var vars = GitLab.GetProjectVariables.Invoke(new()\n    {\n        Project = \"my/example/project\",\n    });\n\n    // Using an environment scope\n    var stagingVars = GitLab.GetProjectVariables.Invoke(new()\n    {\n        Project = \"my/example/project\",\n        EnvironmentScope = \"staging/*\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.GetProjectVariables(ctx, \u0026gitlab.GetProjectVariablesArgs{\n\t\t\tProject: \"my/example/project\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Using an environment scope\n\t\t_, err = gitlab.GetProjectVariables(ctx, \u0026gitlab.GetProjectVariablesArgs{\n\t\t\tProject:          \"my/example/project\",\n\t\t\tEnvironmentScope: pulumi.StringRef(\"staging/*\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetProjectVariablesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var vars = GitlabFunctions.getProjectVariables(GetProjectVariablesArgs.builder()\n            .project(\"my/example/project\")\n            .build());\n\n        // Using an environment scope\n        final var stagingVars = GitlabFunctions.getProjectVariables(GetProjectVariablesArgs.builder()\n            .project(\"my/example/project\")\n            .environmentScope(\"staging/*\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  vars:\n    fn::invoke:\n      Function: gitlab:getProjectVariables\n      Arguments:\n        project: my/example/project\n  # Using an environment scope\n  stagingVars:\n    fn::invoke:\n      Function: gitlab:getProjectVariables\n      Arguments:\n        project: my/example/project\n        environmentScope: staging/*\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectVariables.\n",
                "properties": {
                    "environmentScope": {
                        "type": "string",
                        "description": "The environment scope of the variable. Defaults to all environment (`*`).\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or id of the project.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "project"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectVariables.\n",
                "properties": {
                    "environmentScope": {
                        "description": "The environment scope of the variable. Defaults to all environment (`*`).\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "project": {
                        "description": "The name or id of the project.\n",
                        "type": "string"
                    },
                    "variables": {
                        "description": "The list of variables returned by the search\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectVariablesVariable:getProjectVariablesVariable"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "project",
                    "variables",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getProjects:getProjects": {
            "description": "The `gitlab.getProjects` data source allows details of multiple projects to be retrieved. Optionally filtered by the set attributes.\n\n\u003e This data source supports all available filters exposed by the xanzy/go-gitlab package, which might not expose all available filters exposed by the Gitlab APIs.\n\n\u003e The owner sub-attributes are only populated if the Gitlab token used has an administrator scope.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/projects.html#list-all-projects)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\n// List projects within a group tree\nconst mygroup = gitlab.getGroup({\n    fullPath: \"mygroup\",\n});\nconst groupProjects = mygroup.then(mygroup =\u003e gitlab.getProjects({\n    groupId: mygroup.id,\n    orderBy: \"name\",\n    includeSubgroups: true,\n    withShared: false,\n}));\n// List projects using the search syntax\nconst projects = gitlab.getProjects({\n    search: \"postgresql\",\n    visibility: \"private\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\n# List projects within a group tree\nmygroup = gitlab.get_group(full_path=\"mygroup\")\ngroup_projects = gitlab.get_projects(group_id=mygroup.id,\n    order_by=\"name\",\n    include_subgroups=True,\n    with_shared=False)\n# List projects using the search syntax\nprojects = gitlab.get_projects(search=\"postgresql\",\n    visibility=\"private\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // List projects within a group tree\n    var mygroup = GitLab.GetGroup.Invoke(new()\n    {\n        FullPath = \"mygroup\",\n    });\n\n    var groupProjects = GitLab.GetProjects.Invoke(new()\n    {\n        GroupId = mygroup.Apply(getGroupResult =\u003e getGroupResult.Id),\n        OrderBy = \"name\",\n        IncludeSubgroups = true,\n        WithShared = false,\n    });\n\n    // List projects using the search syntax\n    var projects = GitLab.GetProjects.Invoke(new()\n    {\n        Search = \"postgresql\",\n        Visibility = \"private\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// List projects within a group tree\n\t\tmygroup, err := gitlab.LookupGroup(ctx, \u0026gitlab.LookupGroupArgs{\n\t\t\tFullPath: pulumi.StringRef(\"mygroup\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.GetProjects(ctx, \u0026gitlab.GetProjectsArgs{\n\t\t\tGroupId:          pulumi.IntRef(mygroup.Id),\n\t\t\tOrderBy:          pulumi.StringRef(\"name\"),\n\t\t\tIncludeSubgroups: pulumi.BoolRef(true),\n\t\t\tWithShared:       pulumi.BoolRef(false),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// List projects using the search syntax\n\t\t_, err = gitlab.GetProjects(ctx, \u0026gitlab.GetProjectsArgs{\n\t\t\tSearch:     pulumi.StringRef(\"postgresql\"),\n\t\t\tVisibility: pulumi.StringRef(\"private\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetGroupArgs;\nimport com.pulumi.gitlab.inputs.GetProjectsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // List projects within a group tree\n        final var mygroup = GitlabFunctions.getGroup(GetGroupArgs.builder()\n            .fullPath(\"mygroup\")\n            .build());\n\n        final var groupProjects = GitlabFunctions.getProjects(GetProjectsArgs.builder()\n            .groupId(mygroup.applyValue(getGroupResult -\u003e getGroupResult.id()))\n            .orderBy(\"name\")\n            .includeSubgroups(true)\n            .withShared(false)\n            .build());\n\n        // List projects using the search syntax\n        final var projects = GitlabFunctions.getProjects(GetProjectsArgs.builder()\n            .search(\"postgresql\")\n            .visibility(\"private\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  # List projects within a group tree\n  mygroup:\n    fn::invoke:\n      Function: gitlab:getGroup\n      Arguments:\n        fullPath: mygroup\n  groupProjects:\n    fn::invoke:\n      Function: gitlab:getProjects\n      Arguments:\n        groupId: ${mygroup.id}\n        orderBy: name\n        includeSubgroups: true\n        withShared: false\n  # List projects using the search syntax\n  projects:\n    fn::invoke:\n      Function: gitlab:getProjects\n      Arguments:\n        search: postgresql\n        visibility: private\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProjects.\n",
                "properties": {
                    "archived": {
                        "type": "boolean",
                        "description": "Limit by archived status.\n"
                    },
                    "groupId": {
                        "type": "integer",
                        "description": "The ID of the group owned by the authenticated user to look projects for within. Cannot be used with `min_access_level`, `with_programming_language` or `statistics`.\n"
                    },
                    "includeSubgroups": {
                        "type": "boolean",
                        "description": "Include projects in subgroups of this group. Default is `false`. Needs `group_id`.\n"
                    },
                    "maxQueryablePages": {
                        "type": "integer",
                        "description": "The maximum number of project results pages that may be queried. Prevents overloading your Gitlab instance in case of a misconfiguration.\n"
                    },
                    "membership": {
                        "type": "boolean",
                        "description": "Limit by projects that the current user is a member of.\n"
                    },
                    "minAccessLevel": {
                        "type": "integer",
                        "description": "Limit to projects where current user has at least this access level, refer to the [official documentation](https://docs.gitlab.com/ee/api/members.html) for values. Cannot be used with `group_id`.\n"
                    },
                    "orderBy": {
                        "type": "string",
                        "description": "Return projects ordered ordered by: `id`, `name`, `path`, `created_at`, `updated_at`, `last_activity_at`, `similarity`, `repository_size`, `storage_size`, `packages_size`, `wiki_size`. Some values or only available in certain circumstances. See [upstream docs](https://docs.gitlab.com/ee/api/projects.html#list-all-projects) for details.\n"
                    },
                    "owned": {
                        "type": "boolean",
                        "description": "Limit by projects owned by the current user.\n"
                    },
                    "page": {
                        "type": "integer",
                        "description": "The first page to begin the query on.\n"
                    },
                    "perPage": {
                        "type": "integer",
                        "description": "The number of results to return per page.\n"
                    },
                    "search": {
                        "type": "string",
                        "description": "Return list of authorized projects matching the search criteria.\n"
                    },
                    "simple": {
                        "type": "boolean",
                        "description": "Return only the ID, URL, name, and path of each project.\n"
                    },
                    "sort": {
                        "type": "string",
                        "description": "Return projects sorted in `asc` or `desc` order. Default is `desc`.\n"
                    },
                    "starred": {
                        "type": "boolean",
                        "description": "Limit by projects starred by the current user.\n"
                    },
                    "statistics": {
                        "type": "boolean",
                        "description": "Include project statistics. Cannot be used with `group_id`.\n"
                    },
                    "topics": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Limit by projects that have all of the given topics.\n"
                    },
                    "visibility": {
                        "type": "string",
                        "description": "Limit by visibility `public`, `internal`, or `private`.\n"
                    },
                    "withCustomAttributes": {
                        "type": "boolean",
                        "description": "Include custom attributes in response *(admins only)*.\n"
                    },
                    "withIssuesEnabled": {
                        "type": "boolean",
                        "description": "Limit by projects with issues feature enabled. Default is `false`.\n"
                    },
                    "withMergeRequestsEnabled": {
                        "type": "boolean",
                        "description": "Limit by projects with merge requests feature enabled. Default is `false`.\n"
                    },
                    "withProgrammingLanguage": {
                        "type": "string",
                        "description": "Limit by projects which use the given programming language. Cannot be used with `group_id`.\n"
                    },
                    "withShared": {
                        "type": "boolean",
                        "description": "Include projects shared to this group. Default is `true`. Needs `group_id`.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getProjects.\n",
                "properties": {
                    "archived": {
                        "description": "Limit by archived status.\n",
                        "type": "boolean"
                    },
                    "groupId": {
                        "description": "The ID of the group owned by the authenticated user to look projects for within. Cannot be used with `min_access_level`, `with_programming_language` or `statistics`.\n",
                        "type": "integer"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "includeSubgroups": {
                        "description": "Include projects in subgroups of this group. Default is `false`. Needs `group_id`.\n",
                        "type": "boolean"
                    },
                    "maxQueryablePages": {
                        "description": "The maximum number of project results pages that may be queried. Prevents overloading your Gitlab instance in case of a misconfiguration.\n",
                        "type": "integer"
                    },
                    "membership": {
                        "description": "Limit by projects that the current user is a member of.\n",
                        "type": "boolean"
                    },
                    "minAccessLevel": {
                        "description": "Limit to projects where current user has at least this access level, refer to the [official documentation](https://docs.gitlab.com/ee/api/members.html) for values. Cannot be used with `group_id`.\n",
                        "type": "integer"
                    },
                    "orderBy": {
                        "description": "Return projects ordered ordered by: `id`, `name`, `path`, `created_at`, `updated_at`, `last_activity_at`, `similarity`, `repository_size`, `storage_size`, `packages_size`, `wiki_size`. Some values or only available in certain circumstances. See [upstream docs](https://docs.gitlab.com/ee/api/projects.html#list-all-projects) for details.\n",
                        "type": "string"
                    },
                    "owned": {
                        "description": "Limit by projects owned by the current user.\n",
                        "type": "boolean"
                    },
                    "page": {
                        "description": "The first page to begin the query on.\n",
                        "type": "integer"
                    },
                    "perPage": {
                        "description": "The number of results to return per page.\n",
                        "type": "integer"
                    },
                    "projects": {
                        "description": "A list containing the projects matching the supplied arguments\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getProjectsProject:getProjectsProject"
                        },
                        "type": "array"
                    },
                    "search": {
                        "description": "Return list of authorized projects matching the search criteria.\n",
                        "type": "string"
                    },
                    "simple": {
                        "description": "Return only the ID, URL, name, and path of each project.\n",
                        "type": "boolean"
                    },
                    "sort": {
                        "description": "Return projects sorted in `asc` or `desc` order. Default is `desc`.\n",
                        "type": "string"
                    },
                    "starred": {
                        "description": "Limit by projects starred by the current user.\n",
                        "type": "boolean"
                    },
                    "statistics": {
                        "description": "Include project statistics. Cannot be used with `group_id`.\n",
                        "type": "boolean"
                    },
                    "topics": {
                        "description": "Limit by projects that have all of the given topics.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "visibility": {
                        "description": "Limit by visibility `public`, `internal`, or `private`.\n",
                        "type": "string"
                    },
                    "withCustomAttributes": {
                        "description": "Include custom attributes in response *(admins only)*.\n",
                        "type": "boolean"
                    },
                    "withIssuesEnabled": {
                        "description": "Limit by projects with issues feature enabled. Default is `false`.\n",
                        "type": "boolean"
                    },
                    "withMergeRequestsEnabled": {
                        "description": "Limit by projects with merge requests feature enabled. Default is `false`.\n",
                        "type": "boolean"
                    },
                    "withProgrammingLanguage": {
                        "description": "Limit by projects which use the given programming language. Cannot be used with `group_id`.\n",
                        "type": "string"
                    },
                    "withShared": {
                        "description": "Include projects shared to this group. Default is `true`. Needs `group_id`.\n",
                        "type": "boolean"
                    }
                },
                "required": [
                    "projects",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getRelease:getRelease": {
            "description": "The `gitlab.getRelease` data source retrieves information about a gitlab release for a project.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/releases/)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\n// By project ID and tag_name\nconst example = gitlab.getRelease({\n    projectId: \"1234\",\n    tagName: \"v1.0\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\n# By project ID and tag_name\nexample = gitlab.get_release(project_id=\"1234\",\n    tag_name=\"v1.0\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // By project ID and tag_name\n    var example = GitLab.GetRelease.Invoke(new()\n    {\n        ProjectId = \"1234\",\n        TagName = \"v1.0\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// By project ID and tag_name\n\t\t_, err := gitlab.GetRelease(ctx, \u0026gitlab.GetReleaseArgs{\n\t\t\tProjectId: \"1234\",\n\t\t\tTagName:   \"v1.0\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetReleaseArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // By project ID and tag_name\n        final var example = GitlabFunctions.getRelease(GetReleaseArgs.builder()\n            .projectId(1234)\n            .tagName(\"v1.0\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  # By project ID and tag_name\n  example:\n    fn::invoke:\n      Function: gitlab:getRelease\n      Arguments:\n        projectId: 1234\n        tagName: v1.0\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getRelease.\n",
                "properties": {
                    "assets": {
                        "$ref": "#/types/gitlab:index/getReleaseAssets:getReleaseAssets",
                        "description": "The assets for a release\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The ID or URL-encoded path of the project.\n"
                    },
                    "tagName": {
                        "type": "string",
                        "description": "The Git tag the release is associated with.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId",
                    "tagName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRelease.\n",
                "properties": {
                    "assets": {
                        "$ref": "#/types/gitlab:index/getReleaseAssets:getReleaseAssets",
                        "description": "The assets for a release\n"
                    },
                    "createdAt": {
                        "description": "The date the release was created.\n",
                        "type": "string"
                    },
                    "description": {
                        "description": "An HTML rendered description of the release.\n",
                        "type": "string"
                    },
                    "id": {
                        "type": "string"
                    },
                    "name": {
                        "description": "The name of the release.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "description": "The ID or URL-encoded path of the project.\n",
                        "type": "string"
                    },
                    "releasedAt": {
                        "description": "The date the release was created.\n",
                        "type": "string"
                    },
                    "tagName": {
                        "description": "The Git tag the release is associated with.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "createdAt",
                    "description",
                    "id",
                    "name",
                    "projectId",
                    "releasedAt",
                    "tagName"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getReleaseLink:getReleaseLink": {
            "description": "The `gitlab.ReleaseLink` data source allows get details of a release link.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/releases/links.html)\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getReleaseLink.\n",
                "properties": {
                    "linkId": {
                        "type": "integer",
                        "description": "The ID of the link.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or [URL-encoded path of the project](https://docs.gitlab.com/ee/api/index.html#namespaced-path-encoding).\n"
                    },
                    "tagName": {
                        "type": "string",
                        "description": "The tag associated with the Release.\n"
                    }
                },
                "type": "object",
                "required": [
                    "linkId",
                    "project",
                    "tagName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getReleaseLink.\n",
                "properties": {
                    "directAssetUrl": {
                        "description": "Full path for a [Direct Asset link](https://docs.gitlab.com/ee/user/project/releases/index.html#permanent-links-to-release-assets).\n",
                        "type": "string"
                    },
                    "external": {
                        "description": "External or internal link.\n",
                        "type": "boolean"
                    },
                    "filepath": {
                        "description": "Relative path for a [Direct Asset link](https://docs.gitlab.com/ee/user/project/releases/index.html#permanent-links-to-release-assets).\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "linkId": {
                        "description": "The ID of the link.\n",
                        "type": "integer"
                    },
                    "linkType": {
                        "description": "The type of the link. Valid values are `other`, `runbook`, `image`, `package`. Defaults to other.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "The name of the link. Link names must be unique within the release.\n",
                        "type": "string"
                    },
                    "project": {
                        "description": "The ID or [URL-encoded path of the project](https://docs.gitlab.com/ee/api/index.html#namespaced-path-encoding).\n",
                        "type": "string"
                    },
                    "tagName": {
                        "description": "The tag associated with the Release.\n",
                        "type": "string"
                    },
                    "url": {
                        "description": "The URL of the link. Link URLs must be unique within the release.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "directAssetUrl",
                    "external",
                    "filepath",
                    "linkId",
                    "linkType",
                    "name",
                    "project",
                    "tagName",
                    "url",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getReleaseLinks:getReleaseLinks": {
            "description": "The `gitlab.getReleaseLinks` data source allows get details of release links.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/releases/links.html)\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getReleaseLinks.\n",
                "properties": {
                    "project": {
                        "type": "string",
                        "description": "The ID or full path to the project.\n",
                        "willReplaceOnChanges": true
                    },
                    "tagName": {
                        "type": "string",
                        "description": "The tag associated with the Release.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "project",
                    "tagName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getReleaseLinks.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "project": {
                        "description": "The ID or full path to the project.\n",
                        "type": "string"
                    },
                    "releaseLinks": {
                        "description": "List of release links\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getReleaseLinksReleaseLink:getReleaseLinksReleaseLink"
                        },
                        "type": "array"
                    },
                    "tagName": {
                        "description": "The tag associated with the Release.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "project",
                    "releaseLinks",
                    "tagName",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getRepositoryFile:getRepositoryFile": {
            "description": "The `gitlab.RepositoryFile` data source allows details of a file in a repository to be retrieved.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/repository_files.html)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getRepositoryFile({\n    project: \"example\",\n    ref: \"main\",\n    filePath: \"README.md\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_repository_file(project=\"example\",\n    ref=\"main\",\n    file_path=\"README.md\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetRepositoryFile.Invoke(new()\n    {\n        Project = \"example\",\n        Ref = \"main\",\n        FilePath = \"README.md\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.LookupRepositoryFile(ctx, \u0026gitlab.LookupRepositoryFileArgs{\n\t\t\tProject:  \"example\",\n\t\t\tRef:      \"main\",\n\t\t\tFilePath: \"README.md\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetRepositoryFileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getRepositoryFile(GetRepositoryFileArgs.builder()\n            .project(\"example\")\n            .ref(\"main\")\n            .filePath(\"README.md\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getRepositoryFile\n      Arguments:\n        project: example\n        ref: main\n        filePath: README.md\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getRepositoryFile.\n",
                "properties": {
                    "filePath": {
                        "type": "string",
                        "description": "The full path of the file. It must be relative to the root of the project without a leading slash `/` or `./`.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The name or ID of the project.\n"
                    },
                    "ref": {
                        "type": "string",
                        "description": "The name of branch, tag or commit.\n"
                    }
                },
                "type": "object",
                "required": [
                    "filePath",
                    "project",
                    "ref"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRepositoryFile.\n",
                "properties": {
                    "blobId": {
                        "description": "The blob id.\n",
                        "type": "string"
                    },
                    "commitId": {
                        "description": "The commit id.\n",
                        "type": "string"
                    },
                    "content": {
                        "description": "File content.\n",
                        "type": "string"
                    },
                    "contentSha256": {
                        "description": "File content sha256 digest.\n",
                        "type": "string"
                    },
                    "encoding": {
                        "description": "The file content encoding.\n",
                        "type": "string"
                    },
                    "executeFilemode": {
                        "description": "Enables or disables the execute flag on the file. **Note**: requires GitLab 14.10 or newer.\n",
                        "type": "boolean"
                    },
                    "fileName": {
                        "description": "The filename.\n",
                        "type": "string"
                    },
                    "filePath": {
                        "description": "The full path of the file. It must be relative to the root of the project without a leading slash `/` or `./`.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "lastCommitId": {
                        "description": "The last known commit id.\n",
                        "type": "string"
                    },
                    "project": {
                        "description": "The name or ID of the project.\n",
                        "type": "string"
                    },
                    "ref": {
                        "description": "The name of branch, tag or commit.\n",
                        "type": "string"
                    },
                    "size": {
                        "description": "The file size.\n",
                        "type": "integer"
                    }
                },
                "required": [
                    "blobId",
                    "commitId",
                    "content",
                    "contentSha256",
                    "encoding",
                    "executeFilemode",
                    "fileName",
                    "filePath",
                    "lastCommitId",
                    "project",
                    "ref",
                    "size",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getRepositoryTree:getRepositoryTree": {
            "description": "The `gitlab.getRepositoryTree` data source allows details of directories and files in a repository to be retrieved.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/repositories.html#list-repository-tree)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst this = gitlab.getRepositoryTree({\n    project: \"example\",\n    ref: \"main\",\n    path: \"ExampleSubFolder\",\n    recursive: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nthis = gitlab.get_repository_tree(project=\"example\",\n    ref=\"main\",\n    path=\"ExampleSubFolder\",\n    recursive=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @this = GitLab.GetRepositoryTree.Invoke(new()\n    {\n        Project = \"example\",\n        Ref = \"main\",\n        Path = \"ExampleSubFolder\",\n        Recursive = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.GetRepositoryTree(ctx, \u0026gitlab.GetRepositoryTreeArgs{\n\t\t\tProject:   \"example\",\n\t\t\tRef:       \"main\",\n\t\t\tPath:      pulumi.StringRef(\"ExampleSubFolder\"),\n\t\t\tRecursive: pulumi.BoolRef(true),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetRepositoryTreeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var this = GitlabFunctions.getRepositoryTree(GetRepositoryTreeArgs.builder()\n            .project(\"example\")\n            .ref(\"main\")\n            .path(\"ExampleSubFolder\")\n            .recursive(true)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  this:\n    fn::invoke:\n      Function: gitlab:getRepositoryTree\n      Arguments:\n        project: example\n        ref: main\n        path: ExampleSubFolder\n        recursive: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getRepositoryTree.\n",
                "properties": {
                    "path": {
                        "type": "string",
                        "description": "The path inside repository. Used to get content of subdirectories.\n"
                    },
                    "project": {
                        "type": "string",
                        "description": "The ID or full path of the project owned by the authenticated user.\n"
                    },
                    "recursive": {
                        "type": "boolean",
                        "description": "Boolean value used to get a recursive tree (false by default).\n"
                    },
                    "ref": {
                        "type": "string",
                        "description": "The name of a repository branch or tag.\n"
                    }
                },
                "type": "object",
                "required": [
                    "project",
                    "ref"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRepositoryTree.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "path": {
                        "description": "The path inside repository. Used to get content of subdirectories.\n",
                        "type": "string"
                    },
                    "project": {
                        "description": "The ID or full path of the project owned by the authenticated user.\n",
                        "type": "string"
                    },
                    "recursive": {
                        "description": "Boolean value used to get a recursive tree (false by default).\n",
                        "type": "boolean"
                    },
                    "ref": {
                        "description": "The name of a repository branch or tag.\n",
                        "type": "string"
                    },
                    "trees": {
                        "description": "The list of files/directories returned by the search\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getRepositoryTreeTree:getRepositoryTreeTree"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "project",
                    "ref",
                    "trees",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getRunners:getRunners": {
            "description": "The `gitlab.getRunners` data source retrieves information about all gitlab runners.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/runners.html#list-all-runners)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst thisUserRunner = new gitlab.UserRunner(\"this\", {\n    runnerType: \"instance_type\",\n    tagLists: [\n        \"tag1\",\n        \"tag2\",\n    ],\n});\nconst this = gitlab.getRunners({\n    paused: false,\n    status: \"online\",\n    tagLists: [\n        \"tag1\",\n        \"tag2\",\n    ],\n    type: \"instance_type\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nthis_user_runner = gitlab.UserRunner(\"this\",\n    runner_type=\"instance_type\",\n    tag_lists=[\n        \"tag1\",\n        \"tag2\",\n    ])\nthis = gitlab.get_runners(paused=False,\n    status=\"online\",\n    tag_lists=[\n        \"tag1\",\n        \"tag2\",\n    ],\n    type=\"instance_type\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var thisUserRunner = new GitLab.UserRunner(\"this\", new()\n    {\n        RunnerType = \"instance_type\",\n        TagLists = new[]\n        {\n            \"tag1\",\n            \"tag2\",\n        },\n    });\n\n    var @this = GitLab.GetRunners.Invoke(new()\n    {\n        Paused = false,\n        Status = \"online\",\n        TagLists = new[]\n        {\n            \"tag1\",\n            \"tag2\",\n        },\n        Type = \"instance_type\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.NewUserRunner(ctx, \"this\", \u0026gitlab.UserRunnerArgs{\n\t\t\tRunnerType: pulumi.String(\"instance_type\"),\n\t\t\tTagLists: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"tag1\"),\n\t\t\t\tpulumi.String(\"tag2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.GetRunners(ctx, \u0026gitlab.GetRunnersArgs{\n\t\t\tPaused: pulumi.BoolRef(false),\n\t\t\tStatus: pulumi.StringRef(\"online\"),\n\t\t\tTagLists: []string{\n\t\t\t\t\"tag1\",\n\t\t\t\t\"tag2\",\n\t\t\t},\n\t\t\tType: pulumi.StringRef(\"instance_type\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.UserRunner;\nimport com.pulumi.gitlab.UserRunnerArgs;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetRunnersArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var thisUserRunner = new UserRunner(\"thisUserRunner\", UserRunnerArgs.builder()\n            .runnerType(\"instance_type\")\n            .tagLists(            \n                \"tag1\",\n                \"tag2\")\n            .build());\n\n        final var this = GitlabFunctions.getRunners(GetRunnersArgs.builder()\n            .paused(false)\n            .status(\"online\")\n            .tagLists(            \n                \"tag1\",\n                \"tag2\")\n            .type(\"instance_type\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  thisUserRunner:\n    type: gitlab:UserRunner\n    name: this\n    properties:\n      runnerType: instance_type\n      tagLists:\n        - tag1\n        - tag2\nvariables:\n  this:\n    fn::invoke:\n      Function: gitlab:getRunners\n      Arguments:\n        paused: false\n        status: online\n        tagLists:\n          - tag1\n          - tag2\n        type: instance_type\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getRunners.\n",
                "properties": {
                    "paused": {
                        "type": "boolean",
                        "description": "Filters for runners with the given paused value\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Filters for runners with the given status. Valid Values are `online`, `offline`, `stale`, and `never_contacted`.\n"
                    },
                    "tagLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Filters for runners with all of the given tags\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of runner to return. Valid values are `instance_type`, `group_type` and `project_type`\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getRunners.\n",
                "properties": {
                    "id": {
                        "type": "string"
                    },
                    "paused": {
                        "description": "Filters for runners with the given paused value\n",
                        "type": "boolean"
                    },
                    "runners": {
                        "description": "The list of runners.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getRunnersRunner:getRunnersRunner"
                        },
                        "type": "array"
                    },
                    "status": {
                        "description": "Filters for runners with the given status. Valid Values are `online`, `offline`, `stale`, and `never_contacted`.\n",
                        "type": "string"
                    },
                    "tagLists": {
                        "description": "Filters for runners with all of the given tags\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "type": {
                        "description": "The type of runner to return. Valid values are `instance_type`, `group_type` and `project_type`\n",
                        "type": "string"
                    }
                },
                "required": [
                    "id",
                    "runners"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getUser:getUser": {
            "description": "The `gitlab.User` data source allows details of a user to be retrieved by either the user ID, username or email address.\n\n\u003e Some attributes might not be returned depending on if you're an admin or not.\n\n\u003e When using the `email` attribute, an exact match is not guaranteed. The most related match will be returned. Starting with GitLab 16.6,\nthe most related match will prioritize an exact match if one is available.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/users.html#single-user)\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getUser.\n",
                "properties": {
                    "email": {
                        "type": "string",
                        "description": "The public email address of the user. **Note**: before GitLab 14.8 the lookup was based on the users primary email address.\n"
                    },
                    "namespaceId": {
                        "type": "integer",
                        "description": "The ID of the user's namespace. Requires admin token to access this field. Available since GitLab 14.10.\n"
                    },
                    "userId": {
                        "type": "integer",
                        "description": "The ID of the user.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "The username of the user.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getUser.\n",
                "properties": {
                    "avatarUrl": {
                        "description": "The avatar URL of the user.\n",
                        "type": "string"
                    },
                    "bio": {
                        "description": "The bio of the user.\n",
                        "type": "string"
                    },
                    "canCreateGroup": {
                        "description": "Whether the user can create groups.\n",
                        "type": "boolean"
                    },
                    "canCreateProject": {
                        "description": "Whether the user can create projects.\n",
                        "type": "boolean"
                    },
                    "colorSchemeId": {
                        "description": "User's color scheme ID.\n",
                        "type": "integer"
                    },
                    "createdAt": {
                        "description": "Date the user was created at.\n",
                        "type": "string"
                    },
                    "currentSignInAt": {
                        "description": "Current user's sign-in date.\n",
                        "type": "string"
                    },
                    "email": {
                        "description": "The public email address of the user. **Note**: before GitLab 14.8 the lookup was based on the users primary email address.\n",
                        "type": "string"
                    },
                    "externUid": {
                        "description": "The external UID of the user.\n",
                        "type": "string"
                    },
                    "external": {
                        "description": "Whether the user is external.\n",
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "isAdmin": {
                        "description": "Whether the user is an admin.\n",
                        "type": "boolean"
                    },
                    "isBot": {
                        "description": "Whether the user is a bot.\n",
                        "type": "boolean"
                    },
                    "lastSignInAt": {
                        "description": "Last user's sign-in date.\n",
                        "type": "string"
                    },
                    "linkedin": {
                        "description": "LinkedIn profile of the user.\n",
                        "type": "string"
                    },
                    "location": {
                        "description": "The location of the user.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "The name of the user.\n",
                        "type": "string"
                    },
                    "namespaceId": {
                        "description": "The ID of the user's namespace. Requires admin token to access this field. Available since GitLab 14.10.\n",
                        "type": "integer"
                    },
                    "note": {
                        "description": "Admin notes for this user.\n",
                        "type": "string"
                    },
                    "organization": {
                        "description": "The organization of the user.\n",
                        "type": "string"
                    },
                    "projectsLimit": {
                        "description": "Number of projects the user can create.\n",
                        "type": "integer"
                    },
                    "skype": {
                        "description": "Skype username of the user.\n",
                        "type": "string"
                    },
                    "state": {
                        "description": "Whether the user is active or blocked.\n",
                        "type": "string"
                    },
                    "themeId": {
                        "description": "User's theme ID.\n",
                        "type": "integer"
                    },
                    "twitter": {
                        "description": "Twitter username of the user.\n",
                        "type": "string"
                    },
                    "twoFactorEnabled": {
                        "description": "Whether user's two-factor auth is enabled.\n",
                        "type": "boolean"
                    },
                    "userId": {
                        "description": "The ID of the user.\n",
                        "type": "integer"
                    },
                    "userProvider": {
                        "description": "The UID provider of the user.\n",
                        "type": "string"
                    },
                    "username": {
                        "description": "The username of the user.\n",
                        "type": "string"
                    },
                    "websiteUrl": {
                        "description": "User's website URL.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "avatarUrl",
                    "bio",
                    "canCreateGroup",
                    "canCreateProject",
                    "colorSchemeId",
                    "createdAt",
                    "currentSignInAt",
                    "email",
                    "externUid",
                    "external",
                    "isAdmin",
                    "isBot",
                    "lastSignInAt",
                    "linkedin",
                    "location",
                    "name",
                    "namespaceId",
                    "note",
                    "organization",
                    "projectsLimit",
                    "skype",
                    "state",
                    "themeId",
                    "twitter",
                    "twoFactorEnabled",
                    "userId",
                    "userProvider",
                    "username",
                    "websiteUrl",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getUserSshkeys:getUserSshkeys": {
            "description": "The `gitlab.getUserSshkeys` data source allows a list of SSH keys to be retrieved by either the user ID or username.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ee/api/users.html#list-ssh-keys-for-user)\n",
            "inputs": {
                "description": "A collection of arguments for invoking getUserSshkeys.\n",
                "properties": {
                    "userId": {
                        "type": "integer",
                        "description": "ID of the user to get the SSH keys for.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Username of the user to get the SSH keys for.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getUserSshkeys.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "keys": {
                        "description": "The user's keys.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getUserSshkeysKey:getUserSshkeysKey"
                        },
                        "type": "array"
                    },
                    "userId": {
                        "description": "ID of the user to get the SSH keys for.\n",
                        "type": "integer"
                    },
                    "username": {
                        "description": "Username of the user to get the SSH keys for.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "keys",
                    "userId",
                    "username",
                    "id"
                ],
                "type": "object"
            }
        },
        "gitlab:index/getUsers:getUsers": {
            "description": "The `gitlab.getUsers` data source allows details of multiple users to be retrieved given some optional filter criteria.\n\n\u003e Some attributes might not be returned depending on if you're an admin or not.\n\n\u003e Some available options require administrator privileges.\n\n**Upstream API**: [GitLab REST API docs](https://docs.gitlab.com/ce/api/users.html#list-users)\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gitlab from \"@pulumi/gitlab\";\n\nconst example = gitlab.getUsers({\n    sort: \"desc\",\n    orderBy: \"name\",\n    createdBefore: \"2019-01-01\",\n});\nconst example-two = gitlab.getUsers({\n    search: \"username\",\n});\n```\n```python\nimport pulumi\nimport pulumi_gitlab as gitlab\n\nexample = gitlab.get_users(sort=\"desc\",\n    order_by=\"name\",\n    created_before=\"2019-01-01\")\nexample_two = gitlab.get_users(search=\"username\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing GitLab = Pulumi.GitLab;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = GitLab.GetUsers.Invoke(new()\n    {\n        Sort = \"desc\",\n        OrderBy = \"name\",\n        CreatedBefore = \"2019-01-01\",\n    });\n\n    var example_two = GitLab.GetUsers.Invoke(new()\n    {\n        Search = \"username\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-gitlab/sdk/v8/go/gitlab\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := gitlab.GetUsers(ctx, \u0026gitlab.GetUsersArgs{\n\t\t\tSort:          pulumi.StringRef(\"desc\"),\n\t\t\tOrderBy:       pulumi.StringRef(\"name\"),\n\t\t\tCreatedBefore: pulumi.StringRef(\"2019-01-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = gitlab.GetUsers(ctx, \u0026gitlab.GetUsersArgs{\n\t\t\tSearch: pulumi.StringRef(\"username\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.gitlab.GitlabFunctions;\nimport com.pulumi.gitlab.inputs.GetUsersArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = GitlabFunctions.getUsers(GetUsersArgs.builder()\n            .sort(\"desc\")\n            .orderBy(\"name\")\n            .createdBefore(\"2019-01-01\")\n            .build());\n\n        final var example-two = GitlabFunctions.getUsers(GetUsersArgs.builder()\n            .search(\"username\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: gitlab:getUsers\n      Arguments:\n        sort: desc\n        orderBy: name\n        createdBefore: 2019-01-01\n  example-two:\n    fn::invoke:\n      Function: gitlab:getUsers\n      Arguments:\n        search: username\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getUsers.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "Filter users that are active.\n"
                    },
                    "blocked": {
                        "type": "boolean",
                        "description": "Filter users that are blocked.\n"
                    },
                    "createdAfter": {
                        "type": "string",
                        "description": "Search for users created after a specific date. (Requires administrator privileges)\n"
                    },
                    "createdBefore": {
                        "type": "string",
                        "description": "Search for users created before a specific date. (Requires administrator privileges)\n"
                    },
                    "externProvider": {
                        "type": "string",
                        "description": "Lookup users by external provider. (Requires administrator privileges)\n"
                    },
                    "externUid": {
                        "type": "string",
                        "description": "Lookup users by external UID. (Requires administrator privileges)\n"
                    },
                    "orderBy": {
                        "type": "string",
                        "description": "Order the users' list by `id`, `name`, `username`, `created_at` or `updated_at`. (Requires administrator privileges)\n"
                    },
                    "search": {
                        "type": "string",
                        "description": "Search users by username, name or email.\n"
                    },
                    "sort": {
                        "type": "string",
                        "description": "Sort users' list in asc or desc order. (Requires administrator privileges)\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getUsers.\n",
                "properties": {
                    "active": {
                        "description": "Filter users that are active.\n",
                        "type": "boolean"
                    },
                    "blocked": {
                        "description": "Filter users that are blocked.\n",
                        "type": "boolean"
                    },
                    "createdAfter": {
                        "description": "Search for users created after a specific date. (Requires administrator privileges)\n",
                        "type": "string"
                    },
                    "createdBefore": {
                        "description": "Search for users created before a specific date. (Requires administrator privileges)\n",
                        "type": "string"
                    },
                    "externProvider": {
                        "description": "Lookup users by external provider. (Requires administrator privileges)\n",
                        "type": "string"
                    },
                    "externUid": {
                        "description": "Lookup users by external UID. (Requires administrator privileges)\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "orderBy": {
                        "description": "Order the users' list by `id`, `name`, `username`, `created_at` or `updated_at`. (Requires administrator privileges)\n",
                        "type": "string"
                    },
                    "search": {
                        "description": "Search users by username, name or email.\n",
                        "type": "string"
                    },
                    "sort": {
                        "description": "Sort users' list in asc or desc order. (Requires administrator privileges)\n",
                        "type": "string"
                    },
                    "users": {
                        "description": "The list of users.\n",
                        "items": {
                            "$ref": "#/types/gitlab:index/getUsersUser:getUsersUser"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "users",
                    "id"
                ],
                "type": "object"
            }
        }
    }
}